'use strict'
var createObject = Object.create
var defineProperty = Object.defineProperty
var getPropertyDescriptor = Object.getOwnPropertyDescriptor
var getPropertyNames = Object.getOwnPropertyNames
var getPrototypeOf = Object.getPrototypeOf
var hasOwnProperty = Object.prototype.hasOwnProperty
var createGetter = (func, value) => () => func && (value = func((func = 0))), value
var handleExports = (func, value) => () => value || func((value = { exports: {} }).exports, value), value.exports
var defineProperties = (object, properties) => {
  for (var key in properties)
    defineProperty(object, key, { get: properties[key], enumerable: true })
}
var mergeProperties = (object, properties, key, descriptor) => {
  if ((properties && typeof properties == 'object') || typeof properties == 'function')
    for (let propName of getPropertyNames(properties))
      if (!hasOwnProperty.call(object, propName) && propName !== key)
        defineProperty(object, propName, { get: () => properties[propName], enumerable: !(descriptor = getPropertyDescriptor(properties, propName)) || descriptor.enumerable })
  return object
}
// Function to handle default exports
var handleDefaultExports = (object, properties, result) => {
  result = object != null ? createObject(getPrototypeOf(object)) : {}
  return mergeProperties(properties || !object || !object.__esModule ? defineProperty(result, 'default', { value: object, enumerable: true }) : result, object)
}
var handleEsModuleExports = object => mergeProperties(defineProperty({}, '__esModule', { value: true }), object)
var requestLight = handleExports((qYe, Sz) => {
  'use strict'
  var hbe = Object.create,
    qC = Object.defineProperty,
    gbe = Object.getOwnPropertyDescriptor,
    xz = Object.getOwnPropertyNames,
    vbe = Object.getPrototypeOf,
    _be = Object.prototype.hasOwnProperty,
    ybe = (t, e) =>
      function () {
        return e || (0, t[xz(t)[0]])((e = { exports: {} }).exports, e), e.exports
      },
    xbe = (t, e) => {
      for (var r in e) qC(t, r, { get: e[r], enumerable: !0 })
    },
    bz = (t, e, r, n) => {
      if ((e && typeof e == 'object') || typeof e == 'function')
        for (let i of xz(e))
          !_be.call(t, i) && i !== r && qC(t, i, { get: () => e[i], enumerable: !(n = gbe(e, i)) || n.enumerable })
      return t
    },
    bbe = (t, e, r) => (
      (r = t != null ? hbe(vbe(t)) : {}),
      bz(e || !t || !t.__esModule ? qC(r, 'default', { value: t, enumerable: !0 }) : r, t)
    ),
    Ebe = t => bz(qC({}, '__esModule', { value: !0 }), t),
    Tbe = ybe({
      'node_modules/request-light/lib/node/main.js'(t) {
        ;(() => {
          var e = {
              46: (s, a) => {
                'use strict'
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.default = function (l, c, { signal: u } = {}) {
                    return new Promise((p, d) => {
                      function f() {
                        u?.removeEventListener('abort', f), l.removeListener(c, m), l.removeListener('error', h)
                      }
                      function m(...g) {
                        f(), p(g)
                      }
                      function h(g) {
                        f(), d(g)
                      }
                      u?.addEventListener('abort', f), l.on(c, m), l.on('error', h)
                    })
                  })
              },
              54: function (s, a, l) {
                'use strict'
                var c =
                  (this && this.__importDefault) ||
                  function (g) {
                    return g && g.__esModule ? g : { default: g }
                  }
                let u = l(361),
                  p = c(l(374)),
                  d = c(l(304)),
                  f = p.default('agent-base')
                function m() {
                  let { stack: g } = new Error()
                  return (
                    typeof g == 'string' &&
                    g
                      .split(
                        `
`
                      )
                      .some(v => v.indexOf('(https.js:') !== -1 || v.indexOf('node:https:') !== -1)
                  )
                }
                function h(g, v) {
                  return new h.Agent(g, v)
                }
                ;(function (g) {
                  class v extends u.EventEmitter {
                    constructor(y, b) {
                      super()
                      let x = b
                      typeof y == 'function' ? (this.callback = y) : y && (x = y),
                        (this.timeout = null),
                        x && typeof x.timeout == 'number' && (this.timeout = x.timeout),
                        (this.maxFreeSockets = 1),
                        (this.maxSockets = 1),
                        (this.maxTotalSockets = 1 / 0),
                        (this.sockets = {}),
                        (this.freeSockets = {}),
                        (this.requests = {}),
                        (this.options = {})
                    }
                    get defaultPort() {
                      return typeof this.explicitDefaultPort == 'number' ? this.explicitDefaultPort : m() ? 443 : 80
                    }
                    set defaultPort(y) {
                      this.explicitDefaultPort = y
                    }
                    get protocol() {
                      return typeof this.explicitProtocol == 'string' ? this.explicitProtocol : m() ? 'https:' : 'http:'
                    }
                    set protocol(y) {
                      this.explicitProtocol = y
                    }
                    callback(y, b, x) {
                      throw new Error(
                        '"agent-base" has no default implementation, you must subclass and override `callback()`'
                      )
                    }
                    addRequest(y, b) {
                      let x = Object.assign({}, b)
                      typeof x.secureEndpoint != 'boolean' && (x.secureEndpoint = m()),
                        x.host == null && (x.host = 'localhost'),
                        x.port == null && (x.port = x.secureEndpoint ? 443 : 80),
                        x.protocol == null && (x.protocol = x.secureEndpoint ? 'https:' : 'http:'),
                        x.host && x.path && delete x.path,
                        delete x.agent,
                        delete x.hostname,
                        delete x._defaultAgent,
                        delete x.defaultPort,
                        delete x.createConnection,
                        (y._last = !0),
                        (y.shouldKeepAlive = !1)
                      let P = !1,
                        U = null,
                        H = x.timeout || this.timeout,
                        j = q => {
                          y._hadError || (y.emit('error', q), (y._hadError = !0))
                        },
                        M = () => {
                          ;(U = null), (P = !0)
                          let q = new Error(`A "socket" was not created for HTTP request before ${H}ms`)
                          ;(q.code = 'ETIMEOUT'), j(q)
                        },
                        F = q => {
                          P || (U !== null && (clearTimeout(U), (U = null)), j(q))
                        },
                        z = q => {
                          if (P) return
                          if (
                            (U != null && (clearTimeout(U), (U = null)),
                            (L = q),
                            !!L && typeof L.addRequest == 'function')
                          )
                            return (
                              f('Callback returned another Agent instance %o', q.constructor.name),
                              void q.addRequest(y, x)
                            )
                          var L
                          if (q)
                            return (
                              q.once('free', () => {
                                this.freeSocket(q, x)
                              }),
                              void y.onSocket(q)
                            )
                          let S = new Error(`no Duplex stream was returned to agent-base for \`${y.method} ${y.path}\``)
                          j(S)
                        }
                      if (typeof this.callback == 'function') {
                        this.promisifiedCallback ||
                          (this.callback.length >= 3
                            ? (f('Converting legacy callback function to promise'),
                              (this.promisifiedCallback = d.default(this.callback)))
                            : (this.promisifiedCallback = this.callback)),
                          typeof H == 'number' && H > 0 && (U = setTimeout(M, H)),
                          'port' in x && typeof x.port != 'number' && (x.port = Number(x.port))
                        try {
                          f('Resolving socket for %o request: %o', x.protocol, `${y.method} ${y.path}`),
                            Promise.resolve(this.promisifiedCallback(y, x)).then(z, F)
                        } catch (q) {
                          Promise.reject(q).catch(F)
                        }
                      } else j(new Error('`callback` is not defined'))
                    }
                    freeSocket(y, b) {
                      f('Freeing socket %o %o', y.constructor.name, b), y.destroy()
                    }
                    destroy() {
                      f('Destroying agent %o', this.constructor.name)
                    }
                  }
                  ;(g.Agent = v), (g.prototype = g.Agent.prototype)
                })(h || (h = {})),
                  (s.exports = h)
              },
              304: (s, a) => {
                'use strict'
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.default = function (l) {
                    return function (c, u) {
                      return new Promise((p, d) => {
                        l.call(this, c, u, (f, m) => {
                          f ? d(f) : p(m)
                        })
                      })
                    }
                  })
              },
              370: function (s, a, l) {
                'use strict'
                var c =
                    (this && this.__awaiter) ||
                    function (y, b, x, P) {
                      return new (x || (x = Promise))(function (U, H) {
                        function j(z) {
                          try {
                            F(P.next(z))
                          } catch (q) {
                            H(q)
                          }
                        }
                        function M(z) {
                          try {
                            F(P.throw(z))
                          } catch (q) {
                            H(q)
                          }
                        }
                        function F(z) {
                          var q
                          z.done
                            ? U(z.value)
                            : ((q = z.value),
                              q instanceof x
                                ? q
                                : new x(function (L) {
                                    L(q)
                                  })).then(j, M)
                        }
                        F((P = P.apply(y, b || [])).next())
                      })
                    },
                  u =
                    (this && this.__importDefault) ||
                    function (y) {
                      return y && y.__esModule ? y : { default: y }
                    }
                Object.defineProperty(a, '__esModule', { value: !0 })
                let p = u(l(808)),
                  d = u(l(404)),
                  f = u(l(310)),
                  m = u(l(374)),
                  h = u(l(46)),
                  g = l(54),
                  v = (0, m.default)('http-proxy-agent')
                class _ extends g.Agent {
                  constructor(b) {
                    let x
                    if (((x = typeof b == 'string' ? f.default.parse(b) : b), !x))
                      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!')
                    v('Creating new HttpProxyAgent instance: %o', x), super(x)
                    let P = Object.assign({}, x)
                    var U
                    ;(this.secureProxy =
                      x.secureProxy || (typeof (U = P.protocol) == 'string' && /^https:?$/i.test(U))),
                      (P.host = P.hostname || P.host),
                      typeof P.port == 'string' && (P.port = parseInt(P.port, 10)),
                      !P.port && P.host && (P.port = this.secureProxy ? 443 : 80),
                      P.host && P.path && (delete P.path, delete P.pathname),
                      (this.proxy = P)
                  }
                  callback(b, x) {
                    return c(this, void 0, void 0, function* () {
                      let { proxy: P, secureProxy: U } = this,
                        H = f.default.parse(b.path),
                        j
                      if (
                        (H.protocol || (H.protocol = 'http:'),
                        H.hostname || (H.hostname = x.hostname || x.host || null),
                        H.port == null && (x.port, 1) && (H.port = String(x.port)),
                        H.port === '80' && (H.port = ''),
                        (b.path = f.default.format(H)),
                        P.auth && b.setHeader('Proxy-Authorization', `Basic ${Buffer.from(P.auth).toString('base64')}`),
                        U
                          ? (v('Creating `tls.Socket`: %o', P), (j = d.default.connect(P)))
                          : (v('Creating `net.Socket`: %o', P), (j = p.default.connect(P))),
                        b._header)
                      ) {
                        let M, F
                        v('Regenerating stored HTTP header string for request'),
                          (b._header = null),
                          b._implicitHeader(),
                          b.output && b.output.length > 0
                            ? (v('Patching connection write() output buffer with updated header'),
                              (M = b.output[0]),
                              (F =
                                M.indexOf(`\r
\r
`) + 4),
                              (b.output[0] = b._header + M.substring(F)),
                              v('Output buffer: %o', b.output))
                            : b.outputData &&
                              b.outputData.length > 0 &&
                              (v('Patching connection write() output buffer with updated header'),
                              (M = b.outputData[0].data),
                              (F =
                                M.indexOf(`\r
\r
`) + 4),
                              (b.outputData[0].data = b._header + M.substring(F)),
                              v('Output buffer: %o', b.outputData[0].data))
                      }
                      return yield (0, h.default)(j, 'connect'), j
                    })
                  }
                }
                a.default = _
              },
              201: function (s, a, l) {
                'use strict'
                let c = (
                  (this && this.__importDefault) ||
                  function (p) {
                    return p && p.__esModule ? p : { default: p }
                  }
                )(l(370))
                function u(p) {
                  return new c.default(p)
                }
                ;(function (p) {
                  ;(p.HttpProxyAgent = c.default), (p.prototype = c.default.prototype)
                })(u || (u = {})),
                  (s.exports = u)
              },
              146: function (s, a, l) {
                'use strict'
                var c =
                    (this && this.__awaiter) ||
                    function (x, P, U, H) {
                      return new (U || (U = Promise))(function (j, M) {
                        function F(L) {
                          try {
                            q(H.next(L))
                          } catch (S) {
                            M(S)
                          }
                        }
                        function z(L) {
                          try {
                            q(H.throw(L))
                          } catch (S) {
                            M(S)
                          }
                        }
                        function q(L) {
                          var S
                          L.done
                            ? j(L.value)
                            : ((S = L.value),
                              S instanceof U
                                ? S
                                : new U(function (T) {
                                    T(S)
                                  })).then(F, z)
                        }
                        q((H = H.apply(x, P || [])).next())
                      })
                    },
                  u =
                    (this && this.__importDefault) ||
                    function (x) {
                      return x && x.__esModule ? x : { default: x }
                    }
                Object.defineProperty(a, '__esModule', { value: !0 })
                let p = u(l(808)),
                  d = u(l(404)),
                  f = u(l(310)),
                  m = u(l(491)),
                  h = u(l(374)),
                  g = l(54),
                  v = u(l(829)),
                  _ = h.default('https-proxy-agent:agent')
                class y extends g.Agent {
                  constructor(P) {
                    let U
                    if (((U = typeof P == 'string' ? f.default.parse(P) : P), !U))
                      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!')
                    _('creating new HttpsProxyAgent instance: %o', U), super(U)
                    let H = Object.assign({}, U)
                    var j
                    ;(this.secureProxy =
                      U.secureProxy || (typeof (j = H.protocol) == 'string' && /^https:?$/i.test(j))),
                      (H.host = H.hostname || H.host),
                      typeof H.port == 'string' && (H.port = parseInt(H.port, 10)),
                      !H.port && H.host && (H.port = this.secureProxy ? 443 : 80),
                      this.secureProxy && !('ALPNProtocols' in H) && (H.ALPNProtocols = ['http 1.1']),
                      H.host && H.path && (delete H.path, delete H.pathname),
                      (this.proxy = H)
                  }
                  callback(P, U) {
                    return c(this, void 0, void 0, function* () {
                      let { proxy: H, secureProxy: j } = this,
                        M
                      j
                        ? (_('Creating `tls.Socket`: %o', H), (M = d.default.connect(H)))
                        : (_('Creating `net.Socket`: %o', H), (M = p.default.connect(H)))
                      let F = Object.assign({}, H.headers),
                        z = `CONNECT ${U.host}:${U.port} HTTP/1.1\r
`
                      H.auth && (F['Proxy-Authorization'] = `Basic ${Buffer.from(H.auth).toString('base64')}`)
                      let { host: q, port: L, secureEndpoint: S } = U
                      ;(function (ce, oe) {
                        return !!((!oe && ce === 80) || (oe && ce === 443))
                      })(L, S) || (q += `:${L}`),
                        (F.Host = q),
                        (F.Connection = 'close')
                      for (let ce of Object.keys(F))
                        z += `${ce}: ${F[ce]}\r
`
                      let T = v.default(M)
                      M.write(`${z}\r
`)
                      let { statusCode: A, buffered: X } = yield T
                      if (A === 200) {
                        if ((P.once('socket', b), U.secureEndpoint)) {
                          _('Upgrading socket connection to TLS')
                          let ce = U.servername || U.host
                          return d.default.connect(
                            Object.assign(
                              Object.assign(
                                {},
                                (function (oe, ...ae) {
                                  let je = {},
                                    Ye
                                  for (Ye in oe) ae.includes(Ye) || (je[Ye] = oe[Ye])
                                  return je
                                })(U, 'host', 'hostname', 'path', 'port')
                              ),
                              { socket: M, servername: ce }
                            )
                          )
                        }
                        return M
                      }
                      M.destroy()
                      let fe = new p.default.Socket({ writable: !1 })
                      return (
                        (fe.readable = !0),
                        P.once('socket', ce => {
                          _('replaying proxy buffer for failed request'),
                            m.default(ce.listenerCount('data') > 0),
                            ce.push(X),
                            ce.push(null)
                        }),
                        fe
                      )
                    })
                  }
                }
                function b(x) {
                  x.resume()
                }
                a.default = y
              },
              18: function (s, a, l) {
                'use strict'
                let c = (
                  (this && this.__importDefault) ||
                  function (p) {
                    return p && p.__esModule ? p : { default: p }
                  }
                )(l(146))
                function u(p) {
                  return new c.default(p)
                }
                ;(function (p) {
                  ;(p.HttpsProxyAgent = c.default), (p.prototype = c.default.prototype)
                })(u || (u = {})),
                  (s.exports = u)
              },
              829: function (s, a, l) {
                'use strict'
                var c =
                  (this && this.__importDefault) ||
                  function (p) {
                    return p && p.__esModule ? p : { default: p }
                  }
                Object.defineProperty(a, '__esModule', { value: !0 })
                let u = c(l(374)).default('https-proxy-agent:parse-proxy-response')
                a.default = function (p) {
                  return new Promise((d, f) => {
                    let m = 0,
                      h = []
                    function g() {
                      let y = p.read()
                      y
                        ? (function (b) {
                            h.push(b), (m += b.length)
                            let x = Buffer.concat(h, m)
                            if (
                              x.indexOf(`\r
\r
`) === -1
                            )
                              return u('have not received end of HTTP headers yet...'), void g()
                            let P = x.toString(
                                'ascii',
                                0,
                                x.indexOf(`\r
`)
                              ),
                              U = +P.split(' ')[1]
                            u('got proxy server response: %o', P), d({ statusCode: U, buffered: x })
                          })(y)
                        : p.once('readable', g)
                    }
                    function v(y) {
                      u('onclose had error %o', y)
                    }
                    function _() {
                      u('onend')
                    }
                    p.on('error', function y(b) {
                      p.removeListener('end', _),
                        p.removeListener('error', y),
                        p.removeListener('close', v),
                        p.removeListener('readable', g),
                        u('onerror %o', b),
                        f(b)
                    }),
                      p.on('close', v),
                      p.on('end', _),
                      g()
                  })
                }
              },
              539: function (s, a, l) {
                'use strict'
                var c,
                  u =
                    (this && this.__extends) ||
                    ((c = function (j, M) {
                      return (
                        (c =
                          Object.setPrototypeOf ||
                          ({ __proto__: [] } instanceof Array &&
                            function (F, z) {
                              F.__proto__ = z
                            }) ||
                          function (F, z) {
                            for (var q in z) Object.prototype.hasOwnProperty.call(z, q) && (F[q] = z[q])
                          }),
                        c(j, M)
                      )
                    }),
                    function (j, M) {
                      if (typeof M != 'function' && M !== null)
                        throw new TypeError('Class extends value ' + String(M) + ' is not a constructor or null')
                      function F() {
                        this.constructor = j
                      }
                      c(j, M), (j.prototype = M === null ? Object.create(M) : ((F.prototype = M.prototype), new F()))
                    }),
                  p =
                    (this && this.__assign) ||
                    function () {
                      return (
                        (p =
                          Object.assign ||
                          function (j) {
                            for (var M, F = 1, z = arguments.length; F < z; F++)
                              for (var q in (M = arguments[F]))
                                Object.prototype.hasOwnProperty.call(M, q) && (j[q] = M[q])
                            return j
                          }),
                        p.apply(this, arguments)
                      )
                    }
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.getErrorStatusDescription = a.xhr = a.configure = void 0)
                var d = l(685),
                  f = l(687),
                  m = l(310),
                  h = l(472),
                  g = l(796),
                  v = l(201),
                  _ = l(18)
                if (process.env.VSCODE_NLS_CONFIG) {
                  var y = process.env.VSCODE_NLS_CONFIG
                  h.config(JSON.parse(y))
                }
                var b = h.loadMessageBundle(),
                  x = void 0,
                  P = !0
                function U(j) {
                  var M
                  return new Promise(function (F, z) {
                    var q = (0, m.parse)(j.url),
                      L = {
                        hostname: q.hostname,
                        agent: !!j.agent && j.agent,
                        port: q.port ? parseInt(q.port) : q.protocol === 'https:' ? 443 : 80,
                        path: q.path,
                        method: j.type || 'GET',
                        headers: j.headers,
                        rejectUnauthorized: typeof j.strictSSL != 'boolean' || j.strictSSL,
                      }
                    j.user && j.password && (L.auth = j.user + ':' + j.password)
                    var S = function (T) {
                      if (
                        T.statusCode >= 300 &&
                        T.statusCode < 400 &&
                        j.followRedirects &&
                        j.followRedirects > 0 &&
                        T.headers.location
                      ) {
                        var A = T.headers.location
                        A.startsWith('/') &&
                          (A = (0, m.format)({
                            protocol: q.protocol,
                            hostname: q.hostname,
                            port: q.port,
                            pathname: A,
                          })),
                          F(
                            U(
                              (function (X) {
                                for (var fe = [], ce = 1; ce < arguments.length; ce++) fe[ce - 1] = arguments[ce]
                                return (
                                  fe.forEach(function (oe) {
                                    return Object.keys(oe).forEach(function (ae) {
                                      return (X[ae] = oe[ae])
                                    })
                                  }),
                                  X
                                )
                              })({}, j, { url: A, followRedirects: j.followRedirects - 1 })
                            )
                          )
                      } else F({ req: M, res: T })
                    }
                    ;(M = q.protocol === 'https:' ? f.request(L, S) : d.request(L, S)).on('error', z),
                      j.timeout && M.setTimeout(j.timeout),
                      j.data && M.write(j.data),
                      M.end(),
                      j.token &&
                        (j.token.isCancellationRequested && M.destroy(new H()),
                        j.token.onCancellationRequested(function () {
                          M.destroy(new H())
                        }))
                  })
                }
                ;(a.configure = function (j, M) {
                  ;(x = j), (P = M)
                }),
                  (a.xhr = function (j) {
                    return (
                      typeof (j = p({}, j)).strictSSL != 'boolean' && (j.strictSSL = P),
                      j.agent ||
                        (j.agent = (function (M, F) {
                          F === void 0 && (F = {})
                          var z = (0, m.parse)(M),
                            q =
                              F.proxyUrl ||
                              (function (T) {
                                return T.protocol === 'http:'
                                  ? process.env.HTTP_PROXY || process.env.http_proxy || null
                                  : (T.protocol === 'https:' &&
                                      (process.env.HTTPS_PROXY ||
                                        process.env.https_proxy ||
                                        process.env.HTTP_PROXY ||
                                        process.env.http_proxy)) ||
                                      null
                              })(z)
                          if (!q) return null
                          var L = (0, m.parse)(q)
                          if (!/^https?:$/.test(L.protocol)) return null
                          var S = {
                            host: L.hostname,
                            port: Number(L.port),
                            auth: L.auth,
                            rejectUnauthorized: typeof F.strictSSL != 'boolean' || F.strictSSL,
                            protocol: L.protocol,
                          }
                          return z.protocol === 'http:' ? v(S) : _(S)
                        })(j.url, { proxyUrl: x, strictSSL: P })),
                      typeof j.followRedirects != 'number' && (j.followRedirects = 5),
                      U(j).then(
                        function (M) {
                          return new Promise(function (F, z) {
                            var q,
                              L,
                              S = M.res,
                              T = S,
                              A = !1,
                              X = S.headers && S.headers['content-encoding']
                            if (
                              X &&
                              ((q = j.type),
                              (L = M.res.statusCode),
                              !(q === 'HEAD' || (L >= 100 && L < 200) || L === 204 || L === 304))
                            ) {
                              var fe = { flush: g.constants.Z_SYNC_FLUSH, finishFlush: g.constants.Z_SYNC_FLUSH }
                              if (X === 'gzip') {
                                var ce = g.createGunzip(fe)
                                S.pipe(ce), (T = ce)
                              } else if (X === 'deflate') {
                                var oe = g.createInflate(fe)
                                S.pipe(oe), (T = oe)
                              }
                            }
                            var ae = []
                            T.on('data', function (je) {
                              return ae.push(je)
                            }),
                              T.on('end', function () {
                                if (!A) {
                                  if (
                                    ((A = !0),
                                    j.followRedirects > 0 &&
                                      ((S.statusCode >= 300 && S.statusCode <= 303) || S.statusCode === 307))
                                  ) {
                                    var je = S.headers.location
                                    if (je.startsWith('/')) {
                                      var Ye = (0, m.parse)(j.url)
                                      je = (0, m.format)({
                                        protocol: Ye.protocol,
                                        hostname: Ye.hostname,
                                        port: Ye.port,
                                        pathname: je,
                                      })
                                    }
                                    if (je) {
                                      var Ze = {
                                        type: j.type,
                                        url: je,
                                        user: j.user,
                                        password: j.password,
                                        headers: j.headers,
                                        timeout: j.timeout,
                                        followRedirects: j.followRedirects - 1,
                                        data: j.data,
                                        token: j.token,
                                      }
                                      return void (0, a.xhr)(Ze).then(F, z)
                                    }
                                  }
                                  var ke = Buffer.concat(ae),
                                    st = {
                                      responseText: ke.toString(),
                                      body: ke,
                                      status: S.statusCode,
                                      headers: S.headers || {},
                                    }
                                  ;(S.statusCode >= 200 && S.statusCode < 300) || S.statusCode === 1223 ? F(st) : z(st)
                                }
                              }),
                              T.on('error', function (je) {
                                var Ye
                                ;(Ye = H.is(je)
                                  ? je
                                  : {
                                      responseText: b('error', 'Unable to access {0}. Error: {1}', j.url, je.message),
                                      body: Buffer.concat(ae),
                                      status: 500,
                                      headers: {},
                                    }),
                                  (A = !0),
                                  z(Ye)
                              }),
                              j.token &&
                                (j.token.isCancellationRequested && T.destroy(new H()),
                                j.token.onCancellationRequested(function () {
                                  T.destroy(new H())
                                }))
                          })
                        },
                        function (M) {
                          var F
                          return (
                            (F = H.is(M)
                              ? M
                              : {
                                  responseText: j.agent
                                    ? b(
                                        'error.cannot.connect.proxy',
                                        'Unable to connect to {0} through a proxy. Error: {1}',
                                        j.url,
                                        M.message
                                      )
                                    : b(
                                        'error.cannot.connect',
                                        'Unable to connect to {0}. Error: {1}',
                                        j.url,
                                        M.message
                                      ),
                                  body: Buffer.concat([]),
                                  status: 404,
                                  headers: {},
                                }),
                            Promise.reject(F)
                          )
                        }
                      )
                    )
                  }),
                  (a.getErrorStatusDescription = function (j) {
                    if (!(j < 400))
                      switch (j) {
                        case 400:
                          return b('status.400', 'Bad request. The request cannot be fulfilled due to bad syntax.')
                        case 401:
                          return b('status.401', 'Unauthorized. The server is refusing to respond.')
                        case 403:
                          return b('status.403', 'Forbidden. The server is refusing to respond.')
                        case 404:
                          return b('status.404', 'Not Found. The requested location could not be found.')
                        case 405:
                          return b(
                            'status.405',
                            'Method not allowed. A request was made using a request method not supported by that location.'
                          )
                        case 406:
                          return b(
                            'status.406',
                            'Not Acceptable. The server can only generate a response that is not accepted by the client.'
                          )
                        case 407:
                          return b(
                            'status.407',
                            'Proxy Authentication Required. The client must first authenticate itself with the proxy.'
                          )
                        case 408:
                          return b('status.408', 'Request Timeout. The server timed out waiting for the request.')
                        case 409:
                          return b(
                            'status.409',
                            'Conflict. The request could not be completed because of a conflict in the request.'
                          )
                        case 410:
                          return b('status.410', 'Gone. The requested page is no longer available.')
                        case 411:
                          return b('status.411', 'Length Required. The "Content-Length" is not defined.')
                        case 412:
                          return b(
                            'status.412',
                            'Precondition Failed. The precondition given in the request evaluated to false by the server.'
                          )
                        case 413:
                          return b(
                            'status.413',
                            'Request Entity Too Large. The server will not accept the request, because the request entity is too large.'
                          )
                        case 414:
                          return b(
                            'status.414',
                            'Request-URI Too Long. The server will not accept the request, because the URL is too long.'
                          )
                        case 415:
                          return b(
                            'status.415',
                            'Unsupported Media Type. The server will not accept the request, because the media type is not supported.'
                          )
                        case 500:
                          return b('status.500', 'Internal Server Error.')
                        case 501:
                          return b(
                            'status.501',
                            'Not Implemented. The server either does not recognize the request method, or it lacks the ability to fulfill the request.'
                          )
                        case 503:
                          return b(
                            'status.503',
                            'Service Unavailable. The server is currently unavailable (overloaded or down).'
                          )
                        default:
                          return b('status.416', 'HTTP status code {0}', j)
                      }
                  })
                var H = (function (j) {
                  function M() {
                    var F = j.call(this, 'The user aborted a request') || this
                    return (F.name = 'AbortError'), Object.setPrototypeOf(F, M.prototype), F
                  }
                  return (
                    u(M, j),
                    (M.is = function (F) {
                      return F instanceof M
                    }),
                    M
                  )
                })(Error)
              },
              800: (s, a, l) => {
                'use strict'
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.config =
                    a.loadMessageBundle =
                    a.localize =
                    a.format =
                    a.setPseudo =
                    a.isPseudo =
                    a.isDefined =
                    a.BundleFormat =
                    a.MessageFormat =
                      void 0)
                var c,
                  u,
                  p,
                  d = l(926)
                function f(h) {
                  return h !== void 0
                }
                function m(h, g) {
                  return (
                    a.isPseudo && (h = '\uFF3B' + h.replace(/[aouei]/g, '$&$&') + '\uFF3D'),
                    g.length === 0
                      ? h
                      : h.replace(/\{(\d+)\}/g, function (v, _) {
                          var y = _[0],
                            b = g[y],
                            x = v
                          return (
                            typeof b == 'string'
                              ? (x = b)
                              : (typeof b != 'number' && typeof b != 'boolean' && b != null) || (x = String(b)),
                            x
                          )
                        })
                  )
                }
                ;((p = a.MessageFormat || (a.MessageFormat = {})).file = 'file'),
                  (p.bundle = 'bundle'),
                  (p.both = 'both'),
                  ((u = a.BundleFormat || (a.BundleFormat = {})).standalone = 'standalone'),
                  (u.languagePack = 'languagePack'),
                  (function (h) {
                    h.is = function (g) {
                      var v = g
                      return v && f(v.key) && f(v.comment)
                    }
                  })(c || (c = {})),
                  (a.isDefined = f),
                  (a.isPseudo = !1),
                  (a.setPseudo = function (h) {
                    a.isPseudo = h
                  }),
                  (a.format = m),
                  (a.localize = function (h, g) {
                    for (var v = [], _ = 2; _ < arguments.length; _++) v[_ - 2] = arguments[_]
                    return m(g, v)
                  }),
                  (a.loadMessageBundle = function (h) {
                    return (0, d.default)().loadMessageBundle(h)
                  }),
                  (a.config = function (h) {
                    return (0, d.default)().config(h)
                  })
              },
              926: (s, a) => {
                'use strict'
                var l
                function c() {
                  if (l === void 0) throw new Error('No runtime abstraction layer installed')
                  return l
                }
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (function (u) {
                    u.install = function (p) {
                      if (p === void 0) throw new Error('No runtime abstraction layer provided')
                      l = p
                    }
                  })(c || (c = {})),
                  (a.default = c)
              },
              472: (s, a, l) => {
                'use strict'
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.config = a.loadMessageBundle = a.BundleFormat = a.MessageFormat = void 0)
                var c = l(17),
                  u = l(147),
                  p = l(926),
                  d = l(800),
                  f = l(800)
                Object.defineProperty(a, 'MessageFormat', {
                  enumerable: !0,
                  get: function () {
                    return f.MessageFormat
                  },
                }),
                  Object.defineProperty(a, 'BundleFormat', {
                    enumerable: !0,
                    get: function () {
                      return f.BundleFormat
                    },
                  })
                var m,
                  h,
                  g = Object.prototype.toString
                function v(M) {
                  return g.call(M) === '[object Number]'
                }
                function _(M) {
                  return g.call(M) === '[object String]'
                }
                function y(M) {
                  return JSON.parse(u.readFileSync(M, 'utf8'))
                }
                function b(M) {
                  return function (F, z) {
                    for (var q = [], L = 2; L < arguments.length; L++) q[L - 2] = arguments[L]
                    return v(F)
                      ? F >= M.length
                        ? void console.error(
                            `Broken localize call found. Index out of bounds. Stacktrace is
: `.concat(new Error('').stack)
                          )
                        : (0, d.format)(M[F], q)
                      : _(z)
                      ? (console.warn('Message '.concat(z, " didn't get externalized correctly.")), (0, d.format)(z, q))
                      : void console.error(
                          `Broken localize call found. Stacktrace is
: `.concat(new Error('').stack)
                        )
                  }
                }
                function x(M, F) {
                  return (m[M] = F), F
                }
                function P(M) {
                  try {
                    return (function (F) {
                      var z = y(c.join(F, 'nls.metadata.json')),
                        q = Object.create(null)
                      for (var L in z) {
                        var S = z[L]
                        q[L] = S.messages
                      }
                      return q
                    })(M)
                  } catch (F) {
                    return void console.log('Generating default bundle from meta data failed.', F)
                  }
                }
                function U(M, F) {
                  var z
                  if (
                    h.languagePackSupport === !0 &&
                    h.cacheRoot !== void 0 &&
                    h.languagePackId !== void 0 &&
                    h.translationsConfigFile !== void 0 &&
                    h.translationsConfig !== void 0
                  )
                    try {
                      z = (function (L, S) {
                        var T,
                          A,
                          X,
                          fe = c.join(h.cacheRoot, ''.concat(L.id, '-').concat(L.hash, '.json')),
                          ce = !1,
                          oe = !1
                        try {
                          return (
                            (T = JSON.parse(u.readFileSync(fe, { encoding: 'utf8', flag: 'r' }))),
                            (A = fe),
                            (X = new Date()),
                            u.utimes(A, X, X, function () {}),
                            T
                          )
                        } catch (ae) {
                          if (ae.code === 'ENOENT') oe = !0
                          else {
                            if (!(ae instanceof SyntaxError)) throw ae
                            console.log('Syntax error parsing message bundle: '.concat(ae.message, '.')),
                              u.unlink(fe, function (je) {
                                je && console.error('Deleting corrupted bundle '.concat(fe, ' failed.'))
                              }),
                              (ce = !0)
                          }
                        }
                        if (
                          ((T = (function (ae, je) {
                            var Ye = h.translationsConfig[ae.id]
                            if (Ye) {
                              var Ze = y(Ye).contents,
                                ke = y(c.join(je, 'nls.metadata.json')),
                                st = Object.create(null)
                              for (var tt in ke) {
                                var ve = ke[tt],
                                  W = Ze[''.concat(ae.outDir, '/').concat(tt)]
                                if (W) {
                                  for (var ne = [], ye = 0; ye < ve.keys.length; ye++) {
                                    var Te = ve.keys[ye],
                                      Ne = W[_(Te) ? Te : Te.key]
                                    Ne === void 0 && (Ne = ve.messages[ye]), ne.push(Ne)
                                  }
                                  st[tt] = ne
                                } else st[tt] = ve.messages
                              }
                              return st
                            }
                          })(L, S)),
                          !T || ce)
                        )
                          return T
                        if (oe)
                          try {
                            u.writeFileSync(fe, JSON.stringify(T), { encoding: 'utf8', flag: 'wx' })
                          } catch (ae) {
                            if (ae.code === 'EEXIST') return T
                            throw ae
                          }
                        return T
                      })(M, F)
                    } catch (L) {
                      console.log('Load or create bundle failed ', L)
                    }
                  if (!z) {
                    if (h.languagePackSupport) return P(F)
                    var q = (function (L) {
                      for (var S = h.language; S; ) {
                        var T = c.join(L, 'nls.bundle.'.concat(S, '.json'))
                        if (u.existsSync(T)) return T
                        var A = S.lastIndexOf('-')
                        S = A > 0 ? S.substring(0, A) : void 0
                      }
                      if (S === void 0 && ((T = c.join(L, 'nls.bundle.json')), u.existsSync(T))) return T
                    })(F)
                    if (q)
                      try {
                        return y(q)
                      } catch (L) {
                        console.log('Loading in the box message bundle failed.', L)
                      }
                    z = P(F)
                  }
                  return z
                }
                function H(M) {
                  if (!M) return d.localize
                  var F = c.extname(M)
                  if (
                    (F && (M = M.substr(0, M.length - F.length)),
                    h.messageFormat === d.MessageFormat.both || h.messageFormat === d.MessageFormat.bundle)
                  ) {
                    var z = (function (ce) {
                      for (
                        var oe, ae = c.dirname(ce);
                        (oe = c.join(ae, 'nls.metadata.header.json')), !u.existsSync(oe);

                      ) {
                        var je = c.dirname(ae)
                        if (je === ae) {
                          oe = void 0
                          break
                        }
                        ae = je
                      }
                      return oe
                    })(M)
                    if (z) {
                      var q = c.dirname(z),
                        L = m[q]
                      if (L === void 0)
                        try {
                          var S = JSON.parse(u.readFileSync(z, 'utf8'))
                          try {
                            var T = U(S, q)
                            L = x(q, T ? { header: S, nlsBundle: T } : null)
                          } catch (ce) {
                            console.error('Failed to load nls bundle', ce), (L = x(q, null))
                          }
                        } catch (ce) {
                          console.error('Failed to read header file', ce), (L = x(q, null))
                        }
                      if (L) {
                        var A = M.substr(q.length + 1).replace(/\\/g, '/'),
                          X = L.nlsBundle[A]
                        return X === void 0
                          ? (console.error('Messages for file '.concat(M, ' not found. See console for details.')),
                            function () {
                              return 'Messages not found.'
                            })
                          : b(X)
                      }
                    }
                  }
                  if (h.messageFormat === d.MessageFormat.both || h.messageFormat === d.MessageFormat.file)
                    try {
                      var fe = y(
                        (function (ce) {
                          var oe
                          if (!(h.cacheLanguageResolution && oe)) {
                            if (d.isPseudo || !h.language) oe = '.nls.json'
                            else
                              for (var ae = h.language; ae; ) {
                                var je = '.nls.' + ae + '.json'
                                if (u.existsSync(ce + je)) {
                                  oe = je
                                  break
                                }
                                var Ye = ae.lastIndexOf('-')
                                Ye > 0 ? (ae = ae.substring(0, Ye)) : ((oe = '.nls.json'), (ae = null))
                              }
                            h.cacheLanguageResolution
                          }
                          return ce + oe
                        })(M)
                      )
                      return Array.isArray(fe)
                        ? b(fe)
                        : (0, d.isDefined)(fe.messages) && (0, d.isDefined)(fe.keys)
                        ? b(fe.messages)
                        : (console.error("String bundle '".concat(M, "' uses an unsupported format.")),
                          function () {
                            return 'File bundle has unsupported format. See console for details'
                          })
                    } catch (ce) {
                      ce.code !== 'ENOENT' && console.error('Failed to load single file bundle', ce)
                    }
                  return (
                    console.error('Failed to load message bundle for file '.concat(M)),
                    function () {
                      return 'Failed to load message bundle. See console for details.'
                    }
                  )
                }
                function j(M) {
                  return (
                    M &&
                      (_(M.locale) &&
                        ((h.locale = M.locale.toLowerCase()), (h.language = h.locale), (m = Object.create(null))),
                      M.messageFormat !== void 0 && (h.messageFormat = M.messageFormat),
                      M.bundleFormat === d.BundleFormat.standalone &&
                        h.languagePackSupport === !0 &&
                        (h.languagePackSupport = !1)),
                    (0, d.setPseudo)(h.locale === 'pseudo'),
                    H
                  )
                }
                ;(function () {
                  if (
                    ((h = {
                      locale: void 0,
                      language: void 0,
                      languagePackSupport: !1,
                      cacheLanguageResolution: !0,
                      messageFormat: d.MessageFormat.bundle,
                    }),
                    _(process.env.VSCODE_NLS_CONFIG))
                  )
                    try {
                      var M = JSON.parse(process.env.VSCODE_NLS_CONFIG),
                        F = void 0
                      if (M.availableLanguages) {
                        var z = M.availableLanguages['*']
                        _(z) && (F = z)
                      }
                      if (
                        (_(M.locale) && (h.locale = M.locale.toLowerCase()),
                        F === void 0 ? (h.language = h.locale) : F !== 'en' && (h.language = F),
                        (function (L) {
                          return L === !0 || L === !1
                        })(M._languagePackSupport) && (h.languagePackSupport = M._languagePackSupport),
                        _(M._cacheRoot) && (h.cacheRoot = M._cacheRoot),
                        _(M._languagePackId) && (h.languagePackId = M._languagePackId),
                        _(M._translationsConfigFile))
                      ) {
                        h.translationsConfigFile = M._translationsConfigFile
                        try {
                          h.translationsConfig = y(h.translationsConfigFile)
                        } catch {
                          if (M._corruptedFile) {
                            var q = c.dirname(M._corruptedFile)
                            u.exists(q, function (S) {
                              S &&
                                u.writeFile(M._corruptedFile, 'corrupted', 'utf8', function (T) {
                                  console.error(T)
                                })
                            })
                          }
                        }
                      }
                    } catch {}
                  ;(0, d.setPseudo)(h.locale === 'pseudo'), (m = Object.create(null))
                })(),
                  (a.loadMessageBundle = H),
                  (a.config = j),
                  p.default.install(Object.freeze({ loadMessageBundle: H, config: j }))
              },
              374: (s, a) => {
                function l() {}
                Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.default = function (c) {
                    return l
                  })
              },
              491: s => {
                'use strict'
                s.exports = require('assert')
              },
              361: s => {
                'use strict'
                s.exports = require('events')
              },
              147: s => {
                'use strict'
                s.exports = require('fs')
              },
              685: s => {
                'use strict'
                s.exports = require('http')
              },
              687: s => {
                'use strict'
                s.exports = require('https')
              },
              808: s => {
                'use strict'
                s.exports = require('net')
              },
              17: s => {
                'use strict'
                s.exports = require('path')
              },
              404: s => {
                'use strict'
                s.exports = require('tls')
              },
              310: s => {
                'use strict'
                s.exports = require('url')
              },
              796: s => {
                'use strict'
                s.exports = require('zlib')
              },
            },
            r = {},
            n = (function s(a) {
              var l = r[a]
              if (l !== void 0) return l.exports
              var c = (r[a] = { exports: {} })
              return e[a].call(c.exports, c, c.exports, s), c.exports
            })(539),
            i = t
          for (var o in n) i[o] = n[o]
          n.__esModule && Object.defineProperty(i, '__esModule', { value: !0 })
        })()
      },
    }),
    Ez = {}
  xbe(Ez, { config: () => Abe, t: () => Tz })
  Sz.exports = Ebe(Ez)
  var Sbe = require('fs'),
    Cbe = require('fs/promises'),
    _z = bbe(Tbe())
  async function Ibe(t) {
    if (t.protocol === 'file:') return await (0, Cbe.readFile)(t, 'utf8')
    if (t.protocol === 'http:' || t.protocol === 'https:')
      try {
        let e = await (0, _z.xhr)({
          url: t.toString(),
          followRedirects: 5,
          headers: { 'Accept-Encoding': 'gzip, deflate', Accept: 'application/json' },
        })
        return new TextDecoder().decode(e.body)
      } catch (e) {
        throw new Error(e.responseText ?? (0, _z.getErrorStatusDescription)(e.status) ?? e.toString())
      }
    throw new Error('Unsupported protocol')
  }
  function wbe(t) {
    return (0, Sbe.readFileSync)(t, 'utf8')
  }
  var qx
  function Abe(t) {
    if ('contents' in t) {
      typeof t.contents == 'string' ? (qx = JSON.parse(t.contents)) : (qx = t.contents)
      return
    }
    if ('fsPath' in t) {
      let e = wbe(t.fsPath),
        r = JSON.parse(e)
      qx = yz(r) ? r.contents.bundle : r
      return
    }
    if (t.uri) {
      let e = t.uri
      return (
        typeof t.uri == 'string' && (e = new URL(t.uri)),
        new Promise((r, n) => {
          let i = Ibe(e)
            .then(o => {
              try {
                let s = JSON.parse(o)
                qx = yz(s) ? s.contents.bundle : s
              } catch (s) {
                n(s)
              }
            })
            .catch(o => {
              n(o)
            })
          r(i)
        })
      )
    }
  }
  function Tz(...t) {
    let e = t[0],
      r,
      n,
      i
    if (typeof e == 'string') (r = e), (n = e), t.splice(0, 1), (i = !t || typeof t[0] != 'object' ? t : t[0])
    else if (e instanceof Array) {
      let s = t.slice(1)
      if (e.length !== s.length + 1) throw new Error('expected a string as the first argument to l10n.t')
      let a = e[0]
      for (let l = 1; l < e.length; l++) a += `{${l - 1}}` + e[l]
      return Tz(a, ...s)
    } else
      (n = e.message),
        (r = n),
        e.comment && e.comment.length > 0 && (r += `/${Array.isArray(e.comment) ? e.comment.join('') : e.comment}`),
        (i = e.args ?? {})
    let o = qx?.[r]
    return o ? (typeof o == 'string' ? BC(o, i) : o.comment ? BC(o.message, i) : BC(n, i)) : BC(n, i)
  }
  var Rbe = /{([^}]+)}/g
  function BC(t, e) {
    return t.replace(Rbe, (r, n) => e[n] ?? r)
  }
  function yz(t) {
    return typeof t?.contents?.bundle == 'object' && typeof t?.version == 'string'
  }
})
var Iz = handleExports(OO => {
  var Cz = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('')
  OO.encode = function (t) {
    if (0 <= t && t < Cz.length) return Cz[t]
    throw new TypeError('Must be between 0 and 63: ' + t)
  }
  OO.decode = function (t) {
    var e = 65,
      r = 90,
      n = 97,
      i = 122,
      o = 48,
      s = 57,
      a = 43,
      l = 47,
      c = 26,
      u = 52
    return e <= t && t <= r
      ? t - e
      : n <= t && t <= i
      ? t - n + c
      : o <= t && t <= s
      ? t - o + u
      : t == a
      ? 62
      : t == l
      ? 63
      : -1
  }
})
var FO = handleExports(MO => {
  var wz = Iz(),
    LO = 5,
    Az = 1 << LO,
    Rz = Az - 1,
    Dz = Az
  function Dbe(t) {
    return t < 0 ? (-t << 1) + 1 : (t << 1) + 0
  }
  function Pbe(t) {
    var e = (t & 1) === 1,
      r = t >> 1
    return e ? -r : r
  }
  MO.encode = function (e) {
    var r = '',
      n,
      i = Dbe(e)
    do (n = i & Rz), (i >>>= LO), i > 0 && (n |= Dz), (r += wz.encode(n))
    while (i > 0)
    return r
  }
  MO.decode = function (e, r, n) {
    var i = e.length,
      o = 0,
      s = 0,
      a,
      l
    do {
      if (r >= i) throw new Error('Expected more digits in base 64 VLQ value.')
      if (((l = wz.decode(e.charCodeAt(r++))), l === -1)) throw new Error('Invalid base64 digit: ' + e.charAt(r - 1))
      ;(a = !!(l & Dz)), (l &= Rz), (o = o + (l << s)), (s += LO)
    } while (a)
    ;(n.value = Pbe(o)), (n.rest = r)
  }
})
var x0 = handleExports(vo => {
  function Nbe(t, e, r) {
    if (e in t) return t[e]
    if (arguments.length === 3) return r
    throw new Error('"' + e + '" is a required argument.')
  }
  vo.getArg = Nbe
  var Pz = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
    kbe = /^data:.+\,.+$/
  function Hx(t) {
    var e = t.match(Pz)
    return e ? { scheme: e[1], auth: e[2], host: e[3], port: e[4], path: e[5] } : null
  }
  vo.urlParse = Hx
  function _0(t) {
    var e = ''
    return (
      t.scheme && (e += t.scheme + ':'),
      (e += '//'),
      t.auth && (e += t.auth + '@'),
      t.host && (e += t.host),
      t.port && (e += ':' + t.port),
      t.path && (e += t.path),
      e
    )
  }
  vo.urlGenerate = _0
  function UO(t) {
    var e = t,
      r = Hx(t)
    if (r) {
      if (!r.path) return t
      e = r.path
    }
    for (var n = vo.isAbsolute(e), i = e.split(/\/+/), o, s = 0, a = i.length - 1; a >= 0; a--)
      (o = i[a]),
        o === '.'
          ? i.splice(a, 1)
          : o === '..'
          ? s++
          : s > 0 && (o === '' ? (i.splice(a + 1, s), (s = 0)) : (i.splice(a, 2), s--))
    return (e = i.join('/')), e === '' && (e = n ? '/' : '.'), r ? ((r.path = e), _0(r)) : e
  }
  vo.normalize = UO
  function Nz(t, e) {
    t === '' && (t = '.'), e === '' && (e = '.')
    var r = Hx(e),
      n = Hx(t)
    if ((n && (t = n.path || '/'), r && !r.scheme)) return n && (r.scheme = n.scheme), _0(r)
    if (r || e.match(kbe)) return e
    if (n && !n.host && !n.path) return (n.host = e), _0(n)
    var i = e.charAt(0) === '/' ? e : UO(t.replace(/\/+$/, '') + '/' + e)
    return n ? ((n.path = i), _0(n)) : i
  }
  vo.join = Nz
  vo.isAbsolute = function (t) {
    return t.charAt(0) === '/' || Pz.test(t)
  }
  function Obe(t, e) {
    t === '' && (t = '.'), (t = t.replace(/\/$/, ''))
    for (var r = 0; e.indexOf(t + '/') !== 0; ) {
      var n = t.lastIndexOf('/')
      if (n < 0 || ((t = t.slice(0, n)), t.match(/^([^\/]+:\/)?\/*$/))) return e
      ++r
    }
    return Array(r + 1).join('../') + e.substr(t.length + 1)
  }
  vo.relative = Obe
  var kz = (function () {
    var t = Object.create(null)
    return !('__proto__' in t)
  })()
  function Oz(t) {
    return t
  }
  function Lbe(t) {
    return Lz(t) ? '$' + t : t
  }
  vo.toSetString = kz ? Oz : Lbe
  function Mbe(t) {
    return Lz(t) ? t.slice(1) : t
  }
  vo.fromSetString = kz ? Oz : Mbe
  function Lz(t) {
    if (!t) return !1
    var e = t.length
    if (
      e < 9 ||
      t.charCodeAt(e - 1) !== 95 ||
      t.charCodeAt(e - 2) !== 95 ||
      t.charCodeAt(e - 3) !== 111 ||
      t.charCodeAt(e - 4) !== 116 ||
      t.charCodeAt(e - 5) !== 111 ||
      t.charCodeAt(e - 6) !== 114 ||
      t.charCodeAt(e - 7) !== 112 ||
      t.charCodeAt(e - 8) !== 95 ||
      t.charCodeAt(e - 9) !== 95
    )
      return !1
    for (var r = e - 10; r >= 0; r--) if (t.charCodeAt(r) !== 36) return !1
    return !0
  }
  function Fbe(t, e, r) {
    var n = y0(t.source, e.source)
    return n !== 0 ||
      ((n = t.originalLine - e.originalLine), n !== 0) ||
      ((n = t.originalColumn - e.originalColumn), n !== 0 || r) ||
      ((n = t.generatedColumn - e.generatedColumn), n !== 0) ||
      ((n = t.generatedLine - e.generatedLine), n !== 0)
      ? n
      : y0(t.name, e.name)
  }
  vo.compareByOriginalPositions = Fbe
  function Ube(t, e, r) {
    var n = t.generatedLine - e.generatedLine
    return n !== 0 ||
      ((n = t.generatedColumn - e.generatedColumn), n !== 0 || r) ||
      ((n = y0(t.source, e.source)), n !== 0) ||
      ((n = t.originalLine - e.originalLine), n !== 0) ||
      ((n = t.originalColumn - e.originalColumn), n !== 0)
      ? n
      : y0(t.name, e.name)
  }
  vo.compareByGeneratedPositionsDeflated = Ube
  function y0(t, e) {
    return t === e ? 0 : t === null ? 1 : e === null ? -1 : t > e ? 1 : -1
  }
  function Bbe(t, e) {
    var r = t.generatedLine - e.generatedLine
    return r !== 0 ||
      ((r = t.generatedColumn - e.generatedColumn), r !== 0) ||
      ((r = y0(t.source, e.source)), r !== 0) ||
      ((r = t.originalLine - e.originalLine), r !== 0) ||
      ((r = t.originalColumn - e.originalColumn), r !== 0)
      ? r
      : y0(t.name, e.name)
  }
  vo.compareByGeneratedPositionsInflated = Bbe
  function qbe(t) {
    return JSON.parse(t.replace(/^\)]}'[^\n]*\n/, ''))
  }
  vo.parseSourceMapInput = qbe
  function Hbe(t, e, r) {
    if (((e = e || ''), t && (t[t.length - 1] !== '/' && e[0] !== '/' && (t += '/'), (e = t + e)), r)) {
      var n = Hx(r)
      if (!n) throw new Error('sourceMapURL could not be parsed')
      if (n.path) {
        var i = n.path.lastIndexOf('/')
        i >= 0 && (n.path = n.path.substring(0, i + 1))
      }
      e = Nz(_0(n), e)
    }
    return UO(e)
  }
  vo.computeSourceURL = Hbe
})
var HO = handleExports(Mz => {
  var BO = x0(),
    qO = Object.prototype.hasOwnProperty,
    Ih = typeof Map < 'u'
  function Gu() {
    ;(this._array = []), (this._set = Ih ? new Map() : Object.create(null))
  }
  Gu.fromArray = function (e, r) {
    for (var n = new Gu(), i = 0, o = e.length; i < o; i++) n.add(e[i], r)
    return n
  }
  Gu.prototype.size = function () {
    return Ih ? this._set.size : Object.getOwnPropertyNames(this._set).length
  }
  Gu.prototype.add = function (e, r) {
    var n = Ih ? e : BO.toSetString(e),
      i = Ih ? this.has(e) : qO.call(this._set, n),
      o = this._array.length
    ;(!i || r) && this._array.push(e), i || (Ih ? this._set.set(e, o) : (this._set[n] = o))
  }
  Gu.prototype.has = function (e) {
    if (Ih) return this._set.has(e)
    var r = BO.toSetString(e)
    return qO.call(this._set, r)
  }
  Gu.prototype.indexOf = function (e) {
    if (Ih) {
      var r = this._set.get(e)
      if (r >= 0) return r
    } else {
      var n = BO.toSetString(e)
      if (qO.call(this._set, n)) return this._set[n]
    }
    throw new Error('"' + e + '" is not in the set.')
  }
  Gu.prototype.at = function (e) {
    if (e >= 0 && e < this._array.length) return this._array[e]
    throw new Error('No element indexed by ' + e)
  }
  Gu.prototype.toArray = function () {
    return this._array.slice()
  }
  Mz.ArraySet = Gu
})
var Bz = handleExports(Uz => {
  var Fz = x0()
  function jbe(t, e) {
    var r = t.generatedLine,
      n = e.generatedLine,
      i = t.generatedColumn,
      o = e.generatedColumn
    return n > r || (n == r && o >= i) || Fz.compareByGeneratedPositionsInflated(t, e) <= 0
  }
  function HC() {
    ;(this._array = []), (this._sorted = !0), (this._last = { generatedLine: -1, generatedColumn: 0 })
  }
  HC.prototype.unsortedForEach = function (e, r) {
    this._array.forEach(e, r)
  }
  HC.prototype.add = function (e) {
    jbe(this._last, e) ? ((this._last = e), this._array.push(e)) : ((this._sorted = !1), this._array.push(e))
  }
  HC.prototype.toArray = function () {
    return this._sorted || (this._array.sort(Fz.compareByGeneratedPositionsInflated), (this._sorted = !0)), this._array
  }
  Uz.MappingList = HC
})
var jO = handleExports(qz => {
  var jx = FO(),
    Jn = x0(),
    jC = HO().ArraySet,
    Gbe = Bz().MappingList
  function Aa(t) {
    t || (t = {}),
      (this._file = Jn.getArg(t, 'file', null)),
      (this._sourceRoot = Jn.getArg(t, 'sourceRoot', null)),
      (this._skipValidation = Jn.getArg(t, 'skipValidation', !1)),
      (this._sources = new jC()),
      (this._names = new jC()),
      (this._mappings = new Gbe()),
      (this._sourcesContents = null)
  }
  Aa.prototype._version = 3
  Aa.fromSourceMap = function (e) {
    var r = e.sourceRoot,
      n = new Aa({ file: e.file, sourceRoot: r })
    return (
      e.eachMapping(function (i) {
        var o = { generated: { line: i.generatedLine, column: i.generatedColumn } }
        i.source != null &&
          ((o.source = i.source),
          r != null && (o.source = Jn.relative(r, o.source)),
          (o.original = { line: i.originalLine, column: i.originalColumn }),
          i.name != null && (o.name = i.name)),
          n.addMapping(o)
      }),
      e.sources.forEach(function (i) {
        var o = i
        r !== null && (o = Jn.relative(r, i)), n._sources.has(o) || n._sources.add(o)
        var s = e.sourceContentFor(i)
        s != null && n.setSourceContent(i, s)
      }),
      n
    )
  }
  Aa.prototype.addMapping = function (e) {
    var r = Jn.getArg(e, 'generated'),
      n = Jn.getArg(e, 'original', null),
      i = Jn.getArg(e, 'source', null),
      o = Jn.getArg(e, 'name', null)
    this._skipValidation || this._validateMapping(r, n, i, o),
      i != null && ((i = String(i)), this._sources.has(i) || this._sources.add(i)),
      o != null && ((o = String(o)), this._names.has(o) || this._names.add(o)),
      this._mappings.add({
        generatedLine: r.line,
        generatedColumn: r.column,
        originalLine: n != null && n.line,
        originalColumn: n != null && n.column,
        source: i,
        name: o,
      })
  }
  Aa.prototype.setSourceContent = function (e, r) {
    var n = e
    this._sourceRoot != null && (n = Jn.relative(this._sourceRoot, n)),
      r != null
        ? (this._sourcesContents || (this._sourcesContents = Object.create(null)),
          (this._sourcesContents[Jn.toSetString(n)] = r))
        : this._sourcesContents &&
          (delete this._sourcesContents[Jn.toSetString(n)],
          Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null))
  }
  Aa.prototype.applySourceMap = function (e, r, n) {
    var i = r
    if (r == null) {
      if (e.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        )
      i = e.file
    }
    var o = this._sourceRoot
    o != null && (i = Jn.relative(o, i))
    var s = new jC(),
      a = new jC()
    this._mappings.unsortedForEach(function (l) {
      if (l.source === i && l.originalLine != null) {
        var c = e.originalPositionFor({ line: l.originalLine, column: l.originalColumn })
        c.source != null &&
          ((l.source = c.source),
          n != null && (l.source = Jn.join(n, l.source)),
          o != null && (l.source = Jn.relative(o, l.source)),
          (l.originalLine = c.line),
          (l.originalColumn = c.column),
          c.name != null && (l.name = c.name))
      }
      var u = l.source
      u != null && !s.has(u) && s.add(u)
      var p = l.name
      p != null && !a.has(p) && a.add(p)
    }, this),
      (this._sources = s),
      (this._names = a),
      e.sources.forEach(function (l) {
        var c = e.sourceContentFor(l)
        c != null &&
          (n != null && (l = Jn.join(n, l)), o != null && (l = Jn.relative(o, l)), this.setSourceContent(l, c))
      }, this)
  }
  Aa.prototype._validateMapping = function (e, r, n, i) {
    if (r && typeof r.line != 'number' && typeof r.column != 'number')
      throw new Error(
        'original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.'
      )
    if (!(e && 'line' in e && 'column' in e && e.line > 0 && e.column >= 0 && !r && !n && !i)) {
      if (
        e &&
        'line' in e &&
        'column' in e &&
        r &&
        'line' in r &&
        'column' in r &&
        e.line > 0 &&
        e.column >= 0 &&
        r.line > 0 &&
        r.column >= 0 &&
        n
      )
        return
      throw new Error('Invalid mapping: ' + JSON.stringify({ generated: e, source: n, original: r, name: i }))
    }
  }
  Aa.prototype._serializeMappings = function () {
    for (
      var e = 0,
        r = 1,
        n = 0,
        i = 0,
        o = 0,
        s = 0,
        a = '',
        l,
        c,
        u,
        p,
        d = this._mappings.toArray(),
        f = 0,
        m = d.length;
      f < m;
      f++
    ) {
      if (((c = d[f]), (l = ''), c.generatedLine !== r)) for (e = 0; c.generatedLine !== r; ) (l += ';'), r++
      else if (f > 0) {
        if (!Jn.compareByGeneratedPositionsInflated(c, d[f - 1])) continue
        l += ','
      }
      ;(l += jx.encode(c.generatedColumn - e)),
        (e = c.generatedColumn),
        c.source != null &&
          ((p = this._sources.indexOf(c.source)),
          (l += jx.encode(p - s)),
          (s = p),
          (l += jx.encode(c.originalLine - 1 - i)),
          (i = c.originalLine - 1),
          (l += jx.encode(c.originalColumn - n)),
          (n = c.originalColumn),
          c.name != null && ((u = this._names.indexOf(c.name)), (l += jx.encode(u - o)), (o = u))),
        (a += l)
    }
    return a
  }
  Aa.prototype._generateSourcesContent = function (e, r) {
    return e.map(function (n) {
      if (!this._sourcesContents) return null
      r != null && (n = Jn.relative(r, n))
      var i = Jn.toSetString(n)
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null
    }, this)
  }
  Aa.prototype.toJSON = function () {
    var e = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings(),
    }
    return (
      this._file != null && (e.file = this._file),
      this._sourceRoot != null && (e.sourceRoot = this._sourceRoot),
      this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)),
      e
    )
  }
  Aa.prototype.toString = function () {
    return JSON.stringify(this.toJSON())
  }
  qz.SourceMapGenerator = Aa
})
var Hz = handleExports(wh => {
  wh.GREATEST_LOWER_BOUND = 1
  wh.LEAST_UPPER_BOUND = 2
  function GO(t, e, r, n, i, o) {
    var s = Math.floor((e - t) / 2) + t,
      a = i(r, n[s], !0)
    return a === 0
      ? s
      : a > 0
      ? e - s > 1
        ? GO(s, e, r, n, i, o)
        : o == wh.LEAST_UPPER_BOUND
        ? e < n.length
          ? e
          : -1
        : s
      : s - t > 1
      ? GO(t, s, r, n, i, o)
      : o == wh.LEAST_UPPER_BOUND
      ? s
      : t < 0
      ? -1
      : t
  }
  wh.search = function (e, r, n, i) {
    if (r.length === 0) return -1
    var o = GO(-1, r.length, e, r, n, i || wh.GREATEST_LOWER_BOUND)
    if (o < 0) return -1
    for (; o - 1 >= 0 && n(r[o], r[o - 1], !0) === 0; ) --o
    return o
  }
})
var Gz = handleExports(jz => {
  function VO(t, e, r) {
    var n = t[e]
    ;(t[e] = t[r]), (t[r] = n)
  }
  function Vbe(t, e) {
    return Math.round(t + Math.random() * (e - t))
  }
  function zO(t, e, r, n) {
    if (r < n) {
      var i = Vbe(r, n),
        o = r - 1
      VO(t, i, n)
      for (var s = t[n], a = r; a < n; a++) e(t[a], s) <= 0 && ((o += 1), VO(t, o, a))
      VO(t, o + 1, a)
      var l = o + 1
      zO(t, e, r, l - 1), zO(t, e, l + 1, n)
    }
  }
  jz.quickSort = function (t, e) {
    zO(t, e, 0, t.length - 1)
  }
})
var zz = handleExports(GC => {
  var rt = x0(),
    $O = Hz(),
    b0 = HO().ArraySet,
    zbe = FO(),
    Gx = Gz().quickSort
  function Xr(t, e) {
    var r = t
    return typeof t == 'string' && (r = rt.parseSourceMapInput(t)), r.sections != null ? new xc(r, e) : new Qi(r, e)
  }
  Xr.fromSourceMap = function (t, e) {
    return Qi.fromSourceMap(t, e)
  }
  Xr.prototype._version = 3
  Xr.prototype.__generatedMappings = null
  Object.defineProperty(Xr.prototype, '_generatedMappings', {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings
    },
  })
  Xr.prototype.__originalMappings = null
  Object.defineProperty(Xr.prototype, '_originalMappings', {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings
    },
  })
  Xr.prototype._charIsMappingSeparator = function (e, r) {
    var n = e.charAt(r)
    return n === ';' || n === ','
  }
  Xr.prototype._parseMappings = function (e, r) {
    throw new Error('Subclasses must implement _parseMappings')
  }
  Xr.GENERATED_ORDER = 1
  Xr.ORIGINAL_ORDER = 2
  Xr.GREATEST_LOWER_BOUND = 1
  Xr.LEAST_UPPER_BOUND = 2
  Xr.prototype.eachMapping = function (e, r, n) {
    var i = r || null,
      o = n || Xr.GENERATED_ORDER,
      s
    switch (o) {
      case Xr.GENERATED_ORDER:
        s = this._generatedMappings
        break
      case Xr.ORIGINAL_ORDER:
        s = this._originalMappings
        break
      default:
        throw new Error('Unknown order of iteration.')
    }
    var a = this.sourceRoot
    s.map(function (l) {
      var c = l.source === null ? null : this._sources.at(l.source)
      return (
        (c = rt.computeSourceURL(a, c, this._sourceMapURL)),
        {
          source: c,
          generatedLine: l.generatedLine,
          generatedColumn: l.generatedColumn,
          originalLine: l.originalLine,
          originalColumn: l.originalColumn,
          name: l.name === null ? null : this._names.at(l.name),
        }
      )
    }, this).forEach(e, i)
  }
  Xr.prototype.allGeneratedPositionsFor = function (e) {
    var r = rt.getArg(e, 'line'),
      n = { source: rt.getArg(e, 'source'), originalLine: r, originalColumn: rt.getArg(e, 'column', 0) }
    if (((n.source = this._findSourceIndex(n.source)), n.source < 0)) return []
    var i = [],
      o = this._findMapping(
        n,
        this._originalMappings,
        'originalLine',
        'originalColumn',
        rt.compareByOriginalPositions,
        $O.LEAST_UPPER_BOUND
      )
    if (o >= 0) {
      var s = this._originalMappings[o]
      if (e.column === void 0)
        for (var a = s.originalLine; s && s.originalLine === a; )
          i.push({
            line: rt.getArg(s, 'generatedLine', null),
            column: rt.getArg(s, 'generatedColumn', null),
            lastColumn: rt.getArg(s, 'lastGeneratedColumn', null),
          }),
            (s = this._originalMappings[++o])
      else
        for (var l = s.originalColumn; s && s.originalLine === r && s.originalColumn == l; )
          i.push({
            line: rt.getArg(s, 'generatedLine', null),
            column: rt.getArg(s, 'generatedColumn', null),
            lastColumn: rt.getArg(s, 'lastGeneratedColumn', null),
          }),
            (s = this._originalMappings[++o])
    }
    return i
  }
  GC.SourceMapConsumer = Xr
  function Qi(t, e) {
    var r = t
    typeof t == 'string' && (r = rt.parseSourceMapInput(t))
    var n = rt.getArg(r, 'version'),
      i = rt.getArg(r, 'sources'),
      o = rt.getArg(r, 'names', []),
      s = rt.getArg(r, 'sourceRoot', null),
      a = rt.getArg(r, 'sourcesContent', null),
      l = rt.getArg(r, 'mappings'),
      c = rt.getArg(r, 'file', null)
    if (n != this._version) throw new Error('Unsupported version: ' + n)
    s && (s = rt.normalize(s)),
      (i = i
        .map(String)
        .map(rt.normalize)
        .map(function (u) {
          return s && rt.isAbsolute(s) && rt.isAbsolute(u) ? rt.relative(s, u) : u
        })),
      (this._names = b0.fromArray(o.map(String), !0)),
      (this._sources = b0.fromArray(i, !0)),
      (this._absoluteSources = this._sources.toArray().map(function (u) {
        return rt.computeSourceURL(s, u, e)
      })),
      (this.sourceRoot = s),
      (this.sourcesContent = a),
      (this._mappings = l),
      (this._sourceMapURL = e),
      (this.file = c)
  }
  Qi.prototype = Object.create(Xr.prototype)
  Qi.prototype.consumer = Xr
  Qi.prototype._findSourceIndex = function (t) {
    var e = t
    if ((this.sourceRoot != null && (e = rt.relative(this.sourceRoot, e)), this._sources.has(e)))
      return this._sources.indexOf(e)
    var r
    for (r = 0; r < this._absoluteSources.length; ++r) if (this._absoluteSources[r] == t) return r
    return -1
  }
  Qi.fromSourceMap = function (e, r) {
    var n = Object.create(Qi.prototype),
      i = (n._names = b0.fromArray(e._names.toArray(), !0)),
      o = (n._sources = b0.fromArray(e._sources.toArray(), !0))
    ;(n.sourceRoot = e._sourceRoot),
      (n.sourcesContent = e._generateSourcesContent(n._sources.toArray(), n.sourceRoot)),
      (n.file = e._file),
      (n._sourceMapURL = r),
      (n._absoluteSources = n._sources.toArray().map(function (f) {
        return rt.computeSourceURL(n.sourceRoot, f, r)
      }))
    for (
      var s = e._mappings.toArray().slice(),
        a = (n.__generatedMappings = []),
        l = (n.__originalMappings = []),
        c = 0,
        u = s.length;
      c < u;
      c++
    ) {
      var p = s[c],
        d = new Vz()
      ;(d.generatedLine = p.generatedLine),
        (d.generatedColumn = p.generatedColumn),
        p.source &&
          ((d.source = o.indexOf(p.source)),
          (d.originalLine = p.originalLine),
          (d.originalColumn = p.originalColumn),
          p.name && (d.name = i.indexOf(p.name)),
          l.push(d)),
        a.push(d)
    }
    return Gx(n.__originalMappings, rt.compareByOriginalPositions), n
  }
  Qi.prototype._version = 3
  Object.defineProperty(Qi.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice()
    },
  })
  function Vz() {
    ;(this.generatedLine = 0),
      (this.generatedColumn = 0),
      (this.source = null),
      (this.originalLine = null),
      (this.originalColumn = null),
      (this.name = null)
  }
  Qi.prototype._parseMappings = function (e, r) {
    for (
      var n = 1, i = 0, o = 0, s = 0, a = 0, l = 0, c = e.length, u = 0, p = {}, d = {}, f = [], m = [], h, g, v, _, y;
      u < c;

    )
      if (e.charAt(u) === ';') n++, u++, (i = 0)
      else if (e.charAt(u) === ',') u++
      else {
        for (h = new Vz(), h.generatedLine = n, _ = u; _ < c && !this._charIsMappingSeparator(e, _); _++);
        if (((g = e.slice(u, _)), (v = p[g]), v)) u += g.length
        else {
          for (v = []; u < _; ) zbe.decode(e, u, d), (y = d.value), (u = d.rest), v.push(y)
          if (v.length === 2) throw new Error('Found a source, but no line and column')
          if (v.length === 3) throw new Error('Found a source and line, but no column')
          p[g] = v
        }
        ;(h.generatedColumn = i + v[0]),
          (i = h.generatedColumn),
          v.length > 1 &&
            ((h.source = a + v[1]),
            (a += v[1]),
            (h.originalLine = o + v[2]),
            (o = h.originalLine),
            (h.originalLine += 1),
            (h.originalColumn = s + v[3]),
            (s = h.originalColumn),
            v.length > 4 && ((h.name = l + v[4]), (l += v[4]))),
          m.push(h),
          typeof h.originalLine == 'number' && f.push(h)
      }
    Gx(m, rt.compareByGeneratedPositionsDeflated),
      (this.__generatedMappings = m),
      Gx(f, rt.compareByOriginalPositions),
      (this.__originalMappings = f)
  }
  Qi.prototype._findMapping = function (e, r, n, i, o, s) {
    if (e[n] <= 0) throw new TypeError('Line must be greater than or equal to 1, got ' + e[n])
    if (e[i] < 0) throw new TypeError('Column must be greater than or equal to 0, got ' + e[i])
    return $O.search(e, r, o, s)
  }
  Qi.prototype.computeColumnSpans = function () {
    for (var e = 0; e < this._generatedMappings.length; ++e) {
      var r = this._generatedMappings[e]
      if (e + 1 < this._generatedMappings.length) {
        var n = this._generatedMappings[e + 1]
        if (r.generatedLine === n.generatedLine) {
          r.lastGeneratedColumn = n.generatedColumn - 1
          continue
        }
      }
      r.lastGeneratedColumn = 1 / 0
    }
  }
  Qi.prototype.originalPositionFor = function (e) {
    var r = { generatedLine: rt.getArg(e, 'line'), generatedColumn: rt.getArg(e, 'column') },
      n = this._findMapping(
        r,
        this._generatedMappings,
        'generatedLine',
        'generatedColumn',
        rt.compareByGeneratedPositionsDeflated,
        rt.getArg(e, 'bias', Xr.GREATEST_LOWER_BOUND)
      )
    if (n >= 0) {
      var i = this._generatedMappings[n]
      if (i.generatedLine === r.generatedLine) {
        var o = rt.getArg(i, 'source', null)
        o !== null && ((o = this._sources.at(o)), (o = rt.computeSourceURL(this.sourceRoot, o, this._sourceMapURL)))
        var s = rt.getArg(i, 'name', null)
        return (
          s !== null && (s = this._names.at(s)),
          { source: o, line: rt.getArg(i, 'originalLine', null), column: rt.getArg(i, 'originalColumn', null), name: s }
        )
      }
    }
    return { source: null, line: null, column: null, name: null }
  }
  Qi.prototype.hasContentsOfAllSources = function () {
    return this.sourcesContent
      ? this.sourcesContent.length >= this._sources.size() &&
          !this.sourcesContent.some(function (e) {
            return e == null
          })
      : !1
  }
  Qi.prototype.sourceContentFor = function (e, r) {
    if (!this.sourcesContent) return null
    var n = this._findSourceIndex(e)
    if (n >= 0) return this.sourcesContent[n]
    var i = e
    this.sourceRoot != null && (i = rt.relative(this.sourceRoot, i))
    var o
    if (this.sourceRoot != null && (o = rt.urlParse(this.sourceRoot))) {
      var s = i.replace(/^file:\/\//, '')
      if (o.scheme == 'file' && this._sources.has(s)) return this.sourcesContent[this._sources.indexOf(s)]
      if ((!o.path || o.path == '/') && this._sources.has('/' + i))
        return this.sourcesContent[this._sources.indexOf('/' + i)]
    }
    if (r) return null
    throw new Error('"' + i + '" is not in the SourceMap.')
  }
  Qi.prototype.generatedPositionFor = function (e) {
    var r = rt.getArg(e, 'source')
    if (((r = this._findSourceIndex(r)), r < 0)) return { line: null, column: null, lastColumn: null }
    var n = { source: r, originalLine: rt.getArg(e, 'line'), originalColumn: rt.getArg(e, 'column') },
      i = this._findMapping(
        n,
        this._originalMappings,
        'originalLine',
        'originalColumn',
        rt.compareByOriginalPositions,
        rt.getArg(e, 'bias', Xr.GREATEST_LOWER_BOUND)
      )
    if (i >= 0) {
      var o = this._originalMappings[i]
      if (o.source === n.source)
        return {
          line: rt.getArg(o, 'generatedLine', null),
          column: rt.getArg(o, 'generatedColumn', null),
          lastColumn: rt.getArg(o, 'lastGeneratedColumn', null),
        }
    }
    return { line: null, column: null, lastColumn: null }
  }
  GC.BasicSourceMapConsumer = Qi
  function xc(t, e) {
    var r = t
    typeof t == 'string' && (r = rt.parseSourceMapInput(t))
    var n = rt.getArg(r, 'version'),
      i = rt.getArg(r, 'sections')
    if (n != this._version) throw new Error('Unsupported version: ' + n)
    ;(this._sources = new b0()), (this._names = new b0())
    var o = { line: -1, column: 0 }
    this._sections = i.map(function (s) {
      if (s.url) throw new Error('Support for url field in sections not implemented.')
      var a = rt.getArg(s, 'offset'),
        l = rt.getArg(a, 'line'),
        c = rt.getArg(a, 'column')
      if (l < o.line || (l === o.line && c < o.column))
        throw new Error('Section offsets must be ordered and non-overlapping.')
      return (
        (o = a),
        { generatedOffset: { generatedLine: l + 1, generatedColumn: c + 1 }, consumer: new Xr(rt.getArg(s, 'map'), e) }
      )
    })
  }
  xc.prototype = Object.create(Xr.prototype)
  xc.prototype.constructor = Xr
  xc.prototype._version = 3
  Object.defineProperty(xc.prototype, 'sources', {
    get: function () {
      for (var t = [], e = 0; e < this._sections.length; e++)
        for (var r = 0; r < this._sections[e].consumer.sources.length; r++)
          t.push(this._sections[e].consumer.sources[r])
      return t
    },
  })
  xc.prototype.originalPositionFor = function (e) {
    var r = { generatedLine: rt.getArg(e, 'line'), generatedColumn: rt.getArg(e, 'column') },
      n = $O.search(r, this._sections, function (o, s) {
        var a = o.generatedLine - s.generatedOffset.generatedLine
        return a || o.generatedColumn - s.generatedOffset.generatedColumn
      }),
      i = this._sections[n]
    return i
      ? i.consumer.originalPositionFor({
          line: r.generatedLine - (i.generatedOffset.generatedLine - 1),
          column:
            r.generatedColumn -
            (i.generatedOffset.generatedLine === r.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
          bias: e.bias,
        })
      : { source: null, line: null, column: null, name: null }
  }
  xc.prototype.hasContentsOfAllSources = function () {
    return this._sections.every(function (e) {
      return e.consumer.hasContentsOfAllSources()
    })
  }
  xc.prototype.sourceContentFor = function (e, r) {
    for (var n = 0; n < this._sections.length; n++) {
      var i = this._sections[n],
        o = i.consumer.sourceContentFor(e, !0)
      if (o) return o
    }
    if (r) return null
    throw new Error('"' + e + '" is not in the SourceMap.')
  }
  xc.prototype.generatedPositionFor = function (e) {
    for (var r = 0; r < this._sections.length; r++) {
      var n = this._sections[r]
      if (n.consumer._findSourceIndex(rt.getArg(e, 'source')) !== -1) {
        var i = n.consumer.generatedPositionFor(e)
        if (i) {
          var o = {
            line: i.line + (n.generatedOffset.generatedLine - 1),
            column: i.column + (n.generatedOffset.generatedLine === i.line ? n.generatedOffset.generatedColumn - 1 : 0),
          }
          return o
        }
      }
    }
    return { line: null, column: null }
  }
  xc.prototype._parseMappings = function (e, r) {
    ;(this.__generatedMappings = []), (this.__originalMappings = [])
    for (var n = 0; n < this._sections.length; n++)
      for (var i = this._sections[n], o = i.consumer._generatedMappings, s = 0; s < o.length; s++) {
        var a = o[s],
          l = i.consumer._sources.at(a.source)
        ;(l = rt.computeSourceURL(i.consumer.sourceRoot, l, this._sourceMapURL)),
          this._sources.add(l),
          (l = this._sources.indexOf(l))
        var c = null
        a.name && ((c = i.consumer._names.at(a.name)), this._names.add(c), (c = this._names.indexOf(c)))
        var u = {
          source: l,
          generatedLine: a.generatedLine + (i.generatedOffset.generatedLine - 1),
          generatedColumn:
            a.generatedColumn +
            (i.generatedOffset.generatedLine === a.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
          originalLine: a.originalLine,
          originalColumn: a.originalColumn,
          name: c,
        }
        this.__generatedMappings.push(u), typeof u.originalLine == 'number' && this.__originalMappings.push(u)
      }
    Gx(this.__generatedMappings, rt.compareByGeneratedPositionsDeflated),
      Gx(this.__originalMappings, rt.compareByOriginalPositions)
  }
  GC.IndexedSourceMapConsumer = xc
})
var Wz = handleExports($z => {
  var $be = jO().SourceMapGenerator,
    VC = x0(),
    Wbe = /(\r?\n)/,
    Kbe = 10,
    E0 = '$$$isSourceNode$$$'
  function Ws(t, e, r, n, i) {
    ;(this.children = []),
      (this.sourceContents = {}),
      (this.line = t ?? null),
      (this.column = e ?? null),
      (this.source = r ?? null),
      (this.name = i ?? null),
      (this[E0] = !0),
      n != null && this.add(n)
  }
  Ws.fromStringWithSourceMap = function (e, r, n) {
    var i = new Ws(),
      o = e.split(Wbe),
      s = 0,
      a = function () {
        var d = m(),
          f = m() || ''
        return d + f
        function m() {
          return s < o.length ? o[s++] : void 0
        }
      },
      l = 1,
      c = 0,
      u = null
    return (
      r.eachMapping(function (d) {
        if (u !== null)
          if (l < d.generatedLine) p(u, a()), l++, (c = 0)
          else {
            var f = o[s] || '',
              m = f.substr(0, d.generatedColumn - c)
            ;(o[s] = f.substr(d.generatedColumn - c)), (c = d.generatedColumn), p(u, m), (u = d)
            return
          }
        for (; l < d.generatedLine; ) i.add(a()), l++
        if (c < d.generatedColumn) {
          var f = o[s] || ''
          i.add(f.substr(0, d.generatedColumn)), (o[s] = f.substr(d.generatedColumn)), (c = d.generatedColumn)
        }
        u = d
      }, this),
      s < o.length && (u && p(u, a()), i.add(o.splice(s).join(''))),
      r.sources.forEach(function (d) {
        var f = r.sourceContentFor(d)
        f != null && (n != null && (d = VC.join(n, d)), i.setSourceContent(d, f))
      }),
      i
    )
    function p(d, f) {
      if (d === null || d.source === void 0) i.add(f)
      else {
        var m = n ? VC.join(n, d.source) : d.source
        i.add(new Ws(d.originalLine, d.originalColumn, m, f, d.name))
      }
    }
  }
  Ws.prototype.add = function (e) {
    if (Array.isArray(e))
      e.forEach(function (r) {
        this.add(r)
      }, this)
    else if (e[E0] || typeof e == 'string') e && this.children.push(e)
    else throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + e)
    return this
  }
  Ws.prototype.prepend = function (e) {
    if (Array.isArray(e)) for (var r = e.length - 1; r >= 0; r--) this.prepend(e[r])
    else if (e[E0] || typeof e == 'string') this.children.unshift(e)
    else throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + e)
    return this
  }
  Ws.prototype.walk = function (e) {
    for (var r, n = 0, i = this.children.length; n < i; n++)
      (r = this.children[n]),
        r[E0]
          ? r.walk(e)
          : r !== '' && e(r, { source: this.source, line: this.line, column: this.column, name: this.name })
  }
  Ws.prototype.join = function (e) {
    var r,
      n,
      i = this.children.length
    if (i > 0) {
      for (r = [], n = 0; n < i - 1; n++) r.push(this.children[n]), r.push(e)
      r.push(this.children[n]), (this.children = r)
    }
    return this
  }
  Ws.prototype.replaceRight = function (e, r) {
    var n = this.children[this.children.length - 1]
    return (
      n[E0]
        ? n.replaceRight(e, r)
        : typeof n == 'string'
        ? (this.children[this.children.length - 1] = n.replace(e, r))
        : this.children.push(''.replace(e, r)),
      this
    )
  }
  Ws.prototype.setSourceContent = function (e, r) {
    this.sourceContents[VC.toSetString(e)] = r
  }
  Ws.prototype.walkSourceContents = function (e) {
    for (var r = 0, n = this.children.length; r < n; r++) this.children[r][E0] && this.children[r].walkSourceContents(e)
    for (var i = Object.keys(this.sourceContents), r = 0, n = i.length; r < n; r++)
      e(VC.fromSetString(i[r]), this.sourceContents[i[r]])
  }
  Ws.prototype.toString = function () {
    var e = ''
    return (
      this.walk(function (r) {
        e += r
      }),
      e
    )
  }
  Ws.prototype.toStringWithSourceMap = function (e) {
    var r = { code: '', line: 1, column: 0 },
      n = new $be(e),
      i = !1,
      o = null,
      s = null,
      a = null,
      l = null
    return (
      this.walk(function (c, u) {
        ;(r.code += c),
          u.source !== null && u.line !== null && u.column !== null
            ? ((o !== u.source || s !== u.line || a !== u.column || l !== u.name) &&
                n.addMapping({
                  source: u.source,
                  original: { line: u.line, column: u.column },
                  generated: { line: r.line, column: r.column },
                  name: u.name,
                }),
              (o = u.source),
              (s = u.line),
              (a = u.column),
              (l = u.name),
              (i = !0))
            : i && (n.addMapping({ generated: { line: r.line, column: r.column } }), (o = null), (i = !1))
        for (var p = 0, d = c.length; p < d; p++)
          c.charCodeAt(p) === Kbe
            ? (r.line++,
              (r.column = 0),
              p + 1 === d
                ? ((o = null), (i = !1))
                : i &&
                  n.addMapping({
                    source: u.source,
                    original: { line: u.line, column: u.column },
                    generated: { line: r.line, column: r.column },
                    name: u.name,
                  }))
            : r.column++
      }),
      this.walkSourceContents(function (c, u) {
        n.setSourceContent(c, u)
      }),
      { code: r.code, map: n }
    )
  }
  $z.SourceNode = Ws
})
var Kz = handleExports(zC => {
  zC.SourceMapGenerator = jO().SourceMapGenerator
  zC.SourceMapConsumer = zz().SourceMapConsumer
  zC.SourceNode = Wz().SourceNode
})
var Qz = handleExports((JYe, Yz) => {
  var Ybe = Object.prototype.toString,
    WO =
      typeof Buffer < 'u' &&
      typeof Buffer.alloc == 'function' &&
      typeof Buffer.allocUnsafe == 'function' &&
      typeof Buffer.from == 'function'
  function Qbe(t) {
    return Ybe.call(t).slice(8, -1) === 'ArrayBuffer'
  }
  function Xbe(t, e, r) {
    e >>>= 0
    var n = t.byteLength - e
    if (n < 0) throw new RangeError("'offset' is out of bounds")
    if (r === void 0) r = n
    else if (((r >>>= 0), r > n)) throw new RangeError("'length' is out of bounds")
    return WO ? Buffer.from(t.slice(e, e + r)) : new Buffer(new Uint8Array(t.slice(e, e + r)))
  }
  function Jbe(t, e) {
    if (((typeof e != 'string' || e === '') && (e = 'utf8'), !Buffer.isEncoding(e)))
      throw new TypeError('"encoding" must be a valid string encoding')
    return WO ? Buffer.from(t, e) : new Buffer(t, e)
  }
  function Zbe(t, e, r) {
    if (typeof t == 'number') throw new TypeError('"value" argument must not be a number')
    return Qbe(t) ? Xbe(t, e, r) : typeof t == 'string' ? Jbe(t, e) : WO ? Buffer.from(t) : new Buffer(t)
  }
  Yz.exports = Zbe
})
var i$ = handleExports((Rh, XO) => {
  var eEe = Kz().SourceMapConsumer,
    KO = require('path'),
    fl
  try {
    ;(fl = require('fs')), (!fl.existsSync || !fl.readFileSync) && (fl = null)
  } catch {}
  var tEe = Qz()
  function Xz(t, e) {
    return t.require(e)
  }
  var Jz = !1,
    Zz = !1,
    YO = !1,
    Vx = 'auto',
    Ah = {},
    zx = {},
    rEe = /^data:application\/json[^,]+base64,/,
    Ad = [],
    Rd = []
  function JO() {
    return Vx === 'browser'
      ? !0
      : Vx === 'node'
      ? !1
      : typeof window < 'u' &&
        typeof XMLHttpRequest == 'function' &&
        !(window.require && window.module && window.process && window.process.type === 'renderer')
  }
  function nEe() {
    return typeof process == 'object' && process !== null && typeof process.on == 'function'
  }
  function iEe() {
    return typeof process == 'object' && process !== null ? process.version : ''
  }
  function oEe() {
    if (typeof process == 'object' && process !== null) return process.stderr
  }
  function sEe(t) {
    if (typeof process == 'object' && process !== null && typeof process.exit == 'function') return process.exit(t)
  }
  function $C(t) {
    return function (e) {
      for (var r = 0; r < t.length; r++) {
        var n = t[r](e)
        if (n) return n
      }
      return null
    }
  }
  var ZO = $C(Ad)
  Ad.push(function (t) {
    if (
      ((t = t.trim()),
      /^file:/.test(t) &&
        (t = t.replace(/file:\/\/\/(\w:)?/, function (n, i) {
          return i ? '' : '/'
        })),
      t in Ah)
    )
      return Ah[t]
    var e = ''
    try {
      if (fl) fl.existsSync(t) && (e = fl.readFileSync(t, 'utf8'))
      else {
        var r = new XMLHttpRequest()
        r.open('GET', t, !1), r.send(null), r.readyState === 4 && r.status === 200 && (e = r.responseText)
      }
    } catch {}
    return (Ah[t] = e)
  })
  function QO(t, e) {
    if (!t) return e
    var r = KO.dirname(t),
      n = /^\w+:\/\/[^\/]*/.exec(r),
      i = n ? n[0] : '',
      o = r.slice(i.length)
    return i && /^\/\w\:/.test(o)
      ? ((i += '/'), i + KO.resolve(r.slice(i.length), e).replace(/\\/g, '/'))
      : i + KO.resolve(r.slice(i.length), e)
  }
  function aEe(t) {
    var e
    if (JO())
      try {
        var r = new XMLHttpRequest()
        r.open('GET', t, !1), r.send(null), (e = r.readyState === 4 ? r.responseText : null)
        var n = r.getResponseHeader('SourceMap') || r.getResponseHeader('X-SourceMap')
        if (n) return n
      } catch {}
    e = ZO(t)
    for (
      var i =
          /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm,
        o,
        s;
      (s = i.exec(e));

    )
      o = s
    return o ? o[1] : null
  }
  var eL = $C(Rd)
  Rd.push(function (t) {
    var e = aEe(t)
    if (!e) return null
    var r
    if (rEe.test(e)) {
      var n = e.slice(e.indexOf(',') + 1)
      ;(r = tEe(n, 'base64').toString()), (e = t)
    } else (e = QO(t, e)), (r = ZO(e))
    return r ? { url: e, map: r } : null
  })
  function tL(t) {
    var e = zx[t.source]
    if (!e) {
      var r = eL(t.source)
      r
        ? ((e = zx[t.source] = { url: r.url, map: new eEe(r.map) }),
          e.map.sourcesContent &&
            e.map.sources.forEach(function (i, o) {
              var s = e.map.sourcesContent[o]
              if (s) {
                var a = QO(e.url, i)
                Ah[a] = s
              }
            }))
        : (e = zx[t.source] = { url: null, map: null })
    }
    if (e && e.map && typeof e.map.originalPositionFor == 'function') {
      var n = e.map.originalPositionFor(t)
      if (n.source !== null) return (n.source = QO(e.url, n.source)), n
    }
    return t
  }
  function t$(t) {
    var e = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(t)
    if (e) {
      var r = tL({ source: e[2], line: +e[3], column: e[4] - 1 })
      return 'eval at ' + e[1] + ' (' + r.source + ':' + r.line + ':' + (r.column + 1) + ')'
    }
    return (e = /^eval at ([^(]+) \((.+)\)$/.exec(t)), e ? 'eval at ' + e[1] + ' (' + t$(e[2]) + ')' : t
  }
  function cEe() {
    var t,
      e = ''
    if (this.isNative()) e = 'native'
    else {
      ;(t = this.getScriptNameOrSourceURL()),
        !t && this.isEval() && ((e = this.getEvalOrigin()), (e += ', ')),
        t ? (e += t) : (e += '<anonymous>')
      var r = this.getLineNumber()
      if (r != null) {
        e += ':' + r
        var n = this.getColumnNumber()
        n && (e += ':' + n)
      }
    }
    var i = '',
      o = this.getFunctionName(),
      s = !0,
      a = this.isConstructor(),
      l = !(this.isToplevel() || a)
    if (l) {
      var c = this.getTypeName()
      c === '[object Object]' && (c = 'null')
      var u = this.getMethodName()
      o
        ? (c && o.indexOf(c) != 0 && (i += c + '.'),
          (i += o),
          u && o.indexOf('.' + u) != o.length - u.length - 1 && (i += ' [as ' + u + ']'))
        : (i += c + '.' + (u || '<anonymous>'))
    } else a ? (i += 'new ' + (o || '<anonymous>')) : o ? (i += o) : ((i += e), (s = !1))
    return s && (i += ' (' + e + ')'), i
  }
  function e$(t) {
    var e = {}
    return (
      Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach(function (r) {
        e[r] = /^(?:is|get)/.test(r)
          ? function () {
              return t[r].call(t)
            }
          : t[r]
      }),
      (e.toString = cEe),
      e
    )
  }
  function r$(t, e) {
    if ((e === void 0 && (e = { nextPosition: null, curPosition: null }), t.isNative()))
      return (e.curPosition = null), t
    var r = t.getFileName() || t.getScriptNameOrSourceURL()
    if (r) {
      var n = t.getLineNumber(),
        i = t.getColumnNumber() - 1,
        o = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/,
        s = o.test(iEe()) ? 0 : 62
      n === 1 && i > s && !JO() && !t.isEval() && (i -= s)
      var a = tL({ source: r, line: n, column: i })
      ;(e.curPosition = a), (t = e$(t))
      var l = t.getFunctionName
      return (
        (t.getFunctionName = function () {
          return e.nextPosition == null ? l() : e.nextPosition.name || l()
        }),
        (t.getFileName = function () {
          return a.source
        }),
        (t.getLineNumber = function () {
          return a.line
        }),
        (t.getColumnNumber = function () {
          return a.column + 1
        }),
        (t.getScriptNameOrSourceURL = function () {
          return a.source
        }),
        t
      )
    }
    var c = t.isEval() && t.getEvalOrigin()
    return (
      c &&
        ((c = t$(c)),
        (t = e$(t)),
        (t.getEvalOrigin = function () {
          return c
        })),
      t
    )
  }
  function lEe(t, e) {
    YO && ((Ah = {}), (zx = {}))
    for (
      var r = t.name || 'Error',
        n = t.message || '',
        i = r + ': ' + n,
        o = { nextPosition: null, curPosition: null },
        s = [],
        a = e.length - 1;
      a >= 0;
      a--
    )
      s.push(
        `
    at ` + r$(e[a], o)
      ),
        (o.nextPosition = o.curPosition)
    return (o.curPosition = o.nextPosition = null), i + s.reverse().join('')
  }
  function n$(t) {
    var e = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(t.stack)
    if (e) {
      var r = e[1],
        n = +e[2],
        i = +e[3],
        o = Ah[r]
      if (!o && fl && fl.existsSync(r))
        try {
          o = fl.readFileSync(r, 'utf8')
        } catch {
          o = ''
        }
      if (o) {
        var s = o.split(/(?:\r\n|\r|\n)/)[n - 1]
        if (s)
          return (
            r +
            ':' +
            n +
            `
` +
            s +
            `
` +
            new Array(i).join(' ') +
            '^'
          )
      }
    }
    return null
  }
  function uEe(t) {
    var e = n$(t),
      r = oEe()
    r && r._handle && r._handle.setBlocking && r._handle.setBlocking(!0),
      e && (console.error(), console.error(e)),
      console.error(t.stack),
      sEe(1)
  }
  function pEe() {
    var t = process.emit
    process.emit = function (e) {
      if (e === 'uncaughtException') {
        var r = arguments[1] && arguments[1].stack,
          n = this.listeners(e).length > 0
        if (r && !n) return uEe(arguments[1])
      }
      return t.apply(this, arguments)
    }
  }
  var dEe = Ad.slice(0),
    fEe = Rd.slice(0)
  Rh.wrapCallSite = r$
  Rh.getErrorSource = n$
  Rh.mapSourcePosition = tL
  Rh.retrieveSourceMap = eL
  Rh.install = function (t) {
    if (((t = t || {}), t.environment && ((Vx = t.environment), ['node', 'browser', 'auto'].indexOf(Vx) === -1)))
      throw new Error('environment ' + Vx + ' was unknown. Available options are {auto, browser, node}')
    if (
      (t.retrieveFile && (t.overrideRetrieveFile && (Ad.length = 0), Ad.unshift(t.retrieveFile)),
      t.retrieveSourceMap && (t.overrideRetrieveSourceMap && (Rd.length = 0), Rd.unshift(t.retrieveSourceMap)),
      t.hookRequire && !JO())
    ) {
      var e = Xz(XO, 'module'),
        r = e.prototype._compile
      r.__sourceMapSupport ||
        ((e.prototype._compile = function (o, s) {
          return (Ah[s] = o), (zx[s] = void 0), r.call(this, o, s)
        }),
        (e.prototype._compile.__sourceMapSupport = !0))
    }
    if (
      (YO || (YO = 'emptyCacheBetweenOperations' in t ? t.emptyCacheBetweenOperations : !1),
      Jz || ((Jz = !0), (Error.prepareStackTrace = lEe)),
      !Zz)
    ) {
      var n = 'handleUncaughtExceptions' in t ? t.handleUncaughtExceptions : !0
      try {
        var i = Xz(XO, 'worker_threads')
        i.isMainThread === !1 && (n = !1)
      } catch {}
      n && nEe() && ((Zz = !0), pEe())
    }
  }
  Rh.resetRetrieveHandlers = function () {
    ;(Ad.length = 0), (Rd.length = 0), (Ad = dEe.slice(0)), (Rd = fEe.slice(0)), (eL = $C(Rd)), (ZO = $C(Ad))
  }
})
var getPackageInfo = handleExports((hQe, CEe) => {
  CEe.exports = {
    name: 'copilot-chat',
    displayName: 'GitHub Copilot Chat',
    description: 'AI chat features powered by Copilot',
    build: '1',
    internalAIKey: '1058ec22-3c95-4951-8443-f26c1f325911',
    ariaKey: '0c6ae279ed8443289764825290e4f9e2-1a736e7c-1324-4338-be46-fc2a58ae4d14-7255',
    buildType: 'prod',
    publisher: 'GitHub',
    preview: !0,
    homepage: 'https://github.com/features/copilot',
    license: 'https://docs.github.com/en/site-policy/github-terms/github-copilot-pre-release-license-terms',
    repository: { type: 'git', url: 'https://github.com/microsoft/vscode-copilot-release' },
    bugs: { url: 'https://aka.ms/microsoft/vscode-copilot-release' },
    qna: 'https://github.com/github-community/community/discussions/categories/copilot',
    icon: 'assets/Copilot-App-Icon.png',
    pricing: 'Trial',
    engines: { vscode: '^1.85.0', npm: '>=9.0.0', node: '>=18.0.0' },
    categories: ['Programming Languages', 'Machine Learning', 'Education', 'Snippets'],
    keywords: [
      'ai',
      'openai',
      'codex',
      'pilot',
      'snippets',
      'documentation',
      'autocomplete',
      'intellisense',
      'refactor',
      'javascript',
      'python',
      'typescript',
      'php',
      'go',
      'golang',
      'ruby',
      'c++',
      'c#',
      'java',
      'kotlin',
      'co-pilot',
    ],
    badges: [
      {
        url: 'https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange',
        href: 'https://github.com/github-copilot/signup',
        description: '%github.copilot.badge.signUp%',
      },
      {
        url: 'https://img.shields.io/github/stars/github/copilot-docs?style=social',
        href: 'https://github.com/github/copilot-docs',
        description: '%github.copilot.badge.star%',
      },
      {
        url: 'https://img.shields.io/youtube/channel/views/UC7c3Kb6jYCRj4JOHHZTxKsQ?style=social',
        href: 'https://www.youtube.com/@GitHub/search?query=copilot',
        description: '%github.copilot.badge.youtube%',
      },
      {
        url: 'https://img.shields.io/twitter/follow/github?style=social',
        href: 'https://twitter.com/github',
        description: '%github.copilot.badge.twitter%',
      },
    ],
    activationEvents: ['onStartupFinished'],
    main: './dist/extension',
    l10n: './l10n',
    enabledApiProposals: [
      'interactive',
      'chatProvider',
      'codeActionAI',
      'findTextInFiles',
      'textSearchProvider',
      'terminalDataWriteEvent',
      'terminalExecuteCommandEvent',
      'terminalSelection',
      'terminalQuickFixProvider',
      'readonlyMessage',
      'chatVariables',
      'mappedEditsProvider',
      'aiRelatedInformation',
      'chatAgents2',
      'chatAgents2Additions',
      'defaultChatAgent',
      'contribSourceControlInputBoxMenu',
    ],
    contributes: {
      interactiveSession: [
        { label: 'GitHub Copilot', id: 'copilot', icon: '', when: '!github.copilot.interactiveSession.disabled' },
      ],
      viewsWelcome: [
        {
          view: 'workbench.panel.chat.view.copilot',
          contents: '%github.copilot.viewsWelcome.signIn%',
          when: '!github.copilot.activated && !github.copilot.offline && !github.copilot.interactiveSession.individual.disabled && !github.copilot.interactiveSession.individual.expired && !github.copilot.interactiveSession.enterprise.disabled',
        },
        {
          view: 'workbench.panel.chat.view.copilot',
          contents: '%github.copilot.viewsWelcome.individual%',
          when: 'github.copilot.interactiveSession.individual.disabled',
        },
        {
          view: 'workbench.panel.chat.view.copilot',
          contents: '%github.copilot.viewsWelcome.individual.expired%',
          when: 'github.copilot.interactiveSession.individual.expired',
        },
        {
          view: 'workbench.panel.chat.view.copilot',
          contents: '%github.copilot.viewsWelcome.enterprise%',
          when: 'github.copilot.interactiveSession.enterprise.disabled',
        },
        {
          view: 'workbench.panel.chat.view.copilot',
          contents: '%github.copilot.viewsWelcome.offline%',
          when: 'github.copilot.offline',
        },
      ],
      commands: [
        {
          command: 'github.copilot.interactiveEditor.explain',
          title: '%github.copilot.command.explainThis%',
          enablement: '!github.copilot.interactiveSession.disabled && !editorReadonly',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.interactiveEditor.generate',
          title: '%github.copilot.command.generateThis%',
          enablement: '!github.copilot.interactiveSession.disabled && !editorReadonly',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.interactiveEditor.generateDocs',
          title: '%github.copilot.command.generateDocs%',
          enablement: '!github.copilot.interactiveSession.disabled && !editorReadonly',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.interactiveEditor.generateTests',
          title: '%github.copilot.command.generateTests%',
          enablement: '!github.copilot.interactiveSession.disabled && !editorReadonly',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.interactiveEditor.fix',
          title: '%github.copilot.command.fixThis%',
          enablement: '!github.copilot.interactiveSession.disabled && !editorReadonly',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.interactiveSession.feedback',
          title: '%github.copilot.command.sendChatFeedback%',
          enablement: 'github.copilot.activated && !github.copilot.interactiveSession.disabled',
          icon: '$(feedback)',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.debug.workbenchState',
          title: '%github.copilot.command.logWorkbenchState%',
          category: 'Developer',
        },
        {
          command: 'github.copilot.ghpr.applySuggestion',
          title: '%github.copilot.command.applySuggestionWithCopilot%',
          icon: '$(sparkle)',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.terminal.explainTerminalSelection',
          title: '%github.copilot.command.explainTerminalSelection%',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.terminal.explainTerminalSelectionContextMenu',
          title: '%github.copilot.command.explainTerminalSelectionContextMenu%',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.terminal.explainTerminalLastCommand',
          title: '%github.copilot.command.explainTerminalLastCommand%',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.terminal.suggestCommand',
          title: '%github.copilot.command.suggestCommand%',
          category: 'GitHub Copilot',
        },
        {
          command: 'github.copilot.git.generateCommitMessage',
          title: '%github.copilot.git.generateCommitMessage%',
          icon: '$(sparkle)',
          category: 'GitHub Copilot',
        },
      ],
      configuration: {
        title: 'Copilot',
        properties: {
          'github.copilot.editor.enableCodeActions': {
            type: 'boolean',
            default: !0,
            description: '%github.copilot.config.enableCodeActions%',
          },
          'github.copilot.chat.localeOverride': {
            type: 'string',
            enum: ['auto', 'en', 'fr', 'it', 'de', 'es', 'ru', 'zh-CN', 'zh-TW', 'ja', 'ko', 'cs', 'pt-br', 'tr', 'pl'],
            enumDescriptions: [
              "Use VS Code's configured display language",
              'English',
              'fran\xE7ais',
              'italiano',
              'Deutsch',
              'espa\xF1ol',
              '\u0440\u0443\u0441\u0441\u043A\u0438\u0439',
              '\u4E2D\u6587(\u7B80\u4F53)',
              '\u4E2D\u6587(\u7E41\u9AD4)',
              '\u65E5\u672C\u8A9E',
              '\uD55C\uAD6D\uC5B4',
              '\u010De\u0161tina',
              'portugu\xEAs',
              'T\xFCrk\xE7e',
              'polski',
            ],
            default: 'auto',
            markdownDescription: '%github.copilot.config.localeOverride%',
          },
          'github.copilot.chat.welcomeMessage': {
            type: 'string',
            default: 'first',
            markdownDescription: '%github.copilot.config.welcomeMessage%',
            markdownEnumDescriptions: [
              '%github.copilot.config.welcomeMessage.first%',
              '%github.copilot.config.welcomeMessage.always%',
              '%github.copilot.config.welcomeMessage.never%',
            ],
            enum: ['first', 'always', 'never'],
          },
        },
      },
      configurationDefaults: { 'terminal.integrated.commandsToSkipShell': ['github.copilot.terminal.suggestCommand'] },
      keybindings: [
        { command: 'github.copilot.terminal.suggestCommand', key: 'ctrl+i', mac: 'cmd+i', when: 'terminalFocus' },
      ],
      submenus: [{ id: 'copilot', label: 'Copilot' }],
      menus: {
        'editor/context': [
          {
            submenu: 'copilot',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: '1_copilot@0',
          },
        ],
        copilot: [
          {
            command: 'inlineChat.start',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: 'copilot@1',
          },
          {
            command: 'github.copilot.interactiveEditor.explain',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: 'copilotAction@1',
          },
          {
            command: 'github.copilot.interactiveEditor.fix',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: 'copilotAction@2',
          },
          {
            command: 'github.copilot.interactiveEditor.generateDocs',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: 'copilotAction@3',
          },
          {
            command: 'github.copilot.interactiveEditor.generateTests',
            when: '!github.copilot.interactiveSession.disabled && !editorReadonly',
            group: 'copilotAction@4',
          },
        ],
        'terminal/context': [
          { command: 'github.copilot.terminal.explainTerminalSelectionContextMenu', group: '1_copilot@0' },
        ],
        commandPalette: [
          {
            command: 'github.copilot.interactiveSession.feedback',
            when: 'github.copilot.activated && !github.copilot.interactiveSession.disabled',
          },
          { command: 'github.copilot.debug.workbenchState', when: 'true' },
          { command: 'github.copilot.terminal.explainTerminalSelectionContextMenu', when: 'false' },
          { command: 'github.copilot.git.generateCommitMessage', when: 'false' },
        ],
        'view/title': [
          {
            command: 'github.copilot.interactiveSession.feedback',
            when: 'view == workbench.panel.chat.view.copilot',
            group: 'navigation',
          },
        ],
        'comments/comment/title': [
          {
            command: 'github.copilot.ghpr.applySuggestion',
            title: 'Apply Suggestion with Copilot',
            group: 'inline@0',
            when: 'commentController =~ /^github-review/ && !(comment =~ /hasSuggestion/)',
          },
        ],
        'scm/inputBox': [{ command: 'github.copilot.git.generateCommitMessage', when: 'scmProvider == git' }],
      },
      icons: {
        'copilot-logo': {
          description: '%github.copilot.icon%',
          default: { fontPath: 'assets/copilot.woff', fontCharacter: '\\0041' },
        },
        'copilot-warning': {
          description: '%github.copilot.icon%',
          default: { fontPath: 'assets/copilot.woff', fontCharacter: '\\0042' },
        },
        'copilot-notconnected': {
          description: '%github.copilot.icon%',
          default: { fontPath: 'assets/copilot.woff', fontCharacter: '\\0043' },
        },
      },
      iconFonts: [{ id: 'copilot-font', src: [{ path: 'assets/copilot.woff', format: 'woff' }] }],
      terminalQuickFixes: [
        {
          id: 'copilot-chat.fixWithCopilot',
          commandLineMatcher: '.+',
          commandExitResult: 'error',
          outputMatcher: { anchor: 'bottom', length: 1, lineMatcher: '.+', offset: 0 },
          kind: 'explain',
        },
        {
          id: 'copilot-chat.generateCommitMessage',
          commandLineMatcher: 'git add .+',
          commandExitResult: 'success',
          kind: 'explain',
          outputMatcher: { anchor: 'bottom', length: 1, lineMatcher: '.+', offset: 0 },
        },
      ],
    },
    extensionPack: ['GitHub.copilot'],
    scripts: {
      postinstall: 'tsx ./script/postinstall.ts',
      prepare: 'tsx script/setup/prepare.ts',
      'husky:install': 'husky install',
      'vscode:prepublish': 'npm run build',
      'vscode-dts:dev': 'npx vscode-dts dev && mv vscode.proposed.*.ts src/extension',
      build: 'tsx .esbuild.ts',
      compile: 'tsx .esbuild.ts --dev',
      watch: 'npm-run-all -p watch:*',
      'watch:esbuild': 'tsx .esbuild.ts --watch --dev',
      'watch:tsc-extension': 'tsc --noEmit --watch --project tsconfig.json',
      'watch:tsc-simulation-workbench': 'tsc --noEmit --watch --project test/simulation/workbench/tsconfig.json',
      typecheck:
        'tsc --noEmit -project tsconfig.json && tsc --noEmit --project test/simulation/workbench/tsconfig.json',
      lint: 'eslint src test --max-warnings=0 --ext ts',
      'lint-staged': 'eslint src test --ext ts',
      tsfmt: 'node tsfmt ./tsfmt.json -r --verify',
      test: 'npm-run-all test:*',
      'test:extension': 'vscode-test --code-version=insiders --timeout=5000',
      'test:unit': 'mocha -u tdd dist/test-unit.js --require source-map-support/register --exit --timeout=5000',
      'test:unit_jest': 'jest --forceExit --detectOpenHandles',
      get_token: 'tsx script/setup/getToken.ts',
      'patch-release': 'tsx script/build/applyPatchForRelease.ts',
      'patch-prerelease': 'tsx script/build/applyPatchForRelease.ts -- --prerelease',
      prettier: 'prettier --list-different --write --cache .',
      simulate: 'node dist/simulationMain.js',
      'simulate-ci': 'node dist/simulationMain.js --ci --require-cache',
      'simulate-baseline': 'node dist/simulationMain.js --update-baseline',
      setup: 'python script/setup/setup.py && npm run get_token',
      'setup:dotnet': 'run-script-os',
      'setup:dotnet:darwin:linux':
        'curl -O https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.sh && chmod u+x dotnet-install.sh && ./dotnet-install.sh --version latest --quality GA --channel STS && rm dotnet-install.sh',
      'setup:dotnet:win32':
        'Invoke-WebRequest -Uri https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.ps1 && chmod u+x dotnet-install.ps1 && ./dotnet-install.ps1 --version latest --quality GA --channel STS && rm dotnet-install.ps1',
      aml: 'python test/aml/run.py',
      package: 'vsce package',
    },
    devDependencies: {
      '@jest/globals': '^29.6.1',
      '@nteract/messaging': '^7.0.10',
      '@types/eslint': '8.44.7',
      '@types/kerberos': '^1.1.2',
      '@types/minimist': '^1.2.2',
      '@types/mocha': '^10.0.1',
      '@types/node': '^18.11.9',
      '@types/picomatch': '^2.3.0',
      '@types/react': '^18.2.21',
      '@types/react-dom': '^18.2.7',
      '@types/sinon': '^10.0.13',
      '@types/tar': '^6.1.5',
      '@types/vscode': '^1.74.0',
      '@typescript-eslint/eslint-plugin': '^5.59.9',
      '@typescript-eslint/parser': '^5.56.0',
      '@typescript-eslint/typescript-estree': '^5.59.11',
      '@vscode/dts': '^0.4.0',
      '@vscode/test-cli': '^0.0.4',
      '@vscode/test-electron': '^2.3.8',
      '@vscode/vsce': '2.19.0',
      '@vscode/zeromq': '0.1.6',
      'csv-parse': '^5.5.0',
      dotenv: '^16.3.1',
      electron: '^25.8.4',
      esbuild: '^0.19.3',
      eslint: '^8.38.0',
      'eslint-import-resolver-typescript': '^3.5.5',
      'eslint-plugin-header': '^3.1.1',
      'eslint-plugin-import': '^2.27.5',
      'eslint-plugin-jsdoc': '^46.2.6',
      'eslint-plugin-local': '^1.0.0',
      'eslint-plugin-no-only-tests': '^3.1.0',
      'get-port': '^5.1.1',
      glob: '^10.2.7',
      husky: '^8.0.3',
      jest: '^29.6.1',
      'lint-staged': '^13.2.2',
      minimist: '^1.2.8',
      mobx: '^6.10.2',
      'mobx-react-lite': '^4.0.4',
      mocha: '^10.2.0',
      'monaco-editor': '^0.41.0',
      'npm-run-all': '^4.1.5',
      outdent: '^0.8.0',
      picomatch: '^2.3.1',
      prettier: '2.8.7',
      proxy: '^1.0.2',
      react: '^18.2.0',
      'react-dom': '^18.2.0',
      'run-script-os': '^1.1.6',
      sinon: '^15.1.2',
      tar: '^6.1.15',
      'tree-sitter-c-sharp': '^0.20.0',
      'tree-sitter-cli': '^0.20.8',
      'tree-sitter-cpp': '^0.20.3',
      'tree-sitter-go': '^0.20.0',
      'tree-sitter-java': '^0.20.2',
      'tree-sitter-javascript': '^0.20.1',
      'tree-sitter-python': '^0.20.4',
      'tree-sitter-ruby': '^0.19.0',
      'tree-sitter-rust': '^0.20.4',
      'tree-sitter-typescript': '^0.20.3',
      'ts-dedent': '^2.2.0',
      'ts-jest': '^29.1.1',
      'ts-node': '^10.9.1',
      tsx: '^3.13.0',
      typescript: '^5.0.4',
      zeromq: 'github:rebornix/zeromq.js#a19e8e373b3abc677f91b936d3f00d49b1b61792',
      zlib: '^1.0.5',
    },
    dependencies: {
      '@adobe/helix-fetch': 'github:devm33/helix-fetch#eaa2f1344d93625e1bddb83d6846be5eea007e94',
      '@humanwhocodes/gitignore-to-minimatch': '1.0.2',
      '@microsoft/tiktokenizer': '^1.0.2',
      '@roamhq/mac-ca': '^1.0.7',
      '@vscode/extension-telemetry': '^0.9.0',
      '@vscode/l10n': '^0.0.16',
      applicationinsights: '^2.9.0',
      ignore: '^5.2.4',
      isbinaryfile: '^5.0.0',
      'jsonc-parser': '^3.2.0',
      open: '^8.4.2',
      'p-limit': '^3.0.0',
      'source-map-support': '^0.5.21',
      'vscode-tas-client': '^0.1.75',
      'web-tree-sitter': '^0.20.8',
    },
    'lint-staged': {
      '!(test/simulation/fixtures/**|.test-scenarios/**)*.{ts,js}': ['npm run tsfmt --', 'npm run lint-staged --'],
    },
    isPreRelease: !0,
    version: '0.12.2023120701',
  }
})
var _L = handleExports((yXe, E$) => {
  'use strict'
  var b$ = require('fs'),
    vL
  function MEe() {
    try {
      return b$.statSync('/.dockerenv'), !0
    } catch {
      return !1
    }
  }
  function FEe() {
    try {
      return b$.readFileSync('/proc/self/cgroup', 'utf8').includes('docker')
    } catch {
      return !1
    }
  }
  E$.exports = () => (vL === void 0 && (vL = MEe() || FEe()), vL)
})
var C$ = handleExports((xXe, yL) => {
  'use strict'
  var UEe = require('os'),
    BEe = require('fs'),
    T$ = _L(),
    S$ = () => {
      if (process.platform !== 'linux') return !1
      if (UEe.release().toLowerCase().includes('microsoft')) return !T$()
      try {
        return BEe.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ? !T$() : !1
      } catch {
        return !1
      }
    }
  process.env.__IS_WSL_TEST__ ? (yL.exports = S$) : (yL.exports = S$())
})
var w$ = handleExports((bXe, I$) => {
  'use strict'
  I$.exports = (t, e, r) => {
    let n = i => Object.defineProperty(t, e, { value: i, enumerable: !0, writable: !0 })
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        enumerable: !0,
        get() {
          let i = r()
          return n(i), i
        },
        set(i) {
          n(i)
        },
      }),
      t
    )
  }
})
var handleOpen = handleExports((EXe, k$) => {
  var qEe = require('path'),
    HEe = require('child_process'),
    { promises: fI, constants: N$ } = require('fs'),
    dI = C$(),
    jEe = _L(),
    bL = w$(),
    A$ = qEe.join(__dirname, 'xdg-open'),
    { platform: w0, arch: R$ } = process,
    GEe = () => {
      try {
        return fI.statSync('/run/.containerenv'), !0
      } catch {
        return !1
      }
    },
    xL
  function VEe() {
    return xL === void 0 && (xL = GEe() || jEe()), xL
  }
  var zEe = (() => {
      let t = '/mnt/',
        e
      return async function () {
        if (e) return e
        let r = '/etc/wsl.conf',
          n = !1
        try {
          await fI.access(r, N$.F_OK), (n = !0)
        } catch {}
        if (!n) return t
        let i = await fI.readFile(r, { encoding: 'utf8' }),
          o = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(i)
        return o ? ((e = o.groups.mountPoint.trim()), (e = e.endsWith('/') ? e : `${e}/`), e) : t
      }
    })(),
    D$ = async (t, e) => {
      let r
      for (let n of t)
        try {
          return await e(n)
        } catch (i) {
          r = i
        }
      throw r
    },
    mI = async t => {
      if (((t = { wait: !1, background: !1, newInstance: !1, allowNonzeroExitCode: !1, ...t }), Array.isArray(t.app)))
        return D$(t.app, a => mI({ ...t, app: a }))
      let { name: e, arguments: r = [] } = t.app || {}
      if (((r = [...r]), Array.isArray(e))) return D$(e, a => mI({ ...t, app: { name: a, arguments: r } }))
      let n,
        i = [],
        o = {}
      if (w0 === 'darwin')
        (n = 'open'),
          t.wait && i.push('--wait-apps'),
          t.background && i.push('--background'),
          t.newInstance && i.push('--new'),
          e && i.push('-a', e)
      else if (w0 === 'win32' || (dI && !VEe() && !e)) {
        let a = await zEe()
        ;(n = dI
          ? `${a}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`
          : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`),
          i.push('-NoProfile', '-NonInteractive', '\u2013ExecutionPolicy', 'Bypass', '-EncodedCommand'),
          dI || (o.windowsVerbatimArguments = !0)
        let l = ['Start']
        t.wait && l.push('-Wait'),
          e
            ? (l.push(`"\`"${e}\`""`, '-ArgumentList'), t.target && r.unshift(t.target))
            : t.target && l.push(`"${t.target}"`),
          r.length > 0 && ((r = r.map(c => `"\`"${c}\`""`)), l.push(r.join(','))),
          (t.target = Buffer.from(l.join(' '), 'utf16le').toString('base64'))
      } else {
        if (e) n = e
        else {
          let a = !__dirname || __dirname === '/',
            l = !1
          try {
            await fI.access(A$, N$.X_OK), (l = !0)
          } catch {}
          n = process.versions.electron || w0 === 'android' || a || !l ? 'xdg-open' : A$
        }
        r.length > 0 && i.push(...r), t.wait || ((o.stdio = 'ignore'), (o.detached = !0))
      }
      t.target && i.push(t.target), w0 === 'darwin' && r.length > 0 && i.push('--args', ...r)
      let s = HEe.spawn(n, i, o)
      return t.wait
        ? new Promise((a, l) => {
            s.once('error', l),
              s.once('close', c => {
                if (!t.allowNonzeroExitCode && c > 0) {
                  l(new Error(`Exited with code ${c}`))
                  return
                }
                a(s)
              })
          })
        : (s.unref(), s)
    },
    EL = (t, e) => {
      if (typeof t != 'string') throw new TypeError('Expected a `target`')
      return mI({ ...e, target: t })
    },
    $Ee = (t, e) => {
      if (typeof t != 'string') throw new TypeError('Expected a `name`')
      let { arguments: r = [] } = e || {}
      if (r != null && !Array.isArray(r)) throw new TypeError('Expected `appArguments` as Array type')
      return mI({ ...e, app: { name: t, arguments: r } })
    }
  function P$(t) {
    if (typeof t == 'string' || Array.isArray(t)) return t
    let { [R$]: e } = t
    if (!e) throw new Error(`${R$} is not supported`)
    return e
  }
  function TL({ [w0]: t }, { wsl: e }) {
    if (e && dI) return P$(e)
    if (!t) throw new Error(`${w0} is not supported`)
    return P$(t)
  }
  var hI = {}
  bL(hI, 'chrome', () =>
    TL(
      { darwin: 'google chrome', win32: 'chrome', linux: ['google-chrome', 'google-chrome-stable', 'chromium'] },
      {
        wsl: {
          ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
          x64: [
            '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
          ],
        },
      }
    )
  )
  bL(hI, 'firefox', () =>
    TL(
      { darwin: 'firefox', win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe', linux: 'firefox' },
      { wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe' }
    )
  )
  bL(hI, 'edge', () =>
    TL(
      { darwin: 'microsoft edge', win32: 'msedge', linux: ['microsoft-edge', 'microsoft-edge-dev'] },
      { wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe' }
    )
  )
  EL.apps = hI
  EL.openApp = $Ee
  k$.exports = EL
})
var _W = handleExports(NI => {
  'use strict'
  Object.defineProperty(NI, '__esModule', { value: !0 })
  NI.LRUCache = void 0
  var Jx = typeof performance == 'object' && performance && typeof performance.now == 'function' ? performance : Date,
    hW = new Set(),
    OL = typeof process == 'object' && process ? process : {},
    gW = (t, e, r, n) => {
      typeof OL.emitWarning == 'function' ? OL.emitWarning(t, e, r, n) : console.error(`[${r}] ${e}: ${t}`)
    },
    PI = globalThis.AbortController,
    mW = globalThis.AbortSignal
  if (typeof PI > 'u') {
    ;(mW = class {
      onabort
      _onabort = []
      reason
      aborted = !1
      addEventListener(n, i) {
        this._onabort.push(i)
      }
    }),
      (PI = class {
        constructor() {
          e()
        }
        signal = new mW()
        abort(n) {
          if (!this.signal.aborted) {
            ;(this.signal.reason = n), (this.signal.aborted = !0)
            for (let i of this.signal._onabort) i(n)
            this.signal.onabort?.(n)
          }
        }
      })
    let t = OL.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1',
      e = () => {
        t &&
          ((t = !1),
          gW(
            'AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
            'NO_ABORT_CONTROLLER',
            'ENOTSUP',
            e
          ))
      }
  }
  var LTe = t => !hW.has(t),
    OJe = Symbol('type'),
    jd = t => t && t === Math.floor(t) && t > 0 && isFinite(t),
    vW = t =>
      jd(t)
        ? t <= Math.pow(2, 8)
          ? Uint8Array
          : t <= Math.pow(2, 16)
          ? Uint16Array
          : t <= Math.pow(2, 32)
          ? Uint32Array
          : t <= Number.MAX_SAFE_INTEGER
          ? N0
          : null
        : null,
    N0 = class extends Array {
      constructor(e) {
        super(e), this.fill(0)
      }
    },
    LL = class t {
      heap
      length
      static #c = !1
      static create(e) {
        let r = vW(e)
        if (!r) return []
        t.#c = !0
        let n = new t(e, r)
        return (t.#c = !1), n
      }
      constructor(e, r) {
        if (!t.#c) throw new TypeError('instantiate Stack using Stack.create(n)')
        ;(this.heap = new r(e)), (this.length = 0)
      }
      push(e) {
        this.heap[this.length++] = e
      }
      pop() {
        return this.heap[--this.length]
      }
    },
    ML = class t {
      #c
      #p
      #_
      #m
      #R
      ttl
      ttlResolution
      ttlAutopurge
      updateAgeOnGet
      updateAgeOnHas
      allowStale
      noDisposeOnSet
      noUpdateTTL
      maxEntrySize
      sizeCalculation
      noDeleteOnFetchRejection
      noDeleteOnStaleGet
      allowStaleOnFetchAbort
      allowStaleOnFetchRejection
      ignoreFetchAbort
      #n
      #h
      #i
      #r
      #e
      #l
      #d
      #a
      #o
      #g
      #s
      #E
      #T
      #v
      #y
      #C
      #u
      static unsafeExposeInternals(e) {
        return {
          starts: e.#T,
          ttls: e.#v,
          sizes: e.#E,
          keyMap: e.#i,
          keyList: e.#r,
          valList: e.#e,
          next: e.#l,
          prev: e.#d,
          get head() {
            return e.#a
          },
          get tail() {
            return e.#o
          },
          free: e.#g,
          isBackgroundFetch: r => e.#t(r),
          backgroundFetch: (r, n, i, o) => e.#N(r, n, i, o),
          moveToTail: r => e.#A(r),
          indexes: r => e.#x(r),
          rindexes: r => e.#b(r),
          isStale: r => e.#f(r),
        }
      }
      get max() {
        return this.#c
      }
      get maxSize() {
        return this.#p
      }
      get calculatedSize() {
        return this.#h
      }
      get size() {
        return this.#n
      }
      get fetchMethod() {
        return this.#R
      }
      get dispose() {
        return this.#_
      }
      get disposeAfter() {
        return this.#m
      }
      constructor(e) {
        let {
          max: r = 0,
          ttl: n,
          ttlResolution: i = 1,
          ttlAutopurge: o,
          updateAgeOnGet: s,
          updateAgeOnHas: a,
          allowStale: l,
          dispose: c,
          disposeAfter: u,
          noDisposeOnSet: p,
          noUpdateTTL: d,
          maxSize: f = 0,
          maxEntrySize: m = 0,
          sizeCalculation: h,
          fetchMethod: g,
          noDeleteOnFetchRejection: v,
          noDeleteOnStaleGet: _,
          allowStaleOnFetchRejection: y,
          allowStaleOnFetchAbort: b,
          ignoreFetchAbort: x,
        } = e
        if (r !== 0 && !jd(r)) throw new TypeError('max option must be a nonnegative integer')
        let P = r ? vW(r) : Array
        if (!P) throw new Error('invalid max value: ' + r)
        if (
          ((this.#c = r),
          (this.#p = f),
          (this.maxEntrySize = m || this.#p),
          (this.sizeCalculation = h),
          this.sizeCalculation)
        ) {
          if (!this.#p && !this.maxEntrySize)
            throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize')
          if (typeof this.sizeCalculation != 'function') throw new TypeError('sizeCalculation set to non-function')
        }
        if (g !== void 0 && typeof g != 'function') throw new TypeError('fetchMethod must be a function if specified')
        if (
          ((this.#R = g),
          (this.#C = !!g),
          (this.#i = new Map()),
          (this.#r = new Array(r).fill(void 0)),
          (this.#e = new Array(r).fill(void 0)),
          (this.#l = new P(r)),
          (this.#d = new P(r)),
          (this.#a = 0),
          (this.#o = 0),
          (this.#g = LL.create(r)),
          (this.#n = 0),
          (this.#h = 0),
          typeof c == 'function' && (this.#_ = c),
          typeof u == 'function' ? ((this.#m = u), (this.#s = [])) : ((this.#m = void 0), (this.#s = void 0)),
          (this.#y = !!this.#_),
          (this.#u = !!this.#m),
          (this.noDisposeOnSet = !!p),
          (this.noUpdateTTL = !!d),
          (this.noDeleteOnFetchRejection = !!v),
          (this.allowStaleOnFetchRejection = !!y),
          (this.allowStaleOnFetchAbort = !!b),
          (this.ignoreFetchAbort = !!x),
          this.maxEntrySize !== 0)
        ) {
          if (this.#p !== 0 && !jd(this.#p)) throw new TypeError('maxSize must be a positive integer if specified')
          if (!jd(this.maxEntrySize)) throw new TypeError('maxEntrySize must be a positive integer if specified')
          this.#U()
        }
        if (
          ((this.allowStale = !!l),
          (this.noDeleteOnStaleGet = !!_),
          (this.updateAgeOnGet = !!s),
          (this.updateAgeOnHas = !!a),
          (this.ttlResolution = jd(i) || i === 0 ? i : 1),
          (this.ttlAutopurge = !!o),
          (this.ttl = n || 0),
          this.ttl)
        ) {
          if (!jd(this.ttl)) throw new TypeError('ttl must be a positive integer if specified')
          this.#k()
        }
        if (this.#c === 0 && this.ttl === 0 && this.#p === 0)
          throw new TypeError('At least one of max, maxSize, or ttl is required')
        if (!this.ttlAutopurge && !this.#c && !this.#p) {
          let U = 'LRU_CACHE_UNBOUNDED'
          LTe(U) &&
            (hW.add(U),
            gW(
              'TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.',
              'UnboundedCacheWarning',
              U,
              t
            ))
        }
      }
      getRemainingTTL(e) {
        return this.#i.has(e) ? 1 / 0 : 0
      }
      #k() {
        let e = new N0(this.#c),
          r = new N0(this.#c)
        ;(this.#v = e),
          (this.#T = r),
          (this.#O = (o, s, a = Jx.now()) => {
            if (((r[o] = s !== 0 ? a : 0), (e[o] = s), s !== 0 && this.ttlAutopurge)) {
              let l = setTimeout(() => {
                this.#f(o) && this.delete(this.#r[o])
              }, s + 1)
              l.unref && l.unref()
            }
          }),
          (this.#I = o => {
            r[o] = e[o] !== 0 ? Jx.now() : 0
          }),
          (this.#S = (o, s) => {
            if (e[s]) {
              let a = e[s],
                l = r[s]
              ;(o.ttl = a), (o.start = l), (o.now = n || i())
              let c = o.now - l
              o.remainingTTL = a - c
            }
          })
        let n = 0,
          i = () => {
            let o = Jx.now()
            if (this.ttlResolution > 0) {
              n = o
              let s = setTimeout(() => (n = 0), this.ttlResolution)
              s.unref && s.unref()
            }
            return o
          }
        ;(this.getRemainingTTL = o => {
          let s = this.#i.get(o)
          if (s === void 0) return 0
          let a = e[s],
            l = r[s]
          if (a === 0 || l === 0) return 1 / 0
          let c = (n || i()) - l
          return a - c
        }),
          (this.#f = o => e[o] !== 0 && r[o] !== 0 && (n || i()) - r[o] > e[o])
      }
      #I = () => {}
      #S = () => {}
      #O = () => {}
      #f = () => !1
      #U() {
        let e = new N0(this.#c)
        ;(this.#h = 0),
          (this.#E = e),
          (this.#w = r => {
            ;(this.#h -= e[r]), (e[r] = 0)
          }),
          (this.#L = (r, n, i, o) => {
            if (this.#t(n)) return 0
            if (!jd(i))
              if (o) {
                if (typeof o != 'function') throw new TypeError('sizeCalculation must be a function')
                if (((i = o(n, r)), !jd(i)))
                  throw new TypeError('sizeCalculation return invalid (expect positive integer)')
              } else
                throw new TypeError(
                  'invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.'
                )
            return i
          }),
          (this.#D = (r, n, i) => {
            if (((e[r] = n), this.#p)) {
              let o = this.#p - e[r]
              for (; this.#h > o; ) this.#P(!0)
            }
            ;(this.#h += e[r]), i && ((i.entrySize = n), (i.totalCalculatedSize = this.#h))
          })
      }
      #w = e => {}
      #D = (e, r, n) => {}
      #L = (e, r, n, i) => {
        if (n || i) throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache')
        return 0
      };
      *#x({ allowStale: e = this.allowStale } = {}) {
        if (this.#n)
          for (let r = this.#o; !(!this.#M(r) || ((e || !this.#f(r)) && (yield r), r === this.#a)); ) r = this.#d[r]
      }
      *#b({ allowStale: e = this.allowStale } = {}) {
        if (this.#n)
          for (let r = this.#a; !(!this.#M(r) || ((e || !this.#f(r)) && (yield r), r === this.#o)); ) r = this.#l[r]
      }
      #M(e) {
        return e !== void 0 && this.#i.get(this.#r[e]) === e
      }
      *entries() {
        for (let e of this.#x())
          this.#e[e] !== void 0 && this.#r[e] !== void 0 && !this.#t(this.#e[e]) && (yield [this.#r[e], this.#e[e]])
      }
      *rentries() {
        for (let e of this.#b())
          this.#e[e] !== void 0 && this.#r[e] !== void 0 && !this.#t(this.#e[e]) && (yield [this.#r[e], this.#e[e]])
      }
      *keys() {
        for (let e of this.#x()) {
          let r = this.#r[e]
          r !== void 0 && !this.#t(this.#e[e]) && (yield r)
        }
      }
      *rkeys() {
        for (let e of this.#b()) {
          let r = this.#r[e]
          r !== void 0 && !this.#t(this.#e[e]) && (yield r)
        }
      }
      *values() {
        for (let e of this.#x()) this.#e[e] !== void 0 && !this.#t(this.#e[e]) && (yield this.#e[e])
      }
      *rvalues() {
        for (let e of this.#b()) this.#e[e] !== void 0 && !this.#t(this.#e[e]) && (yield this.#e[e])
      }
      [Symbol.iterator]() {
        return this.entries()
      }
      find(e, r = {}) {
        for (let n of this.#x()) {
          let i = this.#e[n],
            o = this.#t(i) ? i.__staleWhileFetching : i
          if (o !== void 0 && e(o, this.#r[n], this)) return this.get(this.#r[n], r)
        }
      }
      forEach(e, r = this) {
        for (let n of this.#x()) {
          let i = this.#e[n],
            o = this.#t(i) ? i.__staleWhileFetching : i
          o !== void 0 && e.call(r, o, this.#r[n], this)
        }
      }
      rforEach(e, r = this) {
        for (let n of this.#b()) {
          let i = this.#e[n],
            o = this.#t(i) ? i.__staleWhileFetching : i
          o !== void 0 && e.call(r, o, this.#r[n], this)
        }
      }
      purgeStale() {
        let e = !1
        for (let r of this.#b({ allowStale: !0 })) this.#f(r) && (this.delete(this.#r[r]), (e = !0))
        return e
      }
      dump() {
        let e = []
        for (let r of this.#x({ allowStale: !0 })) {
          let n = this.#r[r],
            i = this.#e[r],
            o = this.#t(i) ? i.__staleWhileFetching : i
          if (o === void 0 || n === void 0) continue
          let s = { value: o }
          if (this.#v && this.#T) {
            s.ttl = this.#v[r]
            let a = Jx.now() - this.#T[r]
            s.start = Math.floor(Date.now() - a)
          }
          this.#E && (s.size = this.#E[r]), e.unshift([n, s])
        }
        return e
      }
      load(e) {
        this.clear()
        for (let [r, n] of e) {
          if (n.start) {
            let i = Date.now() - n.start
            n.start = Jx.now() - i
          }
          this.set(r, n.value, n)
        }
      }
      set(e, r, n = {}) {
        if (r === void 0) return this.delete(e), this
        let {
            ttl: i = this.ttl,
            start: o,
            noDisposeOnSet: s = this.noDisposeOnSet,
            sizeCalculation: a = this.sizeCalculation,
            status: l,
          } = n,
          { noUpdateTTL: c = this.noUpdateTTL } = n,
          u = this.#L(e, r, n.size || 0, a)
        if (this.maxEntrySize && u > this.maxEntrySize)
          return l && ((l.set = 'miss'), (l.maxEntrySizeExceeded = !0)), this.delete(e), this
        let p = this.#n === 0 ? void 0 : this.#i.get(e)
        if (p === void 0)
          (p =
            this.#n === 0
              ? this.#o
              : this.#g.length !== 0
              ? this.#g.pop()
              : this.#n === this.#c
              ? this.#P(!1)
              : this.#n),
            (this.#r[p] = e),
            (this.#e[p] = r),
            this.#i.set(e, p),
            (this.#l[this.#o] = p),
            (this.#d[p] = this.#o),
            (this.#o = p),
            this.#n++,
            this.#D(p, u, l),
            l && (l.set = 'add'),
            (c = !1)
        else {
          this.#A(p)
          let d = this.#e[p]
          if (r !== d) {
            if (
              (this.#C && this.#t(d)
                ? d.__abortController.abort(new Error('replaced'))
                : s || (this.#y && this.#_?.(d, e, 'set'), this.#u && this.#s?.push([d, e, 'set'])),
              this.#w(p),
              this.#D(p, u, l),
              (this.#e[p] = r),
              l)
            ) {
              l.set = 'replace'
              let f = d && this.#t(d) ? d.__staleWhileFetching : d
              f !== void 0 && (l.oldValue = f)
            }
          } else l && (l.set = 'update')
        }
        if (
          (i !== 0 && !this.#v && this.#k(),
          this.#v && (c || this.#O(p, i, o), l && this.#S(l, p)),
          !s && this.#u && this.#s)
        ) {
          let d = this.#s,
            f
          for (; (f = d?.shift()); ) this.#m?.(...f)
        }
        return this
      }
      pop() {
        try {
          for (; this.#n; ) {
            let e = this.#e[this.#a]
            if ((this.#P(!0), this.#t(e))) {
              if (e.__staleWhileFetching) return e.__staleWhileFetching
            } else if (e !== void 0) return e
          }
        } finally {
          if (this.#u && this.#s) {
            let e = this.#s,
              r
            for (; (r = e?.shift()); ) this.#m?.(...r)
          }
        }
      }
      #P(e) {
        let r = this.#a,
          n = this.#r[r],
          i = this.#e[r]
        return (
          this.#C && this.#t(i)
            ? i.__abortController.abort(new Error('evicted'))
            : (this.#y || this.#u) && (this.#y && this.#_?.(i, n, 'evict'), this.#u && this.#s?.push([i, n, 'evict'])),
          this.#w(r),
          e && ((this.#r[r] = void 0), (this.#e[r] = void 0), this.#g.push(r)),
          this.#n === 1 ? ((this.#a = this.#o = 0), (this.#g.length = 0)) : (this.#a = this.#l[r]),
          this.#i.delete(n),
          this.#n--,
          r
        )
      }
      has(e, r = {}) {
        let { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = r,
          o = this.#i.get(e)
        if (o !== void 0) {
          let s = this.#e[o]
          if (this.#t(s) && s.__staleWhileFetching === void 0) return !1
          if (this.#f(o)) i && ((i.has = 'stale'), this.#S(i, o))
          else return n && this.#I(o), i && ((i.has = 'hit'), this.#S(i, o)), !0
        } else i && (i.has = 'miss')
        return !1
      }
      peek(e, r = {}) {
        let { allowStale: n = this.allowStale } = r,
          i = this.#i.get(e)
        if (i !== void 0 && (n || !this.#f(i))) {
          let o = this.#e[i]
          return this.#t(o) ? o.__staleWhileFetching : o
        }
      }
      #N(e, r, n, i) {
        let o = r === void 0 ? void 0 : this.#e[r]
        if (this.#t(o)) return o
        let s = new PI(),
          { signal: a } = n
        a?.addEventListener('abort', () => s.abort(a.reason), { signal: s.signal })
        let l = { signal: s.signal, options: n, context: i },
          c = (h, g = !1) => {
            let { aborted: v } = s.signal,
              _ = n.ignoreFetchAbort && h !== void 0
            if (
              (n.status &&
                (v && !g
                  ? ((n.status.fetchAborted = !0),
                    (n.status.fetchError = s.signal.reason),
                    _ && (n.status.fetchAbortIgnored = !0))
                  : (n.status.fetchResolved = !0)),
              v && !_ && !g)
            )
              return p(s.signal.reason)
            let y = f
            return (
              this.#e[r] === f &&
                (h === void 0
                  ? y.__staleWhileFetching
                    ? (this.#e[r] = y.__staleWhileFetching)
                    : this.delete(e)
                  : (n.status && (n.status.fetchUpdated = !0), this.set(e, h, l.options))),
              h
            )
          },
          u = h => (n.status && ((n.status.fetchRejected = !0), (n.status.fetchError = h)), p(h)),
          p = h => {
            let { aborted: g } = s.signal,
              v = g && n.allowStaleOnFetchAbort,
              _ = v || n.allowStaleOnFetchRejection,
              y = _ || n.noDeleteOnFetchRejection,
              b = f
            if (
              (this.#e[r] === f &&
                (!y || b.__staleWhileFetching === void 0 ? this.delete(e) : v || (this.#e[r] = b.__staleWhileFetching)),
              _)
            )
              return (
                n.status && b.__staleWhileFetching !== void 0 && (n.status.returnedStale = !0), b.__staleWhileFetching
              )
            if (b.__returned === b) throw h
          },
          d = (h, g) => {
            let v = this.#R?.(e, o, l)
            v && v instanceof Promise && v.then(_ => h(_), g),
              s.signal.addEventListener('abort', () => {
                ;(!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) &&
                  (h(), n.allowStaleOnFetchAbort && (h = _ => c(_, !0)))
              })
          }
        n.status && (n.status.fetchDispatched = !0)
        let f = new Promise(d).then(c, u),
          m = Object.assign(f, { __abortController: s, __staleWhileFetching: o, __returned: void 0 })
        return (
          r === void 0 ? (this.set(e, m, { ...l.options, status: void 0 }), (r = this.#i.get(e))) : (this.#e[r] = m), m
        )
      }
      #t(e) {
        if (!this.#C) return !1
        let r = e
        return (
          !!r && r instanceof Promise && r.hasOwnProperty('__staleWhileFetching') && r.__abortController instanceof PI
        )
      }
      async fetch(e, r = {}) {
        let {
          allowStale: n = this.allowStale,
          updateAgeOnGet: i = this.updateAgeOnGet,
          noDeleteOnStaleGet: o = this.noDeleteOnStaleGet,
          ttl: s = this.ttl,
          noDisposeOnSet: a = this.noDisposeOnSet,
          size: l = 0,
          sizeCalculation: c = this.sizeCalculation,
          noUpdateTTL: u = this.noUpdateTTL,
          noDeleteOnFetchRejection: p = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection,
          ignoreFetchAbort: f = this.ignoreFetchAbort,
          allowStaleOnFetchAbort: m = this.allowStaleOnFetchAbort,
          context: h,
          forceRefresh: g = !1,
          status: v,
          signal: _,
        } = r
        if (!this.#C)
          return (
            v && (v.fetch = 'get'), this.get(e, { allowStale: n, updateAgeOnGet: i, noDeleteOnStaleGet: o, status: v })
          )
        let y = {
            allowStale: n,
            updateAgeOnGet: i,
            noDeleteOnStaleGet: o,
            ttl: s,
            noDisposeOnSet: a,
            size: l,
            sizeCalculation: c,
            noUpdateTTL: u,
            noDeleteOnFetchRejection: p,
            allowStaleOnFetchRejection: d,
            allowStaleOnFetchAbort: m,
            ignoreFetchAbort: f,
            status: v,
            signal: _,
          },
          b = this.#i.get(e)
        if (b === void 0) {
          v && (v.fetch = 'miss')
          let x = this.#N(e, b, y, h)
          return (x.__returned = x)
        } else {
          let x = this.#e[b]
          if (this.#t(x)) {
            let M = n && x.__staleWhileFetching !== void 0
            return (
              v && ((v.fetch = 'inflight'), M && (v.returnedStale = !0)),
              M ? x.__staleWhileFetching : (x.__returned = x)
            )
          }
          let P = this.#f(b)
          if (!g && !P) return v && (v.fetch = 'hit'), this.#A(b), i && this.#I(b), v && this.#S(v, b), x
          let U = this.#N(e, b, y, h),
            j = U.__staleWhileFetching !== void 0 && n
          return (
            v && ((v.fetch = P ? 'stale' : 'refresh'), j && P && (v.returnedStale = !0)),
            j ? U.__staleWhileFetching : (U.__returned = U)
          )
        }
      }
      get(e, r = {}) {
        let {
            allowStale: n = this.allowStale,
            updateAgeOnGet: i = this.updateAgeOnGet,
            noDeleteOnStaleGet: o = this.noDeleteOnStaleGet,
            status: s,
          } = r,
          a = this.#i.get(e)
        if (a !== void 0) {
          let l = this.#e[a],
            c = this.#t(l)
          return (
            s && this.#S(s, a),
            this.#f(a)
              ? (s && (s.get = 'stale'),
                c
                  ? (s && n && l.__staleWhileFetching !== void 0 && (s.returnedStale = !0),
                    n ? l.__staleWhileFetching : void 0)
                  : (o || this.delete(e), s && n && (s.returnedStale = !0), n ? l : void 0))
              : (s && (s.get = 'hit'), c ? l.__staleWhileFetching : (this.#A(a), i && this.#I(a), l))
          )
        } else s && (s.get = 'miss')
      }
      #F(e, r) {
        ;(this.#d[r] = e), (this.#l[e] = r)
      }
      #A(e) {
        e !== this.#o &&
          (e === this.#a ? (this.#a = this.#l[e]) : this.#F(this.#d[e], this.#l[e]), this.#F(this.#o, e), (this.#o = e))
      }
      delete(e) {
        let r = !1
        if (this.#n !== 0) {
          let n = this.#i.get(e)
          if (n !== void 0)
            if (((r = !0), this.#n === 1)) this.clear()
            else {
              this.#w(n)
              let i = this.#e[n]
              this.#t(i)
                ? i.__abortController.abort(new Error('deleted'))
                : (this.#y || this.#u) &&
                  (this.#y && this.#_?.(i, e, 'delete'), this.#u && this.#s?.push([i, e, 'delete'])),
                this.#i.delete(e),
                (this.#r[n] = void 0),
                (this.#e[n] = void 0),
                n === this.#o
                  ? (this.#o = this.#d[n])
                  : n === this.#a
                  ? (this.#a = this.#l[n])
                  : ((this.#l[this.#d[n]] = this.#l[n]), (this.#d[this.#l[n]] = this.#d[n])),
                this.#n--,
                this.#g.push(n)
            }
        }
        if (this.#u && this.#s?.length) {
          let n = this.#s,
            i
          for (; (i = n?.shift()); ) this.#m?.(...i)
        }
        return r
      }
      clear() {
        for (let e of this.#b({ allowStale: !0 })) {
          let r = this.#e[e]
          if (this.#t(r)) r.__abortController.abort(new Error('deleted'))
          else {
            let n = this.#r[e]
            this.#y && this.#_?.(r, n, 'delete'), this.#u && this.#s?.push([r, n, 'delete'])
          }
        }
        if (
          (this.#i.clear(),
          this.#e.fill(void 0),
          this.#r.fill(void 0),
          this.#v && this.#T && (this.#v.fill(0), this.#T.fill(0)),
          this.#E && this.#E.fill(0),
          (this.#a = 0),
          (this.#o = 0),
          (this.#g.length = 0),
          (this.#h = 0),
          (this.#n = 0),
          this.#u && this.#s)
        ) {
          let e = this.#s,
            r
          for (; (r = e?.shift()); ) this.#m?.(...r)
        }
      }
    }
  NI.LRUCache = ML
})
var yW = handleExports(k0 => {
  'use strict'
  Object.defineProperty(k0, '__esModule', { value: !0 })
  k0.bytePairEncode = k0.uint8ArrayToString = void 0
  function FL(t) {
    return Array.from(t)
      .map(e => e.toString())
      .join('_')
  }
  k0.uint8ArrayToString = FL
  function MTe(t, e) {
    if (t.length === 1) return [e.get(t[0].toString())]
    let r = []
    for (let o = 0; o < t.length + 1; o++) r.push([o, Number.MAX_SAFE_INTEGER])
    function n(o, s = 0) {
      if (o + s + 2 < r.length) {
        let a = t.slice(r[o][0], r[o + s + 2][0]),
          l = e.get(FL(a))
        if (l !== void 0) return l
      }
      return Number.MAX_SAFE_INTEGER
    }
    for (let o = 0; o < r.length - 2; o++) {
      let s = n(o)
      s !== Number.MAX_SAFE_INTEGER && (r[o][1] = s)
    }
    for (; r.length > 1; ) {
      let o = [0, Number.MAX_SAFE_INTEGER]
      for (let s = 0; s < r.length - 1; s++) r[s][1] < o[1] && (o = [s, r[s][1]])
      if (o[1] !== Number.MAX_SAFE_INTEGER) {
        let s = o[0]
        ;(r[s][1] = n(s, 1)), s > 0 && (r[s - 1][1] = n(s - 1, 1)), r.splice(s + 1, 1)
      } else break
    }
    let i = []
    for (let o = 0; o < r.length - 1; o++) i.push(e.get(FL(t.slice(r[o][0], r[o + 1][0]))))
    return i
  }
  k0.bytePairEncode = MTe
})
var qL = handleExports(kI => {
  'use strict'
  Object.defineProperty(kI, '__esModule', { value: !0 })
  kI.TikTokenizer = void 0
  var FTe = require('fs'),
    UTe = _W(),
    UL = require('util'),
    Mh = yW()
  function BTe(t) {
    let e = new Map()
    try {
      let n = FTe.readFileSync(t, 'utf-8')
      return r(n), e
    } catch (n) {
      throw new Error(`Failed to load from BPE encoder file stream: ${n}`)
    }
    function r(n) {
      for (let i of n.split(/[\r\n]+/)) {
        if (i.trim() === '') continue
        let o = i.split(' ')
        if (o.length !== 2) throw new Error('Invalid format in the BPE encoder file stream')
        let s = new Uint8Array(Buffer.from(o[0], 'base64')),
          a = parseInt(o[1])
        if (!isNaN(a)) e.set(s, a)
        else throw new Error(`Can't parse ${o[1]} to integer`)
      }
    }
  }
  function qTe(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  }
  var BL = class {
    constructor(e, r, n, i = 8192) {
      ;(this.textEncoder = new UL.TextEncoder()), (this.textDecoder = new UL.TextDecoder('utf-8'))
      let o = { max: i }
      this.cache = new UTe.LRUCache(o)
      let s = BTe(e)
      this.init(s, r, n)
    }
    init(e, r, n) {
      this.encoder = new Map()
      for (let [i, o] of e) this.encoder.set((0, Mh.uint8ArrayToString)(i), o)
      ;(this.regex = new RegExp(n, 'gu')),
        (this.specialTokensRegex = new RegExp(
          Array.from(r.keys())
            .map(i => qTe(i))
            .join('|')
        )),
        (this.specialTokensEncoder = r),
        (this.decoder = new Map())
      for (let [i, o] of e) this.decoder.set(o, i)
      if (this.encoder.size !== this.decoder.size) throw new Error('Encoder and decoder sizes do not match')
      this.specialTokensDecoder = new Map()
      for (let [i, o] of r) this.specialTokensDecoder.set(o, i)
    }
    findNextSpecialToken(e, r, n) {
      let i = r,
        o = null
      if (n && this.specialTokensRegex)
        for (; (o = e.slice(i).match(this.specialTokensRegex)), !(!o || (n && n.includes(o[0]))); ) i += o.index + 1
      let s = o ? i + o.index : e.length
      return [o, s]
    }
    encode(e, r) {
      let n = [],
        i = 0
      for (;;) {
        let o, s
        if ((([o, s] = this.findNextSpecialToken(e, i, r)), s > i && this.encodeByIndex(e, n, i, s), o)) {
          if (((i = i + this.encodeSpecialToken(n, o)), i >= e.length)) break
        } else break
      }
      return n
    }
    encodeSpecialToken(e, r) {
      let n = this.specialTokensEncoder?.get(r[0])
      return e.push(n), r.index + r[0].length
    }
    encodeByIndex(e, r, n, i) {
      let o,
        s = Array.from(e.substring(n, i).matchAll(this.regex))
      for (var a = 0; a < s.length && ((o = s[a]), o !== void 0); a++)
        if (this.cache.has(o[0])) r.push(...this.cache.get(o[0]))
        else {
          let l = this.textEncoder.encode(o[0]),
            c = this.encoder?.get((0, Mh.uint8ArrayToString)(l))
          if (c !== void 0) r.push(c), this.cache.set(o[0], [c])
          else {
            let u = (0, Mh.bytePairEncode)(l, this.encoder)
            r.push(...u), this.cache.set(o[0], u)
          }
        }
    }
    encodeTrimSuffixByIndex(e, r, n, i, o, s, a) {
      let l,
        c = Array.from(e.substring(n, i).matchAll(this.regex))
      for (var u = 0; u < c.length; u++) {
        l = c[u]
        let p = l[0]
        if (this.cache.has(p)) {
          let d = this.cache.get(p)
          if (((s += d.length), s <= o)) (a += p.length), r.push(...d)
          else break
        } else {
          let d = this.textEncoder.encode(p),
            f = this.encoder.get((0, Mh.uint8ArrayToString)(d))
          if (f !== void 0)
            if ((s++, s <= o)) (a += p.length), r.push(f)
            else break
          else {
            let m = (0, Mh.bytePairEncode)(d, this.encoder)
            if ((this.cache.set(p, m), (s += m.length), s <= o)) (a += p.length), r.push(...m)
            else break
          }
        }
        if (s >= o) break
      }
      return { tokenCount: s, encodeLength: a }
    }
    encodeTrimSuffix(e, r, n) {
      let i = [],
        o = 0,
        s = 0,
        a = 0
      for (;;) {
        let c, u
        if ((([c, u] = this.findNextSpecialToken(e, o, n)), u > o)) {
          let { tokenCount: p, encodeLength: d } = this.encodeTrimSuffixByIndex(e, i, o, u, r, s, a)
          if (((s = p), (a = d), s >= r)) break
        }
        if (c !== null) {
          if ((s++, (s <= r && ((o = o + this.encodeSpecialToken(i, c)), (a += c[0].length), o >= e.length)) || s >= r))
            break
        } else break
      }
      let l = a === e.length ? e : e.slice(0, a)
      return { tokenIds: i, text: l }
    }
    encodeTrimPrefix(e, r, n) {
      let i = [],
        o = 0,
        s = 0,
        a = 0,
        l = new Map()
      for (l.set(s, a); ; ) {
        let f, m
        if ((([f, m] = this.findNextSpecialToken(e, o, n)), m > o)) {
          let h,
            g = Array.from(e.substring(o, m).matchAll(this.regex))
          for (var c = 0; c < g.length; c++) {
            h = g[c]
            let v = h[0]
            if (this.cache.has(v)) {
              let _ = this.cache.get(v)
              ;(s += _.length), (a += v.length), i.push(..._), l.set(s, a)
            } else {
              let _ = new UL.TextEncoder().encode(v),
                y = this.encoder.get((0, Mh.uint8ArrayToString)(_))
              if (y !== void 0) s++, (a += v.length), i.push(y), l.set(s, a)
              else {
                let b = (0, Mh.bytePairEncode)(_, this.encoder)
                this.cache.set(v, b), (s += b.length), (a += v.length), i.push(...b), l.set(s, a)
              }
            }
          }
        }
        if (f !== null) {
          if (((o = o + this.encodeSpecialToken(i, f)), s++, (a += f[0].length), l.set(s, a), o >= e.length)) break
        } else break
      }
      if (s <= r) return { tokenIds: i, text: e }
      let u = s - r,
        p = 0,
        d = 0
      for (let [f, m] of l)
        if (f >= u) {
          ;(p = f), (d = m)
          break
        }
      return { tokenIds: i.slice(p), text: e.slice(d) }
    }
    decode(e) {
      let r = []
      for (let n of e) {
        let i = [],
          o = this.decoder?.get(n)
        if (o !== void 0) i = Array.from(o)
        else {
          let s = this.specialTokensDecoder?.get(n)
          s !== void 0 && (i = Array.from(this.textEncoder.encode(s)))
        }
        r.push(...i)
      }
      return this.textDecoder.decode(new Uint8Array(r))
    }
  }
  kI.TikTokenizer = BL
})
var wW = handleExports(ei => {
  'use strict'
  Object.defineProperty(ei, '__esModule', { value: !0 })
  ei.createTokenizer =
    ei.createByEncoderName =
    ei.createByModelName =
    ei.getRegexByModel =
    ei.getRegexByEncoder =
    ei.getSpecialTokensByModel =
    ei.getSpecialTokensByEncoder =
    ei.MODEL_TO_ENCODING =
      void 0
  var OI = require('fs'),
    HL = require('path'),
    HTe = qL(),
    jTe = new Map([
      ['gpt-4-', 'cl100k_base'],
      ['gpt-3.5-turbo-', 'cl100k_base'],
    ])
  ei.MODEL_TO_ENCODING = new Map([
    ['gpt-4', 'cl100k_base'],
    ['gpt-3.5-turbo', 'cl100k_base'],
    ['text-davinci-003', 'p50k_base'],
    ['text-davinci-002', 'p50k_base'],
    ['text-davinci-001', 'r50k_base'],
    ['text-curie-001', 'r50k_base'],
    ['text-babbage-001', 'r50k_base'],
    ['text-ada-001', 'r50k_base'],
    ['davinci', 'r50k_base'],
    ['curie', 'r50k_base'],
    ['babbage', 'r50k_base'],
    ['ada', 'r50k_base'],
    ['code-davinci-002', 'p50k_base'],
    ['code-davinci-001', 'p50k_base'],
    ['code-cushman-002', 'p50k_base'],
    ['code-cushman-001', 'p50k_base'],
    ['davinci-codex', 'p50k_base'],
    ['cushman-codex', 'p50k_base'],
    ['text-davinci-edit-001', 'p50k_edit'],
    ['code-davinci-edit-001', 'p50k_edit'],
    ['text-embedding-ada-002', 'cl100k_base'],
    ['text-similarity-davinci-001', 'r50k_base'],
    ['text-similarity-curie-001', 'r50k_base'],
    ['text-similarity-babbage-001', 'r50k_base'],
    ['text-similarity-ada-001', 'r50k_base'],
    ['text-search-davinci-doc-001', 'r50k_base'],
    ['text-search-curie-doc-001', 'r50k_base'],
    ['text-search-babbage-doc-001', 'r50k_base'],
    ['text-search-ada-doc-001', 'r50k_base'],
    ['code-search-babbage-code-001', 'r50k_base'],
    ['code-search-ada-code-001', 'r50k_base'],
    ['gpt2', 'gpt2'],
  ])
  var jL = '<|endoftext|>',
    xW = '<|fim_prefix|>',
    bW = '<|fim_middle|>',
    EW = '<|fim_suffix|>',
    GTe = '<|endofprompt|>',
    Zx = "'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+",
    TW =
      "(?:'s|'S|'t|'T|'re|'RE|'Re|'eR|'ve|'VE|'vE|'Ve|'m|'M|'ll|'lL|'Ll|'LL|'d|'D)|[^\\r\\n\\p{L}\\p{N}]?\\p{L}+|\\p{N}{1,3}| ?[^\\s\\p{L}\\p{N}]+[\\r\\n]*|\\s*[\\r\\n]+|\\s+(?!\\S)|\\s+"
  function GL(t) {
    let e = ''
    if (ei.MODEL_TO_ENCODING.has(t)) e = ei.MODEL_TO_ENCODING.get(t)
    else
      for (let [r, n] of jTe)
        if (t.startsWith(r)) {
          e = n
          break
        }
    return e
  }
  async function VTe(t, e) {
    let r = await fetch(t)
    if (!r.ok) throw new Error(`Failed to fetch file from ${t}. Status code: ${r.status}`)
    let n = await r.text()
    OI.writeFileSync(e, n)
  }
  function VL(t) {
    let e = new Map([[jL, 50256]])
    switch (t) {
      case 'cl100k_base':
        e = new Map([
          [jL, 100257],
          [xW, 100258],
          [bW, 100259],
          [EW, 100260],
          [GTe, 100276],
        ])
        break
      case 'p50k_edit':
        e = new Map([
          [jL, 50256],
          [xW, 50281],
          [bW, 50282],
          [EW, 50283],
        ])
        break
      default:
        break
    }
    return e
  }
  ei.getSpecialTokensByEncoder = VL
  function zTe(t) {
    let e = GL(t)
    return VL(e)
  }
  ei.getSpecialTokensByModel = zTe
  function SW(t) {
    switch (t) {
      case 'cl100k_base':
        return TW
      default:
        break
    }
    return Zx
  }
  ei.getRegexByEncoder = SW
  function $Te(t) {
    let e = GL(t)
    return SW(e)
  }
  ei.getRegexByModel = $Te
  async function WTe(t, e = null) {
    return CW(GL(t), e)
  }
  ei.createByModelName = WTe
  async function CW(t, e = null) {
    let r,
      n,
      i = VL(t)
    switch (t) {
      case 'cl100k_base':
        ;(r = TW), (n = 'https://openaipublic.blob.core.windows.net/encodings/cl100k_base.tiktoken')
        break
      case 'p50k_base':
        ;(r = Zx), (n = 'https://openaipublic.blob.core.windows.net/encodings/p50k_base.tiktoken')
        break
      case 'p50k_edit':
        ;(r = Zx), (n = 'https://openaipublic.blob.core.windows.net/encodings/p50k_base.tiktoken')
        break
      case 'r50k_base':
        ;(r = Zx), (n = 'https://openaipublic.blob.core.windows.net/encodings/r50k_base.tiktoken')
        break
      case 'gpt2':
        ;(r = Zx), (n = 'https://pythia.blob.core.windows.net/public/encoding/gpt2.tiktoken')
        break
      default:
        throw new Error(`Doesn't support this encoder [${t}]`)
    }
    e !== null && (i = new Map([...i, ...e]))
    let o = HL.basename(n),
      s = HL.resolve(__dirname, '..', 'model')
    OI.existsSync(s) || OI.mkdirSync(s, { recursive: !0 })
    let a = HL.resolve(s, o)
    return (
      OI.existsSync(a) ||
        (console.log(`Downloading file from ${n}`), await VTe(n, a), console.log(`Saved file to ${a}`)),
      IW(a, i, r)
    )
  }
  ei.createByEncoderName = CW
  function IW(t, e, r, n = 8192) {
    return new HTe.TikTokenizer(t, e, r, n)
  }
  ei.createTokenizer = IW
})
var AW = handleExports(ti => {
  'use strict'
  Object.defineProperty(ti, '__esModule', { value: !0 })
  ti.createTokenizer =
    ti.createByEncoderName =
    ti.createByModelName =
    ti.getSpecialTokensByModel =
    ti.getSpecialTokensByEncoder =
    ti.getRegexByModel =
    ti.getRegexByEncoder =
    ti.MODEL_TO_ENCODING =
    ti.TikTokenizer =
      void 0
  var KTe = qL()
  Object.defineProperty(ti, 'TikTokenizer', {
    enumerable: !0,
    get: function () {
      return KTe.TikTokenizer
    },
  })
  var Gd = wW()
  Object.defineProperty(ti, 'MODEL_TO_ENCODING', {
    enumerable: !0,
    get: function () {
      return Gd.MODEL_TO_ENCODING
    },
  })
  Object.defineProperty(ti, 'getRegexByEncoder', {
    enumerable: !0,
    get: function () {
      return Gd.getRegexByEncoder
    },
  })
  Object.defineProperty(ti, 'getRegexByModel', {
    enumerable: !0,
    get: function () {
      return Gd.getRegexByModel
    },
  })
  Object.defineProperty(ti, 'getSpecialTokensByEncoder', {
    enumerable: !0,
    get: function () {
      return Gd.getSpecialTokensByEncoder
    },
  })
  Object.defineProperty(ti, 'getSpecialTokensByModel', {
    enumerable: !0,
    get: function () {
      return Gd.getSpecialTokensByModel
    },
  })
  Object.defineProperty(ti, 'createByModelName', {
    enumerable: !0,
    get: function () {
      return Gd.createByModelName
    },
  })
  Object.defineProperty(ti, 'createByEncoderName', {
    enumerable: !0,
    get: function () {
      return Gd.createByEncoderName
    },
  })
  Object.defineProperty(ti, 'createTokenizer', {
    enumerable: !0,
    get: function () {
      return Gd.createTokenizer
    },
  })
})
var eK = handleExports((exports, module) => {
  var Module = Module !== void 0 ? Module : {},
    TreeSitter = (function () {
      var initPromise,
        document = typeof window == 'object' ? { currentScript: window.document.currentScript } : null
      class Parser {
        constructor() {
          this.initialize()
        }
        initialize() {
          throw new Error('cannot construct a Parser before calling `init()`')
        }
        static init(moduleOptions) {
          return (
            initPromise ||
            ((Module = Object.assign({}, Module, moduleOptions)),
            (initPromise = new Promise(resolveInitPromise => {
              var moduleOverrides = Object.assign({}, Module),
                arguments_ = [],
                thisProgram = './this.program',
                quit_ = (t, e) => {
                  throw e
                },
                ENVIRONMENT_IS_WEB = typeof window == 'object',
                ENVIRONMENT_IS_WORKER = typeof importScripts == 'function',
                ENVIRONMENT_IS_NODE =
                  typeof process == 'object' &&
                  typeof process.versions == 'object' &&
                  typeof process.versions.node == 'string',
                scriptDirectory = '',
                read_,
                readAsync,
                readBinary,
                setWindowTitle
              function locateFile(t) {
                return Module.locateFile ? Module.locateFile(t, scriptDirectory) : scriptDirectory + t
              }
              function logExceptionOnExit(t) {
                t instanceof ExitStatus || err('exiting due to exception: ' + t)
              }
              if (ENVIRONMENT_IS_NODE) {
                var fs = require('fs'),
                  nodePath = require('path')
                ;(scriptDirectory = ENVIRONMENT_IS_WORKER ? nodePath.dirname(scriptDirectory) + '/' : __dirname + '/'),
                  (read_ = (t, e) => (
                    (t = isFileURI(t) ? new URL(t) : nodePath.normalize(t)), fs.readFileSync(t, e ? void 0 : 'utf8')
                  )),
                  (readBinary = t => {
                    var e = read_(t, !0)
                    return e.buffer || (e = new Uint8Array(e)), e
                  }),
                  (readAsync = (t, e, r) => {
                    ;(t = isFileURI(t) ? new URL(t) : nodePath.normalize(t)),
                      fs.readFile(t, function (n, i) {
                        n ? r(n) : e(i.buffer)
                      })
                  }),
                  process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, '/')),
                  (arguments_ = process.argv.slice(2)),
                  typeof module < 'u' && (module.exports = Module),
                  (quit_ = (t, e) => {
                    if (keepRuntimeAlive()) throw ((process.exitCode = t), e)
                    logExceptionOnExit(e), process.exit(t)
                  }),
                  (Module.inspect = function () {
                    return '[Emscripten Module object]'
                  })
              } else
                (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) &&
                  (ENVIRONMENT_IS_WORKER
                    ? (scriptDirectory = self.location.href)
                    : document !== void 0 && document.currentScript && (scriptDirectory = document.currentScript.src),
                  (scriptDirectory =
                    scriptDirectory.indexOf('blob:') !== 0
                      ? scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1)
                      : ''),
                  (read_ = t => {
                    var e = new XMLHttpRequest()
                    return e.open('GET', t, !1), e.send(null), e.responseText
                  }),
                  ENVIRONMENT_IS_WORKER &&
                    (readBinary = t => {
                      var e = new XMLHttpRequest()
                      return (
                        e.open('GET', t, !1), (e.responseType = 'arraybuffer'), e.send(null), new Uint8Array(e.response)
                      )
                    }),
                  (readAsync = (t, e, r) => {
                    var n = new XMLHttpRequest()
                    n.open('GET', t, !0),
                      (n.responseType = 'arraybuffer'),
                      (n.onload = () => {
                        n.status == 200 || (n.status == 0 && n.response) ? e(n.response) : r()
                      }),
                      (n.onerror = r),
                      n.send(null)
                  }),
                  (setWindowTitle = t => (document.title = t)))
              var out = Module.print || console.log.bind(console),
                err = Module.printErr || console.warn.bind(console)
              Object.assign(Module, moduleOverrides),
                (moduleOverrides = null),
                Module.arguments && (arguments_ = Module.arguments),
                Module.thisProgram && (thisProgram = Module.thisProgram),
                Module.quit && (quit_ = Module.quit)
              var STACK_ALIGN = 16,
                dynamicLibraries = Module.dynamicLibraries || [],
                wasmBinary
              Module.wasmBinary && (wasmBinary = Module.wasmBinary)
              var noExitRuntime = Module.noExitRuntime || !0,
                wasmMemory
              typeof WebAssembly != 'object' && abort('no native wasm support detected')
              var ABORT = !1,
                EXITSTATUS,
                UTF8Decoder = typeof TextDecoder < 'u' ? new TextDecoder('utf8') : void 0,
                buffer,
                HEAP8,
                HEAPU8,
                HEAP16,
                HEAPU16,
                HEAP32,
                HEAPU32,
                HEAPF32,
                HEAPF64
              function UTF8ArrayToString(t, e, r) {
                for (var n = e + r, i = e; t[i] && !(i >= n); ) ++i
                if (i - e > 16 && t.buffer && UTF8Decoder) return UTF8Decoder.decode(t.subarray(e, i))
                for (var o = ''; e < i; ) {
                  var s = t[e++]
                  if (128 & s) {
                    var a = 63 & t[e++]
                    if ((224 & s) != 192) {
                      var l = 63 & t[e++]
                      if (
                        (s =
                          (240 & s) == 224
                            ? ((15 & s) << 12) | (a << 6) | l
                            : ((7 & s) << 18) | (a << 12) | (l << 6) | (63 & t[e++])) < 65536
                      )
                        o += String.fromCharCode(s)
                      else {
                        var c = s - 65536
                        o += String.fromCharCode(55296 | (c >> 10), 56320 | (1023 & c))
                      }
                    } else o += String.fromCharCode(((31 & s) << 6) | a)
                  } else o += String.fromCharCode(s)
                }
                return o
              }
              function UTF8ToString(t, e) {
                return t ? UTF8ArrayToString(HEAPU8, t, e) : ''
              }
              function stringToUTF8Array(t, e, r, n) {
                if (!(n > 0)) return 0
                for (var i = r, o = r + n - 1, s = 0; s < t.length; ++s) {
                  var a = t.charCodeAt(s)
                  if (
                    (a >= 55296 && a <= 57343 && (a = (65536 + ((1023 & a) << 10)) | (1023 & t.charCodeAt(++s))),
                    a <= 127)
                  ) {
                    if (r >= o) break
                    e[r++] = a
                  } else if (a <= 2047) {
                    if (r + 1 >= o) break
                    ;(e[r++] = 192 | (a >> 6)), (e[r++] = 128 | (63 & a))
                  } else if (a <= 65535) {
                    if (r + 2 >= o) break
                    ;(e[r++] = 224 | (a >> 12)), (e[r++] = 128 | ((a >> 6) & 63)), (e[r++] = 128 | (63 & a))
                  } else {
                    if (r + 3 >= o) break
                    ;(e[r++] = 240 | (a >> 18)),
                      (e[r++] = 128 | ((a >> 12) & 63)),
                      (e[r++] = 128 | ((a >> 6) & 63)),
                      (e[r++] = 128 | (63 & a))
                  }
                }
                return (e[r] = 0), r - i
              }
              function stringToUTF8(t, e, r) {
                return stringToUTF8Array(t, HEAPU8, e, r)
              }
              function lengthBytesUTF8(t) {
                for (var e = 0, r = 0; r < t.length; ++r) {
                  var n = t.charCodeAt(r)
                  n <= 127 ? e++ : n <= 2047 ? (e += 2) : n >= 55296 && n <= 57343 ? ((e += 4), ++r) : (e += 3)
                }
                return e
              }
              function updateGlobalBufferAndViews(t) {
                ;(buffer = t),
                  (Module.HEAP8 = HEAP8 = new Int8Array(t)),
                  (Module.HEAP16 = HEAP16 = new Int16Array(t)),
                  (Module.HEAP32 = HEAP32 = new Int32Array(t)),
                  (Module.HEAPU8 = HEAPU8 = new Uint8Array(t)),
                  (Module.HEAPU16 = HEAPU16 = new Uint16Array(t)),
                  (Module.HEAPU32 = HEAPU32 = new Uint32Array(t)),
                  (Module.HEAPF32 = HEAPF32 = new Float32Array(t)),
                  (Module.HEAPF64 = HEAPF64 = new Float64Array(t))
              }
              var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432
              ;(wasmMemory = Module.wasmMemory
                ? Module.wasmMemory
                : new WebAssembly.Memory({ initial: INITIAL_MEMORY / 65536, maximum: 32768 })),
                wasmMemory && (buffer = wasmMemory.buffer),
                (INITIAL_MEMORY = buffer.byteLength),
                updateGlobalBufferAndViews(buffer)
              var wasmTable = new WebAssembly.Table({ initial: 20, element: 'anyfunc' }),
                __ATPRERUN__ = [],
                __ATINIT__ = [],
                __ATMAIN__ = [],
                __ATPOSTRUN__ = [],
                __RELOC_FUNCS__ = [],
                runtimeInitialized = !1
              function keepRuntimeAlive() {
                return noExitRuntime
              }
              function preRun() {
                if (Module.preRun)
                  for (typeof Module.preRun == 'function' && (Module.preRun = [Module.preRun]); Module.preRun.length; )
                    addOnPreRun(Module.preRun.shift())
                callRuntimeCallbacks(__ATPRERUN__)
              }
              function initRuntime() {
                ;(runtimeInitialized = !0), callRuntimeCallbacks(__RELOC_FUNCS__), callRuntimeCallbacks(__ATINIT__)
              }
              function preMain() {
                callRuntimeCallbacks(__ATMAIN__)
              }
              function postRun() {
                if (Module.postRun)
                  for (
                    typeof Module.postRun == 'function' && (Module.postRun = [Module.postRun]);
                    Module.postRun.length;

                  )
                    addOnPostRun(Module.postRun.shift())
                callRuntimeCallbacks(__ATPOSTRUN__)
              }
              function addOnPreRun(t) {
                __ATPRERUN__.unshift(t)
              }
              function addOnInit(t) {
                __ATINIT__.unshift(t)
              }
              function addOnPostRun(t) {
                __ATPOSTRUN__.unshift(t)
              }
              var runDependencies = 0,
                runDependencyWatcher = null,
                dependenciesFulfilled = null
              function addRunDependency(t) {
                runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies)
              }
              function removeRunDependency(t) {
                if (
                  (runDependencies--,
                  Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies),
                  runDependencies == 0 &&
                    (runDependencyWatcher !== null &&
                      (clearInterval(runDependencyWatcher), (runDependencyWatcher = null)),
                    dependenciesFulfilled))
                ) {
                  var e = dependenciesFulfilled
                  ;(dependenciesFulfilled = null), e()
                }
              }
              function abort(t) {
                throw (
                  (Module.onAbort && Module.onAbort(t),
                  err((t = 'Aborted(' + t + ')')),
                  (ABORT = !0),
                  (EXITSTATUS = 1),
                  (t += '. Build with -sASSERTIONS for more info.'),
                  new WebAssembly.RuntimeError(t))
                )
              }
              var dataURIPrefix = 'data:application/octet-stream;base64,',
                wasmBinaryFile,
                tempDouble,
                tempI64
              function isDataURI(t) {
                return t.startsWith(dataURIPrefix)
              }
              function isFileURI(t) {
                return t.startsWith('file://')
              }
              function getBinary(t) {
                try {
                  if (t == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary)
                  if (readBinary) return readBinary(t)
                  throw 'both async and sync fetching of the wasm failed'
                } catch (e) {
                  abort(e)
                }
              }
              function getBinaryPromise() {
                if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                  if (typeof fetch == 'function' && !isFileURI(wasmBinaryFile))
                    return fetch(wasmBinaryFile, { credentials: 'same-origin' })
                      .then(function (t) {
                        if (!t.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                        return t.arrayBuffer()
                      })
                      .catch(function () {
                        return getBinary(wasmBinaryFile)
                      })
                  if (readAsync)
                    return new Promise(function (t, e) {
                      readAsync(
                        wasmBinaryFile,
                        function (r) {
                          t(new Uint8Array(r))
                        },
                        e
                      )
                    })
                }
                return Promise.resolve().then(function () {
                  return getBinary(wasmBinaryFile)
                })
              }
              function createWasm() {
                var t = {
                  env: asmLibraryArg,
                  wasi_snapshot_preview1: asmLibraryArg,
                  'GOT.mem': new Proxy(asmLibraryArg, GOTHandler),
                  'GOT.func': new Proxy(asmLibraryArg, GOTHandler),
                }
                function e(i, o) {
                  var s = i.exports
                  s = relocateExports(s, 1024)
                  var a = getDylinkMetadata(o)
                  a.neededDynlibs && (dynamicLibraries = a.neededDynlibs.concat(dynamicLibraries)),
                    mergeLibSymbols(s, 'main'),
                    (Module.asm = s),
                    addOnInit(Module.asm.__wasm_call_ctors),
                    __RELOC_FUNCS__.push(Module.asm.__wasm_apply_data_relocs),
                    removeRunDependency('wasm-instantiate')
                }
                function r(i) {
                  e(i.instance, i.module)
                }
                function n(i) {
                  return getBinaryPromise()
                    .then(function (o) {
                      return WebAssembly.instantiate(o, t)
                    })
                    .then(function (o) {
                      return o
                    })
                    .then(i, function (o) {
                      err('failed to asynchronously prepare wasm: ' + o), abort(o)
                    })
                }
                if ((addRunDependency('wasm-instantiate'), Module.instantiateWasm))
                  try {
                    return Module.instantiateWasm(t, e)
                  } catch (i) {
                    return err('Module.instantiateWasm callback failed with error: ' + i), !1
                  }
                return (
                  wasmBinary ||
                  typeof WebAssembly.instantiateStreaming != 'function' ||
                  isDataURI(wasmBinaryFile) ||
                  isFileURI(wasmBinaryFile) ||
                  ENVIRONMENT_IS_NODE ||
                  typeof fetch != 'function'
                    ? n(r)
                    : fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (i) {
                        return WebAssembly.instantiateStreaming(i, t).then(r, function (o) {
                          return (
                            err('wasm streaming compile failed: ' + o),
                            err('falling back to ArrayBuffer instantiation'),
                            n(r)
                          )
                        })
                      }),
                  {}
                )
              }
              ;(wasmBinaryFile = 'tree-sitter.wasm'),
                isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile))
              var ASM_CONSTS = {}
              function ExitStatus(t) {
                ;(this.name = 'ExitStatus'),
                  (this.message = 'Program terminated with exit(' + t + ')'),
                  (this.status = t)
              }
              var GOT = {},
                CurrentModuleWeakSymbols = new Set([]),
                GOTHandler = {
                  get: function (t, e) {
                    var r = GOT[e]
                    return (
                      r || (r = GOT[e] = new WebAssembly.Global({ value: 'i32', mutable: !0 })),
                      CurrentModuleWeakSymbols.has(e) || (r.required = !0),
                      r
                    )
                  },
                }
              function callRuntimeCallbacks(t) {
                for (; t.length > 0; ) t.shift()(Module)
              }
              function getDylinkMetadata(t) {
                var e = 0,
                  r = 0
                function n() {
                  for (var v = 0, _ = 1; ; ) {
                    var y = t[e++]
                    if (((v += (127 & y) * _), (_ *= 128), !(128 & y))) break
                  }
                  return v
                }
                function i() {
                  var v = n()
                  return UTF8ArrayToString(t, (e += v) - v, v)
                }
                function o(v, _) {
                  if (v) throw new Error(_)
                }
                var s = 'dylink.0'
                if (t instanceof WebAssembly.Module) {
                  var a = WebAssembly.Module.customSections(t, s)
                  a.length === 0 && ((s = 'dylink'), (a = WebAssembly.Module.customSections(t, s))),
                    o(a.length === 0, 'need dylink section'),
                    (r = (t = new Uint8Array(a[0])).length)
                } else {
                  o(
                    new Uint32Array(new Uint8Array(t.subarray(0, 24)).buffer)[0] != 1836278016,
                    'need to see wasm magic number'
                  ),
                    o(t[8] !== 0, 'need the dylink section to be first'),
                    (e = 9)
                  var l = n()
                  ;(r = e + l), (s = i())
                }
                var c = { neededDynlibs: [], tlsExports: new Set(), weakImports: new Set() }
                if (s == 'dylink') {
                  ;(c.memorySize = n()), (c.memoryAlign = n()), (c.tableSize = n()), (c.tableAlign = n())
                  for (var u = n(), p = 0; p < u; ++p) {
                    var d = i()
                    c.neededDynlibs.push(d)
                  }
                } else
                  for (o(s !== 'dylink.0'); e < r; ) {
                    var f = t[e++],
                      m = n()
                    if (f === 1) (c.memorySize = n()), (c.memoryAlign = n()), (c.tableSize = n()), (c.tableAlign = n())
                    else if (f === 2) for (u = n(), p = 0; p < u; ++p) (d = i()), c.neededDynlibs.push(d)
                    else if (f === 3)
                      for (var h = n(); h--; ) {
                        var g = i()
                        256 & n() && c.tlsExports.add(g)
                      }
                    else if (f === 4) for (h = n(); h--; ) i(), (g = i()), (3 & n()) == 1 && c.weakImports.add(g)
                    else e += m
                  }
                return c
              }
              function getValue(t, e = 'i8') {
                switch ((e.endsWith('*') && (e = '*'), e)) {
                  case 'i1':
                  case 'i8':
                    return HEAP8[t >> 0]
                  case 'i16':
                    return HEAP16[t >> 1]
                  case 'i32':
                  case 'i64':
                    return HEAP32[t >> 2]
                  case 'float':
                    return HEAPF32[t >> 2]
                  case 'double':
                    return HEAPF64[t >> 3]
                  case '*':
                    return HEAPU32[t >> 2]
                  default:
                    abort('invalid type for getValue: ' + e)
                }
                return null
              }
              function asmjsMangle(t) {
                return t.indexOf('dynCall_') == 0 ||
                  ['stackAlloc', 'stackSave', 'stackRestore', 'getTempRet0', 'setTempRet0'].includes(t)
                  ? t
                  : '_' + t
              }
              function mergeLibSymbols(t, e) {
                for (var r in t)
                  if (t.hasOwnProperty(r)) {
                    asmLibraryArg.hasOwnProperty(r) || (asmLibraryArg[r] = t[r])
                    var n = asmjsMangle(r)
                    Module.hasOwnProperty(n) || (Module[n] = t[r]), r == '__main_argc_argv' && (Module._main = t[r])
                  }
              }
              var LDSO = { loadedLibsByName: {}, loadedLibsByHandle: {} }
              function dynCallLegacy(t, e, r) {
                var n = Module['dynCall_' + t]
                return r && r.length ? n.apply(null, [e].concat(r)) : n.call(null, e)
              }
              var wasmTableMirror = []
              function getWasmTableEntry(t) {
                var e = wasmTableMirror[t]
                return (
                  e ||
                    (t >= wasmTableMirror.length && (wasmTableMirror.length = t + 1),
                    (wasmTableMirror[t] = e = wasmTable.get(t))),
                  e
                )
              }
              function dynCall(t, e, r) {
                return t.includes('j') ? dynCallLegacy(t, e, r) : getWasmTableEntry(e).apply(null, r)
              }
              function createInvokeFunction(t) {
                return function () {
                  var e = stackSave()
                  try {
                    return dynCall(t, arguments[0], Array.prototype.slice.call(arguments, 1))
                  } catch (r) {
                    if ((stackRestore(e), r !== r + 0)) throw r
                    _setThrew(1, 0)
                  }
                }
              }
              var ___heap_base = 78144
              function zeroMemory(t, e) {
                return HEAPU8.fill(0, t, t + e), t
              }
              function getMemory(t) {
                if (runtimeInitialized) return zeroMemory(_malloc(t), t)
                var e = ___heap_base,
                  r = (e + t + 15) & -16
                return (___heap_base = r), (GOT.__heap_base.value = r), e
              }
              function isInternalSym(t) {
                return [
                  '__cpp_exception',
                  '__c_longjmp',
                  '__wasm_apply_data_relocs',
                  '__dso_handle',
                  '__tls_size',
                  '__tls_align',
                  '__set_stack_limits',
                  '_emscripten_tls_init',
                  '__wasm_init_tls',
                  '__wasm_call_ctors',
                  '__start_em_asm',
                  '__stop_em_asm',
                ].includes(t)
              }
              function uleb128Encode(t, e) {
                t < 128 ? e.push(t) : e.push(t % 128 | 128, t >> 7)
              }
              function sigToWasmTypes(t) {
                for (
                  var e = { i: 'i32', j: 'i32', f: 'f32', d: 'f64', p: 'i32' },
                    r = { parameters: [], results: t[0] == 'v' ? [] : [e[t[0]]] },
                    n = 1;
                  n < t.length;
                  ++n
                )
                  r.parameters.push(e[t[n]]), t[n] === 'j' && r.parameters.push('i32')
                return r
              }
              function generateFuncType(t, e) {
                var r = t.slice(0, 1),
                  n = t.slice(1),
                  i = { i: 127, p: 127, j: 126, f: 125, d: 124 }
                e.push(96), uleb128Encode(n.length, e)
                for (var o = 0; o < n.length; ++o) e.push(i[n[o]])
                r == 'v' ? e.push(0) : e.push(1, i[r])
              }
              function convertJsFunctionToWasm(t, e) {
                if (typeof WebAssembly.Function == 'function') return new WebAssembly.Function(sigToWasmTypes(e), t)
                var r = [1]
                generateFuncType(e, r)
                var n = [0, 97, 115, 109, 1, 0, 0, 0, 1]
                uleb128Encode(r.length, n),
                  n.push.apply(n, r),
                  n.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0)
                var i = new WebAssembly.Module(new Uint8Array(n))
                return new WebAssembly.Instance(i, { e: { f: t } }).exports.f
              }
              function updateTableMap(t, e) {
                if (functionsInTableMap)
                  for (var r = t; r < t + e; r++) {
                    var n = getWasmTableEntry(r)
                    n && functionsInTableMap.set(n, r)
                  }
              }
              var functionsInTableMap = void 0,
                freeTableIndexes = []
              function getEmptyTableSlot() {
                if (freeTableIndexes.length) return freeTableIndexes.pop()
                try {
                  wasmTable.grow(1)
                } catch (t) {
                  throw t instanceof RangeError ? 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.' : t
                }
                return wasmTable.length - 1
              }
              function setWasmTableEntry(t, e) {
                wasmTable.set(t, e), (wasmTableMirror[t] = wasmTable.get(t))
              }
              function addFunction(t, e) {
                if (
                  (functionsInTableMap || ((functionsInTableMap = new WeakMap()), updateTableMap(0, wasmTable.length)),
                  functionsInTableMap.has(t))
                )
                  return functionsInTableMap.get(t)
                var r = getEmptyTableSlot()
                try {
                  setWasmTableEntry(r, t)
                } catch (n) {
                  if (!(n instanceof TypeError)) throw n
                  setWasmTableEntry(r, convertJsFunctionToWasm(t, e))
                }
                return functionsInTableMap.set(t, r), r
              }
              function updateGOT(t, e) {
                for (var r in t)
                  if (!isInternalSym(r)) {
                    var n = t[r]
                    r.startsWith('orig$') && ((r = r.split('$')[1]), (e = !0)),
                      GOT[r] || (GOT[r] = new WebAssembly.Global({ value: 'i32', mutable: !0 })),
                      (e || GOT[r].value == 0) &&
                        (typeof n == 'function'
                          ? (GOT[r].value = addFunction(n))
                          : typeof n == 'number'
                          ? (GOT[r].value = n)
                          : err('unhandled export type for `' + r + '`: ' + typeof n))
                  }
              }
              function relocateExports(t, e, r) {
                var n = {}
                for (var i in t) {
                  var o = t[i]
                  typeof o == 'object' && (o = o.value), typeof o == 'number' && (o += e), (n[i] = o)
                }
                return updateGOT(n, r), n
              }
              function resolveGlobalSymbol(t, e) {
                var r
                return (
                  e && (r = asmLibraryArg['orig$' + t]),
                  r || ((r = asmLibraryArg[t]) && r.stub && (r = void 0)),
                  r || (r = Module[asmjsMangle(t)]),
                  !r && t.startsWith('invoke_') && (r = createInvokeFunction(t.split('_')[1])),
                  r
                )
              }
              function alignMemory(t, e) {
                return Math.ceil(t / e) * e
              }
              function loadWebAssemblyModule(binary, flags, handle) {
                var metadata = getDylinkMetadata(binary)
                function loadModule() {
                  var firstLoad = !handle || !HEAP8[(handle + 12) >> 0]
                  if (firstLoad) {
                    var memAlign = Math.pow(2, metadata.memoryAlign)
                    memAlign = Math.max(memAlign, STACK_ALIGN)
                    var memoryBase = metadata.memorySize
                        ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign)
                        : 0,
                      tableBase = metadata.tableSize ? wasmTable.length : 0
                    handle &&
                      ((HEAP8[(handle + 12) >> 0] = 1),
                      (HEAPU32[(handle + 16) >> 2] = memoryBase),
                      (HEAP32[(handle + 20) >> 2] = metadata.memorySize),
                      (HEAPU32[(handle + 24) >> 2] = tableBase),
                      (HEAP32[(handle + 28) >> 2] = metadata.tableSize))
                  } else (memoryBase = HEAPU32[(handle + 16) >> 2]), (tableBase = HEAPU32[(handle + 24) >> 2])
                  var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length,
                    moduleExports
                  function resolveSymbol(t) {
                    var e = resolveGlobalSymbol(t, !1)
                    return e || (e = moduleExports[t]), e
                  }
                  tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded)
                  var proxyHandler = {
                      get: function (t, e) {
                        switch (e) {
                          case '__memory_base':
                            return memoryBase
                          case '__table_base':
                            return tableBase
                        }
                        if (e in asmLibraryArg) return asmLibraryArg[e]
                        var r
                        return (
                          e in t ||
                            (t[e] = function () {
                              return r || (r = resolveSymbol(e)), r.apply(null, arguments)
                            }),
                          t[e]
                        )
                      },
                    },
                    proxy = new Proxy({}, proxyHandler),
                    info = {
                      'GOT.mem': new Proxy({}, GOTHandler),
                      'GOT.func': new Proxy({}, GOTHandler),
                      env: proxy,
                      wasi_snapshot_preview1: proxy,
                    }
                  function postInstantiation(instance) {
                    function addEmAsm(addr, body) {
                      for (var args = [], arity = 0; arity < 16 && body.indexOf('$' + arity) != -1; arity++)
                        args.push('$' + arity)
                      args = args.join(',')
                      var func = '(' + args + ' ) => { ' + body + '};'
                      ASM_CONSTS[start] = eval(func)
                    }
                    if (
                      (updateTableMap(tableBase, metadata.tableSize),
                      (moduleExports = relocateExports(instance.exports, memoryBase)),
                      flags.allowUndefined || reportUndefinedSymbols(),
                      '__start_em_asm' in moduleExports)
                    )
                      for (
                        var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm;
                        start < stop;

                      ) {
                        var jsString = UTF8ToString(start)
                        addEmAsm(start, jsString), (start = HEAPU8.indexOf(0, start) + 1)
                      }
                    var applyRelocs = moduleExports.__wasm_apply_data_relocs
                    applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs))
                    var init = moduleExports.__wasm_call_ctors
                    return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports
                  }
                  if (flags.loadAsync) {
                    if (binary instanceof WebAssembly.Module) {
                      var instance = new WebAssembly.Instance(binary, info)
                      return Promise.resolve(postInstantiation(instance))
                    }
                    return WebAssembly.instantiate(binary, info).then(function (t) {
                      return postInstantiation(t.instance)
                    })
                  }
                  var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
                    instance = new WebAssembly.Instance(module, info)
                  return postInstantiation(instance)
                }
                return (
                  (CurrentModuleWeakSymbols = metadata.weakImports),
                  flags.loadAsync
                    ? metadata.neededDynlibs
                        .reduce(function (t, e) {
                          return t.then(function () {
                            return loadDynamicLibrary(e, flags)
                          })
                        }, Promise.resolve())
                        .then(function () {
                          return loadModule()
                        })
                    : (metadata.neededDynlibs.forEach(function (t) {
                        loadDynamicLibrary(t, flags)
                      }),
                      loadModule())
                )
              }
              function loadDynamicLibrary(t, e, r) {
                e = e || { global: !0, nodelete: !0 }
                var n = LDSO.loadedLibsByName[t]
                if (n)
                  return (
                    e.global && !n.global && ((n.global = !0), n.module !== 'loading' && mergeLibSymbols(n.module, t)),
                    e.nodelete && n.refcount !== 1 / 0 && (n.refcount = 1 / 0),
                    n.refcount++,
                    r && (LDSO.loadedLibsByHandle[r] = n),
                    !e.loadAsync || Promise.resolve(!0)
                  )
                function i(a) {
                  if (e.fs && e.fs.findObject(a)) {
                    var l = e.fs.readFile(a, { encoding: 'binary' })
                    return l instanceof Uint8Array || (l = new Uint8Array(l)), e.loadAsync ? Promise.resolve(l) : l
                  }
                  if (((a = locateFile(a)), e.loadAsync))
                    return new Promise(function (c, u) {
                      readAsync(a, p => c(new Uint8Array(p)), u)
                    })
                  if (!readBinary)
                    throw new Error(a + ': file not found, and synchronous loading of external files is not available')
                  return readBinary(a)
                }
                function o() {
                  if (typeof preloadedWasm < 'u' && preloadedWasm[t]) {
                    var a = preloadedWasm[t]
                    return e.loadAsync ? Promise.resolve(a) : a
                  }
                  return e.loadAsync
                    ? i(t).then(function (l) {
                        return loadWebAssemblyModule(l, e, r)
                      })
                    : loadWebAssemblyModule(i(t), e, r)
                }
                function s(a) {
                  n.global && mergeLibSymbols(a, t), (n.module = a)
                }
                return (
                  (n = { refcount: e.nodelete ? 1 / 0 : 1, name: t, module: 'loading', global: e.global }),
                  (LDSO.loadedLibsByName[t] = n),
                  r && (LDSO.loadedLibsByHandle[r] = n),
                  e.loadAsync
                    ? o().then(function (a) {
                        return s(a), !0
                      })
                    : (s(o()), !0)
                )
              }
              function reportUndefinedSymbols() {
                for (var t in GOT)
                  if (GOT[t].value == 0) {
                    var e = resolveGlobalSymbol(t, !0)
                    if (!e && !GOT[t].required) continue
                    if (typeof e == 'function') GOT[t].value = addFunction(e, e.sig)
                    else {
                      if (typeof e != 'number') throw new Error('bad export type for `' + t + '`: ' + typeof e)
                      GOT[t].value = e
                    }
                  }
              }
              function preloadDylibs() {
                dynamicLibraries.length
                  ? (addRunDependency('preloadDylibs'),
                    dynamicLibraries
                      .reduce(function (t, e) {
                        return t.then(function () {
                          return loadDynamicLibrary(e, { loadAsync: !0, global: !0, nodelete: !0, allowUndefined: !0 })
                        })
                      }, Promise.resolve())
                      .then(function () {
                        reportUndefinedSymbols(), removeRunDependency('preloadDylibs')
                      }))
                  : reportUndefinedSymbols()
              }
              function setValue(t, e, r = 'i8') {
                switch ((r.endsWith('*') && (r = '*'), r)) {
                  case 'i1':
                  case 'i8':
                    HEAP8[t >> 0] = e
                    break
                  case 'i16':
                    HEAP16[t >> 1] = e
                    break
                  case 'i32':
                    HEAP32[t >> 2] = e
                    break
                  case 'i64':
                    ;(tempI64 = [
                      e >>> 0,
                      ((tempDouble = e),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                      (HEAP32[t >> 2] = tempI64[0]),
                      (HEAP32[(t + 4) >> 2] = tempI64[1])
                    break
                  case 'float':
                    HEAPF32[t >> 2] = e
                    break
                  case 'double':
                    HEAPF64[t >> 3] = e
                    break
                  case '*':
                    HEAPU32[t >> 2] = e
                    break
                  default:
                    abort('invalid type for setValue: ' + r)
                }
              }
              var ___memory_base = new WebAssembly.Global({ value: 'i32', mutable: !1 }, 1024),
                ___stack_pointer = new WebAssembly.Global({ value: 'i32', mutable: !0 }, 78144),
                ___table_base = new WebAssembly.Global({ value: 'i32', mutable: !1 }, 1),
                nowIsMonotonic = !0,
                _emscripten_get_now
              function __emscripten_get_now_is_monotonic() {
                return nowIsMonotonic
              }
              function _abort() {
                abort('')
              }
              function _emscripten_date_now() {
                return Date.now()
              }
              function _emscripten_memcpy_big(t, e, r) {
                HEAPU8.copyWithin(t, e, e + r)
              }
              function getHeapMax() {
                return 2147483648
              }
              function emscripten_realloc_buffer(t) {
                try {
                  return (
                    wasmMemory.grow((t - buffer.byteLength + 65535) >>> 16),
                    updateGlobalBufferAndViews(wasmMemory.buffer),
                    1
                  )
                } catch {}
              }
              function _emscripten_resize_heap(t) {
                var e = HEAPU8.length
                t >>>= 0
                var r = getHeapMax()
                if (t > r) return !1
                for (var n = 1; n <= 4; n *= 2) {
                  var i = e * (1 + 0.2 / n)
                  if (
                    ((i = Math.min(i, t + 100663296)),
                    emscripten_realloc_buffer(Math.min(r, (o = Math.max(t, i)) + (((s = 65536) - (o % s)) % s))))
                  )
                    return !0
                }
                var o, s
                return !1
              }
              ;(__emscripten_get_now_is_monotonic.sig = 'i'),
                (Module._abort = _abort),
                (_abort.sig = 'v'),
                (_emscripten_date_now.sig = 'd'),
                (_emscripten_get_now = ENVIRONMENT_IS_NODE
                  ? () => {
                      var t = process.hrtime()
                      return 1e3 * t[0] + t[1] / 1e6
                    }
                  : () => performance.now()),
                (_emscripten_get_now.sig = 'd'),
                (_emscripten_memcpy_big.sig = 'vppp'),
                (_emscripten_resize_heap.sig = 'ip')
              var SYSCALLS = {
                DEFAULT_POLLMASK: 5,
                calculateAt: function (t, e, r) {
                  if (PATH.isAbs(e)) return e
                  var n
                  if ((t === -100 ? (n = FS.cwd()) : (n = SYSCALLS.getStreamFromFD(t).path), e.length == 0)) {
                    if (!r) throw new FS.ErrnoError(44)
                    return n
                  }
                  return PATH.join2(n, e)
                },
                doStat: function (t, e, r) {
                  try {
                    var n = t(e)
                  } catch (a) {
                    if (a && a.node && PATH.normalize(e) !== PATH.normalize(FS.getPath(a.node))) return -54
                    throw a
                  }
                  ;(HEAP32[r >> 2] = n.dev),
                    (HEAP32[(r + 8) >> 2] = n.ino),
                    (HEAP32[(r + 12) >> 2] = n.mode),
                    (HEAPU32[(r + 16) >> 2] = n.nlink),
                    (HEAP32[(r + 20) >> 2] = n.uid),
                    (HEAP32[(r + 24) >> 2] = n.gid),
                    (HEAP32[(r + 28) >> 2] = n.rdev),
                    (tempI64 = [
                      n.size >>> 0,
                      ((tempDouble = n.size),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[(r + 40) >> 2] = tempI64[0]),
                    (HEAP32[(r + 44) >> 2] = tempI64[1]),
                    (HEAP32[(r + 48) >> 2] = 4096),
                    (HEAP32[(r + 52) >> 2] = n.blocks)
                  var i = n.atime.getTime(),
                    o = n.mtime.getTime(),
                    s = n.ctime.getTime()
                  return (
                    (tempI64 = [
                      Math.floor(i / 1e3) >>> 0,
                      ((tempDouble = Math.floor(i / 1e3)),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[(r + 56) >> 2] = tempI64[0]),
                    (HEAP32[(r + 60) >> 2] = tempI64[1]),
                    (HEAPU32[(r + 64) >> 2] = (i % 1e3) * 1e3),
                    (tempI64 = [
                      Math.floor(o / 1e3) >>> 0,
                      ((tempDouble = Math.floor(o / 1e3)),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[(r + 72) >> 2] = tempI64[0]),
                    (HEAP32[(r + 76) >> 2] = tempI64[1]),
                    (HEAPU32[(r + 80) >> 2] = (o % 1e3) * 1e3),
                    (tempI64 = [
                      Math.floor(s / 1e3) >>> 0,
                      ((tempDouble = Math.floor(s / 1e3)),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[(r + 88) >> 2] = tempI64[0]),
                    (HEAP32[(r + 92) >> 2] = tempI64[1]),
                    (HEAPU32[(r + 96) >> 2] = (s % 1e3) * 1e3),
                    (tempI64 = [
                      n.ino >>> 0,
                      ((tempDouble = n.ino),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[(r + 104) >> 2] = tempI64[0]),
                    (HEAP32[(r + 108) >> 2] = tempI64[1]),
                    0
                  )
                },
                doMsync: function (t, e, r, n, i) {
                  if (!FS.isFile(e.node.mode)) throw new FS.ErrnoError(43)
                  if (2 & n) return 0
                  var o = HEAPU8.slice(t, t + r)
                  FS.msync(e, o, i, r, n)
                },
                varargs: void 0,
                get: function () {
                  return (SYSCALLS.varargs += 4), HEAP32[(SYSCALLS.varargs - 4) >> 2]
                },
                getStr: function (t) {
                  return UTF8ToString(t)
                },
                getStreamFromFD: function (t) {
                  var e = FS.getStream(t)
                  if (!e) throw new FS.ErrnoError(8)
                  return e
                },
              }
              function _proc_exit(t) {
                ;(EXITSTATUS = t),
                  keepRuntimeAlive() || (Module.onExit && Module.onExit(t), (ABORT = !0)),
                  quit_(t, new ExitStatus(t))
              }
              function exitJS(t, e) {
                ;(EXITSTATUS = t), _proc_exit(t)
              }
              _proc_exit.sig = 'vi'
              var _exit = exitJS
              function _fd_close(t) {
                try {
                  var e = SYSCALLS.getStreamFromFD(t)
                  return FS.close(e), 0
                } catch (r) {
                  if (typeof FS > 'u' || !(r instanceof FS.ErrnoError)) throw r
                  return r.errno
                }
              }
              function convertI32PairToI53Checked(t, e) {
                return (e + 2097152) >>> 0 < 4194305 - !!t ? (t >>> 0) + 4294967296 * e : NaN
              }
              function _fd_seek(t, e, r, n, i) {
                try {
                  var o = convertI32PairToI53Checked(e, r)
                  if (isNaN(o)) return 61
                  var s = SYSCALLS.getStreamFromFD(t)
                  return (
                    FS.llseek(s, o, n),
                    (tempI64 = [
                      s.position >>> 0,
                      ((tempDouble = s.position),
                      +Math.abs(tempDouble) >= 1
                        ? tempDouble > 0
                          ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0
                          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                        : 0),
                    ]),
                    (HEAP32[i >> 2] = tempI64[0]),
                    (HEAP32[(i + 4) >> 2] = tempI64[1]),
                    s.getdents && o === 0 && n === 0 && (s.getdents = null),
                    0
                  )
                } catch (a) {
                  if (typeof FS > 'u' || !(a instanceof FS.ErrnoError)) throw a
                  return a.errno
                }
              }
              function doWritev(t, e, r, n) {
                for (var i = 0, o = 0; o < r; o++) {
                  var s = HEAPU32[e >> 2],
                    a = HEAPU32[(e + 4) >> 2]
                  e += 8
                  var l = FS.write(t, HEAP8, s, a, n)
                  if (l < 0) return -1
                  ;(i += l), n !== void 0 && (n += l)
                }
                return i
              }
              function _fd_write(t, e, r, n) {
                try {
                  var i = doWritev(SYSCALLS.getStreamFromFD(t), e, r)
                  return (HEAPU32[n >> 2] = i), 0
                } catch (o) {
                  if (typeof FS > 'u' || !(o instanceof FS.ErrnoError)) throw o
                  return o.errno
                }
              }
              function _tree_sitter_log_callback(t, e) {
                if (currentLogCallback) {
                  let r = UTF8ToString(e)
                  currentLogCallback(r, t !== 0)
                }
              }
              function _tree_sitter_parse_callback(t, e, r, n, i) {
                var o = currentParseCallback(e, { row: r, column: n })
                typeof o == 'string'
                  ? (setValue(i, o.length, 'i32'), stringToUTF16(o, t, 10240))
                  : setValue(i, 0, 'i32')
              }
              function handleException(t) {
                if (t instanceof ExitStatus || t == 'unwind') return EXITSTATUS
                quit_(1, t)
              }
              function allocateUTF8OnStack(t) {
                var e = lengthBytesUTF8(t) + 1,
                  r = stackAlloc(e)
                return stringToUTF8Array(t, HEAP8, r, e), r
              }
              function stringToUTF16(t, e, r) {
                if ((r === void 0 && (r = 2147483647), r < 2)) return 0
                for (var n = e, i = (r -= 2) < 2 * t.length ? r / 2 : t.length, o = 0; o < i; ++o) {
                  var s = t.charCodeAt(o)
                  ;(HEAP16[e >> 1] = s), (e += 2)
                }
                return (HEAP16[e >> 1] = 0), e - n
              }
              function AsciiToString(t) {
                for (var e = ''; ; ) {
                  var r = HEAPU8[t++ >> 0]
                  if (!r) return e
                  e += String.fromCharCode(r)
                }
              }
              ;(_exit.sig = 'vi'), (_fd_close.sig = 'ii'), (_fd_seek.sig = 'iijip'), (_fd_write.sig = 'iippp')
              var asmLibraryArg = {
                  __heap_base: ___heap_base,
                  __indirect_function_table: wasmTable,
                  __memory_base: ___memory_base,
                  __stack_pointer: ___stack_pointer,
                  __table_base: ___table_base,
                  _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
                  abort: _abort,
                  emscripten_get_now: _emscripten_get_now,
                  emscripten_memcpy_big: _emscripten_memcpy_big,
                  emscripten_resize_heap: _emscripten_resize_heap,
                  exit: _exit,
                  fd_close: _fd_close,
                  fd_seek: _fd_seek,
                  fd_write: _fd_write,
                  memory: wasmMemory,
                  tree_sitter_log_callback: _tree_sitter_log_callback,
                  tree_sitter_parse_callback: _tree_sitter_parse_callback,
                },
                asm = createWasm(),
                ___wasm_call_ctors = (Module.___wasm_call_ctors = function () {
                  return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(
                    null,
                    arguments
                  )
                }),
                ___wasm_apply_data_relocs = (Module.___wasm_apply_data_relocs = function () {
                  return (___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs =
                    Module.asm.__wasm_apply_data_relocs).apply(null, arguments)
                }),
                _malloc = (Module._malloc = function () {
                  return (_malloc = Module._malloc = Module.asm.malloc).apply(null, arguments)
                }),
                _calloc = (Module._calloc = function () {
                  return (_calloc = Module._calloc = Module.asm.calloc).apply(null, arguments)
                }),
                _realloc = (Module._realloc = function () {
                  return (_realloc = Module._realloc = Module.asm.realloc).apply(null, arguments)
                }),
                _free = (Module._free = function () {
                  return (_free = Module._free = Module.asm.free).apply(null, arguments)
                }),
                _ts_language_symbol_count = (Module._ts_language_symbol_count = function () {
                  return (_ts_language_symbol_count = Module._ts_language_symbol_count =
                    Module.asm.ts_language_symbol_count).apply(null, arguments)
                }),
                _ts_language_version = (Module._ts_language_version = function () {
                  return (_ts_language_version = Module._ts_language_version = Module.asm.ts_language_version).apply(
                    null,
                    arguments
                  )
                }),
                _ts_language_field_count = (Module._ts_language_field_count = function () {
                  return (_ts_language_field_count = Module._ts_language_field_count =
                    Module.asm.ts_language_field_count).apply(null, arguments)
                }),
                _ts_language_symbol_name = (Module._ts_language_symbol_name = function () {
                  return (_ts_language_symbol_name = Module._ts_language_symbol_name =
                    Module.asm.ts_language_symbol_name).apply(null, arguments)
                }),
                _ts_language_symbol_for_name = (Module._ts_language_symbol_for_name = function () {
                  return (_ts_language_symbol_for_name = Module._ts_language_symbol_for_name =
                    Module.asm.ts_language_symbol_for_name).apply(null, arguments)
                }),
                _ts_language_symbol_type = (Module._ts_language_symbol_type = function () {
                  return (_ts_language_symbol_type = Module._ts_language_symbol_type =
                    Module.asm.ts_language_symbol_type).apply(null, arguments)
                }),
                _ts_language_field_name_for_id = (Module._ts_language_field_name_for_id = function () {
                  return (_ts_language_field_name_for_id = Module._ts_language_field_name_for_id =
                    Module.asm.ts_language_field_name_for_id).apply(null, arguments)
                }),
                _memset = (Module._memset = function () {
                  return (_memset = Module._memset = Module.asm.memset).apply(null, arguments)
                }),
                _memcpy = (Module._memcpy = function () {
                  return (_memcpy = Module._memcpy = Module.asm.memcpy).apply(null, arguments)
                }),
                _ts_parser_delete = (Module._ts_parser_delete = function () {
                  return (_ts_parser_delete = Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(
                    null,
                    arguments
                  )
                }),
                _ts_parser_reset = (Module._ts_parser_reset = function () {
                  return (_ts_parser_reset = Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(
                    null,
                    arguments
                  )
                }),
                _ts_parser_set_language = (Module._ts_parser_set_language = function () {
                  return (_ts_parser_set_language = Module._ts_parser_set_language =
                    Module.asm.ts_parser_set_language).apply(null, arguments)
                }),
                _ts_parser_timeout_micros = (Module._ts_parser_timeout_micros = function () {
                  return (_ts_parser_timeout_micros = Module._ts_parser_timeout_micros =
                    Module.asm.ts_parser_timeout_micros).apply(null, arguments)
                }),
                _ts_parser_set_timeout_micros = (Module._ts_parser_set_timeout_micros = function () {
                  return (_ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros =
                    Module.asm.ts_parser_set_timeout_micros).apply(null, arguments)
                }),
                _memmove = (Module._memmove = function () {
                  return (_memmove = Module._memmove = Module.asm.memmove).apply(null, arguments)
                }),
                _memcmp = (Module._memcmp = function () {
                  return (_memcmp = Module._memcmp = Module.asm.memcmp).apply(null, arguments)
                }),
                _ts_query_new = (Module._ts_query_new = function () {
                  return (_ts_query_new = Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments)
                }),
                _ts_query_delete = (Module._ts_query_delete = function () {
                  return (_ts_query_delete = Module._ts_query_delete = Module.asm.ts_query_delete).apply(
                    null,
                    arguments
                  )
                }),
                _iswspace = (Module._iswspace = function () {
                  return (_iswspace = Module._iswspace = Module.asm.iswspace).apply(null, arguments)
                }),
                _iswalnum = (Module._iswalnum = function () {
                  return (_iswalnum = Module._iswalnum = Module.asm.iswalnum).apply(null, arguments)
                }),
                _ts_query_pattern_count = (Module._ts_query_pattern_count = function () {
                  return (_ts_query_pattern_count = Module._ts_query_pattern_count =
                    Module.asm.ts_query_pattern_count).apply(null, arguments)
                }),
                _ts_query_capture_count = (Module._ts_query_capture_count = function () {
                  return (_ts_query_capture_count = Module._ts_query_capture_count =
                    Module.asm.ts_query_capture_count).apply(null, arguments)
                }),
                _ts_query_string_count = (Module._ts_query_string_count = function () {
                  return (_ts_query_string_count = Module._ts_query_string_count =
                    Module.asm.ts_query_string_count).apply(null, arguments)
                }),
                _ts_query_capture_name_for_id = (Module._ts_query_capture_name_for_id = function () {
                  return (_ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id =
                    Module.asm.ts_query_capture_name_for_id).apply(null, arguments)
                }),
                _ts_query_string_value_for_id = (Module._ts_query_string_value_for_id = function () {
                  return (_ts_query_string_value_for_id = Module._ts_query_string_value_for_id =
                    Module.asm.ts_query_string_value_for_id).apply(null, arguments)
                }),
                _ts_query_predicates_for_pattern = (Module._ts_query_predicates_for_pattern = function () {
                  return (_ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern =
                    Module.asm.ts_query_predicates_for_pattern).apply(null, arguments)
                }),
                _ts_tree_copy = (Module._ts_tree_copy = function () {
                  return (_ts_tree_copy = Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments)
                }),
                _ts_tree_delete = (Module._ts_tree_delete = function () {
                  return (_ts_tree_delete = Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments)
                }),
                _ts_init = (Module._ts_init = function () {
                  return (_ts_init = Module._ts_init = Module.asm.ts_init).apply(null, arguments)
                }),
                _ts_parser_new_wasm = (Module._ts_parser_new_wasm = function () {
                  return (_ts_parser_new_wasm = Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_parser_enable_logger_wasm = (Module._ts_parser_enable_logger_wasm = function () {
                  return (_ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm =
                    Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments)
                }),
                _ts_parser_parse_wasm = (Module._ts_parser_parse_wasm = function () {
                  return (_ts_parser_parse_wasm = Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_language_type_is_named_wasm = (Module._ts_language_type_is_named_wasm = function () {
                  return (_ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm =
                    Module.asm.ts_language_type_is_named_wasm).apply(null, arguments)
                }),
                _ts_language_type_is_visible_wasm = (Module._ts_language_type_is_visible_wasm = function () {
                  return (_ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm =
                    Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments)
                }),
                _ts_tree_root_node_wasm = (Module._ts_tree_root_node_wasm = function () {
                  return (_ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm =
                    Module.asm.ts_tree_root_node_wasm).apply(null, arguments)
                }),
                _ts_tree_edit_wasm = (Module._ts_tree_edit_wasm = function () {
                  return (_ts_tree_edit_wasm = Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_tree_get_changed_ranges_wasm = (Module._ts_tree_get_changed_ranges_wasm = function () {
                  return (_ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm =
                    Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_new_wasm = (Module._ts_tree_cursor_new_wasm = function () {
                  return (_ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm =
                    Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_delete_wasm = (Module._ts_tree_cursor_delete_wasm = function () {
                  return (_ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm =
                    Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_reset_wasm = (Module._ts_tree_cursor_reset_wasm = function () {
                  return (_ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm =
                    Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_goto_first_child_wasm = (Module._ts_tree_cursor_goto_first_child_wasm = function () {
                  return (_ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm =
                    Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_goto_next_sibling_wasm = (Module._ts_tree_cursor_goto_next_sibling_wasm = function () {
                  return (_ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm =
                    Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_goto_parent_wasm = (Module._ts_tree_cursor_goto_parent_wasm = function () {
                  return (_ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm =
                    Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_current_node_type_id_wasm = (Module._ts_tree_cursor_current_node_type_id_wasm =
                  function () {
                    return (_ts_tree_cursor_current_node_type_id_wasm =
                      Module._ts_tree_cursor_current_node_type_id_wasm =
                        Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments)
                  }),
                _ts_tree_cursor_current_node_is_named_wasm = (Module._ts_tree_cursor_current_node_is_named_wasm =
                  function () {
                    return (_ts_tree_cursor_current_node_is_named_wasm =
                      Module._ts_tree_cursor_current_node_is_named_wasm =
                        Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments)
                  }),
                _ts_tree_cursor_current_node_is_missing_wasm = (Module._ts_tree_cursor_current_node_is_missing_wasm =
                  function () {
                    return (_ts_tree_cursor_current_node_is_missing_wasm =
                      Module._ts_tree_cursor_current_node_is_missing_wasm =
                        Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments)
                  }),
                _ts_tree_cursor_current_node_id_wasm = (Module._ts_tree_cursor_current_node_id_wasm = function () {
                  return (_ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm =
                    Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_start_position_wasm = (Module._ts_tree_cursor_start_position_wasm = function () {
                  return (_ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm =
                    Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_end_position_wasm = (Module._ts_tree_cursor_end_position_wasm = function () {
                  return (_ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm =
                    Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_start_index_wasm = (Module._ts_tree_cursor_start_index_wasm = function () {
                  return (_ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm =
                    Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_end_index_wasm = (Module._ts_tree_cursor_end_index_wasm = function () {
                  return (_ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm =
                    Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_current_field_id_wasm = (Module._ts_tree_cursor_current_field_id_wasm = function () {
                  return (_ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm =
                    Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments)
                }),
                _ts_tree_cursor_current_node_wasm = (Module._ts_tree_cursor_current_node_wasm = function () {
                  return (_ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm =
                    Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments)
                }),
                _ts_node_symbol_wasm = (Module._ts_node_symbol_wasm = function () {
                  return (_ts_node_symbol_wasm = Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_node_child_count_wasm = (Module._ts_node_child_count_wasm = function () {
                  return (_ts_node_child_count_wasm = Module._ts_node_child_count_wasm =
                    Module.asm.ts_node_child_count_wasm).apply(null, arguments)
                }),
                _ts_node_named_child_count_wasm = (Module._ts_node_named_child_count_wasm = function () {
                  return (_ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm =
                    Module.asm.ts_node_named_child_count_wasm).apply(null, arguments)
                }),
                _ts_node_child_wasm = (Module._ts_node_child_wasm = function () {
                  return (_ts_node_child_wasm = Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_node_named_child_wasm = (Module._ts_node_named_child_wasm = function () {
                  return (_ts_node_named_child_wasm = Module._ts_node_named_child_wasm =
                    Module.asm.ts_node_named_child_wasm).apply(null, arguments)
                }),
                _ts_node_child_by_field_id_wasm = (Module._ts_node_child_by_field_id_wasm = function () {
                  return (_ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm =
                    Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments)
                }),
                _ts_node_next_sibling_wasm = (Module._ts_node_next_sibling_wasm = function () {
                  return (_ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm =
                    Module.asm.ts_node_next_sibling_wasm).apply(null, arguments)
                }),
                _ts_node_prev_sibling_wasm = (Module._ts_node_prev_sibling_wasm = function () {
                  return (_ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm =
                    Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments)
                }),
                _ts_node_next_named_sibling_wasm = (Module._ts_node_next_named_sibling_wasm = function () {
                  return (_ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm =
                    Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments)
                }),
                _ts_node_prev_named_sibling_wasm = (Module._ts_node_prev_named_sibling_wasm = function () {
                  return (_ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm =
                    Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments)
                }),
                _ts_node_parent_wasm = (Module._ts_node_parent_wasm = function () {
                  return (_ts_node_parent_wasm = Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(
                    null,
                    arguments
                  )
                }),
                _ts_node_descendant_for_index_wasm = (Module._ts_node_descendant_for_index_wasm = function () {
                  return (_ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm =
                    Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments)
                }),
                _ts_node_named_descendant_for_index_wasm = (Module._ts_node_named_descendant_for_index_wasm =
                  function () {
                    return (_ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm =
                      Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments)
                  }),
                _ts_node_descendant_for_position_wasm = (Module._ts_node_descendant_for_position_wasm = function () {
                  return (_ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm =
                    Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments)
                }),
                _ts_node_named_descendant_for_position_wasm = (Module._ts_node_named_descendant_for_position_wasm =
                  function () {
                    return (_ts_node_named_descendant_for_position_wasm =
                      Module._ts_node_named_descendant_for_position_wasm =
                        Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments)
                  }),
                _ts_node_start_point_wasm = (Module._ts_node_start_point_wasm = function () {
                  return (_ts_node_start_point_wasm = Module._ts_node_start_point_wasm =
                    Module.asm.ts_node_start_point_wasm).apply(null, arguments)
                }),
                _ts_node_end_point_wasm = (Module._ts_node_end_point_wasm = function () {
                  return (_ts_node_end_point_wasm = Module._ts_node_end_point_wasm =
                    Module.asm.ts_node_end_point_wasm).apply(null, arguments)
                }),
                _ts_node_start_index_wasm = (Module._ts_node_start_index_wasm = function () {
                  return (_ts_node_start_index_wasm = Module._ts_node_start_index_wasm =
                    Module.asm.ts_node_start_index_wasm).apply(null, arguments)
                }),
                _ts_node_end_index_wasm = (Module._ts_node_end_index_wasm = function () {
                  return (_ts_node_end_index_wasm = Module._ts_node_end_index_wasm =
                    Module.asm.ts_node_end_index_wasm).apply(null, arguments)
                }),
                _ts_node_to_string_wasm = (Module._ts_node_to_string_wasm = function () {
                  return (_ts_node_to_string_wasm = Module._ts_node_to_string_wasm =
                    Module.asm.ts_node_to_string_wasm).apply(null, arguments)
                }),
                _ts_node_children_wasm = (Module._ts_node_children_wasm = function () {
                  return (_ts_node_children_wasm = Module._ts_node_children_wasm =
                    Module.asm.ts_node_children_wasm).apply(null, arguments)
                }),
                _ts_node_named_children_wasm = (Module._ts_node_named_children_wasm = function () {
                  return (_ts_node_named_children_wasm = Module._ts_node_named_children_wasm =
                    Module.asm.ts_node_named_children_wasm).apply(null, arguments)
                }),
                _ts_node_descendants_of_type_wasm = (Module._ts_node_descendants_of_type_wasm = function () {
                  return (_ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm =
                    Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments)
                }),
                _ts_node_is_named_wasm = (Module._ts_node_is_named_wasm = function () {
                  return (_ts_node_is_named_wasm = Module._ts_node_is_named_wasm =
                    Module.asm.ts_node_is_named_wasm).apply(null, arguments)
                }),
                _ts_node_has_changes_wasm = (Module._ts_node_has_changes_wasm = function () {
                  return (_ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm =
                    Module.asm.ts_node_has_changes_wasm).apply(null, arguments)
                }),
                _ts_node_has_error_wasm = (Module._ts_node_has_error_wasm = function () {
                  return (_ts_node_has_error_wasm = Module._ts_node_has_error_wasm =
                    Module.asm.ts_node_has_error_wasm).apply(null, arguments)
                }),
                _ts_node_is_missing_wasm = (Module._ts_node_is_missing_wasm = function () {
                  return (_ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm =
                    Module.asm.ts_node_is_missing_wasm).apply(null, arguments)
                }),
                _ts_query_matches_wasm = (Module._ts_query_matches_wasm = function () {
                  return (_ts_query_matches_wasm = Module._ts_query_matches_wasm =
                    Module.asm.ts_query_matches_wasm).apply(null, arguments)
                }),
                _ts_query_captures_wasm = (Module._ts_query_captures_wasm = function () {
                  return (_ts_query_captures_wasm = Module._ts_query_captures_wasm =
                    Module.asm.ts_query_captures_wasm).apply(null, arguments)
                }),
                ___cxa_atexit = (Module.___cxa_atexit = function () {
                  return (___cxa_atexit = Module.___cxa_atexit = Module.asm.__cxa_atexit).apply(null, arguments)
                }),
                _iswdigit = (Module._iswdigit = function () {
                  return (_iswdigit = Module._iswdigit = Module.asm.iswdigit).apply(null, arguments)
                }),
                _iswalpha = (Module._iswalpha = function () {
                  return (_iswalpha = Module._iswalpha = Module.asm.iswalpha).apply(null, arguments)
                }),
                _iswlower = (Module._iswlower = function () {
                  return (_iswlower = Module._iswlower = Module.asm.iswlower).apply(null, arguments)
                }),
                _memchr = (Module._memchr = function () {
                  return (_memchr = Module._memchr = Module.asm.memchr).apply(null, arguments)
                }),
                _strlen = (Module._strlen = function () {
                  return (_strlen = Module._strlen = Module.asm.strlen).apply(null, arguments)
                }),
                _towupper = (Module._towupper = function () {
                  return (_towupper = Module._towupper = Module.asm.towupper).apply(null, arguments)
                }),
                _setThrew = (Module._setThrew = function () {
                  return (_setThrew = Module._setThrew = Module.asm.setThrew).apply(null, arguments)
                }),
                stackSave = (Module.stackSave = function () {
                  return (stackSave = Module.stackSave = Module.asm.stackSave).apply(null, arguments)
                }),
                stackRestore = (Module.stackRestore = function () {
                  return (stackRestore = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments)
                }),
                stackAlloc = (Module.stackAlloc = function () {
                  return (stackAlloc = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments)
                }),
                __Znwm = (Module.__Znwm = function () {
                  return (__Znwm = Module.__Znwm = Module.asm._Znwm).apply(null, arguments)
                }),
                __ZdlPv = (Module.__ZdlPv = function () {
                  return (__ZdlPv = Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments)
                }),
                __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =
                  (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =
                      Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =
                        Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =
                  (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =
                    function () {
                      return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =
                        Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =
                          Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(
                        null,
                        arguments
                      )
                    }),
                __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =
                  (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =
                      Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =
                        Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =
                  (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =
                      Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =
                        Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =
                  (Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {
                    return (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =
                      Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =
                        Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =
                  (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =
                      Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =
                        Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =
                  (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =
                      Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =
                        Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =
                  (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =
                      Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =
                        Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(
                      null,
                      arguments
                    )
                  }),
                __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw =
                  (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw =
                      Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw =
                        Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw).apply(
                      null,
                      arguments
                    )
                  }),
                dynCall_jiji = (Module.dynCall_jiji = function () {
                  return (dynCall_jiji = Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments)
                }),
                _orig$ts_parser_timeout_micros = (Module._orig$ts_parser_timeout_micros = function () {
                  return (_orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros =
                    Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments)
                }),
                _orig$ts_parser_set_timeout_micros = (Module._orig$ts_parser_set_timeout_micros = function () {
                  return (_orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros =
                    Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments)
                }),
                calledRun
              function callMain(t) {
                var e = Module._main
                if (e) {
                  ;(t = t || []).unshift(thisProgram)
                  var r = t.length,
                    n = stackAlloc(4 * (r + 1)),
                    i = n >> 2
                  t.forEach(s => {
                    HEAP32[i++] = allocateUTF8OnStack(s)
                  }),
                    (HEAP32[i] = 0)
                  try {
                    var o = e(r, n)
                    return exitJS(o, !0), o
                  } catch (s) {
                    return handleException(s)
                  }
                }
              }
              ;(Module.AsciiToString = AsciiToString),
                (Module.stringToUTF16 = stringToUTF16),
                (dependenciesFulfilled = function t() {
                  calledRun || run(), calledRun || (dependenciesFulfilled = t)
                })
              var dylibsLoaded = !1
              function run(t) {
                function e() {
                  calledRun ||
                    ((calledRun = !0),
                    (Module.calledRun = !0),
                    ABORT ||
                      (initRuntime(),
                      preMain(),
                      Module.onRuntimeInitialized && Module.onRuntimeInitialized(),
                      shouldRunNow && callMain(t),
                      postRun()))
                }
                ;(t = t || arguments_),
                  runDependencies > 0 ||
                    (!dylibsLoaded && (preloadDylibs(), (dylibsLoaded = !0), runDependencies > 0)) ||
                    (preRun(),
                    runDependencies > 0 ||
                      (Module.setStatus
                        ? (Module.setStatus('Running...'),
                          setTimeout(function () {
                            setTimeout(function () {
                              Module.setStatus('')
                            }, 1),
                              e()
                          }, 1))
                        : e()))
              }
              if (Module.preInit)
                for (
                  typeof Module.preInit == 'function' && (Module.preInit = [Module.preInit]);
                  Module.preInit.length > 0;

                )
                  Module.preInit.pop()()
              var shouldRunNow = !0
              Module.noInitialRun && (shouldRunNow = !1), run()
              let C = Module,
                INTERNAL = {},
                SIZE_OF_INT = 4,
                SIZE_OF_NODE = 5 * SIZE_OF_INT,
                SIZE_OF_POINT = 2 * SIZE_OF_INT,
                SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
                ZERO_POINT = { row: 0, column: 0 },
                QUERY_WORD_REGEX = /[\w-.]*/g,
                PREDICATE_STEP_TYPE_CAPTURE = 1,
                PREDICATE_STEP_TYPE_STRING = 2,
                LANGUAGE_FUNCTION_REGEX = /^_?tree_sitter_\w+/
              var VERSION, MIN_COMPATIBLE_VERSION, TRANSFER_BUFFER, currentParseCallback, currentLogCallback
              class ParserImpl {
                static init() {
                  ;(TRANSFER_BUFFER = C._ts_init()),
                    (VERSION = getValue(TRANSFER_BUFFER, 'i32')),
                    (MIN_COMPATIBLE_VERSION = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'))
                }
                initialize() {
                  C._ts_parser_new_wasm(),
                    (this[0] = getValue(TRANSFER_BUFFER, 'i32')),
                    (this[1] = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'))
                }
                delete() {
                  C._ts_parser_delete(this[0]), C._free(this[1]), (this[0] = 0), (this[1] = 0)
                }
                setLanguage(e) {
                  let r
                  if (e) {
                    if (e.constructor !== Language) throw new Error('Argument must be a Language')
                    {
                      r = e[0]
                      let n = C._ts_language_version(r)
                      if (n < MIN_COMPATIBLE_VERSION || VERSION < n)
                        throw new Error(
                          `Incompatible language version ${n}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${VERSION}.`
                        )
                    }
                  } else (r = 0), (e = null)
                  return (this.language = e), C._ts_parser_set_language(this[0], r), this
                }
                getLanguage() {
                  return this.language
                }
                parse(e, r, n) {
                  if (typeof e == 'string') currentParseCallback = (l, c, u) => e.slice(l, u)
                  else {
                    if (typeof e != 'function') throw new Error('Argument must be a string or a function')
                    currentParseCallback = e
                  }
                  this.logCallback
                    ? ((currentLogCallback = this.logCallback), C._ts_parser_enable_logger_wasm(this[0], 1))
                    : ((currentLogCallback = null), C._ts_parser_enable_logger_wasm(this[0], 0))
                  let i = 0,
                    o = 0
                  if (n && n.includedRanges) {
                    ;(i = n.includedRanges.length), (o = C._calloc(i, SIZE_OF_RANGE))
                    let l = o
                    for (let c = 0; c < i; c++) marshalRange(l, n.includedRanges[c]), (l += SIZE_OF_RANGE)
                  }
                  let s = C._ts_parser_parse_wasm(this[0], this[1], r ? r[0] : 0, o, i)
                  if (!s)
                    throw ((currentParseCallback = null), (currentLogCallback = null), new Error('Parsing failed'))
                  let a = new Tree(INTERNAL, s, this.language, currentParseCallback)
                  return (currentParseCallback = null), (currentLogCallback = null), a
                }
                reset() {
                  C._ts_parser_reset(this[0])
                }
                setTimeoutMicros(e) {
                  C._ts_parser_set_timeout_micros(this[0], e)
                }
                getTimeoutMicros() {
                  return C._ts_parser_timeout_micros(this[0])
                }
                setLogger(e) {
                  if (e) {
                    if (typeof e != 'function') throw new Error('Logger callback must be a function')
                  } else e = null
                  return (this.logCallback = e), this
                }
                getLogger() {
                  return this.logCallback
                }
              }
              class Tree {
                constructor(e, r, n, i) {
                  assertInternal(e), (this[0] = r), (this.language = n), (this.textCallback = i)
                }
                copy() {
                  let e = C._ts_tree_copy(this[0])
                  return new Tree(INTERNAL, e, this.language, this.textCallback)
                }
                delete() {
                  C._ts_tree_delete(this[0]), (this[0] = 0)
                }
                edit(e) {
                  marshalEdit(e), C._ts_tree_edit_wasm(this[0])
                }
                get rootNode() {
                  return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this)
                }
                getLanguage() {
                  return this.language
                }
                walk() {
                  return this.rootNode.walk()
                }
                getChangedRanges(e) {
                  if (e.constructor !== Tree) throw new TypeError('Argument must be a Tree')
                  C._ts_tree_get_changed_ranges_wasm(this[0], e[0])
                  let r = getValue(TRANSFER_BUFFER, 'i32'),
                    n = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'),
                    i = new Array(r)
                  if (r > 0) {
                    let o = n
                    for (let s = 0; s < r; s++) (i[s] = unmarshalRange(o)), (o += SIZE_OF_RANGE)
                    C._free(n)
                  }
                  return i
                }
              }
              class Node {
                constructor(e, r) {
                  assertInternal(e), (this.tree = r)
                }
                get typeId() {
                  return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0])
                }
                get type() {
                  return this.tree.language.types[this.typeId] || 'ERROR'
                }
                get endPosition() {
                  return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER)
                }
                get endIndex() {
                  return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0])
                }
                get text() {
                  return getText(this.tree, this.startIndex, this.endIndex)
                }
                isNamed() {
                  return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1
                }
                hasError() {
                  return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1
                }
                hasChanges() {
                  return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1
                }
                isMissing() {
                  return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1
                }
                equals(e) {
                  return this.id === e.id
                }
                child(e) {
                  return marshalNode(this), C._ts_node_child_wasm(this.tree[0], e), unmarshalNode(this.tree)
                }
                namedChild(e) {
                  return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], e), unmarshalNode(this.tree)
                }
                childForFieldId(e) {
                  return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], e), unmarshalNode(this.tree)
                }
                childForFieldName(e) {
                  let r = this.tree.language.fields.indexOf(e)
                  if (r !== -1) return this.childForFieldId(r)
                }
                get childCount() {
                  return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0])
                }
                get namedChildCount() {
                  return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0])
                }
                get firstChild() {
                  return this.child(0)
                }
                get firstNamedChild() {
                  return this.namedChild(0)
                }
                get lastChild() {
                  return this.child(this.childCount - 1)
                }
                get lastNamedChild() {
                  return this.namedChild(this.namedChildCount - 1)
                }
                get children() {
                  if (!this._children) {
                    marshalNode(this), C._ts_node_children_wasm(this.tree[0])
                    let e = getValue(TRANSFER_BUFFER, 'i32'),
                      r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32')
                    if (((this._children = new Array(e)), e > 0)) {
                      let n = r
                      for (let i = 0; i < e; i++) (this._children[i] = unmarshalNode(this.tree, n)), (n += SIZE_OF_NODE)
                      C._free(r)
                    }
                  }
                  return this._children
                }
                get namedChildren() {
                  if (!this._namedChildren) {
                    marshalNode(this), C._ts_node_named_children_wasm(this.tree[0])
                    let e = getValue(TRANSFER_BUFFER, 'i32'),
                      r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32')
                    if (((this._namedChildren = new Array(e)), e > 0)) {
                      let n = r
                      for (let i = 0; i < e; i++)
                        (this._namedChildren[i] = unmarshalNode(this.tree, n)), (n += SIZE_OF_NODE)
                      C._free(r)
                    }
                  }
                  return this._namedChildren
                }
                descendantsOfType(e, r, n) {
                  Array.isArray(e) || (e = [e]), r || (r = ZERO_POINT), n || (n = ZERO_POINT)
                  let i = [],
                    o = this.tree.language.types
                  for (let u = 0, p = o.length; u < p; u++) e.includes(o[u]) && i.push(u)
                  let s = C._malloc(SIZE_OF_INT * i.length)
                  for (let u = 0, p = i.length; u < p; u++) setValue(s + u * SIZE_OF_INT, i[u], 'i32')
                  marshalNode(this),
                    C._ts_node_descendants_of_type_wasm(this.tree[0], s, i.length, r.row, r.column, n.row, n.column)
                  let a = getValue(TRANSFER_BUFFER, 'i32'),
                    l = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'),
                    c = new Array(a)
                  if (a > 0) {
                    let u = l
                    for (let p = 0; p < a; p++) (c[p] = unmarshalNode(this.tree, u)), (u += SIZE_OF_NODE)
                  }
                  return C._free(l), C._free(s), c
                }
                get nextSibling() {
                  return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
                }
                get previousSibling() {
                  return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
                }
                get nextNamedSibling() {
                  return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
                }
                get previousNamedSibling() {
                  return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
                }
                get parent() {
                  return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree)
                }
                descendantForIndex(e, r = e) {
                  if (typeof e != 'number' || typeof r != 'number') throw new Error('Arguments must be numbers')
                  marshalNode(this)
                  let n = TRANSFER_BUFFER + SIZE_OF_NODE
                  return (
                    setValue(n, e, 'i32'),
                    setValue(n + SIZE_OF_INT, r, 'i32'),
                    C._ts_node_descendant_for_index_wasm(this.tree[0]),
                    unmarshalNode(this.tree)
                  )
                }
                namedDescendantForIndex(e, r = e) {
                  if (typeof e != 'number' || typeof r != 'number') throw new Error('Arguments must be numbers')
                  marshalNode(this)
                  let n = TRANSFER_BUFFER + SIZE_OF_NODE
                  return (
                    setValue(n, e, 'i32'),
                    setValue(n + SIZE_OF_INT, r, 'i32'),
                    C._ts_node_named_descendant_for_index_wasm(this.tree[0]),
                    unmarshalNode(this.tree)
                  )
                }
                descendantForPosition(e, r = e) {
                  if (!isPoint(e) || !isPoint(r)) throw new Error('Arguments must be {row, column} objects')
                  marshalNode(this)
                  let n = TRANSFER_BUFFER + SIZE_OF_NODE
                  return (
                    marshalPoint(n, e),
                    marshalPoint(n + SIZE_OF_POINT, r),
                    C._ts_node_descendant_for_position_wasm(this.tree[0]),
                    unmarshalNode(this.tree)
                  )
                }
                namedDescendantForPosition(e, r = e) {
                  if (!isPoint(e) || !isPoint(r)) throw new Error('Arguments must be {row, column} objects')
                  marshalNode(this)
                  let n = TRANSFER_BUFFER + SIZE_OF_NODE
                  return (
                    marshalPoint(n, e),
                    marshalPoint(n + SIZE_OF_POINT, r),
                    C._ts_node_named_descendant_for_position_wasm(this.tree[0]),
                    unmarshalNode(this.tree)
                  )
                }
                walk() {
                  return (
                    marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree)
                  )
                }
                toString() {
                  marshalNode(this)
                  let e = C._ts_node_to_string_wasm(this.tree[0]),
                    r = AsciiToString(e)
                  return C._free(e), r
                }
              }
              class TreeCursor {
                constructor(e, r) {
                  assertInternal(e), (this.tree = r), unmarshalTreeCursor(this)
                }
                delete() {
                  marshalTreeCursor(this),
                    C._ts_tree_cursor_delete_wasm(this.tree[0]),
                    (this[0] = this[1] = this[2] = 0)
                }
                reset(e) {
                  marshalNode(e),
                    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE),
                    C._ts_tree_cursor_reset_wasm(this.tree[0]),
                    unmarshalTreeCursor(this)
                }
                get nodeType() {
                  return this.tree.language.types[this.nodeTypeId] || 'ERROR'
                }
                get nodeTypeId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0])
                }
                get nodeId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0])
                }
                get nodeIsNamed() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1
                }
                get nodeIsMissing() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1
                }
                get nodeText() {
                  marshalTreeCursor(this)
                  let e = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
                    r = C._ts_tree_cursor_end_index_wasm(this.tree[0])
                  return getText(this.tree, e, r)
                }
                get startPosition() {
                  return (
                    marshalTreeCursor(this),
                    C._ts_tree_cursor_start_position_wasm(this.tree[0]),
                    unmarshalPoint(TRANSFER_BUFFER)
                  )
                }
                get endPosition() {
                  return (
                    marshalTreeCursor(this),
                    C._ts_tree_cursor_end_position_wasm(this.tree[0]),
                    unmarshalPoint(TRANSFER_BUFFER)
                  )
                }
                get startIndex() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0])
                }
                get endIndex() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0])
                }
                currentNode() {
                  return (
                    marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree)
                  )
                }
                currentFieldId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0])
                }
                currentFieldName() {
                  return this.tree.language.fields[this.currentFieldId()]
                }
                gotoFirstChild() {
                  marshalTreeCursor(this)
                  let e = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0])
                  return unmarshalTreeCursor(this), e === 1
                }
                gotoNextSibling() {
                  marshalTreeCursor(this)
                  let e = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0])
                  return unmarshalTreeCursor(this), e === 1
                }
                gotoParent() {
                  marshalTreeCursor(this)
                  let e = C._ts_tree_cursor_goto_parent_wasm(this.tree[0])
                  return unmarshalTreeCursor(this), e === 1
                }
              }
              class Language {
                constructor(e, r) {
                  assertInternal(e), (this[0] = r), (this.types = new Array(C._ts_language_symbol_count(this[0])))
                  for (let n = 0, i = this.types.length; n < i; n++)
                    C._ts_language_symbol_type(this[0], n) < 2 &&
                      (this.types[n] = UTF8ToString(C._ts_language_symbol_name(this[0], n)))
                  this.fields = new Array(C._ts_language_field_count(this[0]) + 1)
                  for (let n = 0, i = this.fields.length; n < i; n++) {
                    let o = C._ts_language_field_name_for_id(this[0], n)
                    this.fields[n] = o !== 0 ? UTF8ToString(o) : null
                  }
                }
                get version() {
                  return C._ts_language_version(this[0])
                }
                get fieldCount() {
                  return this.fields.length - 1
                }
                fieldIdForName(e) {
                  let r = this.fields.indexOf(e)
                  return r !== -1 ? r : null
                }
                fieldNameForId(e) {
                  return this.fields[e] || null
                }
                idForNodeType(e, r) {
                  let n = lengthBytesUTF8(e),
                    i = C._malloc(n + 1)
                  stringToUTF8(e, i, n + 1)
                  let o = C._ts_language_symbol_for_name(this[0], i, n, r)
                  return C._free(i), o || null
                }
                get nodeTypeCount() {
                  return C._ts_language_symbol_count(this[0])
                }
                nodeTypeForId(e) {
                  let r = C._ts_language_symbol_name(this[0], e)
                  return r ? UTF8ToString(r) : null
                }
                nodeTypeIsNamed(e) {
                  return !!C._ts_language_type_is_named_wasm(this[0], e)
                }
                nodeTypeIsVisible(e) {
                  return !!C._ts_language_type_is_visible_wasm(this[0], e)
                }
                query(e) {
                  let r = lengthBytesUTF8(e),
                    n = C._malloc(r + 1)
                  stringToUTF8(e, n, r + 1)
                  let i = C._ts_query_new(this[0], n, r, TRANSFER_BUFFER, TRANSFER_BUFFER + SIZE_OF_INT)
                  if (!i) {
                    let h = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'),
                      g = UTF8ToString(n, getValue(TRANSFER_BUFFER, 'i32')).length,
                      v = e.substr(g, 100).split(`
`)[0],
                      _,
                      y = v.match(QUERY_WORD_REGEX)[0]
                    switch (h) {
                      case 2:
                        _ = new RangeError(`Bad node name '${y}'`)
                        break
                      case 3:
                        _ = new RangeError(`Bad field name '${y}'`)
                        break
                      case 4:
                        _ = new RangeError(`Bad capture name @${y}`)
                        break
                      case 5:
                        ;(_ = new TypeError(`Bad pattern structure at offset ${g}: '${v}'...`)), (y = '')
                        break
                      default:
                        ;(_ = new SyntaxError(`Bad syntax at offset ${g}: '${v}'...`)), (y = '')
                    }
                    throw ((_.index = g), (_.length = y.length), C._free(n), _)
                  }
                  let o = C._ts_query_string_count(i),
                    s = C._ts_query_capture_count(i),
                    a = C._ts_query_pattern_count(i),
                    l = new Array(s),
                    c = new Array(o)
                  for (let h = 0; h < s; h++) {
                    let g = C._ts_query_capture_name_for_id(i, h, TRANSFER_BUFFER),
                      v = getValue(TRANSFER_BUFFER, 'i32')
                    l[h] = UTF8ToString(g, v)
                  }
                  for (let h = 0; h < o; h++) {
                    let g = C._ts_query_string_value_for_id(i, h, TRANSFER_BUFFER),
                      v = getValue(TRANSFER_BUFFER, 'i32')
                    c[h] = UTF8ToString(g, v)
                  }
                  let u = new Array(a),
                    p = new Array(a),
                    d = new Array(a),
                    f = new Array(a),
                    m = new Array(a)
                  for (let h = 0; h < a; h++) {
                    let g = C._ts_query_predicates_for_pattern(i, h, TRANSFER_BUFFER),
                      v = getValue(TRANSFER_BUFFER, 'i32')
                    ;(f[h] = []), (m[h] = [])
                    let _ = [],
                      y = g
                    for (let b = 0; b < v; b++) {
                      let x = getValue(y, 'i32')
                      y += SIZE_OF_INT
                      let P = getValue(y, 'i32')
                      if (((y += SIZE_OF_INT), x === PREDICATE_STEP_TYPE_CAPTURE))
                        _.push({ type: 'capture', name: l[P] })
                      else if (x === PREDICATE_STEP_TYPE_STRING) _.push({ type: 'string', value: c[P] })
                      else if (_.length > 0) {
                        if (_[0].type !== 'string') throw new Error('Predicates must begin with a literal value')
                        let U = _[0].value,
                          H = !0
                        switch (U) {
                          case 'not-eq?':
                            H = !1
                          case 'eq?':
                            if (_.length !== 3)
                              throw new Error(
                                'Wrong number of arguments to `#eq?` predicate. Expected 2, got ' + (_.length - 1)
                              )
                            if (_[1].type !== 'capture')
                              throw new Error(
                                `First argument of \`#eq?\` predicate must be a capture. Got "${_[1].value}"`
                              )
                            if (_[2].type === 'capture') {
                              let z = _[1].name,
                                q = _[2].name
                              m[h].push(function (L) {
                                let S, T
                                for (let A of L) A.name === z && (S = A.node), A.name === q && (T = A.node)
                                return S === void 0 || T === void 0 || (S.text === T.text) === H
                              })
                            } else {
                              let z = _[1].name,
                                q = _[2].value
                              m[h].push(function (L) {
                                for (let S of L) if (S.name === z) return (S.node.text === q) === H
                                return !0
                              })
                            }
                            break
                          case 'not-match?':
                            H = !1
                          case 'match?':
                            if (_.length !== 3)
                              throw new Error(
                                `Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${_.length - 1}.`
                              )
                            if (_[1].type !== 'capture')
                              throw new Error(
                                `First argument of \`#match?\` predicate must be a capture. Got "${_[1].value}".`
                              )
                            if (_[2].type !== 'string')
                              throw new Error(
                                `Second argument of \`#match?\` predicate must be a string. Got @${_[2].value}.`
                              )
                            let j = _[1].name,
                              M = new RegExp(_[2].value)
                            m[h].push(function (z) {
                              for (let q of z) if (q.name === j) return M.test(q.node.text) === H
                              return !0
                            })
                            break
                          case 'set!':
                            if (_.length < 2 || _.length > 3)
                              throw new Error(
                                `Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${
                                  _.length - 1
                                }.`
                              )
                            if (_.some(z => z.type !== 'string'))
                              throw new Error('Arguments to `#set!` predicate must be a strings.".')
                            u[h] || (u[h] = {}), (u[h][_[1].value] = _[2] ? _[2].value : null)
                            break
                          case 'is?':
                          case 'is-not?':
                            if (_.length < 2 || _.length > 3)
                              throw new Error(
                                `Wrong number of arguments to \`#${U}\` predicate. Expected 1 or 2. Got ${
                                  _.length - 1
                                }.`
                              )
                            if (_.some(z => z.type !== 'string'))
                              throw new Error(`Arguments to \`#${U}\` predicate must be a strings.".`)
                            let F = U === 'is?' ? p : d
                            F[h] || (F[h] = {}), (F[h][_[1].value] = _[2] ? _[2].value : null)
                            break
                          default:
                            f[h].push({ operator: U, operands: _.slice(1) })
                        }
                        _.length = 0
                      }
                    }
                    Object.freeze(u[h]), Object.freeze(p[h]), Object.freeze(d[h])
                  }
                  return (
                    C._free(n), new Query(INTERNAL, i, l, m, f, Object.freeze(u), Object.freeze(p), Object.freeze(d))
                  )
                }
                static load(e) {
                  let r
                  if (e instanceof Uint8Array) r = Promise.resolve(e)
                  else {
                    let i = e
                    if (typeof process < 'u' && process.versions && process.versions.node) {
                      let o = require('fs')
                      r = Promise.resolve(o.readFileSync(i))
                    } else
                      r = fetch(i).then(o =>
                        o.arrayBuffer().then(s => {
                          if (o.ok) return new Uint8Array(s)
                          {
                            let a = new TextDecoder('utf-8').decode(s)
                            throw new Error(`Language.load failed with status ${o.status}.

${a}`)
                          }
                        })
                      )
                  }
                  let n = typeof loadSideModule == 'function' ? loadSideModule : loadWebAssemblyModule
                  return r
                    .then(i => n(i, { loadAsync: !0 }))
                    .then(i => {
                      let o = Object.keys(i),
                        s = o.find(l => LANGUAGE_FUNCTION_REGEX.test(l) && !l.includes('external_scanner_'))
                      s ||
                        console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(o, null, 2)}`)
                      let a = i[s]()
                      return new Language(INTERNAL, a)
                    })
                }
              }
              class Query {
                constructor(e, r, n, i, o, s, a, l) {
                  assertInternal(e),
                    (this[0] = r),
                    (this.captureNames = n),
                    (this.textPredicates = i),
                    (this.predicates = o),
                    (this.setProperties = s),
                    (this.assertedProperties = a),
                    (this.refutedProperties = l),
                    (this.exceededMatchLimit = !1)
                }
                delete() {
                  C._ts_query_delete(this[0]), (this[0] = 0)
                }
                matches(e, r, n, i) {
                  r || (r = ZERO_POINT), n || (n = ZERO_POINT), i || (i = {})
                  let o = i.matchLimit
                  if (o === void 0) o = 0
                  else if (typeof o != 'number') throw new Error('Arguments must be numbers')
                  marshalNode(e), C._ts_query_matches_wasm(this[0], e.tree[0], r.row, r.column, n.row, n.column, o)
                  let s = getValue(TRANSFER_BUFFER, 'i32'),
                    a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'),
                    l = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32'),
                    c = new Array(s)
                  this.exceededMatchLimit = !!l
                  let u = 0,
                    p = a
                  for (let d = 0; d < s; d++) {
                    let f = getValue(p, 'i32')
                    p += SIZE_OF_INT
                    let m = getValue(p, 'i32')
                    p += SIZE_OF_INT
                    let h = new Array(m)
                    if (((p = unmarshalCaptures(this, e.tree, p, h)), this.textPredicates[f].every(g => g(h)))) {
                      c[u++] = { pattern: f, captures: h }
                      let g = this.setProperties[f]
                      g && (c[d].setProperties = g)
                      let v = this.assertedProperties[f]
                      v && (c[d].assertedProperties = v)
                      let _ = this.refutedProperties[f]
                      _ && (c[d].refutedProperties = _)
                    }
                  }
                  return (c.length = u), C._free(a), c
                }
                captures(e, r, n, i) {
                  r || (r = ZERO_POINT), n || (n = ZERO_POINT), i || (i = {})
                  let o = i.matchLimit
                  if (o === void 0) o = 0
                  else if (typeof o != 'number') throw new Error('Arguments must be numbers')
                  marshalNode(e), C._ts_query_captures_wasm(this[0], e.tree[0], r.row, r.column, n.row, n.column, o)
                  let s = getValue(TRANSFER_BUFFER, 'i32'),
                    a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, 'i32'),
                    l = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32'),
                    c = []
                  this.exceededMatchLimit = !!l
                  let u = [],
                    p = a
                  for (let d = 0; d < s; d++) {
                    let f = getValue(p, 'i32')
                    p += SIZE_OF_INT
                    let m = getValue(p, 'i32')
                    p += SIZE_OF_INT
                    let h = getValue(p, 'i32')
                    if (
                      ((p += SIZE_OF_INT),
                      (u.length = m),
                      (p = unmarshalCaptures(this, e.tree, p, u)),
                      this.textPredicates[f].every(g => g(u)))
                    ) {
                      let g = u[h],
                        v = this.setProperties[f]
                      v && (g.setProperties = v)
                      let _ = this.assertedProperties[f]
                      _ && (g.assertedProperties = _)
                      let y = this.refutedProperties[f]
                      y && (g.refutedProperties = y), c.push(g)
                    }
                  }
                  return C._free(a), c
                }
                predicatesForPattern(e) {
                  return this.predicates[e]
                }
                didExceedMatchLimit() {
                  return this.exceededMatchLimit
                }
              }
              function getText(t, e, r) {
                let n = r - e,
                  i = t.textCallback(e, null, r)
                for (e += i.length; e < r; ) {
                  let o = t.textCallback(e, null, r)
                  if (!(o && o.length > 0)) break
                  ;(e += o.length), (i += o)
                }
                return e > r && (i = i.slice(0, n)), i
              }
              function unmarshalCaptures(t, e, r, n) {
                for (let i = 0, o = n.length; i < o; i++) {
                  let s = getValue(r, 'i32'),
                    a = unmarshalNode(e, (r += SIZE_OF_INT))
                  ;(r += SIZE_OF_NODE), (n[i] = { name: t.captureNames[s], node: a })
                }
                return r
              }
              function assertInternal(t) {
                if (t !== INTERNAL) throw new Error('Illegal constructor')
              }
              function isPoint(t) {
                return t && typeof t.row == 'number' && typeof t.column == 'number'
              }
              function marshalNode(t) {
                let e = TRANSFER_BUFFER
                setValue(e, t.id, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t.startIndex, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t.startPosition.row, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t.startPosition.column, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t[0], 'i32')
              }
              function unmarshalNode(t, e = TRANSFER_BUFFER) {
                let r = getValue(e, 'i32')
                if (r === 0) return null
                let n = getValue((e += SIZE_OF_INT), 'i32'),
                  i = getValue((e += SIZE_OF_INT), 'i32'),
                  o = getValue((e += SIZE_OF_INT), 'i32'),
                  s = getValue((e += SIZE_OF_INT), 'i32'),
                  a = new Node(INTERNAL, t)
                return (a.id = r), (a.startIndex = n), (a.startPosition = { row: i, column: o }), (a[0] = s), a
              }
              function marshalTreeCursor(t, e = TRANSFER_BUFFER) {
                setValue(e + 0 * SIZE_OF_INT, t[0], 'i32'),
                  setValue(e + 1 * SIZE_OF_INT, t[1], 'i32'),
                  setValue(e + 2 * SIZE_OF_INT, t[2], 'i32')
              }
              function unmarshalTreeCursor(t) {
                ;(t[0] = getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, 'i32')),
                  (t[1] = getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, 'i32')),
                  (t[2] = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, 'i32'))
              }
              function marshalPoint(t, e) {
                setValue(t, e.row, 'i32'), setValue(t + SIZE_OF_INT, e.column, 'i32')
              }
              function unmarshalPoint(t) {
                return { row: getValue(t, 'i32'), column: getValue(t + SIZE_OF_INT, 'i32') }
              }
              function marshalRange(t, e) {
                marshalPoint(t, e.startPosition),
                  marshalPoint((t += SIZE_OF_POINT), e.endPosition),
                  setValue((t += SIZE_OF_POINT), e.startIndex, 'i32'),
                  setValue((t += SIZE_OF_INT), e.endIndex, 'i32'),
                  (t += SIZE_OF_INT)
              }
              function unmarshalRange(t) {
                let e = {}
                return (
                  (e.startPosition = unmarshalPoint(t)),
                  (t += SIZE_OF_POINT),
                  (e.endPosition = unmarshalPoint(t)),
                  (t += SIZE_OF_POINT),
                  (e.startIndex = getValue(t, 'i32')),
                  (t += SIZE_OF_INT),
                  (e.endIndex = getValue(t, 'i32')),
                  e
                )
              }
              function marshalEdit(t) {
                let e = TRANSFER_BUFFER
                marshalPoint(e, t.startPosition),
                  (e += SIZE_OF_POINT),
                  marshalPoint(e, t.oldEndPosition),
                  (e += SIZE_OF_POINT),
                  marshalPoint(e, t.newEndPosition),
                  (e += SIZE_OF_POINT),
                  setValue(e, t.startIndex, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t.oldEndIndex, 'i32'),
                  (e += SIZE_OF_INT),
                  setValue(e, t.newEndIndex, 'i32'),
                  (e += SIZE_OF_INT)
              }
              for (let t of Object.getOwnPropertyNames(ParserImpl.prototype))
                Object.defineProperty(Parser.prototype, t, {
                  value: ParserImpl.prototype[t],
                  enumerable: !1,
                  writable: !1,
                })
              ;(Parser.Language = Language),
                (Module.onRuntimeInitialized = () => {
                  ParserImpl.init(), resolveInitPromise()
                })
            })))
          )
        }
      }
      return Parser
    })()
  typeof exports == 'object' && (module.exports = TreeSitter)
})
var lb = handleExports((mrt, YK) => {
  'use strict'
  var uCe = require('path'),
    Cl = '\\\\/',
    zK = `[^${Cl}]`,
    rp = '\\.',
    pCe = '\\+',
    dCe = '\\?',
    ZI = '\\/',
    fCe = '(?=.)',
    $K = '[^/]',
    E5 = `(?:${ZI}|$)`,
    WK = `(?:^|${ZI})`,
    T5 = `${rp}{1,2}${E5}`,
    mCe = `(?!${rp})`,
    hCe = `(?!${WK}${T5})`,
    gCe = `(?!${rp}{0,1}${E5})`,
    vCe = `(?!${T5})`,
    _Ce = `[^.${ZI}]`,
    yCe = `${$K}*?`,
    KK = {
      DOT_LITERAL: rp,
      PLUS_LITERAL: pCe,
      QMARK_LITERAL: dCe,
      SLASH_LITERAL: ZI,
      ONE_CHAR: fCe,
      QMARK: $K,
      END_ANCHOR: E5,
      DOTS_SLASH: T5,
      NO_DOT: mCe,
      NO_DOTS: hCe,
      NO_DOT_SLASH: gCe,
      NO_DOTS_SLASH: vCe,
      QMARK_NO_DOT: _Ce,
      STAR: yCe,
      START_ANCHOR: WK,
    },
    xCe = {
      ...KK,
      SLASH_LITERAL: `[${Cl}]`,
      QMARK: zK,
      STAR: `${zK}*?`,
      DOTS_SLASH: `${rp}{1,2}(?:[${Cl}]|$)`,
      NO_DOT: `(?!${rp})`,
      NO_DOTS: `(?!(?:^|[${Cl}])${rp}{1,2}(?:[${Cl}]|$))`,
      NO_DOT_SLASH: `(?!${rp}{0,1}(?:[${Cl}]|$))`,
      NO_DOTS_SLASH: `(?!${rp}{1,2}(?:[${Cl}]|$))`,
      QMARK_NO_DOT: `[^.${Cl}]`,
      START_ANCHOR: `(?:^|[${Cl}])`,
      END_ANCHOR: `(?:[${Cl}]|$)`,
    },
    bCe = {
      alnum: 'a-zA-Z0-9',
      alpha: 'a-zA-Z',
      ascii: '\\x00-\\x7F',
      blank: ' \\t',
      cntrl: '\\x00-\\x1F\\x7F',
      digit: '0-9',
      graph: '\\x21-\\x7E',
      lower: 'a-z',
      print: '\\x20-\\x7E ',
      punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
      space: ' \\t\\r\\n\\v\\f',
      upper: 'A-Z',
      word: 'A-Za-z0-9_',
      xdigit: 'A-Fa-f0-9',
    }
  YK.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: bCe,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: { '***': '*', '**/**': '**', '**/**/**': '**' },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: uCe.sep,
    extglobChars(t) {
      return {
        '!': { type: 'negate', open: '(?:(?!(?:', close: `))${t.STAR})` },
        '?': { type: 'qmark', open: '(?:', close: ')?' },
        '+': { type: 'plus', open: '(?:', close: ')+' },
        '*': { type: 'star', open: '(?:', close: ')*' },
        '@': { type: 'at', open: '(?:', close: ')' },
      }
    },
    globChars(t) {
      return t === !0 ? xCe : KK
    },
  }
})
var ew = handleExports(vs => {
  'use strict'
  var ECe = require('path'),
    TCe = process.platform === 'win32',
    {
      REGEX_BACKSLASH: SCe,
      REGEX_REMOVE_BACKSLASH: CCe,
      REGEX_SPECIAL_CHARS: ICe,
      REGEX_SPECIAL_CHARS_GLOBAL: wCe,
    } = lb()
  vs.isObject = t => t !== null && typeof t == 'object' && !Array.isArray(t)
  vs.hasRegexChars = t => ICe.test(t)
  vs.isRegexChar = t => t.length === 1 && vs.hasRegexChars(t)
  vs.escapeRegex = t => t.replace(wCe, '\\$1')
  vs.toPosixSlashes = t => t.replace(SCe, '/')
  vs.removeBackslashes = t => t.replace(CCe, e => (e === '\\' ? '' : e))
  vs.supportsLookbehinds = () => {
    let t = process.version.slice(1).split('.').map(Number)
    return (t.length === 3 && t[0] >= 9) || (t[0] === 8 && t[1] >= 10)
  }
  vs.isWindows = t => (t && typeof t.windows == 'boolean' ? t.windows : TCe === !0 || ECe.sep === '\\')
  vs.escapeLast = (t, e, r) => {
    let n = t.lastIndexOf(e, r)
    return n === -1 ? t : t[n - 1] === '\\' ? vs.escapeLast(t, e, n - 1) : `${t.slice(0, n)}\\${t.slice(n)}`
  }
  vs.removePrefix = (t, e = {}) => {
    let r = t
    return r.startsWith('./') && ((r = r.slice(2)), (e.prefix = './')), r
  }
  vs.wrapOutput = (t, e = {}, r = {}) => {
    let n = r.contains ? '' : '^',
      i = r.contains ? '' : '$',
      o = `${n}(?:${t})${i}`
    return e.negated === !0 && (o = `(?:^(?!${o}).*$)`), o
  }
})
var nY = handleExports((grt, rY) => {
  'use strict'
  var QK = ew(),
    {
      CHAR_ASTERISK: S5,
      CHAR_AT: ACe,
      CHAR_BACKWARD_SLASH: ub,
      CHAR_COMMA: RCe,
      CHAR_DOT: C5,
      CHAR_EXCLAMATION_MARK: I5,
      CHAR_FORWARD_SLASH: tY,
      CHAR_LEFT_CURLY_BRACE: w5,
      CHAR_LEFT_PARENTHESES: A5,
      CHAR_LEFT_SQUARE_BRACKET: DCe,
      CHAR_PLUS: PCe,
      CHAR_QUESTION_MARK: XK,
      CHAR_RIGHT_CURLY_BRACE: NCe,
      CHAR_RIGHT_PARENTHESES: JK,
      CHAR_RIGHT_SQUARE_BRACKET: kCe,
    } = lb(),
    ZK = t => t === tY || t === ub,
    eY = t => {
      t.isPrefix !== !0 && (t.depth = t.isGlobstar ? 1 / 0 : 1)
    },
    OCe = (t, e) => {
      let r = e || {},
        n = t.length - 1,
        i = r.parts === !0 || r.scanToEnd === !0,
        o = [],
        s = [],
        a = [],
        l = t,
        c = -1,
        u = 0,
        p = 0,
        d = !1,
        f = !1,
        m = !1,
        h = !1,
        g = !1,
        v = !1,
        _ = !1,
        y = !1,
        b = !1,
        x = !1,
        P = 0,
        U,
        H,
        j = { value: '', depth: 0, isGlob: !1 },
        M = () => c >= n,
        F = () => l.charCodeAt(c + 1),
        z = () => ((U = H), l.charCodeAt(++c))
      for (; c < n; ) {
        H = z()
        let A
        if (H === ub) {
          ;(_ = j.backslashes = !0), (H = z()), H === w5 && (v = !0)
          continue
        }
        if (v === !0 || H === w5) {
          for (P++; M() !== !0 && (H = z()); ) {
            if (H === ub) {
              ;(_ = j.backslashes = !0), z()
              continue
            }
            if (H === w5) {
              P++
              continue
            }
            if (v !== !0 && H === C5 && (H = z()) === C5) {
              if (((d = j.isBrace = !0), (m = j.isGlob = !0), (x = !0), i === !0)) continue
              break
            }
            if (v !== !0 && H === RCe) {
              if (((d = j.isBrace = !0), (m = j.isGlob = !0), (x = !0), i === !0)) continue
              break
            }
            if (H === NCe && (P--, P === 0)) {
              ;(v = !1), (d = j.isBrace = !0), (x = !0)
              break
            }
          }
          if (i === !0) continue
          break
        }
        if (H === tY) {
          if ((o.push(c), s.push(j), (j = { value: '', depth: 0, isGlob: !1 }), x === !0)) continue
          if (U === C5 && c === u + 1) {
            u += 2
            continue
          }
          p = c + 1
          continue
        }
        if (r.noext !== !0 && (H === PCe || H === ACe || H === S5 || H === XK || H === I5) === !0 && F() === A5) {
          if (((m = j.isGlob = !0), (h = j.isExtglob = !0), (x = !0), H === I5 && c === u && (b = !0), i === !0)) {
            for (; M() !== !0 && (H = z()); ) {
              if (H === ub) {
                ;(_ = j.backslashes = !0), (H = z())
                continue
              }
              if (H === JK) {
                ;(m = j.isGlob = !0), (x = !0)
                break
              }
            }
            continue
          }
          break
        }
        if (H === S5) {
          if ((U === S5 && (g = j.isGlobstar = !0), (m = j.isGlob = !0), (x = !0), i === !0)) continue
          break
        }
        if (H === XK) {
          if (((m = j.isGlob = !0), (x = !0), i === !0)) continue
          break
        }
        if (H === DCe) {
          for (; M() !== !0 && (A = z()); ) {
            if (A === ub) {
              ;(_ = j.backslashes = !0), z()
              continue
            }
            if (A === kCe) {
              ;(f = j.isBracket = !0), (m = j.isGlob = !0), (x = !0)
              break
            }
          }
          if (i === !0) continue
          break
        }
        if (r.nonegate !== !0 && H === I5 && c === u) {
          ;(y = j.negated = !0), u++
          continue
        }
        if (r.noparen !== !0 && H === A5) {
          if (((m = j.isGlob = !0), i === !0)) {
            for (; M() !== !0 && (H = z()); ) {
              if (H === A5) {
                ;(_ = j.backslashes = !0), (H = z())
                continue
              }
              if (H === JK) {
                x = !0
                break
              }
            }
            continue
          }
          break
        }
        if (m === !0) {
          if (((x = !0), i === !0)) continue
          break
        }
      }
      r.noext === !0 && ((h = !1), (m = !1))
      let q = l,
        L = '',
        S = ''
      u > 0 && ((L = l.slice(0, u)), (l = l.slice(u)), (p -= u)),
        q && m === !0 && p > 0 ? ((q = l.slice(0, p)), (S = l.slice(p))) : m === !0 ? ((q = ''), (S = l)) : (q = l),
        q && q !== '' && q !== '/' && q !== l && ZK(q.charCodeAt(q.length - 1)) && (q = q.slice(0, -1)),
        r.unescape === !0 && (S && (S = QK.removeBackslashes(S)), q && _ === !0 && (q = QK.removeBackslashes(q)))
      let T = {
        prefix: L,
        input: t,
        start: u,
        base: q,
        glob: S,
        isBrace: d,
        isBracket: f,
        isGlob: m,
        isExtglob: h,
        isGlobstar: g,
        negated: y,
        negatedExtglob: b,
      }
      if (
        (r.tokens === !0 && ((T.maxDepth = 0), ZK(H) || s.push(j), (T.tokens = s)), r.parts === !0 || r.tokens === !0)
      ) {
        let A
        for (let X = 0; X < o.length; X++) {
          let fe = A ? A + 1 : u,
            ce = o[X],
            oe = t.slice(fe, ce)
          r.tokens &&
            (X === 0 && u !== 0 ? ((s[X].isPrefix = !0), (s[X].value = L)) : (s[X].value = oe),
            eY(s[X]),
            (T.maxDepth += s[X].depth)),
            (X !== 0 || oe !== '') && a.push(oe),
            (A = ce)
        }
        if (A && A + 1 < t.length) {
          let X = t.slice(A + 1)
          a.push(X),
            r.tokens && ((s[s.length - 1].value = X), eY(s[s.length - 1]), (T.maxDepth += s[s.length - 1].depth))
        }
        ;(T.slashes = o), (T.parts = a)
      }
      return T
    }
  rY.exports = OCe
})
var sY = handleExports((vrt, oY) => {
  'use strict'
  var tw = lb(),
    na = ew(),
    {
      MAX_LENGTH: rw,
      POSIX_REGEX_SOURCE: LCe,
      REGEX_NON_SPECIAL_CHARS: MCe,
      REGEX_SPECIAL_CHARS_BACKREF: FCe,
      REPLACEMENTS: iY,
    } = tw,
    UCe = (t, e) => {
      if (typeof e.expandRange == 'function') return e.expandRange(...t, e)
      t.sort()
      let r = `[${t.join('-')}]`
      try {
        new RegExp(r)
      } catch {
        return t.map(i => na.escapeRegex(i)).join('..')
      }
      return r
    },
    V0 = (t, e) => `Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`,
    R5 = (t, e) => {
      if (typeof t != 'string') throw new TypeError('Expected a string')
      t = iY[t] || t
      let r = { ...e },
        n = typeof r.maxLength == 'number' ? Math.min(rw, r.maxLength) : rw,
        i = t.length
      if (i > n) throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`)
      let o = { type: 'bos', value: '', output: r.prepend || '' },
        s = [o],
        a = r.capture ? '' : '?:',
        l = na.isWindows(e),
        c = tw.globChars(l),
        u = tw.extglobChars(c),
        {
          DOT_LITERAL: p,
          PLUS_LITERAL: d,
          SLASH_LITERAL: f,
          ONE_CHAR: m,
          DOTS_SLASH: h,
          NO_DOT: g,
          NO_DOT_SLASH: v,
          NO_DOTS_SLASH: _,
          QMARK: y,
          QMARK_NO_DOT: b,
          STAR: x,
          START_ANCHOR: P,
        } = c,
        U = ve => `(${a}(?:(?!${P}${ve.dot ? h : p}).)*?)`,
        H = r.dot ? '' : g,
        j = r.dot ? y : b,
        M = r.bash === !0 ? U(r) : x
      r.capture && (M = `(${M})`), typeof r.noext == 'boolean' && (r.noextglob = r.noext)
      let F = {
        input: t,
        index: -1,
        start: 0,
        dot: r.dot === !0,
        consumed: '',
        output: '',
        prefix: '',
        backtrack: !1,
        negated: !1,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: !1,
        tokens: s,
      }
      ;(t = na.removePrefix(t, F)), (i = t.length)
      let z = [],
        q = [],
        L = [],
        S = o,
        T,
        A = () => F.index === i - 1,
        X = (F.peek = (ve = 1) => t[F.index + ve]),
        fe = (F.advance = () => t[++F.index] || ''),
        ce = () => t.slice(F.index + 1),
        oe = (ve = '', W = 0) => {
          ;(F.consumed += ve), (F.index += W)
        },
        ae = ve => {
          ;(F.output += ve.output != null ? ve.output : ve.value), oe(ve.value)
        },
        je = () => {
          let ve = 1
          for (; X() === '!' && (X(2) !== '(' || X(3) === '?'); ) fe(), F.start++, ve++
          return ve % 2 === 0 ? !1 : ((F.negated = !0), F.start++, !0)
        },
        Ye = ve => {
          F[ve]++, L.push(ve)
        },
        Ze = ve => {
          F[ve]--, L.pop()
        },
        ke = ve => {
          if (S.type === 'globstar') {
            let W = F.braces > 0 && (ve.type === 'comma' || ve.type === 'brace'),
              ne = ve.extglob === !0 || (z.length && (ve.type === 'pipe' || ve.type === 'paren'))
            ve.type !== 'slash' &&
              ve.type !== 'paren' &&
              !W &&
              !ne &&
              ((F.output = F.output.slice(0, -S.output.length)),
              (S.type = 'star'),
              (S.value = '*'),
              (S.output = M),
              (F.output += S.output))
          }
          if (
            (z.length && ve.type !== 'paren' && (z[z.length - 1].inner += ve.value),
            (ve.value || ve.output) && ae(ve),
            S && S.type === 'text' && ve.type === 'text')
          ) {
            ;(S.value += ve.value), (S.output = (S.output || '') + ve.value)
            return
          }
          ;(ve.prev = S), s.push(ve), (S = ve)
        },
        st = (ve, W) => {
          let ne = { ...u[W], conditions: 1, inner: '' }
          ;(ne.prev = S), (ne.parens = F.parens), (ne.output = F.output)
          let ye = (r.capture ? '(' : '') + ne.open
          Ye('parens'),
            ke({ type: ve, value: W, output: F.output ? '' : m }),
            ke({ type: 'paren', extglob: !0, value: fe(), output: ye }),
            z.push(ne)
        },
        tt = ve => {
          let W = ve.close + (r.capture ? ')' : ''),
            ne
          if (ve.type === 'negate') {
            let ye = M
            if (
              (ve.inner && ve.inner.length > 1 && ve.inner.includes('/') && (ye = U(r)),
              (ye !== M || A() || /^\)+$/.test(ce())) && (W = ve.close = `)$))${ye}`),
              ve.inner.includes('*') && (ne = ce()) && /^\.[^\\/.]+$/.test(ne))
            ) {
              let Te = R5(ne, { ...e, fastpaths: !1 }).output
              W = ve.close = `)${Te})${ye})`
            }
            ve.prev.type === 'bos' && (F.negatedExtglob = !0)
          }
          ke({ type: 'paren', extglob: !0, value: T, output: W }), Ze('parens')
        }
      if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(t)) {
        let ve = !1,
          W = t.replace(FCe, (ne, ye, Te, Ne, qe, bt) =>
            Ne === '\\'
              ? ((ve = !0), ne)
              : Ne === '?'
              ? ye
                ? ye + Ne + (qe ? y.repeat(qe.length) : '')
                : bt === 0
                ? j + (qe ? y.repeat(qe.length) : '')
                : y.repeat(Te.length)
              : Ne === '.'
              ? p.repeat(Te.length)
              : Ne === '*'
              ? ye
                ? ye + Ne + (qe ? M : '')
                : M
              : ye
              ? ne
              : `\\${ne}`
          )
        return (
          ve === !0 &&
            (r.unescape === !0
              ? (W = W.replace(/\\/g, ''))
              : (W = W.replace(/\\+/g, ne => (ne.length % 2 === 0 ? '\\\\' : ne ? '\\' : '')))),
          W === t && r.contains === !0 ? ((F.output = t), F) : ((F.output = na.wrapOutput(W, F, e)), F)
        )
      }
      for (; !A(); ) {
        if (((T = fe()), T === '\0')) continue
        if (T === '\\') {
          let ne = X()
          if ((ne === '/' && r.bash !== !0) || ne === '.' || ne === ';') continue
          if (!ne) {
            ;(T += '\\'), ke({ type: 'text', value: T })
            continue
          }
          let ye = /^\\+/.exec(ce()),
            Te = 0
          if (
            (ye && ye[0].length > 2 && ((Te = ye[0].length), (F.index += Te), Te % 2 !== 0 && (T += '\\')),
            r.unescape === !0 ? (T = fe()) : (T += fe()),
            F.brackets === 0)
          ) {
            ke({ type: 'text', value: T })
            continue
          }
        }
        if (F.brackets > 0 && (T !== ']' || S.value === '[' || S.value === '[^')) {
          if (r.posix !== !1 && T === ':') {
            let ne = S.value.slice(1)
            if (ne.includes('[') && ((S.posix = !0), ne.includes(':'))) {
              let ye = S.value.lastIndexOf('['),
                Te = S.value.slice(0, ye),
                Ne = S.value.slice(ye + 2),
                qe = LCe[Ne]
              if (qe) {
                ;(S.value = Te + qe), (F.backtrack = !0), fe(), !o.output && s.indexOf(S) === 1 && (o.output = m)
                continue
              }
            }
          }
          ;((T === '[' && X() !== ':') || (T === '-' && X() === ']')) && (T = `\\${T}`),
            T === ']' && (S.value === '[' || S.value === '[^') && (T = `\\${T}`),
            r.posix === !0 && T === '!' && S.value === '[' && (T = '^'),
            (S.value += T),
            ae({ value: T })
          continue
        }
        if (F.quotes === 1 && T !== '"') {
          ;(T = na.escapeRegex(T)), (S.value += T), ae({ value: T })
          continue
        }
        if (T === '"') {
          ;(F.quotes = F.quotes === 1 ? 0 : 1), r.keepQuotes === !0 && ke({ type: 'text', value: T })
          continue
        }
        if (T === '(') {
          Ye('parens'), ke({ type: 'paren', value: T })
          continue
        }
        if (T === ')') {
          if (F.parens === 0 && r.strictBrackets === !0) throw new SyntaxError(V0('opening', '('))
          let ne = z[z.length - 1]
          if (ne && F.parens === ne.parens + 1) {
            tt(z.pop())
            continue
          }
          ke({ type: 'paren', value: T, output: F.parens ? ')' : '\\)' }), Ze('parens')
          continue
        }
        if (T === '[') {
          if (r.nobracket === !0 || !ce().includes(']')) {
            if (r.nobracket !== !0 && r.strictBrackets === !0) throw new SyntaxError(V0('closing', ']'))
            T = `\\${T}`
          } else Ye('brackets')
          ke({ type: 'bracket', value: T })
          continue
        }
        if (T === ']') {
          if (r.nobracket === !0 || (S && S.type === 'bracket' && S.value.length === 1)) {
            ke({ type: 'text', value: T, output: `\\${T}` })
            continue
          }
          if (F.brackets === 0) {
            if (r.strictBrackets === !0) throw new SyntaxError(V0('opening', '['))
            ke({ type: 'text', value: T, output: `\\${T}` })
            continue
          }
          Ze('brackets')
          let ne = S.value.slice(1)
          if (
            (S.posix !== !0 && ne[0] === '^' && !ne.includes('/') && (T = `/${T}`),
            (S.value += T),
            ae({ value: T }),
            r.literalBrackets === !1 || na.hasRegexChars(ne))
          )
            continue
          let ye = na.escapeRegex(S.value)
          if (((F.output = F.output.slice(0, -S.value.length)), r.literalBrackets === !0)) {
            ;(F.output += ye), (S.value = ye)
            continue
          }
          ;(S.value = `(${a}${ye}|${S.value})`), (F.output += S.value)
          continue
        }
        if (T === '{' && r.nobrace !== !0) {
          Ye('braces')
          let ne = { type: 'brace', value: T, output: '(', outputIndex: F.output.length, tokensIndex: F.tokens.length }
          q.push(ne), ke(ne)
          continue
        }
        if (T === '}') {
          let ne = q[q.length - 1]
          if (r.nobrace === !0 || !ne) {
            ke({ type: 'text', value: T, output: T })
            continue
          }
          let ye = ')'
          if (ne.dots === !0) {
            let Te = s.slice(),
              Ne = []
            for (let qe = Te.length - 1; qe >= 0 && (s.pop(), Te[qe].type !== 'brace'); qe--)
              Te[qe].type !== 'dots' && Ne.unshift(Te[qe].value)
            ;(ye = UCe(Ne, r)), (F.backtrack = !0)
          }
          if (ne.comma !== !0 && ne.dots !== !0) {
            let Te = F.output.slice(0, ne.outputIndex),
              Ne = F.tokens.slice(ne.tokensIndex)
            ;(ne.value = ne.output = '\\{'), (T = ye = '\\}'), (F.output = Te)
            for (let qe of Ne) F.output += qe.output || qe.value
          }
          ke({ type: 'brace', value: T, output: ye }), Ze('braces'), q.pop()
          continue
        }
        if (T === '|') {
          z.length > 0 && z[z.length - 1].conditions++, ke({ type: 'text', value: T })
          continue
        }
        if (T === ',') {
          let ne = T,
            ye = q[q.length - 1]
          ye && L[L.length - 1] === 'braces' && ((ye.comma = !0), (ne = '|')),
            ke({ type: 'comma', value: T, output: ne })
          continue
        }
        if (T === '/') {
          if (S.type === 'dot' && F.index === F.start + 1) {
            ;(F.start = F.index + 1), (F.consumed = ''), (F.output = ''), s.pop(), (S = o)
            continue
          }
          ke({ type: 'slash', value: T, output: f })
          continue
        }
        if (T === '.') {
          if (F.braces > 0 && S.type === 'dot') {
            S.value === '.' && (S.output = p)
            let ne = q[q.length - 1]
            ;(S.type = 'dots'), (S.output += T), (S.value += T), (ne.dots = !0)
            continue
          }
          if (F.braces + F.parens === 0 && S.type !== 'bos' && S.type !== 'slash') {
            ke({ type: 'text', value: T, output: p })
            continue
          }
          ke({ type: 'dot', value: T, output: p })
          continue
        }
        if (T === '?') {
          if (!(S && S.value === '(') && r.noextglob !== !0 && X() === '(' && X(2) !== '?') {
            st('qmark', T)
            continue
          }
          if (S && S.type === 'paren') {
            let ye = X(),
              Te = T
            if (ye === '<' && !na.supportsLookbehinds())
              throw new Error('Node.js v10 or higher is required for regex lookbehinds')
            ;((S.value === '(' && !/[!=<:]/.test(ye)) || (ye === '<' && !/<([!=]|\w+>)/.test(ce()))) && (Te = `\\${T}`),
              ke({ type: 'text', value: T, output: Te })
            continue
          }
          if (r.dot !== !0 && (S.type === 'slash' || S.type === 'bos')) {
            ke({ type: 'qmark', value: T, output: b })
            continue
          }
          ke({ type: 'qmark', value: T, output: y })
          continue
        }
        if (T === '!') {
          if (r.noextglob !== !0 && X() === '(' && (X(2) !== '?' || !/[!=<:]/.test(X(3)))) {
            st('negate', T)
            continue
          }
          if (r.nonegate !== !0 && F.index === 0) {
            je()
            continue
          }
        }
        if (T === '+') {
          if (r.noextglob !== !0 && X() === '(' && X(2) !== '?') {
            st('plus', T)
            continue
          }
          if ((S && S.value === '(') || r.regex === !1) {
            ke({ type: 'plus', value: T, output: d })
            continue
          }
          if ((S && (S.type === 'bracket' || S.type === 'paren' || S.type === 'brace')) || F.parens > 0) {
            ke({ type: 'plus', value: T })
            continue
          }
          ke({ type: 'plus', value: d })
          continue
        }
        if (T === '@') {
          if (r.noextglob !== !0 && X() === '(' && X(2) !== '?') {
            ke({ type: 'at', extglob: !0, value: T, output: '' })
            continue
          }
          ke({ type: 'text', value: T })
          continue
        }
        if (T !== '*') {
          ;(T === '$' || T === '^') && (T = `\\${T}`)
          let ne = MCe.exec(ce())
          ne && ((T += ne[0]), (F.index += ne[0].length)), ke({ type: 'text', value: T })
          continue
        }
        if (S && (S.type === 'globstar' || S.star === !0)) {
          ;(S.type = 'star'),
            (S.star = !0),
            (S.value += T),
            (S.output = M),
            (F.backtrack = !0),
            (F.globstar = !0),
            oe(T)
          continue
        }
        let ve = ce()
        if (r.noextglob !== !0 && /^\([^?]/.test(ve)) {
          st('star', T)
          continue
        }
        if (S.type === 'star') {
          if (r.noglobstar === !0) {
            oe(T)
            continue
          }
          let ne = S.prev,
            ye = ne.prev,
            Te = ne.type === 'slash' || ne.type === 'bos',
            Ne = ye && (ye.type === 'star' || ye.type === 'globstar')
          if (r.bash === !0 && (!Te || (ve[0] && ve[0] !== '/'))) {
            ke({ type: 'star', value: T, output: '' })
            continue
          }
          let qe = F.braces > 0 && (ne.type === 'comma' || ne.type === 'brace'),
            bt = z.length && (ne.type === 'pipe' || ne.type === 'paren')
          if (!Te && ne.type !== 'paren' && !qe && !bt) {
            ke({ type: 'star', value: T, output: '' })
            continue
          }
          for (; ve.slice(0, 3) === '/**'; ) {
            let Jt = t[F.index + 4]
            if (Jt && Jt !== '/') break
            ;(ve = ve.slice(3)), oe('/**', 3)
          }
          if (ne.type === 'bos' && A()) {
            ;(S.type = 'globstar'), (S.value += T), (S.output = U(r)), (F.output = S.output), (F.globstar = !0), oe(T)
            continue
          }
          if (ne.type === 'slash' && ne.prev.type !== 'bos' && !Ne && A()) {
            ;(F.output = F.output.slice(0, -(ne.output + S.output).length)),
              (ne.output = `(?:${ne.output}`),
              (S.type = 'globstar'),
              (S.output = U(r) + (r.strictSlashes ? ')' : '|$)')),
              (S.value += T),
              (F.globstar = !0),
              (F.output += ne.output + S.output),
              oe(T)
            continue
          }
          if (ne.type === 'slash' && ne.prev.type !== 'bos' && ve[0] === '/') {
            let Jt = ve[1] !== void 0 ? '|$' : ''
            ;(F.output = F.output.slice(0, -(ne.output + S.output).length)),
              (ne.output = `(?:${ne.output}`),
              (S.type = 'globstar'),
              (S.output = `${U(r)}${f}|${f}${Jt})`),
              (S.value += T),
              (F.output += ne.output + S.output),
              (F.globstar = !0),
              oe(T + fe()),
              ke({ type: 'slash', value: '/', output: '' })
            continue
          }
          if (ne.type === 'bos' && ve[0] === '/') {
            ;(S.type = 'globstar'),
              (S.value += T),
              (S.output = `(?:^|${f}|${U(r)}${f})`),
              (F.output = S.output),
              (F.globstar = !0),
              oe(T + fe()),
              ke({ type: 'slash', value: '/', output: '' })
            continue
          }
          ;(F.output = F.output.slice(0, -S.output.length)),
            (S.type = 'globstar'),
            (S.output = U(r)),
            (S.value += T),
            (F.output += S.output),
            (F.globstar = !0),
            oe(T)
          continue
        }
        let W = { type: 'star', value: T, output: M }
        if (r.bash === !0) {
          ;(W.output = '.*?'), (S.type === 'bos' || S.type === 'slash') && (W.output = H + W.output), ke(W)
          continue
        }
        if (S && (S.type === 'bracket' || S.type === 'paren') && r.regex === !0) {
          ;(W.output = T), ke(W)
          continue
        }
        ;(F.index === F.start || S.type === 'slash' || S.type === 'dot') &&
          (S.type === 'dot'
            ? ((F.output += v), (S.output += v))
            : r.dot === !0
            ? ((F.output += _), (S.output += _))
            : ((F.output += H), (S.output += H)),
          X() !== '*' && ((F.output += m), (S.output += m))),
          ke(W)
      }
      for (; F.brackets > 0; ) {
        if (r.strictBrackets === !0) throw new SyntaxError(V0('closing', ']'))
        ;(F.output = na.escapeLast(F.output, '[')), Ze('brackets')
      }
      for (; F.parens > 0; ) {
        if (r.strictBrackets === !0) throw new SyntaxError(V0('closing', ')'))
        ;(F.output = na.escapeLast(F.output, '(')), Ze('parens')
      }
      for (; F.braces > 0; ) {
        if (r.strictBrackets === !0) throw new SyntaxError(V0('closing', '}'))
        ;(F.output = na.escapeLast(F.output, '{')), Ze('braces')
      }
      if (
        (r.strictSlashes !== !0 &&
          (S.type === 'star' || S.type === 'bracket') &&
          ke({ type: 'maybe_slash', value: '', output: `${f}?` }),
        F.backtrack === !0)
      ) {
        F.output = ''
        for (let ve of F.tokens)
          (F.output += ve.output != null ? ve.output : ve.value), ve.suffix && (F.output += ve.suffix)
      }
      return F
    }
  R5.fastpaths = (t, e) => {
    let r = { ...e },
      n = typeof r.maxLength == 'number' ? Math.min(rw, r.maxLength) : rw,
      i = t.length
    if (i > n) throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`)
    t = iY[t] || t
    let o = na.isWindows(e),
      {
        DOT_LITERAL: s,
        SLASH_LITERAL: a,
        ONE_CHAR: l,
        DOTS_SLASH: c,
        NO_DOT: u,
        NO_DOTS: p,
        NO_DOTS_SLASH: d,
        STAR: f,
        START_ANCHOR: m,
      } = tw.globChars(o),
      h = r.dot ? p : u,
      g = r.dot ? d : u,
      v = r.capture ? '' : '?:',
      _ = { negated: !1, prefix: '' },
      y = r.bash === !0 ? '.*?' : f
    r.capture && (y = `(${y})`)
    let b = H => (H.noglobstar === !0 ? y : `(${v}(?:(?!${m}${H.dot ? c : s}).)*?)`),
      x = H => {
        switch (H) {
          case '*':
            return `${h}${l}${y}`
          case '.*':
            return `${s}${l}${y}`
          case '*.*':
            return `${h}${y}${s}${l}${y}`
          case '*/*':
            return `${h}${y}${a}${l}${g}${y}`
          case '**':
            return h + b(r)
          case '**/*':
            return `(?:${h}${b(r)}${a})?${g}${l}${y}`
          case '**/*.*':
            return `(?:${h}${b(r)}${a})?${g}${y}${s}${l}${y}`
          case '**/.*':
            return `(?:${h}${b(r)}${a})?${s}${l}${y}`
          default: {
            let j = /^(.*?)\.(\w+)$/.exec(H)
            if (!j) return
            let M = x(j[1])
            return M ? M + s + j[2] : void 0
          }
        }
      },
      P = na.removePrefix(t, _),
      U = x(P)
    return U && r.strictSlashes !== !0 && (U += `${a}?`), U
  }
  oY.exports = R5
})
var patternMatcher = handleExports((_rt, aY) => {
  'use strict'
  var BCe = require('path'),
    qCe = nY(),
    D5 = sY(),
    P5 = ew(),
    HCe = lb(),
    jCe = t => t && typeof t == 'object' && !Array.isArray(t),
    Gn = (t, e, r = !1) => {
      if (Array.isArray(t)) {
        let u = t.map(d => Gn(d, e, r))
        return d => {
          for (let f of u) {
            let m = f(d)
            if (m) return m
          }
          return !1
        }
      }
      let n = jCe(t) && t.tokens && t.input
      if (t === '' || (typeof t != 'string' && !n)) throw new TypeError('Expected pattern to be a non-empty string')
      let i = e || {},
        o = P5.isWindows(e),
        s = n ? Gn.compileRe(t, e) : Gn.makeRe(t, e, !1, !0),
        a = s.state
      delete s.state
      let l = () => !1
      if (i.ignore) {
        let u = { ...e, ignore: null, onMatch: null, onResult: null }
        l = Gn(i.ignore, u, r)
      }
      let c = (u, p = !1) => {
        let { isMatch: d, match: f, output: m } = Gn.test(u, s, e, { glob: t, posix: o }),
          h = { glob: t, state: a, regex: s, posix: o, input: u, output: m, match: f, isMatch: d }
        return (
          typeof i.onResult == 'function' && i.onResult(h),
          d === !1
            ? ((h.isMatch = !1), p ? h : !1)
            : l(u)
            ? (typeof i.onIgnore == 'function' && i.onIgnore(h), (h.isMatch = !1), p ? h : !1)
            : (typeof i.onMatch == 'function' && i.onMatch(h), p ? h : !0)
        )
      }
      return r && (c.state = a), c
    }
  Gn.test = (t, e, r, { glob: n, posix: i } = {}) => {
    if (typeof t != 'string') throw new TypeError('Expected input to be a string')
    if (t === '') return { isMatch: !1, output: '' }
    let o = r || {},
      s = o.format || (i ? P5.toPosixSlashes : null),
      a = t === n,
      l = a && s ? s(t) : t
    return (
      a === !1 && ((l = s ? s(t) : t), (a = l === n)),
      (a === !1 || o.capture === !0) &&
        (o.matchBase === !0 || o.basename === !0 ? (a = Gn.matchBase(t, e, r, i)) : (a = e.exec(l))),
      { isMatch: !!a, match: a, output: l }
    )
  }
  Gn.matchBase = (t, e, r, n = P5.isWindows(r)) => (e instanceof RegExp ? e : Gn.makeRe(e, r)).test(BCe.basename(t))
  Gn.isMatch = (t, e, r) => Gn(e, r)(t)
  Gn.parse = (t, e) => (Array.isArray(t) ? t.map(r => Gn.parse(r, e)) : D5(t, { ...e, fastpaths: !1 }))
  Gn.scan = (t, e) => qCe(t, e)
  Gn.compileRe = (t, e, r = !1, n = !1) => {
    if (r === !0) return t.output
    let i = e || {},
      o = i.contains ? '' : '^',
      s = i.contains ? '' : '$',
      a = `${o}(?:${t.output})${s}`
    t && t.negated === !0 && (a = `^(?!${a}).*$`)
    let l = Gn.toRegex(a, e)
    return n === !0 && (l.state = t), l
  }
  Gn.makeRe = (t, e = {}, r = !1, n = !1) => {
    if (!t || typeof t != 'string') throw new TypeError('Expected a non-empty string')
    let i = { negated: !1, fastpaths: !0 }
    return (
      e.fastpaths !== !1 && (t[0] === '.' || t[0] === '*') && (i.output = D5.fastpaths(t, e)),
      i.output || (i = D5(t, e)),
      Gn.compileRe(i, e, r, n)
    )
  }
  Gn.toRegex = (t, e) => {
    try {
      let r = e || {}
      return new RegExp(t, r.flags || (r.nocase ? 'i' : ''))
    } catch (r) {
      if (e && e.debug === !0) throw r
      return /$^/
    }
  }
  Gn.constants = HCe
  aY.exports = Gn
})
var patternMatcherModule = handleExports((runtime, exports) => {
  'use strict'
  exports.exports = patternMatcher()
})
var CY = handleExports((cw, SY) => {
  'use strict'
  ;(function (t, e) {
    typeof define == 'function' && define.amd
      ? define(['exports'], e)
      : typeof cw == 'object' && typeof SY < 'u'
      ? e(cw)
      : ((t = typeof globalThis < 'u' ? globalThis : t || self), e((t.marked = {})))
  })(cw, function (t) {
    'use strict'
    function e(le, ee) {
      for (var te = 0; te < ee.length; te++) {
        var N = ee[te]
        ;(N.enumerable = N.enumerable || !1),
          (N.configurable = !0),
          'value' in N && (N.writable = !0),
          Object.defineProperty(le, N.key, N)
      }
    }
    function r(le, ee, te) {
      return ee && e(le.prototype, ee), te && e(le, te), Object.defineProperty(le, 'prototype', { writable: !1 }), le
    }
    function n(le, ee) {
      if (le) {
        if (typeof le == 'string') return i(le, ee)
        var te = Object.prototype.toString.call(le).slice(8, -1)
        if ((te === 'Object' && le.constructor && (te = le.constructor.name), te === 'Map' || te === 'Set'))
          return Array.from(le)
        if (te === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te)) return i(le, ee)
      }
    }
    function i(le, ee) {
      ;(ee == null || ee > le.length) && (ee = le.length)
      for (var te = 0, N = new Array(ee); te < ee; te++) N[te] = le[te]
      return N
    }
    function o(le, ee) {
      var te = (typeof Symbol < 'u' && le[Symbol.iterator]) || le['@@iterator']
      if (te) return (te = te.call(le)).next.bind(te)
      if (Array.isArray(le) || (te = n(le)) || (ee && le && typeof le.length == 'number')) {
        te && (le = te)
        var N = 0
        return function () {
          return N >= le.length ? { done: !0 } : { done: !1, value: le[N++] }
        }
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    function s() {
      return {
        async: !1,
        baseUrl: null,
        breaks: !1,
        extensions: null,
        gfm: !0,
        headerIds: !0,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: !0,
        pedantic: !1,
        renderer: null,
        sanitize: !1,
        sanitizer: null,
        silent: !1,
        smartLists: !1,
        smartypants: !1,
        tokenizer: null,
        walkTokens: null,
        xhtml: !1,
      }
    }
    t.defaults = s()
    function a(le) {
      t.defaults = le
    }
    var l = /[&<>"']/,
      c = /[&<>"']/g,
      u = /[<>"']|&(?!#?\w+;)/,
      p = /[<>"']|&(?!#?\w+;)/g,
      d = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' },
      f = function (ee) {
        return d[ee]
      }
    function m(le, ee) {
      if (ee) {
        if (l.test(le)) return le.replace(c, f)
      } else if (u.test(le)) return le.replace(p, f)
      return le
    }
    var h = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi
    function g(le) {
      return le.replace(h, function (ee, te) {
        return (
          (te = te.toLowerCase()),
          te === 'colon'
            ? ':'
            : te.charAt(0) === '#'
            ? te.charAt(1) === 'x'
              ? String.fromCharCode(parseInt(te.substring(2), 16))
              : String.fromCharCode(+te.substring(1))
            : ''
        )
      })
    }
    var v = /(^|[^\[])\^/g
    function _(le, ee) {
      ;(le = typeof le == 'string' ? le : le.source), (ee = ee || '')
      var te = {
        replace: function (O, K) {
          return (K = K.source || K), (K = K.replace(v, '$1')), (le = le.replace(O, K)), te
        },
        getRegex: function () {
          return new RegExp(le, ee)
        },
      }
      return te
    }
    var y = /[^\w:]/g,
      b = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i
    function x(le, ee, te) {
      if (le) {
        var N
        try {
          N = decodeURIComponent(g(te)).replace(y, '').toLowerCase()
        } catch {
          return null
        }
        if (N.indexOf('javascript:') === 0 || N.indexOf('vbscript:') === 0 || N.indexOf('data:') === 0) return null
      }
      ee && !b.test(te) && (te = M(ee, te))
      try {
        te = encodeURI(te).replace(/%25/g, '%')
      } catch {
        return null
      }
      return te
    }
    var P = {},
      U = /^[^:]+:\/*[^/]*$/,
      H = /^([^:]+:)[\s\S]*$/,
      j = /^([^:]+:\/*[^/]*)[\s\S]*$/
    function M(le, ee) {
      P[' ' + le] || (U.test(le) ? (P[' ' + le] = le + '/') : (P[' ' + le] = L(le, '/', !0))), (le = P[' ' + le])
      var te = le.indexOf(':') === -1
      return ee.substring(0, 2) === '//'
        ? te
          ? ee
          : le.replace(H, '$1') + ee
        : ee.charAt(0) === '/'
        ? te
          ? ee
          : le.replace(j, '$1') + ee
        : le + ee
    }
    var F = { exec: function () {} }
    function z(le) {
      for (var ee = 1, te, N; ee < arguments.length; ee++) {
        te = arguments[ee]
        for (N in te) Object.prototype.hasOwnProperty.call(te, N) && (le[N] = te[N])
      }
      return le
    }
    function q(le, ee) {
      var te = le.replace(/\|/g, function (K, G, pe) {
          for (var be = !1, E = G; --E >= 0 && pe[E] === '\\'; ) be = !be
          return be ? '|' : ' |'
        }),
        N = te.split(/ \|/),
        O = 0
      if ((N[0].trim() || N.shift(), N.length > 0 && !N[N.length - 1].trim() && N.pop(), N.length > ee)) N.splice(ee)
      else for (; N.length < ee; ) N.push('')
      for (; O < N.length; O++) N[O] = N[O].trim().replace(/\\\|/g, '|')
      return N
    }
    function L(le, ee, te) {
      var N = le.length
      if (N === 0) return ''
      for (var O = 0; O < N; ) {
        var K = le.charAt(N - O - 1)
        if (K === ee && !te) O++
        else if (K !== ee && te) O++
        else break
      }
      return le.slice(0, N - O)
    }
    function S(le, ee) {
      if (le.indexOf(ee[1]) === -1) return -1
      for (var te = le.length, N = 0, O = 0; O < te; O++)
        if (le[O] === '\\') O++
        else if (le[O] === ee[0]) N++
        else if (le[O] === ee[1] && (N--, N < 0)) return O
      return -1
    }
    function T(le) {
      le &&
        le.sanitize &&
        !le.silent &&
        console.warn(
          'marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options'
        )
    }
    function A(le, ee) {
      if (ee < 1) return ''
      for (var te = ''; ee > 1; ) ee & 1 && (te += le), (ee >>= 1), (le += le)
      return te + le
    }
    function X(le, ee, te, N) {
      var O = ee.href,
        K = ee.title ? m(ee.title) : null,
        G = le[1].replace(/\\([\[\]])/g, '$1')
      if (le[0].charAt(0) !== '!') {
        N.state.inLink = !0
        var pe = { type: 'link', raw: te, href: O, title: K, text: G, tokens: N.inlineTokens(G) }
        return (N.state.inLink = !1), pe
      }
      return { type: 'image', raw: te, href: O, title: K, text: m(G) }
    }
    function fe(le, ee) {
      var te = le.match(/^(\s+)(?:```)/)
      if (te === null) return ee
      var N = te[1]
      return ee
        .split(
          `
`
        )
        .map(function (O) {
          var K = O.match(/^\s+/)
          if (K === null) return O
          var G = K[0]
          return G.length >= N.length ? O.slice(N.length) : O
        }).join(`
`)
    }
    var ce = (function () {
        function le(te) {
          this.options = te || t.defaults
        }
        var ee = le.prototype
        return (
          (ee.space = function (N) {
            var O = this.rules.block.newline.exec(N)
            if (O && O[0].length > 0) return { type: 'space', raw: O[0] }
          }),
          (ee.code = function (N) {
            var O = this.rules.block.code.exec(N)
            if (O) {
              var K = O[0].replace(/^ {1,4}/gm, '')
              return {
                type: 'code',
                raw: O[0],
                codeBlockStyle: 'indented',
                text: this.options.pedantic
                  ? K
                  : L(
                      K,
                      `
`
                    ),
              }
            }
          }),
          (ee.fences = function (N) {
            var O = this.rules.block.fences.exec(N)
            if (O) {
              var K = O[0],
                G = fe(K, O[3] || '')
              return { type: 'code', raw: K, lang: O[2] ? O[2].trim() : O[2], text: G }
            }
          }),
          (ee.heading = function (N) {
            var O = this.rules.block.heading.exec(N)
            if (O) {
              var K = O[2].trim()
              if (/#$/.test(K)) {
                var G = L(K, '#')
                ;(this.options.pedantic || !G || / $/.test(G)) && (K = G.trim())
              }
              return { type: 'heading', raw: O[0], depth: O[1].length, text: K, tokens: this.lexer.inline(K) }
            }
          }),
          (ee.hr = function (N) {
            var O = this.rules.block.hr.exec(N)
            if (O) return { type: 'hr', raw: O[0] }
          }),
          (ee.blockquote = function (N) {
            var O = this.rules.block.blockquote.exec(N)
            if (O) {
              var K = O[0].replace(/^ *>[ \t]?/gm, '')
              return { type: 'blockquote', raw: O[0], tokens: this.lexer.blockTokens(K, []), text: K }
            }
          }),
          (ee.list = function (N) {
            var O = this.rules.block.list.exec(N)
            if (O) {
              var K,
                G,
                pe,
                be,
                E,
                B,
                Y,
                Q,
                me,
                ge,
                se,
                V,
                ie = O[1].trim(),
                re = ie.length > 1,
                xe = { type: 'list', raw: '', ordered: re, start: re ? +ie.slice(0, -1) : '', loose: !1, items: [] }
              ;(ie = re ? '\\d{1,9}\\' + ie.slice(-1) : '\\' + ie), this.options.pedantic && (ie = re ? ie : '[*+-]')
              for (
                var Ie = new RegExp('^( {0,3}' + ie + ')((?:[	 ][^\\n]*)?(?:\\n|$))');
                N && ((V = !1), !(!(O = Ie.exec(N)) || this.rules.block.hr.test(N)));

              ) {
                if (
                  ((K = O[0]),
                  (N = N.substring(K.length)),
                  (Q = O[2].split(
                    `
`,
                    1
                  )[0]),
                  (me = N.split(
                    `
`,
                    1
                  )[0]),
                  this.options.pedantic
                    ? ((be = 2), (se = Q.trimLeft()))
                    : ((be = O[2].search(/[^ ]/)), (be = be > 4 ? 1 : be), (se = Q.slice(be)), (be += O[1].length)),
                  (B = !1),
                  !Q &&
                    /^ *$/.test(me) &&
                    ((K +=
                      me +
                      `
`),
                    (N = N.substring(me.length + 1)),
                    (V = !0)),
                  !V)
                )
                  for (
                    var We = new RegExp(
                        '^ {0,' + Math.min(3, be - 1) + '}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))'
                      ),
                      ft = new RegExp(
                        '^ {0,' + Math.min(3, be - 1) + '}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)'
                      ),
                      Et = new RegExp('^ {0,' + Math.min(3, be - 1) + '}(?:```|~~~)'),
                      It = new RegExp('^ {0,' + Math.min(3, be - 1) + '}#');
                    N &&
                    ((ge = N.split(
                      `
`,
                      1
                    )[0]),
                    (Q = ge),
                    this.options.pedantic && (Q = Q.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ')),
                    !(Et.test(Q) || It.test(Q) || We.test(Q) || ft.test(N)));

                  ) {
                    if (Q.search(/[^ ]/) >= be || !Q.trim())
                      se +=
                        `
` + Q.slice(be)
                    else if (!B)
                      se +=
                        `
` + Q
                    else break
                    !B && !Q.trim() && (B = !0),
                      (K +=
                        ge +
                        `
`),
                      (N = N.substring(ge.length + 1))
                  }
                xe.loose || (Y ? (xe.loose = !0) : /\n *\n *$/.test(K) && (Y = !0)),
                  this.options.gfm &&
                    ((G = /^\[[ xX]\] /.exec(se)),
                    G && ((pe = G[0] !== '[ ] '), (se = se.replace(/^\[[ xX]\] +/, '')))),
                  xe.items.push({ type: 'list_item', raw: K, task: !!G, checked: pe, loose: !1, text: se }),
                  (xe.raw += K)
              }
              ;(xe.items[xe.items.length - 1].raw = K.trimRight()),
                (xe.items[xe.items.length - 1].text = se.trimRight()),
                (xe.raw = xe.raw.trimRight())
              var Hn = xe.items.length
              for (E = 0; E < Hn; E++) {
                ;(this.lexer.state.top = !1), (xe.items[E].tokens = this.lexer.blockTokens(xe.items[E].text, []))
                var Zt = xe.items[E].tokens.filter(function (Rn) {
                    return Rn.type === 'space'
                  }),
                  Er = Zt.every(function (Rn) {
                    for (var wd = Rn.raw.split(''), FC = 0, cbe = o(wd), gz; !(gz = cbe()).done; ) {
                      var lbe = gz.value
                      if (
                        (lbe ===
                          `
` && (FC += 1),
                        FC > 1)
                      )
                        return !0
                    }
                    return !1
                  })
                !xe.loose && Zt.length && Er && ((xe.loose = !0), (xe.items[E].loose = !0))
              }
              return xe
            }
          }),
          (ee.html = function (N) {
            var O = this.rules.block.html.exec(N)
            if (O) {
              var K = {
                type: 'html',
                raw: O[0],
                pre: !this.options.sanitizer && (O[1] === 'pre' || O[1] === 'script' || O[1] === 'style'),
                text: O[0],
              }
              if (this.options.sanitize) {
                var G = this.options.sanitizer ? this.options.sanitizer(O[0]) : m(O[0])
                ;(K.type = 'paragraph'), (K.text = G), (K.tokens = this.lexer.inline(G))
              }
              return K
            }
          }),
          (ee.def = function (N) {
            var O = this.rules.block.def.exec(N)
            if (O) {
              O[3] && (O[3] = O[3].substring(1, O[3].length - 1))
              var K = O[1].toLowerCase().replace(/\s+/g, ' ')
              return { type: 'def', tag: K, raw: O[0], href: O[2], title: O[3] }
            }
          }),
          (ee.table = function (N) {
            var O = this.rules.block.table.exec(N)
            if (O) {
              var K = {
                type: 'table',
                header: q(O[1]).map(function (Y) {
                  return { text: Y }
                }),
                align: O[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                rows:
                  O[3] && O[3].trim()
                    ? O[3].replace(/\n[ \t]*$/, '').split(`
`)
                    : [],
              }
              if (K.header.length === K.align.length) {
                K.raw = O[0]
                var G = K.align.length,
                  pe,
                  be,
                  E,
                  B
                for (pe = 0; pe < G; pe++)
                  /^ *-+: *$/.test(K.align[pe])
                    ? (K.align[pe] = 'right')
                    : /^ *:-+: *$/.test(K.align[pe])
                    ? (K.align[pe] = 'center')
                    : /^ *:-+ *$/.test(K.align[pe])
                    ? (K.align[pe] = 'left')
                    : (K.align[pe] = null)
                for (G = K.rows.length, pe = 0; pe < G; pe++)
                  K.rows[pe] = q(K.rows[pe], K.header.length).map(function (Y) {
                    return { text: Y }
                  })
                for (G = K.header.length, be = 0; be < G; be++)
                  K.header[be].tokens = this.lexer.inline(K.header[be].text)
                for (G = K.rows.length, be = 0; be < G; be++)
                  for (B = K.rows[be], E = 0; E < B.length; E++) B[E].tokens = this.lexer.inline(B[E].text)
                return K
              }
            }
          }),
          (ee.lheading = function (N) {
            var O = this.rules.block.lheading.exec(N)
            if (O)
              return {
                type: 'heading',
                raw: O[0],
                depth: O[2].charAt(0) === '=' ? 1 : 2,
                text: O[1],
                tokens: this.lexer.inline(O[1]),
              }
          }),
          (ee.paragraph = function (N) {
            var O = this.rules.block.paragraph.exec(N)
            if (O) {
              var K =
                O[1].charAt(O[1].length - 1) ===
                `
`
                  ? O[1].slice(0, -1)
                  : O[1]
              return { type: 'paragraph', raw: O[0], text: K, tokens: this.lexer.inline(K) }
            }
          }),
          (ee.text = function (N) {
            var O = this.rules.block.text.exec(N)
            if (O) return { type: 'text', raw: O[0], text: O[0], tokens: this.lexer.inline(O[0]) }
          }),
          (ee.escape = function (N) {
            var O = this.rules.inline.escape.exec(N)
            if (O) return { type: 'escape', raw: O[0], text: m(O[1]) }
          }),
          (ee.tag = function (N) {
            var O = this.rules.inline.tag.exec(N)
            if (O)
              return (
                !this.lexer.state.inLink && /^<a /i.test(O[0])
                  ? (this.lexer.state.inLink = !0)
                  : this.lexer.state.inLink && /^<\/a>/i.test(O[0]) && (this.lexer.state.inLink = !1),
                !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(O[0])
                  ? (this.lexer.state.inRawBlock = !0)
                  : this.lexer.state.inRawBlock &&
                    /^<\/(pre|code|kbd|script)(\s|>)/i.test(O[0]) &&
                    (this.lexer.state.inRawBlock = !1),
                {
                  type: this.options.sanitize ? 'text' : 'html',
                  raw: O[0],
                  inLink: this.lexer.state.inLink,
                  inRawBlock: this.lexer.state.inRawBlock,
                  text: this.options.sanitize
                    ? this.options.sanitizer
                      ? this.options.sanitizer(O[0])
                      : m(O[0])
                    : O[0],
                }
              )
          }),
          (ee.link = function (N) {
            var O = this.rules.inline.link.exec(N)
            if (O) {
              var K = O[2].trim()
              if (!this.options.pedantic && /^</.test(K)) {
                if (!/>$/.test(K)) return
                var G = L(K.slice(0, -1), '\\')
                if ((K.length - G.length) % 2 === 0) return
              } else {
                var pe = S(O[2], '()')
                if (pe > -1) {
                  var be = O[0].indexOf('!') === 0 ? 5 : 4,
                    E = be + O[1].length + pe
                  ;(O[2] = O[2].substring(0, pe)), (O[0] = O[0].substring(0, E).trim()), (O[3] = '')
                }
              }
              var B = O[2],
                Y = ''
              if (this.options.pedantic) {
                var Q = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(B)
                Q && ((B = Q[1]), (Y = Q[3]))
              } else Y = O[3] ? O[3].slice(1, -1) : ''
              return (
                (B = B.trim()),
                /^</.test(B) && (this.options.pedantic && !/>$/.test(K) ? (B = B.slice(1)) : (B = B.slice(1, -1))),
                X(
                  O,
                  {
                    href: B && B.replace(this.rules.inline._escapes, '$1'),
                    title: Y && Y.replace(this.rules.inline._escapes, '$1'),
                  },
                  O[0],
                  this.lexer
                )
              )
            }
          }),
          (ee.reflink = function (N, O) {
            var K
            if ((K = this.rules.inline.reflink.exec(N)) || (K = this.rules.inline.nolink.exec(N))) {
              var G = (K[2] || K[1]).replace(/\s+/g, ' ')
              if (((G = O[G.toLowerCase()]), !G || !G.href)) {
                var pe = K[0].charAt(0)
                return { type: 'text', raw: pe, text: pe }
              }
              return X(K, G, K[0], this.lexer)
            }
          }),
          (ee.emStrong = function (N, O, K) {
            K === void 0 && (K = '')
            var G = this.rules.inline.emStrong.lDelim.exec(N)
            if (
              G &&
              !(
                G[3] &&
                K.match(
                  /(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/
                )
              )
            ) {
              var pe = G[1] || G[2] || ''
              if (!pe || (pe && (K === '' || this.rules.inline.punctuation.exec(K)))) {
                var be = G[0].length - 1,
                  E,
                  B,
                  Y = be,
                  Q = 0,
                  me = G[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd
                for (me.lastIndex = 0, O = O.slice(-1 * N.length + be); (G = me.exec(O)) != null; )
                  if (((E = G[1] || G[2] || G[3] || G[4] || G[5] || G[6]), !!E)) {
                    if (((B = E.length), G[3] || G[4])) {
                      Y += B
                      continue
                    } else if ((G[5] || G[6]) && be % 3 && !((be + B) % 3)) {
                      Q += B
                      continue
                    }
                    if (((Y -= B), !(Y > 0))) {
                      if (((B = Math.min(B, B + Y + Q)), Math.min(be, B) % 2)) {
                        var ge = N.slice(1, be + G.index + B)
                        return {
                          type: 'em',
                          raw: N.slice(0, be + G.index + B + 1),
                          text: ge,
                          tokens: this.lexer.inlineTokens(ge),
                        }
                      }
                      var se = N.slice(2, be + G.index + B - 1)
                      return {
                        type: 'strong',
                        raw: N.slice(0, be + G.index + B + 1),
                        text: se,
                        tokens: this.lexer.inlineTokens(se),
                      }
                    }
                  }
              }
            }
          }),
          (ee.codespan = function (N) {
            var O = this.rules.inline.code.exec(N)
            if (O) {
              var K = O[2].replace(/\n/g, ' '),
                G = /[^ ]/.test(K),
                pe = /^ /.test(K) && / $/.test(K)
              return (
                G && pe && (K = K.substring(1, K.length - 1)), (K = m(K, !0)), { type: 'codespan', raw: O[0], text: K }
              )
            }
          }),
          (ee.br = function (N) {
            var O = this.rules.inline.br.exec(N)
            if (O) return { type: 'br', raw: O[0] }
          }),
          (ee.del = function (N) {
            var O = this.rules.inline.del.exec(N)
            if (O) return { type: 'del', raw: O[0], text: O[2], tokens: this.lexer.inlineTokens(O[2]) }
          }),
          (ee.autolink = function (N, O) {
            var K = this.rules.inline.autolink.exec(N)
            if (K) {
              var G, pe
              return (
                K[2] === '@'
                  ? ((G = m(this.options.mangle ? O(K[1]) : K[1])), (pe = 'mailto:' + G))
                  : ((G = m(K[1])), (pe = G)),
                { type: 'link', raw: K[0], text: G, href: pe, tokens: [{ type: 'text', raw: G, text: G }] }
              )
            }
          }),
          (ee.url = function (N, O) {
            var K
            if ((K = this.rules.inline.url.exec(N))) {
              var G, pe
              if (K[2] === '@') (G = m(this.options.mangle ? O(K[0]) : K[0])), (pe = 'mailto:' + G)
              else {
                var be
                do (be = K[0]), (K[0] = this.rules.inline._backpedal.exec(K[0])[0])
                while (be !== K[0])
                ;(G = m(K[0])), K[1] === 'www.' ? (pe = 'http://' + G) : (pe = G)
              }
              return { type: 'link', raw: K[0], text: G, href: pe, tokens: [{ type: 'text', raw: G, text: G }] }
            }
          }),
          (ee.inlineText = function (N, O) {
            var K = this.rules.inline.text.exec(N)
            if (K) {
              var G
              return (
                this.lexer.state.inRawBlock
                  ? (G = this.options.sanitize
                      ? this.options.sanitizer
                        ? this.options.sanitizer(K[0])
                        : m(K[0])
                      : K[0])
                  : (G = m(this.options.smartypants ? O(K[0]) : K[0])),
                { type: 'text', raw: K[0], text: G }
              )
            }
          }),
          le
        )
      })(),
      oe = {
        newline: /^(?: *(?:\n|$))+/,
        code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
        fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
        hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
        html: '^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))',
        def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
        table: F,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
        text: /^[^\n]+/,
      }
    ;(oe._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/),
      (oe._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/),
      (oe.def = _(oe.def).replace('label', oe._label).replace('title', oe._title).getRegex()),
      (oe.bullet = /(?:[*+-]|\d{1,9}[.)])/),
      (oe.listItemStart = _(/^( *)(bull) */)
        .replace('bull', oe.bullet)
        .getRegex()),
      (oe.list = _(oe.list)
        .replace(/bull/g, oe.bullet)
        .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
        .replace('def', '\\n+(?=' + oe.def.source + ')')
        .getRegex()),
      (oe._tag =
        'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul'),
      (oe._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/),
      (oe.html = _(oe.html, 'i')
        .replace('comment', oe._comment)
        .replace('tag', oe._tag)
        .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
        .getRegex()),
      (oe.paragraph = _(oe._paragraph)
        .replace('hr', oe.hr)
        .replace('heading', ' {0,3}#{1,6} ')
        .replace('|lheading', '')
        .replace('|table', '')
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', oe._tag)
        .getRegex()),
      (oe.blockquote = _(oe.blockquote).replace('paragraph', oe.paragraph).getRegex()),
      (oe.normal = z({}, oe)),
      (oe.gfm = z({}, oe.normal, {
        table:
          '^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
      })),
      (oe.gfm.table = _(oe.gfm.table)
        .replace('hr', oe.hr)
        .replace('heading', ' {0,3}#{1,6} ')
        .replace('blockquote', ' {0,3}>')
        .replace('code', ' {4}[^\\n]')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', oe._tag)
        .getRegex()),
      (oe.gfm.paragraph = _(oe._paragraph)
        .replace('hr', oe.hr)
        .replace('heading', ' {0,3}#{1,6} ')
        .replace('|lheading', '')
        .replace('table', oe.gfm.table)
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', oe._tag)
        .getRegex()),
      (oe.pedantic = z({}, oe.normal, {
        html: _(
          `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
        )
          .replace('comment', oe._comment)
          .replace(
            /tag/g,
            '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b'
          )
          .getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: F,
        paragraph: _(oe.normal._paragraph)
          .replace('hr', oe.hr)
          .replace(
            'heading',
            ` *#{1,6} *[^
]`
          )
          .replace('lheading', oe.lheading)
          .replace('blockquote', ' {0,3}>')
          .replace('|fences', '')
          .replace('|list', '')
          .replace('|html', '')
          .getRegex(),
      }))
    var ae = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: F,
      tag: '^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: 'reflink|nolink(?!\\()',
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst:
          /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd:
          /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/,
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: F,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/,
    }
    ;(ae._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~'),
      (ae.punctuation = _(ae.punctuation)
        .replace(/punctuation/g, ae._punctuation)
        .getRegex()),
      (ae.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g),
      (ae.escapedEmSt = /\\\*|\\_/g),
      (ae._comment = _(oe._comment).replace('(?:-->|$)', '-->').getRegex()),
      (ae.emStrong.lDelim = _(ae.emStrong.lDelim).replace(/punct/g, ae._punctuation).getRegex()),
      (ae.emStrong.rDelimAst = _(ae.emStrong.rDelimAst, 'g').replace(/punct/g, ae._punctuation).getRegex()),
      (ae.emStrong.rDelimUnd = _(ae.emStrong.rDelimUnd, 'g').replace(/punct/g, ae._punctuation).getRegex()),
      (ae._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g),
      (ae._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/),
      (ae._email =
        /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/),
      (ae.autolink = _(ae.autolink).replace('scheme', ae._scheme).replace('email', ae._email).getRegex()),
      (ae._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/),
      (ae.tag = _(ae.tag).replace('comment', ae._comment).replace('attribute', ae._attribute).getRegex()),
      (ae._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
      (ae._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/),
      (ae._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/),
      (ae.link = _(ae.link)
        .replace('label', ae._label)
        .replace('href', ae._href)
        .replace('title', ae._title)
        .getRegex()),
      (ae.reflink = _(ae.reflink).replace('label', ae._label).replace('ref', oe._label).getRegex()),
      (ae.nolink = _(ae.nolink).replace('ref', oe._label).getRegex()),
      (ae.reflinkSearch = _(ae.reflinkSearch, 'g')
        .replace('reflink', ae.reflink)
        .replace('nolink', ae.nolink)
        .getRegex()),
      (ae.normal = z({}, ae)),
      (ae.pedantic = z({}, ae.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g,
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g,
        },
        link: _(/^!?\[(label)\]\((.*?)\)/)
          .replace('label', ae._label)
          .getRegex(),
        reflink: _(/^!?\[(label)\]\s*\[([^\]]*)\]/)
          .replace('label', ae._label)
          .getRegex(),
      })),
      (ae.gfm = z({}, ae.normal, {
        escape: _(ae.escape).replace('])', '~|])').getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
      })),
      (ae.gfm.url = _(ae.gfm.url, 'i').replace('email', ae.gfm._extended_email).getRegex()),
      (ae.breaks = z({}, ae.gfm, {
        br: _(ae.br).replace('{2,}', '*').getRegex(),
        text: _(ae.gfm.text)
          .replace('\\b_', '\\b_| {2,}\\n')
          .replace(/\{2,\}/g, '*')
          .getRegex(),
      }))
    function je(le) {
      return le
        .replace(/---/g, '\u2014')
        .replace(/--/g, '\u2013')
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        .replace(/'/g, '\u2019')
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201C')
        .replace(/"/g, '\u201D')
        .replace(/\.{3}/g, '\u2026')
    }
    function Ye(le) {
      var ee = '',
        te,
        N,
        O = le.length
      for (te = 0; te < O; te++)
        (N = le.charCodeAt(te)), Math.random() > 0.5 && (N = 'x' + N.toString(16)), (ee += '&#' + N + ';')
      return ee
    }
    var Ze = (function () {
        function le(te) {
          ;(this.tokens = []),
            (this.tokens.links = Object.create(null)),
            (this.options = te || t.defaults),
            (this.options.tokenizer = this.options.tokenizer || new ce()),
            (this.tokenizer = this.options.tokenizer),
            (this.tokenizer.options = this.options),
            (this.tokenizer.lexer = this),
            (this.inlineQueue = []),
            (this.state = { inLink: !1, inRawBlock: !1, top: !0 })
          var N = { block: oe.normal, inline: ae.normal }
          this.options.pedantic
            ? ((N.block = oe.pedantic), (N.inline = ae.pedantic))
            : this.options.gfm &&
              ((N.block = oe.gfm), this.options.breaks ? (N.inline = ae.breaks) : (N.inline = ae.gfm)),
            (this.tokenizer.rules = N)
        }
        ;(le.lex = function (N, O) {
          var K = new le(O)
          return K.lex(N)
        }),
          (le.lexInline = function (N, O) {
            var K = new le(O)
            return K.inlineTokens(N)
          })
        var ee = le.prototype
        return (
          (ee.lex = function (N) {
            ;(N = N.replace(
              /\r\n|\r/g,
              `
`
            )),
              this.blockTokens(N, this.tokens)
            for (var O; (O = this.inlineQueue.shift()); ) this.inlineTokens(O.src, O.tokens)
            return this.tokens
          }),
          (ee.blockTokens = function (N, O) {
            var K = this
            O === void 0 && (O = []),
              this.options.pedantic
                ? (N = N.replace(/\t/g, '    ').replace(/^ +$/gm, ''))
                : (N = N.replace(/^( *)(\t+)/gm, function (Y, Q, me) {
                    return Q + '    '.repeat(me.length)
                  }))
            for (var G, pe, be, E; N; )
              if (
                !(
                  this.options.extensions &&
                  this.options.extensions.block &&
                  this.options.extensions.block.some(function (Y) {
                    return (G = Y.call({ lexer: K }, N, O)) ? ((N = N.substring(G.raw.length)), O.push(G), !0) : !1
                  })
                )
              ) {
                if ((G = this.tokenizer.space(N))) {
                  ;(N = N.substring(G.raw.length)),
                    G.raw.length === 1 && O.length > 0
                      ? (O[O.length - 1].raw += `
`)
                      : O.push(G)
                  continue
                }
                if ((G = this.tokenizer.code(N))) {
                  ;(N = N.substring(G.raw.length)),
                    (pe = O[O.length - 1]),
                    pe && (pe.type === 'paragraph' || pe.type === 'text')
                      ? ((pe.raw +=
                          `
` + G.raw),
                        (pe.text +=
                          `
` + G.text),
                        (this.inlineQueue[this.inlineQueue.length - 1].src = pe.text))
                      : O.push(G)
                  continue
                }
                if ((G = this.tokenizer.fences(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.heading(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.hr(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.blockquote(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.list(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.html(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.def(N))) {
                  ;(N = N.substring(G.raw.length)),
                    (pe = O[O.length - 1]),
                    pe && (pe.type === 'paragraph' || pe.type === 'text')
                      ? ((pe.raw +=
                          `
` + G.raw),
                        (pe.text +=
                          `
` + G.raw),
                        (this.inlineQueue[this.inlineQueue.length - 1].src = pe.text))
                      : this.tokens.links[G.tag] || (this.tokens.links[G.tag] = { href: G.href, title: G.title })
                  continue
                }
                if ((G = this.tokenizer.table(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.lheading(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if (
                  ((be = N),
                  this.options.extensions &&
                    this.options.extensions.startBlock &&
                    (function () {
                      var Y = 1 / 0,
                        Q = N.slice(1),
                        me = void 0
                      K.options.extensions.startBlock.forEach(function (ge) {
                        ;(me = ge.call({ lexer: this }, Q)), typeof me == 'number' && me >= 0 && (Y = Math.min(Y, me))
                      }),
                        Y < 1 / 0 && Y >= 0 && (be = N.substring(0, Y + 1))
                    })(),
                  this.state.top && (G = this.tokenizer.paragraph(be)))
                ) {
                  ;(pe = O[O.length - 1]),
                    E && pe.type === 'paragraph'
                      ? ((pe.raw +=
                          `
` + G.raw),
                        (pe.text +=
                          `
` + G.text),
                        this.inlineQueue.pop(),
                        (this.inlineQueue[this.inlineQueue.length - 1].src = pe.text))
                      : O.push(G),
                    (E = be.length !== N.length),
                    (N = N.substring(G.raw.length))
                  continue
                }
                if ((G = this.tokenizer.text(N))) {
                  ;(N = N.substring(G.raw.length)),
                    (pe = O[O.length - 1]),
                    pe && pe.type === 'text'
                      ? ((pe.raw +=
                          `
` + G.raw),
                        (pe.text +=
                          `
` + G.text),
                        this.inlineQueue.pop(),
                        (this.inlineQueue[this.inlineQueue.length - 1].src = pe.text))
                      : O.push(G)
                  continue
                }
                if (N) {
                  var B = 'Infinite loop on byte: ' + N.charCodeAt(0)
                  if (this.options.silent) {
                    console.error(B)
                    break
                  } else throw new Error(B)
                }
              }
            return (this.state.top = !0), O
          }),
          (ee.inline = function (N, O) {
            return O === void 0 && (O = []), this.inlineQueue.push({ src: N, tokens: O }), O
          }),
          (ee.inlineTokens = function (N, O) {
            var K = this
            O === void 0 && (O = [])
            var G,
              pe,
              be,
              E = N,
              B,
              Y,
              Q
            if (this.tokens.links) {
              var me = Object.keys(this.tokens.links)
              if (me.length > 0)
                for (; (B = this.tokenizer.rules.inline.reflinkSearch.exec(E)) != null; )
                  me.includes(B[0].slice(B[0].lastIndexOf('[') + 1, -1)) &&
                    (E =
                      E.slice(0, B.index) +
                      '[' +
                      A('a', B[0].length - 2) +
                      ']' +
                      E.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
            }
            for (; (B = this.tokenizer.rules.inline.blockSkip.exec(E)) != null; )
              E =
                E.slice(0, B.index) +
                '[' +
                A('a', B[0].length - 2) +
                ']' +
                E.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
            for (; (B = this.tokenizer.rules.inline.escapedEmSt.exec(E)) != null; )
              E = E.slice(0, B.index) + '++' + E.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex)
            for (; N; )
              if (
                (Y || (Q = ''),
                (Y = !1),
                !(
                  this.options.extensions &&
                  this.options.extensions.inline &&
                  this.options.extensions.inline.some(function (se) {
                    return (G = se.call({ lexer: K }, N, O)) ? ((N = N.substring(G.raw.length)), O.push(G), !0) : !1
                  })
                ))
              ) {
                if ((G = this.tokenizer.escape(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.tag(N))) {
                  ;(N = N.substring(G.raw.length)),
                    (pe = O[O.length - 1]),
                    pe && G.type === 'text' && pe.type === 'text' ? ((pe.raw += G.raw), (pe.text += G.text)) : O.push(G)
                  continue
                }
                if ((G = this.tokenizer.link(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.reflink(N, this.tokens.links))) {
                  ;(N = N.substring(G.raw.length)),
                    (pe = O[O.length - 1]),
                    pe && G.type === 'text' && pe.type === 'text' ? ((pe.raw += G.raw), (pe.text += G.text)) : O.push(G)
                  continue
                }
                if ((G = this.tokenizer.emStrong(N, E, Q))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.codespan(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.br(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.del(N))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if ((G = this.tokenizer.autolink(N, Ye))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if (!this.state.inLink && (G = this.tokenizer.url(N, Ye))) {
                  ;(N = N.substring(G.raw.length)), O.push(G)
                  continue
                }
                if (
                  ((be = N),
                  this.options.extensions &&
                    this.options.extensions.startInline &&
                    (function () {
                      var se = 1 / 0,
                        V = N.slice(1),
                        ie = void 0
                      K.options.extensions.startInline.forEach(function (re) {
                        ;(ie = re.call({ lexer: this }, V)), typeof ie == 'number' && ie >= 0 && (se = Math.min(se, ie))
                      }),
                        se < 1 / 0 && se >= 0 && (be = N.substring(0, se + 1))
                    })(),
                  (G = this.tokenizer.inlineText(be, je)))
                ) {
                  ;(N = N.substring(G.raw.length)),
                    G.raw.slice(-1) !== '_' && (Q = G.raw.slice(-1)),
                    (Y = !0),
                    (pe = O[O.length - 1]),
                    pe && pe.type === 'text' ? ((pe.raw += G.raw), (pe.text += G.text)) : O.push(G)
                  continue
                }
                if (N) {
                  var ge = 'Infinite loop on byte: ' + N.charCodeAt(0)
                  if (this.options.silent) {
                    console.error(ge)
                    break
                  } else throw new Error(ge)
                }
              }
            return O
          }),
          r(le, null, [
            {
              key: 'rules',
              get: function () {
                return { block: oe, inline: ae }
              },
            },
          ]),
          le
        )
      })(),
      ke = (function () {
        function le(te) {
          this.options = te || t.defaults
        }
        var ee = le.prototype
        return (
          (ee.code = function (N, O, K) {
            var G = (O || '').match(/\S*/)[0]
            if (this.options.highlight) {
              var pe = this.options.highlight(N, G)
              pe != null && pe !== N && ((K = !0), (N = pe))
            }
            return (
              (N =
                N.replace(/\n$/, '') +
                `
`),
              G
                ? '<pre><code class="' +
                  this.options.langPrefix +
                  m(G, !0) +
                  '">' +
                  (K ? N : m(N, !0)) +
                  `</code></pre>
`
                : '<pre><code>' +
                  (K ? N : m(N, !0)) +
                  `</code></pre>
`
            )
          }),
          (ee.blockquote = function (N) {
            return (
              `<blockquote>
` +
              N +
              `</blockquote>
`
            )
          }),
          (ee.html = function (N) {
            return N
          }),
          (ee.heading = function (N, O, K, G) {
            if (this.options.headerIds) {
              var pe = this.options.headerPrefix + G.slug(K)
              return (
                '<h' +
                O +
                ' id="' +
                pe +
                '">' +
                N +
                '</h' +
                O +
                `>
`
              )
            }
            return (
              '<h' +
              O +
              '>' +
              N +
              '</h' +
              O +
              `>
`
            )
          }),
          (ee.hr = function () {
            return this.options.xhtml
              ? `<hr/>
`
              : `<hr>
`
          }),
          (ee.list = function (N, O, K) {
            var G = O ? 'ol' : 'ul',
              pe = O && K !== 1 ? ' start="' + K + '"' : ''
            return (
              '<' +
              G +
              pe +
              `>
` +
              N +
              '</' +
              G +
              `>
`
            )
          }),
          (ee.listitem = function (N) {
            return (
              '<li>' +
              N +
              `</li>
`
            )
          }),
          (ee.checkbox = function (N) {
            return (
              '<input ' +
              (N ? 'checked="" ' : '') +
              'disabled="" type="checkbox"' +
              (this.options.xhtml ? ' /' : '') +
              '> '
            )
          }),
          (ee.paragraph = function (N) {
            return (
              '<p>' +
              N +
              `</p>
`
            )
          }),
          (ee.table = function (N, O) {
            return (
              O && (O = '<tbody>' + O + '</tbody>'),
              `<table>
<thead>
` +
                N +
                `</thead>
` +
                O +
                `</table>
`
            )
          }),
          (ee.tablerow = function (N) {
            return (
              `<tr>
` +
              N +
              `</tr>
`
            )
          }),
          (ee.tablecell = function (N, O) {
            var K = O.header ? 'th' : 'td',
              G = O.align ? '<' + K + ' align="' + O.align + '">' : '<' + K + '>'
            return (
              G +
              N +
              ('</' +
                K +
                `>
`)
            )
          }),
          (ee.strong = function (N) {
            return '<strong>' + N + '</strong>'
          }),
          (ee.em = function (N) {
            return '<em>' + N + '</em>'
          }),
          (ee.codespan = function (N) {
            return '<code>' + N + '</code>'
          }),
          (ee.br = function () {
            return this.options.xhtml ? '<br/>' : '<br>'
          }),
          (ee.del = function (N) {
            return '<del>' + N + '</del>'
          }),
          (ee.link = function (N, O, K) {
            if (((N = x(this.options.sanitize, this.options.baseUrl, N)), N === null)) return K
            var G = '<a href="' + m(N) + '"'
            return O && (G += ' title="' + O + '"'), (G += '>' + K + '</a>'), G
          }),
          (ee.image = function (N, O, K) {
            if (((N = x(this.options.sanitize, this.options.baseUrl, N)), N === null)) return K
            var G = '<img src="' + N + '" alt="' + K + '"'
            return O && (G += ' title="' + O + '"'), (G += this.options.xhtml ? '/>' : '>'), G
          }),
          (ee.text = function (N) {
            return N
          }),
          le
        )
      })(),
      st = (function () {
        function le() {}
        var ee = le.prototype
        return (
          (ee.strong = function (N) {
            return N
          }),
          (ee.em = function (N) {
            return N
          }),
          (ee.codespan = function (N) {
            return N
          }),
          (ee.del = function (N) {
            return N
          }),
          (ee.html = function (N) {
            return N
          }),
          (ee.text = function (N) {
            return N
          }),
          (ee.link = function (N, O, K) {
            return '' + K
          }),
          (ee.image = function (N, O, K) {
            return '' + K
          }),
          (ee.br = function () {
            return ''
          }),
          le
        )
      })(),
      tt = (function () {
        function le() {
          this.seen = {}
        }
        var ee = le.prototype
        return (
          (ee.serialize = function (N) {
            return N.toLowerCase()
              .trim()
              .replace(/<[!\/a-z].*?>/gi, '')
              .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
              .replace(/\s/g, '-')
          }),
          (ee.getNextSafeSlug = function (N, O) {
            var K = N,
              G = 0
            if (this.seen.hasOwnProperty(K)) {
              G = this.seen[N]
              do G++, (K = N + '-' + G)
              while (this.seen.hasOwnProperty(K))
            }
            return O || ((this.seen[N] = G), (this.seen[K] = 0)), K
          }),
          (ee.slug = function (N, O) {
            O === void 0 && (O = {})
            var K = this.serialize(N)
            return this.getNextSafeSlug(K, O.dryrun)
          }),
          le
        )
      })(),
      ve = (function () {
        function le(te) {
          ;(this.options = te || t.defaults),
            (this.options.renderer = this.options.renderer || new ke()),
            (this.renderer = this.options.renderer),
            (this.renderer.options = this.options),
            (this.textRenderer = new st()),
            (this.slugger = new tt())
        }
        ;(le.parse = function (N, O) {
          var K = new le(O)
          return K.parse(N)
        }),
          (le.parseInline = function (N, O) {
            var K = new le(O)
            return K.parseInline(N)
          })
        var ee = le.prototype
        return (
          (ee.parse = function (N, O) {
            O === void 0 && (O = !0)
            var K = '',
              G,
              pe,
              be,
              E,
              B,
              Y,
              Q,
              me,
              ge,
              se,
              V,
              ie,
              re,
              xe,
              Ie,
              We,
              ft,
              Et,
              It,
              Hn = N.length
            for (G = 0; G < Hn; G++) {
              if (
                ((se = N[G]),
                this.options.extensions &&
                  this.options.extensions.renderers &&
                  this.options.extensions.renderers[se.type] &&
                  ((It = this.options.extensions.renderers[se.type].call({ parser: this }, se)),
                  It !== !1 ||
                    ![
                      'space',
                      'hr',
                      'heading',
                      'code',
                      'table',
                      'blockquote',
                      'list',
                      'html',
                      'paragraph',
                      'text',
                    ].includes(se.type)))
              ) {
                K += It || ''
                continue
              }
              switch (se.type) {
                case 'space':
                  continue
                case 'hr': {
                  K += this.renderer.hr()
                  continue
                }
                case 'heading': {
                  K += this.renderer.heading(
                    this.parseInline(se.tokens),
                    se.depth,
                    g(this.parseInline(se.tokens, this.textRenderer)),
                    this.slugger
                  )
                  continue
                }
                case 'code': {
                  K += this.renderer.code(se.text, se.lang, se.escaped)
                  continue
                }
                case 'table': {
                  for (me = '', Q = '', E = se.header.length, pe = 0; pe < E; pe++)
                    Q += this.renderer.tablecell(this.parseInline(se.header[pe].tokens), {
                      header: !0,
                      align: se.align[pe],
                    })
                  for (me += this.renderer.tablerow(Q), ge = '', E = se.rows.length, pe = 0; pe < E; pe++) {
                    for (Y = se.rows[pe], Q = '', B = Y.length, be = 0; be < B; be++)
                      Q += this.renderer.tablecell(this.parseInline(Y[be].tokens), { header: !1, align: se.align[be] })
                    ge += this.renderer.tablerow(Q)
                  }
                  K += this.renderer.table(me, ge)
                  continue
                }
                case 'blockquote': {
                  ;(ge = this.parse(se.tokens)), (K += this.renderer.blockquote(ge))
                  continue
                }
                case 'list': {
                  for (V = se.ordered, ie = se.start, re = se.loose, E = se.items.length, ge = '', pe = 0; pe < E; pe++)
                    (Ie = se.items[pe]),
                      (We = Ie.checked),
                      (ft = Ie.task),
                      (xe = ''),
                      Ie.task &&
                        ((Et = this.renderer.checkbox(We)),
                        re
                          ? Ie.tokens.length > 0 && Ie.tokens[0].type === 'paragraph'
                            ? ((Ie.tokens[0].text = Et + ' ' + Ie.tokens[0].text),
                              Ie.tokens[0].tokens &&
                                Ie.tokens[0].tokens.length > 0 &&
                                Ie.tokens[0].tokens[0].type === 'text' &&
                                (Ie.tokens[0].tokens[0].text = Et + ' ' + Ie.tokens[0].tokens[0].text))
                            : Ie.tokens.unshift({ type: 'text', text: Et })
                          : (xe += Et)),
                      (xe += this.parse(Ie.tokens, re)),
                      (ge += this.renderer.listitem(xe, ft, We))
                  K += this.renderer.list(ge, V, ie)
                  continue
                }
                case 'html': {
                  K += this.renderer.html(se.text)
                  continue
                }
                case 'paragraph': {
                  K += this.renderer.paragraph(this.parseInline(se.tokens))
                  continue
                }
                case 'text': {
                  for (ge = se.tokens ? this.parseInline(se.tokens) : se.text; G + 1 < Hn && N[G + 1].type === 'text'; )
                    (se = N[++G]),
                      (ge +=
                        `
` + (se.tokens ? this.parseInline(se.tokens) : se.text))
                  K += O ? this.renderer.paragraph(ge) : ge
                  continue
                }
                default: {
                  var Zt = 'Token with "' + se.type + '" type was not found.'
                  if (this.options.silent) {
                    console.error(Zt)
                    return
                  } else throw new Error(Zt)
                }
              }
            }
            return K
          }),
          (ee.parseInline = function (N, O) {
            O = O || this.renderer
            var K = '',
              G,
              pe,
              be,
              E = N.length
            for (G = 0; G < E; G++) {
              if (
                ((pe = N[G]),
                this.options.extensions &&
                  this.options.extensions.renderers &&
                  this.options.extensions.renderers[pe.type] &&
                  ((be = this.options.extensions.renderers[pe.type].call({ parser: this }, pe)),
                  be !== !1 ||
                    !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(
                      pe.type
                    )))
              ) {
                K += be || ''
                continue
              }
              switch (pe.type) {
                case 'escape': {
                  K += O.text(pe.text)
                  break
                }
                case 'html': {
                  K += O.html(pe.text)
                  break
                }
                case 'link': {
                  K += O.link(pe.href, pe.title, this.parseInline(pe.tokens, O))
                  break
                }
                case 'image': {
                  K += O.image(pe.href, pe.title, pe.text)
                  break
                }
                case 'strong': {
                  K += O.strong(this.parseInline(pe.tokens, O))
                  break
                }
                case 'em': {
                  K += O.em(this.parseInline(pe.tokens, O))
                  break
                }
                case 'codespan': {
                  K += O.codespan(pe.text)
                  break
                }
                case 'br': {
                  K += O.br()
                  break
                }
                case 'del': {
                  K += O.del(this.parseInline(pe.tokens, O))
                  break
                }
                case 'text': {
                  K += O.text(pe.text)
                  break
                }
                default: {
                  var B = 'Token with "' + pe.type + '" type was not found.'
                  if (this.options.silent) {
                    console.error(B)
                    return
                  } else throw new Error(B)
                }
              }
            }
            return K
          }),
          le
        )
      })()
    function W(le, ee, te) {
      if (typeof le > 'u' || le === null) throw new Error('marked(): input parameter is undefined or null')
      if (typeof le != 'string')
        throw new Error(
          'marked(): input parameter is of type ' + Object.prototype.toString.call(le) + ', string expected'
        )
      if ((typeof ee == 'function' && ((te = ee), (ee = null)), (ee = z({}, W.defaults, ee || {})), T(ee), te)) {
        var N = ee.highlight,
          O
        try {
          O = Ze.lex(le, ee)
        } catch (E) {
          return te(E)
        }
        var K = function (B) {
          var Y
          if (!B)
            try {
              ee.walkTokens && W.walkTokens(O, ee.walkTokens), (Y = ve.parse(O, ee))
            } catch (Q) {
              B = Q
            }
          return (ee.highlight = N), B ? te(B) : te(null, Y)
        }
        if (!N || N.length < 3 || (delete ee.highlight, !O.length)) return K()
        var G = 0
        W.walkTokens(O, function (E) {
          E.type === 'code' &&
            (G++,
            setTimeout(function () {
              N(E.text, E.lang, function (B, Y) {
                if (B) return K(B)
                Y != null && Y !== E.text && ((E.text = Y), (E.escaped = !0)), G--, G === 0 && K()
              })
            }, 0))
        }),
          G === 0 && K()
        return
      }
      function pe(E) {
        if (
          ((E.message += `
Please report this to https://github.com/markedjs/marked.`),
          ee.silent)
        )
          return '<p>An error occurred:</p><pre>' + m(E.message + '', !0) + '</pre>'
        throw E
      }
      try {
        var be = Ze.lex(le, ee)
        if (ee.walkTokens) {
          if (ee.async)
            return Promise.all(W.walkTokens(be, ee.walkTokens))
              .then(function () {
                return ve.parse(be, ee)
              })
              .catch(pe)
          W.walkTokens(be, ee.walkTokens)
        }
        return ve.parse(be, ee)
      } catch (E) {
        pe(E)
      }
    }
    ;(W.options = W.setOptions =
      function (le) {
        return z(W.defaults, le), a(W.defaults), W
      }),
      (W.getDefaults = s),
      (W.defaults = t.defaults),
      (W.use = function () {
        for (var le = arguments.length, ee = new Array(le), te = 0; te < le; te++) ee[te] = arguments[te]
        var N = z.apply(void 0, [{}].concat(ee)),
          O = W.defaults.extensions || { renderers: {}, childTokens: {} },
          K
        ee.forEach(function (G) {
          if (
            (G.extensions &&
              ((K = !0),
              G.extensions.forEach(function (be) {
                if (!be.name) throw new Error('extension name required')
                if (be.renderer) {
                  var E = O.renderers ? O.renderers[be.name] : null
                  E
                    ? (O.renderers[be.name] = function () {
                        for (var B = arguments.length, Y = new Array(B), Q = 0; Q < B; Q++) Y[Q] = arguments[Q]
                        var me = be.renderer.apply(this, Y)
                        return me === !1 && (me = E.apply(this, Y)), me
                      })
                    : (O.renderers[be.name] = be.renderer)
                }
                if (be.tokenizer) {
                  if (!be.level || (be.level !== 'block' && be.level !== 'inline'))
                    throw new Error("extension level must be 'block' or 'inline'")
                  O[be.level] ? O[be.level].unshift(be.tokenizer) : (O[be.level] = [be.tokenizer]),
                    be.start &&
                      (be.level === 'block'
                        ? O.startBlock
                          ? O.startBlock.push(be.start)
                          : (O.startBlock = [be.start])
                        : be.level === 'inline' &&
                          (O.startInline ? O.startInline.push(be.start) : (O.startInline = [be.start])))
                }
                be.childTokens && (O.childTokens[be.name] = be.childTokens)
              })),
            G.renderer &&
              (function () {
                var be = W.defaults.renderer || new ke(),
                  E = function (Q) {
                    var me = be[Q]
                    be[Q] = function () {
                      for (var ge = arguments.length, se = new Array(ge), V = 0; V < ge; V++) se[V] = arguments[V]
                      var ie = G.renderer[Q].apply(be, se)
                      return ie === !1 && (ie = me.apply(be, se)), ie
                    }
                  }
                for (var B in G.renderer) E(B)
                N.renderer = be
              })(),
            G.tokenizer &&
              (function () {
                var be = W.defaults.tokenizer || new ce(),
                  E = function (Q) {
                    var me = be[Q]
                    be[Q] = function () {
                      for (var ge = arguments.length, se = new Array(ge), V = 0; V < ge; V++) se[V] = arguments[V]
                      var ie = G.tokenizer[Q].apply(be, se)
                      return ie === !1 && (ie = me.apply(be, se)), ie
                    }
                  }
                for (var B in G.tokenizer) E(B)
                N.tokenizer = be
              })(),
            G.walkTokens)
          ) {
            var pe = W.defaults.walkTokens
            N.walkTokens = function (be) {
              var E = []
              return E.push(G.walkTokens.call(this, be)), pe && (E = E.concat(pe.call(this, be))), E
            }
          }
          K && (N.extensions = O), W.setOptions(N)
        })
      }),
      (W.walkTokens = function (le, ee) {
        for (
          var te = [],
            N = function () {
              var pe = K.value
              switch (((te = te.concat(ee.call(W, pe))), pe.type)) {
                case 'table': {
                  for (var be = o(pe.header), E; !(E = be()).done; ) {
                    var B = E.value
                    te = te.concat(W.walkTokens(B.tokens, ee))
                  }
                  for (var Y = o(pe.rows), Q; !(Q = Y()).done; )
                    for (var me = Q.value, ge = o(me), se; !(se = ge()).done; ) {
                      var V = se.value
                      te = te.concat(W.walkTokens(V.tokens, ee))
                    }
                  break
                }
                case 'list': {
                  te = te.concat(W.walkTokens(pe.items, ee))
                  break
                }
                default:
                  W.defaults.extensions &&
                  W.defaults.extensions.childTokens &&
                  W.defaults.extensions.childTokens[pe.type]
                    ? W.defaults.extensions.childTokens[pe.type].forEach(function (ie) {
                        te = te.concat(W.walkTokens(pe[ie], ee))
                      })
                    : pe.tokens && (te = te.concat(W.walkTokens(pe.tokens, ee)))
              }
            },
            O = o(le),
            K;
          !(K = O()).done;

        )
          N()
        return te
      }),
      (W.parseInline = function (le, ee) {
        if (typeof le > 'u' || le === null)
          throw new Error('marked.parseInline(): input parameter is undefined or null')
        if (typeof le != 'string')
          throw new Error(
            'marked.parseInline(): input parameter is of type ' +
              Object.prototype.toString.call(le) +
              ', string expected'
          )
        ;(ee = z({}, W.defaults, ee || {})), T(ee)
        try {
          var te = Ze.lexInline(le, ee)
          return ee.walkTokens && W.walkTokens(te, ee.walkTokens), ve.parseInline(te, ee)
        } catch (N) {
          if (
            ((N.message += `
Please report this to https://github.com/markedjs/marked.`),
            ee.silent)
          )
            return '<p>An error occurred:</p><pre>' + m(N.message + '', !0) + '</pre>'
          throw N
        }
      }),
      (W.Parser = ve),
      (W.parser = ve.parse),
      (W.Renderer = ke),
      (W.TextRenderer = st),
      (W.Lexer = Ze),
      (W.lexer = Ze.lex),
      (W.Tokenizer = ce),
      (W.Slugger = tt),
      (W.parse = W)
    var ne = W.options,
      ye = W.setOptions,
      Te = W.use,
      Ne = W.walkTokens,
      qe = W.parseInline,
      bt = W,
      Jt = ve.parse,
      qr = Ze.lex
    ;(t.Lexer = Ze),
      (t.Parser = ve),
      (t.Renderer = ke),
      (t.Slugger = tt),
      (t.TextRenderer = st),
      (t.Tokenizer = ce),
      (t.getDefaults = s),
      (t.lexer = qr),
      (t.marked = W),
      (t.options = ne),
      (t.parse = bt),
      (t.parseInline = qe),
      (t.parser = Jt),
      (t.setOptions = ye),
      (t.use = Te),
      (t.walkTokens = Ne),
      Object.defineProperty(t, '__esModule', { value: !0 })
  })
})
var zY = handleExports(sf => {
  'use strict'
  var _Ie =
    (sf && sf.__awaiter) ||
    function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }
  Object.defineProperty(sf, '__esModule', { value: !0 })
  sf.isBinaryFileSync = sf.isBinaryFile = void 0
  var of = require('fs'),
    y3 = require('util'),
    yIe = y3.promisify(of.stat),
    xIe = y3.promisify(of.open),
    bIe = y3.promisify(of.close),
    xb = 512,
    _3 = class {
      constructor(e, r) {
        ;(this.fileBuffer = e), (this.size = r), (this.offset = 0), (this.error = !1)
      }
      hasError() {
        return this.error
      }
      nextByte() {
        return this.offset === this.size || this.hasError() ? ((this.error = !0), 255) : this.fileBuffer[this.offset++]
      }
      next(e) {
        let r = new Array()
        for (let n = 0; n < e; n++) r[n] = this.nextByte()
        return r
      }
    }
  function v3(t) {
    let e = 0,
      r = 0
    for (; !t.hasError(); ) {
      let n = t.nextByte()
      if (((r = r | ((n & 127) << (7 * e))), !(n & 128))) break
      e++
    }
    return r
  }
  function EIe(t) {
    switch (v3(t) & 7) {
      case 0:
        return v3(t), !0
      case 1:
        return t.next(8), !0
      case 2:
        let n = v3(t)
        return t.next(n), !0
      case 5:
        return t.next(4), !0
    }
    return !1
  }
  function TIe(t, e) {
    let r = new _3(t, e),
      n = 0
    for (;;) {
      if (!EIe(r) && !r.hasError()) return !1
      if (r.hasError()) break
      n++
    }
    return n > 0
  }
  function SIe(t, e) {
    return _Ie(this, void 0, void 0, function* () {
      if (GY(t)) {
        let r = yield yIe(t)
        VY(r)
        let n = yield xIe(t, 'r'),
          i = Buffer.alloc(xb)
        return new Promise((o, s) => {
          of.read(n, i, 0, xb, 0, (a, l, c) => {
            bIe(n), a ? s(a) : o(gw(i, l))
          })
        })
      } else return e === void 0 && (e = t.length), gw(t, e)
    })
  }
  sf.isBinaryFile = SIe
  function CIe(t, e) {
    if (GY(t)) {
      let r = of.statSync(t)
      VY(r)
      let n = of.openSync(t, 'r'),
        i = Buffer.alloc(xb),
        o = of.readSync(n, i, 0, xb, 0)
      return of.closeSync(n), gw(i, o)
    } else return e === void 0 && (e = t.length), gw(t, e)
  }
  sf.isBinaryFileSync = CIe
  function gw(t, e) {
    if (e === 0) return !1
    let r = 0,
      n = Math.min(e, xb)
    if (
      (e >= 3 && t[0] === 239 && t[1] === 187 && t[2] === 191) ||
      (e >= 4 && t[0] === 0 && t[1] === 0 && t[2] === 254 && t[3] === 255) ||
      (e >= 4 && t[0] === 255 && t[1] === 254 && t[2] === 0 && t[3] === 0) ||
      (e >= 4 && t[0] === 132 && t[1] === 49 && t[2] === 149 && t[3] === 51)
    )
      return !1
    if (n >= 5 && t.slice(0, 5).toString() === '%PDF-') return !0
    if ((e >= 2 && t[0] === 254 && t[1] === 255) || (e >= 2 && t[0] === 255 && t[1] === 254)) return !1
    for (let i = 0; i < n; i++) {
      if (t[i] === 0) return !0
      if ((t[i] < 7 || t[i] > 14) && (t[i] < 32 || t[i] > 127)) {
        if (t[i] > 193 && t[i] < 224 && i + 1 < n) {
          if ((i++, t[i] > 127 && t[i] < 192)) continue
        } else if (
          t[i] > 223 &&
          t[i] < 240 &&
          i + 2 < n &&
          (i++, t[i] > 127 && t[i] < 192 && t[i + 1] > 127 && t[i + 1] < 192)
        ) {
          i++
          continue
        }
        if ((r++, i >= 32 && (r * 100) / n > 10)) return !0
      }
    }
    return !!((r * 100) / n > 10 || (r > 1 && TIe(t, n)))
  }
  function GY(t) {
    return typeof t == 'string'
  }
  function VY(t) {
    if (!t.isFile()) throw new Error('Path provided was not a file!')
  }
})
var QueueModule = handleExports((wct, QY) => {
  var Node = class {
      constructor(value) {
        this.value = value
        this.next = undefined
      }
    },
    Queue = class {
      constructor() {
        this.clear()
      }
      enqueue(value) {
        let node = new Node(value)
        this._head ? (this._tail.next = node, this._tail = node) : (this._head = node, this._tail = node)
        this._size++
      }
      dequeue() {
        let node = this._head
        if (node) {
          this._head = this._head.next
          this._size--
          return node.value
        }
      }
      clear() {
        this._head = undefined
        this._tail = undefined
        this._size = 0
      }
      get size() {
        return this._size
      }
      *[Symbol.iterator]() {
        let node = this._head
        while (node) {
          yield node.value
          node = node.next
        }
      }
    }
  QY.exports = Queue
})
var ConcurrencyModule = handleExports((Act, JY) => {
  'use strict'
  var Queue = QueueModule(),
    Concurrency = concurrency => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0))
        throw new TypeError('Expected `concurrency` to be a number from 1 and up')
      let queue = new Queue(),
        activeCount = 0,
        decrementActiveCount = () => {
          activeCount--
          if (queue.size > 0) {
            queue.dequeue()()
          }
        },
        executeAsync = async (asyncFunc, resolve, ...args) => {
          activeCount++
          let promise = (async () => asyncFunc(...args))()
          resolve(promise)
          try {
            await promise
          } catch {}
          decrementActiveCount()
        },
        enqueueAsync = (asyncFunc, resolve, ...args) => {
          queue.enqueue(executeAsync.bind(null, asyncFunc, resolve, ...args))
          (async () => {
            await Promise.resolve()
            if (activeCount < concurrency && queue.size > 0) {
              queue.dequeue()()
            }
          })()
        },
        executeWithLimit = (asyncFunc, ...args) =>
          new Promise(resolve => {
            enqueueAsync(asyncFunc, resolve, ...args)
          })
      return Object.defineProperties(executeWithLimit, {
        activeCount: { get: () => activeCount },
        pendingCount: { get: () => queue.size },
        clearQueue: {
          value: () => {
            queue.clear()
          },
        },
      })
    }
  JY.exports = Concurrency
})
var MQ = handleExports((Rmt, LQ) => {
  var o_ = 1e3,
    s_ = o_ * 60,
    a_ = s_ * 60,
    og = a_ * 24,
    Uwe = og * 7,
    Bwe = og * 365.25
  LQ.exports = function (t, e) {
    e = e || {}
    var r = typeof t
    if (r === 'string' && t.length > 0) return qwe(t)
    if (r === 'number' && isFinite(t)) return e.long ? jwe(t) : Hwe(t)
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(t))
  }
  function qwe(t) {
    if (((t = String(t)), !(t.length > 100))) {
      var e =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          t
        )
      if (e) {
        var r = parseFloat(e[1]),
          n = (e[2] || 'ms').toLowerCase()
        switch (n) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return r * Bwe
          case 'weeks':
          case 'week':
          case 'w':
            return r * Uwe
          case 'days':
          case 'day':
          case 'd':
            return r * og
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return r * a_
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return r * s_
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return r * o_
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return r
          default:
            return
        }
      }
    }
  }
  function Hwe(t) {
    var e = Math.abs(t)
    return e >= og
      ? Math.round(t / og) + 'd'
      : e >= a_
      ? Math.round(t / a_) + 'h'
      : e >= s_
      ? Math.round(t / s_) + 'm'
      : e >= o_
      ? Math.round(t / o_) + 's'
      : t + 'ms'
  }
  function jwe(t) {
    var e = Math.abs(t)
    return e >= og
      ? Gw(t, e, og, 'day')
      : e >= a_
      ? Gw(t, e, a_, 'hour')
      : e >= s_
      ? Gw(t, e, s_, 'minute')
      : e >= o_
      ? Gw(t, e, o_, 'second')
      : t + ' ms'
  }
  function Gw(t, e, r, n) {
    var i = e >= r * 1.5
    return Math.round(t / r) + ' ' + n + (i ? 's' : '')
  }
})
var $3 = handleExports((Dmt, FQ) => {
  function Gwe(t) {
    ;(r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = o),
      (r.enable = i),
      (r.enabled = s),
      (r.humanize = MQ()),
      (r.destroy = c),
      Object.keys(t).forEach(u => {
        r[u] = t[u]
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {})
    function e(u) {
      let p = 0
      for (let d = 0; d < u.length; d++) (p = (p << 5) - p + u.charCodeAt(d)), (p |= 0)
      return r.colors[Math.abs(p) % r.colors.length]
    }
    r.selectColor = e
    function r(u) {
      let p,
        d = null,
        f,
        m
      function h(...g) {
        if (!h.enabled) return
        let v = h,
          _ = Number(new Date()),
          y = _ - (p || _)
        ;(v.diff = y),
          (v.prev = p),
          (v.curr = _),
          (p = _),
          (g[0] = r.coerce(g[0])),
          typeof g[0] != 'string' && g.unshift('%O')
        let b = 0
        ;(g[0] = g[0].replace(/%([a-zA-Z%])/g, (P, U) => {
          if (P === '%%') return '%'
          b++
          let H = r.formatters[U]
          if (typeof H == 'function') {
            let j = g[b]
            ;(P = H.call(v, j)), g.splice(b, 1), b--
          }
          return P
        })),
          r.formatArgs.call(v, g),
          (v.log || r.log).apply(v, g)
      }
      return (
        (h.namespace = u),
        (h.useColors = r.useColors()),
        (h.color = r.selectColor(u)),
        (h.extend = n),
        (h.destroy = r.destroy),
        Object.defineProperty(h, 'enabled', {
          enumerable: !0,
          configurable: !1,
          get: () => (d !== null ? d : (f !== r.namespaces && ((f = r.namespaces), (m = r.enabled(u))), m)),
          set: g => {
            d = g
          },
        }),
        typeof r.init == 'function' && r.init(h),
        h
      )
    }
    function n(u, p) {
      let d = r(this.namespace + (typeof p > 'u' ? ':' : p) + u)
      return (d.log = this.log), d
    }
    function i(u) {
      r.save(u), (r.namespaces = u), (r.names = []), (r.skips = [])
      let p,
        d = (typeof u == 'string' ? u : '').split(/[\s,]+/),
        f = d.length
      for (p = 0; p < f; p++)
        d[p] &&
          ((u = d[p].replace(/\*/g, '.*?')),
          u[0] === '-' ? r.skips.push(new RegExp('^' + u.slice(1) + '$')) : r.names.push(new RegExp('^' + u + '$')))
    }
    function o() {
      let u = [...r.names.map(a), ...r.skips.map(a).map(p => '-' + p)].join(',')
      return r.enable(''), u
    }
    function s(u) {
      if (u[u.length - 1] === '*') return !0
      let p, d
      for (p = 0, d = r.skips.length; p < d; p++) if (r.skips[p].test(u)) return !1
      for (p = 0, d = r.names.length; p < d; p++) if (r.names[p].test(u)) return !0
      return !1
    }
    function a(u) {
      return u
        .toString()
        .substring(2, u.toString().length - 2)
        .replace(/\.\*\?$/, '*')
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u
    }
    function c() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
      )
    }
    return r.enable(r.load()), r
  }
  FQ.exports = Gwe
})
var UQ = handleExports((ca, Vw) => {
  ca.formatArgs = zwe
  ca.save = $we
  ca.load = Wwe
  ca.useColors = Vwe
  ca.storage = Kwe()
  ca.destroy = (() => {
    let t = !1
    return () => {
      t ||
        ((t = !0),
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
        ))
    }
  })()
  ca.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ]
  function Vwe() {
    return typeof window < 'u' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)
      ? !0
      : typeof navigator < 'u' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ? !1
      : (typeof document < 'u' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        (typeof window < 'u' &&
          window.console &&
          (window.console.firebug || (window.console.exception && window.console.table))) ||
        (typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) ||
        (typeof navigator < 'u' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
  }
  function zwe(t) {
    if (
      ((t[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        t[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        Vw.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    let e = 'color: ' + this.color
    t.splice(1, 0, e, 'color: inherit')
    let r = 0,
      n = 0
    t[0].replace(/%[a-zA-Z%]/g, i => {
      i !== '%%' && (r++, i === '%c' && (n = r))
    }),
      t.splice(n, 0, e)
  }
  ca.log = console.debug || console.log || (() => {})
  function $we(t) {
    try {
      t ? ca.storage.setItem('debug', t) : ca.storage.removeItem('debug')
    } catch {}
  }
  function Wwe() {
    let t
    try {
      t = ca.storage.getItem('debug')
    } catch {}
    return !t && typeof process < 'u' && 'env' in process && (t = process.env.DEBUG), t
  }
  function Kwe() {
    try {
      return localStorage
    } catch {}
  }
  Vw.exports = $3()(ca)
  var { formatters: Ywe } = Vw.exports
  Ywe.j = function (t) {
    try {
      return JSON.stringify(t)
    } catch (e) {
      return '[UnexpectedJSONParseError]: ' + e.message
    }
  }
})
var qQ = handleExports((Pmt, BQ) => {
  'use strict'
  BQ.exports = (t, e = process.argv) => {
    let r = t.startsWith('-') ? '' : t.length === 1 ? '-' : '--',
      n = e.indexOf(r + t),
      i = e.indexOf('--')
    return n !== -1 && (i === -1 || n < i)
  }
})
var GQ = handleExports((Nmt, jQ) => {
  'use strict'
  var Qwe = require('os'),
    HQ = require('tty'),
    Oa = qQ(),
    { env: Oi } = process,
    gf
  Oa('no-color') || Oa('no-colors') || Oa('color=false') || Oa('color=never')
    ? (gf = 0)
    : (Oa('color') || Oa('colors') || Oa('color=true') || Oa('color=always')) && (gf = 1)
  'FORCE_COLOR' in Oi &&
    (Oi.FORCE_COLOR === 'true'
      ? (gf = 1)
      : Oi.FORCE_COLOR === 'false'
      ? (gf = 0)
      : (gf = Oi.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(Oi.FORCE_COLOR, 10), 3)))
  function W3(t) {
    return t === 0 ? !1 : { level: t, hasBasic: !0, has256: t >= 2, has16m: t >= 3 }
  }
  function K3(t, e) {
    if (gf === 0) return 0
    if (Oa('color=16m') || Oa('color=full') || Oa('color=truecolor')) return 3
    if (Oa('color=256')) return 2
    if (t && !e && gf === void 0) return 0
    let r = gf || 0
    if (Oi.TERM === 'dumb') return r
    if (process.platform === 'win32') {
      let n = Qwe.release().split('.')
      return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? (Number(n[2]) >= 14931 ? 3 : 2) : 1
    }
    if ('CI' in Oi)
      return ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(n => n in Oi) ||
        Oi.CI_NAME === 'codeship'
        ? 1
        : r
    if ('TEAMCITY_VERSION' in Oi) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Oi.TEAMCITY_VERSION) ? 1 : 0
    if (Oi.COLORTERM === 'truecolor') return 3
    if ('TERM_PROGRAM' in Oi) {
      let n = parseInt((Oi.TERM_PROGRAM_VERSION || '').split('.')[0], 10)
      switch (Oi.TERM_PROGRAM) {
        case 'iTerm.app':
          return n >= 3 ? 3 : 2
        case 'Apple_Terminal':
          return 2
      }
    }
    return /-256(color)?$/i.test(Oi.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Oi.TERM) || 'COLORTERM' in Oi
      ? 1
      : r
  }
  function Xwe(t) {
    let e = K3(t, t && t.isTTY)
    return W3(e)
  }
  jQ.exports = { supportsColor: Xwe, stdout: W3(K3(!0, HQ.isatty(1))), stderr: W3(K3(!0, HQ.isatty(2))) }
})
var zQ = handleExports((to, $w) => {
  var Jwe = require('tty'),
    zw = require('util')
  to.init = oAe
  to.log = rAe
  to.formatArgs = eAe
  to.save = nAe
  to.load = iAe
  to.useColors = Zwe
  to.destroy = zw.deprecate(() => {},
  'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')
  to.colors = [6, 2, 3, 4, 5, 1]
  try {
    let t = GQ()
    t &&
      (t.stderr || t).level >= 2 &&
      (to.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81,
        92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,
        171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214,
        215, 220, 221,
      ])
  } catch {}
  to.inspectOpts = Object.keys(process.env)
    .filter(t => /^debug_/i.test(t))
    .reduce((t, e) => {
      let r = e
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (i, o) => o.toUpperCase()),
        n = process.env[e]
      return (
        /^(yes|on|true|enabled)$/i.test(n)
          ? (n = !0)
          : /^(no|off|false|disabled)$/i.test(n)
          ? (n = !1)
          : n === 'null'
          ? (n = null)
          : (n = Number(n)),
        (t[r] = n),
        t
      )
    }, {})
  function Zwe() {
    return 'colors' in to.inspectOpts ? !!to.inspectOpts.colors : Jwe.isatty(process.stderr.fd)
  }
  function eAe(t) {
    let { namespace: e, useColors: r } = this
    if (r) {
      let n = this.color,
        i = '\x1B[3' + (n < 8 ? n : '8;5;' + n),
        o = `  ${i};1m${e} \x1B[0m`
      ;(t[0] =
        o +
        t[0]
          .split(
            `
`
          )
          .join(
            `
` + o
          )),
        t.push(i + 'm+' + $w.exports.humanize(this.diff) + '\x1B[0m')
    } else t[0] = tAe() + e + ' ' + t[0]
  }
  function tAe() {
    return to.inspectOpts.hideDate ? '' : new Date().toISOString() + ' '
  }
  function rAe(...t) {
    return process.stderr.write(
      zw.format(...t) +
        `
`
    )
  }
  function nAe(t) {
    t ? (process.env.DEBUG = t) : delete process.env.DEBUG
  }
  function iAe() {
    return process.env.DEBUG
  }
  function oAe(t) {
    t.inspectOpts = {}
    let e = Object.keys(to.inspectOpts)
    for (let r = 0; r < e.length; r++) t.inspectOpts[e[r]] = to.inspectOpts[e[r]]
  }
  $w.exports = $3()(to)
  var { formatters: VQ } = $w.exports
  VQ.o = function (t) {
    return (
      (this.inspectOpts.colors = this.useColors),
      zw
        .inspect(t, this.inspectOpts)
        .split(
          `
`
        )
        .map(e => e.trim())
        .join(' ')
    )
  }
  VQ.O = function (t) {
    return (this.inspectOpts.colors = this.useColors), zw.inspect(t, this.inspectOpts)
  }
})
var La = handleExports((kmt, Y3) => {
  typeof process > 'u' || process.type === 'renderer' || process.browser === !0 || process.__nwjs
    ? (Y3.exports = UQ())
    : (Y3.exports = zQ())
})
var t8 = handleExports((Mmt, YQ) => {
  var Nb = typeof performance == 'object' && performance && typeof performance.now == 'function' ? performance : Date,
    sAe = typeof AbortController == 'function',
    Ww = sAe
      ? AbortController
      : class {
          constructor() {
            this.signal = new $Q()
          }
          abort() {
            this.signal.dispatchEvent('abort')
          }
        },
    aAe = typeof AbortSignal == 'function',
    cAe = typeof Ww.AbortSignal == 'function',
    $Q = aAe
      ? AbortSignal
      : cAe
      ? Ww.AbortController
      : class {
          constructor() {
            ;(this.aborted = !1), (this._listeners = [])
          }
          dispatchEvent(e) {
            if (e === 'abort') {
              this.aborted = !0
              let r = { type: e, target: this }
              this.onabort(r), this._listeners.forEach(n => n(r), this)
            }
          }
          onabort() {}
          addEventListener(e, r) {
            e === 'abort' && this._listeners.push(r)
          }
          removeEventListener(e, r) {
            e === 'abort' && (this._listeners = this._listeners.filter(n => n !== r))
          }
        },
    Z3 = new Set(),
    Q3 = (t, e) => {
      let r = `LRU_CACHE_OPTION_${t}`
      Kw(r) && e8(r, `${t} option`, `options.${e}`, l_)
    },
    X3 = (t, e) => {
      let r = `LRU_CACHE_METHOD_${t}`
      if (Kw(r)) {
        let { prototype: n } = l_,
          { get: i } = Object.getOwnPropertyDescriptor(n, t)
        e8(r, `${t} method`, `cache.${e}()`, i)
      }
    },
    lAe = (t, e) => {
      let r = `LRU_CACHE_PROPERTY_${t}`
      if (Kw(r)) {
        let { prototype: n } = l_,
          { get: i } = Object.getOwnPropertyDescriptor(n, t)
        e8(r, `${t} property`, `cache.${e}`, i)
      }
    },
    WQ = (...t) => {
      typeof process == 'object' && process && typeof process.emitWarning == 'function'
        ? process.emitWarning(...t)
        : console.error(...t)
    },
    Kw = t => !Z3.has(t),
    e8 = (t, e, r, n) => {
      Z3.add(t)
      let i = `The ${e} is deprecated. Please use ${r} instead.`
      WQ(i, 'DeprecationWarning', t, n)
    },
    sg = t => t && t === Math.floor(t) && t > 0 && isFinite(t),
    KQ = t =>
      sg(t)
        ? t <= Math.pow(2, 8)
          ? Uint8Array
          : t <= Math.pow(2, 16)
          ? Uint16Array
          : t <= Math.pow(2, 32)
          ? Uint32Array
          : t <= Number.MAX_SAFE_INTEGER
          ? c_
          : null
        : null,
    c_ = class extends Array {
      constructor(e) {
        super(e), this.fill(0)
      }
    },
    J3 = class {
      constructor(e) {
        if (e === 0) return []
        let r = KQ(e)
        ;(this.heap = new r(e)), (this.length = 0)
      }
      push(e) {
        this.heap[this.length++] = e
      }
      pop() {
        return this.heap[--this.length]
      }
    },
    l_ = class t {
      constructor(e = {}) {
        let {
            max: r = 0,
            ttl: n,
            ttlResolution: i = 1,
            ttlAutopurge: o,
            updateAgeOnGet: s,
            updateAgeOnHas: a,
            allowStale: l,
            dispose: c,
            disposeAfter: u,
            noDisposeOnSet: p,
            noUpdateTTL: d,
            maxSize: f = 0,
            sizeCalculation: m,
            fetchMethod: h,
            fetchContext: g,
            noDeleteOnFetchRejection: v,
            noDeleteOnStaleGet: _,
          } = e,
          { length: y, maxAge: b, stale: x } = e instanceof t ? {} : e
        if (r !== 0 && !sg(r)) throw new TypeError('max option must be a nonnegative integer')
        let P = r ? KQ(r) : Array
        if (!P) throw new Error('invalid max value: ' + r)
        if (((this.max = r), (this.maxSize = f), (this.sizeCalculation = m || y), this.sizeCalculation)) {
          if (!this.maxSize) throw new TypeError('cannot set sizeCalculation without setting maxSize')
          if (typeof this.sizeCalculation != 'function') throw new TypeError('sizeCalculation set to non-function')
        }
        if (((this.fetchMethod = h || null), this.fetchMethod && typeof this.fetchMethod != 'function'))
          throw new TypeError('fetchMethod must be a function if specified')
        if (((this.fetchContext = g), !this.fetchMethod && g !== void 0))
          throw new TypeError('cannot set fetchContext without fetchMethod')
        if (
          ((this.keyMap = new Map()),
          (this.keyList = new Array(r).fill(null)),
          (this.valList = new Array(r).fill(null)),
          (this.next = new P(r)),
          (this.prev = new P(r)),
          (this.head = 0),
          (this.tail = 0),
          (this.free = new J3(r)),
          (this.initialFill = 1),
          (this.size = 0),
          typeof c == 'function' && (this.dispose = c),
          typeof u == 'function'
            ? ((this.disposeAfter = u), (this.disposed = []))
            : ((this.disposeAfter = null), (this.disposed = null)),
          (this.noDisposeOnSet = !!p),
          (this.noUpdateTTL = !!d),
          (this.noDeleteOnFetchRejection = !!v),
          this.maxSize !== 0)
        ) {
          if (!sg(this.maxSize)) throw new TypeError('maxSize must be a positive integer if specified')
          this.initializeSizeTracking()
        }
        if (
          ((this.allowStale = !!l || !!x),
          (this.noDeleteOnStaleGet = !!_),
          (this.updateAgeOnGet = !!s),
          (this.updateAgeOnHas = !!a),
          (this.ttlResolution = sg(i) || i === 0 ? i : 1),
          (this.ttlAutopurge = !!o),
          (this.ttl = n || b || 0),
          this.ttl)
        ) {
          if (!sg(this.ttl)) throw new TypeError('ttl must be a positive integer if specified')
          this.initializeTTLTracking()
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0)
          throw new TypeError('At least one of max, maxSize, or ttl is required')
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          let U = 'LRU_CACHE_UNBOUNDED'
          Kw(U) &&
            (Z3.add(U),
            WQ(
              'TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.',
              'UnboundedCacheWarning',
              U,
              t
            ))
        }
        x && Q3('stale', 'allowStale'), b && Q3('maxAge', 'ttl'), y && Q3('length', 'sizeCalculation')
      }
      getRemainingTTL(e) {
        return this.has(e, { updateAgeOnHas: !1 }) ? 1 / 0 : 0
      }
      initializeTTLTracking() {
        ;(this.ttls = new c_(this.max)),
          (this.starts = new c_(this.max)),
          (this.setItemTTL = (n, i, o = Nb.now()) => {
            if (((this.starts[n] = i !== 0 ? o : 0), (this.ttls[n] = i), i !== 0 && this.ttlAutopurge)) {
              let s = setTimeout(() => {
                this.isStale(n) && this.delete(this.keyList[n])
              }, i + 1)
              s.unref && s.unref()
            }
          }),
          (this.updateItemAge = n => {
            this.starts[n] = this.ttls[n] !== 0 ? Nb.now() : 0
          })
        let e = 0,
          r = () => {
            let n = Nb.now()
            if (this.ttlResolution > 0) {
              e = n
              let i = setTimeout(() => (e = 0), this.ttlResolution)
              i.unref && i.unref()
            }
            return n
          }
        ;(this.getRemainingTTL = n => {
          let i = this.keyMap.get(n)
          return i === void 0
            ? 0
            : this.ttls[i] === 0 || this.starts[i] === 0
            ? 1 / 0
            : this.starts[i] + this.ttls[i] - (e || r())
        }),
          (this.isStale = n => this.ttls[n] !== 0 && this.starts[n] !== 0 && (e || r()) - this.starts[n] > this.ttls[n])
      }
      updateItemAge(e) {}
      setItemTTL(e, r, n) {}
      isStale(e) {
        return !1
      }
      initializeSizeTracking() {
        ;(this.calculatedSize = 0),
          (this.sizes = new c_(this.max)),
          (this.removeItemSize = e => {
            ;(this.calculatedSize -= this.sizes[e]), (this.sizes[e] = 0)
          }),
          (this.requireSize = (e, r, n, i) => {
            if (!sg(n))
              if (i) {
                if (typeof i != 'function') throw new TypeError('sizeCalculation must be a function')
                if (((n = i(r, e)), !sg(n)))
                  throw new TypeError('sizeCalculation return invalid (expect positive integer)')
              } else throw new TypeError('invalid size value (must be positive integer)')
            return n
          }),
          (this.addItemSize = (e, r) => {
            this.sizes[e] = r
            let n = this.maxSize - this.sizes[e]
            for (; this.calculatedSize > n; ) this.evict(!0)
            this.calculatedSize += this.sizes[e]
          })
      }
      removeItemSize(e) {}
      addItemSize(e, r) {}
      requireSize(e, r, n, i) {
        if (n || i) throw new TypeError('cannot set size without setting maxSize on cache')
      }
      *indexes({ allowStale: e = this.allowStale } = {}) {
        if (this.size)
          for (let r = this.tail; !(!this.isValidIndex(r) || ((e || !this.isStale(r)) && (yield r), r === this.head)); )
            r = this.prev[r]
      }
      *rindexes({ allowStale: e = this.allowStale } = {}) {
        if (this.size)
          for (let r = this.head; !(!this.isValidIndex(r) || ((e || !this.isStale(r)) && (yield r), r === this.tail)); )
            r = this.next[r]
      }
      isValidIndex(e) {
        return this.keyMap.get(this.keyList[e]) === e
      }
      *entries() {
        for (let e of this.indexes()) yield [this.keyList[e], this.valList[e]]
      }
      *rentries() {
        for (let e of this.rindexes()) yield [this.keyList[e], this.valList[e]]
      }
      *keys() {
        for (let e of this.indexes()) yield this.keyList[e]
      }
      *rkeys() {
        for (let e of this.rindexes()) yield this.keyList[e]
      }
      *values() {
        for (let e of this.indexes()) yield this.valList[e]
      }
      *rvalues() {
        for (let e of this.rindexes()) yield this.valList[e]
      }
      [Symbol.iterator]() {
        return this.entries()
      }
      find(e, r = {}) {
        for (let n of this.indexes()) if (e(this.valList[n], this.keyList[n], this)) return this.get(this.keyList[n], r)
      }
      forEach(e, r = this) {
        for (let n of this.indexes()) e.call(r, this.valList[n], this.keyList[n], this)
      }
      rforEach(e, r = this) {
        for (let n of this.rindexes()) e.call(r, this.valList[n], this.keyList[n], this)
      }
      get prune() {
        return X3('prune', 'purgeStale'), this.purgeStale
      }
      purgeStale() {
        let e = !1
        for (let r of this.rindexes({ allowStale: !0 })) this.isStale(r) && (this.delete(this.keyList[r]), (e = !0))
        return e
      }
      dump() {
        let e = []
        for (let r of this.indexes({ allowStale: !0 })) {
          let n = this.keyList[r],
            i = this.valList[r],
            s = { value: this.isBackgroundFetch(i) ? i.__staleWhileFetching : i }
          if (this.ttls) {
            s.ttl = this.ttls[r]
            let a = Nb.now() - this.starts[r]
            s.start = Math.floor(Date.now() - a)
          }
          this.sizes && (s.size = this.sizes[r]), e.unshift([n, s])
        }
        return e
      }
      load(e) {
        this.clear()
        for (let [r, n] of e) {
          if (n.start) {
            let i = Date.now() - n.start
            n.start = Nb.now() - i
          }
          this.set(r, n.value, n)
        }
      }
      dispose(e, r, n) {}
      set(
        e,
        r,
        {
          ttl: n = this.ttl,
          start: i,
          noDisposeOnSet: o = this.noDisposeOnSet,
          size: s = 0,
          sizeCalculation: a = this.sizeCalculation,
          noUpdateTTL: l = this.noUpdateTTL,
        } = {}
      ) {
        if (((s = this.requireSize(e, r, s, a)), this.maxSize && s > this.maxSize)) return this
        let c = this.size === 0 ? void 0 : this.keyMap.get(e)
        if (c === void 0)
          (c = this.newIndex()),
            (this.keyList[c] = e),
            (this.valList[c] = r),
            this.keyMap.set(e, c),
            (this.next[this.tail] = c),
            (this.prev[c] = this.tail),
            (this.tail = c),
            this.size++,
            this.addItemSize(c, s),
            (l = !1)
        else {
          let u = this.valList[c]
          r !== u &&
            (this.isBackgroundFetch(u)
              ? u.__abortController.abort()
              : o || (this.dispose(u, e, 'set'), this.disposeAfter && this.disposed.push([u, e, 'set'])),
            this.removeItemSize(c),
            (this.valList[c] = r),
            this.addItemSize(c, s)),
            this.moveToTail(c)
        }
        if (
          (n !== 0 && this.ttl === 0 && !this.ttls && this.initializeTTLTracking(),
          l || this.setItemTTL(c, n, i),
          this.disposeAfter)
        )
          for (; this.disposed.length; ) this.disposeAfter(...this.disposed.shift())
        return this
      }
      newIndex() {
        return this.size === 0
          ? this.tail
          : this.size === this.max && this.max !== 0
          ? this.evict(!1)
          : this.free.length !== 0
          ? this.free.pop()
          : this.initialFill++
      }
      pop() {
        if (this.size) {
          let e = this.valList[this.head]
          return this.evict(!0), e
        }
      }
      evict(e) {
        let r = this.head,
          n = this.keyList[r],
          i = this.valList[r]
        return (
          this.isBackgroundFetch(i)
            ? i.__abortController.abort()
            : (this.dispose(i, n, 'evict'), this.disposeAfter && this.disposed.push([i, n, 'evict'])),
          this.removeItemSize(r),
          e && ((this.keyList[r] = null), (this.valList[r] = null), this.free.push(r)),
          (this.head = this.next[r]),
          this.keyMap.delete(n),
          this.size--,
          r
        )
      }
      has(e, { updateAgeOnHas: r = this.updateAgeOnHas } = {}) {
        let n = this.keyMap.get(e)
        return n !== void 0 && !this.isStale(n) ? (r && this.updateItemAge(n), !0) : !1
      }
      peek(e, { allowStale: r = this.allowStale } = {}) {
        let n = this.keyMap.get(e)
        if (n !== void 0 && (r || !this.isStale(n))) {
          let i = this.valList[n]
          return this.isBackgroundFetch(i) ? i.__staleWhileFetching : i
        }
      }
      backgroundFetch(e, r, n, i) {
        let o = r === void 0 ? void 0 : this.valList[r]
        if (this.isBackgroundFetch(o)) return o
        let s = new Ww(),
          a = { signal: s.signal, options: n, context: i },
          l = d => (s.signal.aborted || this.set(e, d, a.options), d),
          c = d => {
            if (
              (this.valList[r] === p &&
                (!n.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0
                  ? this.delete(e)
                  : (this.valList[r] = p.__staleWhileFetching)),
              p.__returned === p)
            )
              throw d
          },
          u = d => d(this.fetchMethod(e, o, a)),
          p = new Promise(u).then(l, c)
        return (
          (p.__abortController = s),
          (p.__staleWhileFetching = o),
          (p.__returned = null),
          r === void 0 ? (this.set(e, p, a.options), (r = this.keyMap.get(e))) : (this.valList[r] = p),
          p
        )
      }
      isBackgroundFetch(e) {
        return (
          e &&
          typeof e == 'object' &&
          typeof e.then == 'function' &&
          Object.prototype.hasOwnProperty.call(e, '__staleWhileFetching') &&
          Object.prototype.hasOwnProperty.call(e, '__returned') &&
          (e.__returned === e || e.__returned === null)
        )
      }
      async fetch(
        e,
        {
          allowStale: r = this.allowStale,
          updateAgeOnGet: n = this.updateAgeOnGet,
          noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
          ttl: o = this.ttl,
          noDisposeOnSet: s = this.noDisposeOnSet,
          size: a = 0,
          sizeCalculation: l = this.sizeCalculation,
          noUpdateTTL: c = this.noUpdateTTL,
          noDeleteOnFetchRejection: u = this.noDeleteOnFetchRejection,
          fetchContext: p = this.fetchContext,
          forceRefresh: d = !1,
        } = {}
      ) {
        if (!this.fetchMethod) return this.get(e, { allowStale: r, updateAgeOnGet: n, noDeleteOnStaleGet: i })
        let f = {
            allowStale: r,
            updateAgeOnGet: n,
            noDeleteOnStaleGet: i,
            ttl: o,
            noDisposeOnSet: s,
            size: a,
            sizeCalculation: l,
            noUpdateTTL: c,
            noDeleteOnFetchRejection: u,
          },
          m = this.keyMap.get(e)
        if (m === void 0) {
          let h = this.backgroundFetch(e, m, f, p)
          return (h.__returned = h)
        } else {
          let h = this.valList[m]
          if (this.isBackgroundFetch(h))
            return r && h.__staleWhileFetching !== void 0 ? h.__staleWhileFetching : (h.__returned = h)
          if (!d && !this.isStale(m)) return this.moveToTail(m), n && this.updateItemAge(m), h
          let g = this.backgroundFetch(e, m, f, p)
          return r && g.__staleWhileFetching !== void 0 ? g.__staleWhileFetching : (g.__returned = g)
        }
      }
      get(
        e,
        {
          allowStale: r = this.allowStale,
          updateAgeOnGet: n = this.updateAgeOnGet,
          noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
        } = {}
      ) {
        let o = this.keyMap.get(e)
        if (o !== void 0) {
          let s = this.valList[o],
            a = this.isBackgroundFetch(s)
          return this.isStale(o)
            ? a
              ? r
                ? s.__staleWhileFetching
                : void 0
              : (i || this.delete(e), r ? s : void 0)
            : a
            ? void 0
            : (this.moveToTail(o), n && this.updateItemAge(o), s)
        }
      }
      connect(e, r) {
        ;(this.prev[r] = e), (this.next[e] = r)
      }
      moveToTail(e) {
        e !== this.tail &&
          (e === this.head ? (this.head = this.next[e]) : this.connect(this.prev[e], this.next[e]),
          this.connect(this.tail, e),
          (this.tail = e))
      }
      get del() {
        return X3('del', 'delete'), this.delete
      }
      delete(e) {
        let r = !1
        if (this.size !== 0) {
          let n = this.keyMap.get(e)
          if (n !== void 0)
            if (((r = !0), this.size === 1)) this.clear()
            else {
              this.removeItemSize(n)
              let i = this.valList[n]
              this.isBackgroundFetch(i)
                ? i.__abortController.abort()
                : (this.dispose(i, e, 'delete'), this.disposeAfter && this.disposed.push([i, e, 'delete'])),
                this.keyMap.delete(e),
                (this.keyList[n] = null),
                (this.valList[n] = null),
                n === this.tail
                  ? (this.tail = this.prev[n])
                  : n === this.head
                  ? (this.head = this.next[n])
                  : ((this.next[this.prev[n]] = this.next[n]), (this.prev[this.next[n]] = this.prev[n])),
                this.size--,
                this.free.push(n)
            }
        }
        if (this.disposed) for (; this.disposed.length; ) this.disposeAfter(...this.disposed.shift())
        return r
      }
      clear() {
        for (let e of this.rindexes({ allowStale: !0 })) {
          let r = this.valList[e]
          if (this.isBackgroundFetch(r)) r.__abortController.abort()
          else {
            let n = this.keyList[e]
            this.dispose(r, n, 'delete'), this.disposeAfter && this.disposed.push([r, n, 'delete'])
          }
        }
        if (
          (this.keyMap.clear(),
          this.valList.fill(null),
          this.keyList.fill(null),
          this.ttls && (this.ttls.fill(0), this.starts.fill(0)),
          this.sizes && this.sizes.fill(0),
          (this.head = 0),
          (this.tail = 0),
          (this.initialFill = 1),
          (this.free.length = 0),
          (this.calculatedSize = 0),
          (this.size = 0),
          this.disposed)
        )
          for (; this.disposed.length; ) this.disposeAfter(...this.disposed.shift())
      }
      get reset() {
        return X3('reset', 'clear'), this.clear
      }
      get length() {
        return lAe('length', 'size'), this.size
      }
      static get AbortController() {
        return Ww
      }
      static get AbortSignal() {
        return $Q
      }
    }
  YQ.exports = l_
})
var i8 = handleExports((Fmt, QQ) => {
  'use strict'
  var kb = class extends Error {
      constructor(e, r) {
        super(e), (this.type = r)
      }
      get name() {
        return this.constructor.name
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
    },
    r8 = class extends kb {
      constructor(e, r, n) {
        super(e, r), n && ((this.code = n.code), (this.errno = n.errno), (this.erroredSysCall = n.syscall))
      }
    },
    n8 = class extends kb {
      constructor(e, r = 'aborted') {
        super(e, r)
      }
    }
  QQ.exports = { FetchBaseError: kb, FetchError: r8, AbortError: n8 }
})
var up = handleExports((Umt, JQ) => {
  'use strict'
  var {
      constants: { MAX_LENGTH: uAe },
    } = require('buffer'),
    { pipeline: Yw, PassThrough: pAe } = require('stream'),
    { promisify: dAe } = require('util'),
    {
      createGunzip: fAe,
      createInflate: mAe,
      createBrotliDecompress: hAe,
      constants: { Z_SYNC_FLUSH: XQ },
    } = require('zlib'),
    gAe = La()('helix-fetch:utils'),
    vAe = dAe(Yw),
    _Ae = (t, e) =>
      t === 204 || t === 304 || +e['content-length'] == 0
        ? !1
        : /^\s*(?:(x-)?deflate|(x-)?gzip|br)\s*$/.test(e['content-encoding']),
    yAe = (t, e, r, n) => {
      if (!_Ae(t, e)) return r
      let i = o => {
        o && (gAe(`encountered error while decoding stream: ${o}`), n(o))
      }
      switch (e['content-encoding'].trim()) {
        case 'gzip':
        case 'x-gzip':
          return Yw(r, fAe({ flush: XQ, finishFlush: XQ }), i)
        case 'deflate':
        case 'x-deflate':
          return Yw(r, mAe(), i)
        case 'br':
          return Yw(r, hAe(), i)
        default:
          return r
      }
    },
    xAe = t => {
      if (!t || typeof t != 'object' || Object.prototype.toString.call(t) !== '[object Object]') return !1
      if (Object.getPrototypeOf(t) === null) return !0
      let e = t
      for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
      return Object.getPrototypeOf(t) === e
    },
    Qw = (t, e) => {
      if (Buffer.isBuffer(t)) return t.length
      switch (typeof t) {
        case 'string':
          return t.length * 2
        case 'boolean':
          return 4
        case 'number':
          return 8
        case 'symbol':
          return Symbol.keyFor(t) ? Symbol.keyFor(t).length * 2 : (t.toString().length - 8) * 2
        case 'object':
          return Array.isArray(t) ? bAe(t, e) : EAe(t, e)
        default:
          return 0
      }
    },
    bAe = (t, e) => (e.add(t), t.map(r => (e.has(r) ? 0 : Qw(r, e))).reduce((r, n) => r + n, 0)),
    EAe = (t, e) => {
      if (t == null) return 0
      e.add(t)
      let r = 0,
        n = []
      for (let i in t) n.push(i)
      return (
        n.push(...Object.getOwnPropertySymbols(t)),
        n.forEach(i => {
          if (((r += Qw(i, e)), typeof t[i] == 'object' && t[i] !== null)) {
            if (e.has(t[i])) return
            e.add(t[i])
          }
          r += Qw(t[i], e)
        }),
        r
      )
    },
    TAe = t => Qw(t, new WeakSet()),
    SAe = async t => {
      let e = new pAe(),
        r = 0,
        n = []
      return (
        e.on('data', i => {
          if (r + i.length > uAe) throw new Error('Buffer.constants.MAX_SIZE exceeded')
          n.push(i), (r += i.length)
        }),
        await vAe(t, e),
        Buffer.concat(n, r)
      )
    }
  JQ.exports = { decodeStream: yAe, isPlainObject: xAe, sizeof: TAe, streamToBuffer: SAe }
})
var Jw = handleExports((Bmt, rX) => {
  'use strict'
  var { PassThrough: ZQ, Readable: pp } = require('stream'),
    {
      types: { isAnyArrayBuffer: tX },
    } = require('util'),
    { FetchError: CAe, FetchBaseError: IAe } = i8(),
    { streamToBuffer: wAe } = up(),
    AAe = Buffer.alloc(0),
    Ma = Symbol('Body internals'),
    RAe = t => t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength),
    eX = async t => {
      if (t[Ma].disturbed) throw new TypeError('Already read')
      if (t[Ma].error) throw new TypeError(`Stream had error: ${t[Ma].error.message}`)
      t[Ma].disturbed = !0
      let { stream: e } = t[Ma]
      return e === null ? AAe : wAe(e)
    },
    Xw = class {
      constructor(e) {
        let r
        e == null
          ? (r = null)
          : e instanceof URLSearchParams
          ? (r = pp.from(e.toString()))
          : e instanceof pp
          ? (r = e)
          : Buffer.isBuffer(e)
          ? (r = pp.from(e))
          : tX(e)
          ? (r = pp.from(Buffer.from(e)))
          : typeof e == 'string' || e instanceof String
          ? (r = pp.from(e))
          : (r = pp.from(String(e))),
          (this[Ma] = { stream: r, disturbed: !1, error: null }),
          e instanceof pp &&
            r.on('error', n => {
              let i =
                n instanceof IAe
                  ? n
                  : new CAe(`Invalid response body while trying to fetch ${this.url}: ${n.message}`, 'system', n)
              this[Ma].error = i
            })
      }
      get body() {
        return this[Ma].stream
      }
      get bodyUsed() {
        return this[Ma].disturbed
      }
      async buffer() {
        return eX(this)
      }
      async arrayBuffer() {
        return RAe(await this.buffer())
      }
      async text() {
        return (await eX(this)).toString()
      }
      async json() {
        return JSON.parse(await this.text())
      }
    }
  Object.defineProperties(Xw.prototype, {
    body: { enumerable: !0 },
    bodyUsed: { enumerable: !0 },
    arrayBuffer: { enumerable: !0 },
    json: { enumerable: !0 },
    text: { enumerable: !0 },
  })
  var DAe = t => {
      if (t[Ma].disturbed) throw new TypeError('Cannot clone: already read')
      let { stream: e } = t[Ma],
        r = e
      if (e instanceof pp) {
        r = new ZQ()
        let n = new ZQ()
        e.pipe(r), e.pipe(n), (t[Ma].stream = n)
      }
      return r
    },
    PAe = t =>
      t === null
        ? null
        : typeof t == 'string'
        ? 'text/plain; charset=utf-8'
        : t instanceof URLSearchParams
        ? 'application/x-www-form-urlencoded; charset=utf-8'
        : Buffer.isBuffer(t) || tX(t) || t instanceof pp
        ? null
        : 'text/plain; charset=utf-8'
  rX.exports = { Body: Xw, cloneStream: DAe, guessContentType: PAe }
})
var u_ = handleExports((qmt, sX) => {
  'use strict'
  var { validateHeaderName: nX, validateHeaderValue: iX } = require('http'),
    { isPlainObject: NAe } = up(),
    dp = Symbol('Headers internals'),
    Ob = t => {
      let e = typeof t != 'string' ? String(t) : t
      if (typeof nX == 'function') nX(e)
      else if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(e)) {
        let r = new TypeError(`Header name must be a valid HTTP token [${e}]`)
        throw (Object.defineProperty(r, 'code', { value: 'ERR_INVALID_HTTP_TOKEN' }), r)
      }
      return e.toLowerCase()
    },
    oX = (t, e) => {
      let r = typeof t != 'string' ? String(t) : t
      if (typeof iX == 'function') iX(e, r)
      else if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(r)) {
        let n = new TypeError(`Invalid character in header content ["${e}"]`)
        throw (Object.defineProperty(n, 'code', { value: 'ERR_INVALID_CHAR' }), n)
      }
      return r
    },
    Zw = class t {
      constructor(e = {}) {
        if (((this[dp] = { map: new Map() }), e instanceof t))
          e.forEach((r, n) => {
            this.append(n, r)
          })
        else if (Array.isArray(e))
          e.forEach(([r, n]) => {
            this.append(r, n)
          })
        else if (NAe(e)) for (let [r, n] of Object.entries(e)) this.append(r, n)
      }
      set(e, r) {
        this[dp].map.set(Ob(e), oX(r, e))
      }
      has(e) {
        return this[dp].map.has(Ob(e))
      }
      get(e) {
        let r = this[dp].map.get(Ob(e))
        return r === void 0 ? null : r
      }
      append(e, r) {
        let n = Ob(e),
          i = oX(r, e),
          o = this[dp].map.get(n)
        this[dp].map.set(n, o ? `${o}, ${i}` : i)
      }
      delete(e) {
        this[dp].map.delete(Ob(e))
      }
      forEach(e, r) {
        for (let n of this.keys()) e.call(r, this.get(n), n)
      }
      keys() {
        return Array.from(this[dp].map.keys()).sort()
      }
      *values() {
        for (let e of this.keys()) yield this.get(e)
      }
      *entries() {
        for (let e of this.keys()) yield [e, this.get(e)]
      }
      [Symbol.iterator]() {
        return this.entries()
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
      plain() {
        return Object.fromEntries(this[dp].map)
      }
    }
  Object.defineProperties(
    Zw.prototype,
    ['append', 'delete', 'entries', 'forEach', 'get', 'has', 'keys', 'set', 'values'].reduce(
      (t, e) => ((t[e] = { enumerable: !0 }), t),
      {}
    )
  )
  sX.exports = { Headers: Zw }
})
var o8 = handleExports((Hmt, aX) => {
  'use strict'
  var { EventEmitter: kAe } = require('events'),
    Nc = Symbol('AbortSignal internals'),
    p_ = class {
      constructor() {
        this[Nc] = { eventEmitter: new kAe(), onabort: null, aborted: !1 }
      }
      get aborted() {
        return this[Nc].aborted
      }
      get onabort() {
        return this[Nc].onabort
      }
      set onabort(e) {
        this[Nc].onabort = e
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
      removeEventListener(e, r) {
        this[Nc].eventEmitter.removeListener(e, r)
      }
      addEventListener(e, r) {
        this[Nc].eventEmitter.on(e, r)
      }
      dispatchEvent(e) {
        let r = { type: e, target: this },
          n = `on${e}`
        typeof this[Nc][n] == 'function' && this[n](r), this[Nc].eventEmitter.emit(e, r)
      }
      fire() {
        ;(this[Nc].aborted = !0), this.dispatchEvent('abort')
      }
    }
  Object.defineProperties(p_.prototype, {
    addEventListener: { enumerable: !0 },
    removeEventListener: { enumerable: !0 },
    dispatchEvent: { enumerable: !0 },
    aborted: { enumerable: !0 },
    onabort: { enumerable: !0 },
  })
  var tA = class extends p_ {
    constructor(e) {
      if (!Number.isInteger(e)) throw new TypeError(`Expected an integer, got ${typeof e}`)
      super(),
        (this[Nc].timerId = setTimeout(() => {
          this.fire()
        }, e))
    }
    clear() {
      clearTimeout(this[Nc].timerId)
    }
  }
  Object.defineProperties(tA.prototype, { clear: { enumerable: !0 } })
  var eA = Symbol('AbortController internals'),
    rA = class {
      constructor() {
        this[eA] = { signal: new p_() }
      }
      get signal() {
        return this[eA].signal
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
      abort() {
        this[eA].signal.aborted || this[eA].signal.fire()
      }
    }
  Object.defineProperties(rA.prototype, { signal: { enumerable: !0 }, abort: { enumerable: !0 } })
  aX.exports = { AbortController: rA, AbortSignal: p_, TimeoutSignal: tA }
})
var Lb = handleExports((jmt, uX) => {
  'use strict'
  var { randomBytes: OAe } = require('crypto'),
    { Readable: LAe } = require('stream'),
    a8 = t =>
      typeof t == 'object' &&
      ['arrayBuffer', 'stream', 'text', 'slice', 'constructor'].map(e => typeof t[e]).filter(e => e !== 'function')
        .length === 0 &&
      typeof t.type == 'string' &&
      typeof t.size == 'number' &&
      /^(Blob|File)$/.test(t[Symbol.toStringTag]),
    MAe = t =>
      t != null &&
      typeof t == 'object' &&
      ['append', 'delete', 'get', 'getAll', 'has', 'set', 'keys', 'values', 'entries', 'constructor']
        .map(e => typeof t[e])
        .filter(e => e !== 'function').length === 0 &&
      t[Symbol.toStringTag] === 'FormData',
    cX = t => `--${t}--\r
\r
`,
    lX = (t, e, r) => {
      let n = ''
      return (
        (n += `--${t}\r
`),
        (n += `Content-Disposition: form-data; name="${e}"`),
        a8(r) &&
          ((n += `; filename="${r.name}"\r
`),
          (n += `Content-Type: ${r.type || 'application/octet-stream'}`)),
        `${n}\r
\r
`
      )
    }
  async function* FAe(t, e) {
    for (let [r, n] of t)
      yield lX(e, r, n),
        a8(n) ? yield* n.stream() : yield n,
        yield `\r
`
    yield cX(e)
  }
  var UAe = (t, e) => {
      let r = 0
      for (let [n, i] of t)
        (r += Buffer.byteLength(lX(e, n, i))),
          (r += a8(i) ? i.size : Buffer.byteLength(String(i))),
          (r += Buffer.byteLength(`\r
`))
      return (r += Buffer.byteLength(cX(e))), r
    },
    s8 = class {
      constructor(e) {
        ;(this.fd = e), (this.boundary = OAe(8).toString('hex'))
      }
      length() {
        return typeof this._length > 'u' && (this._length = UAe(this.fd, this.boundary)), this._length
      }
      contentType() {
        return `multipart/form-data; boundary=${this.boundary}`
      }
      stream() {
        return LAe.from(FAe(this.fd, this.boundary))
      }
    }
  uX.exports = { isFormData: MAe, FormDataSerializer: s8 }
})
var dX = handleExports((Gmt, pX) => {
  'use strict'
  var { AbortSignal: BAe } = o8(),
    { Body: qAe, cloneStream: HAe, guessContentType: jAe } = Jw(),
    { Headers: GAe } = u_(),
    { isPlainObject: VAe } = up(),
    { isFormData: zAe, FormDataSerializer: $Ae } = Lb(),
    WAe = 20,
    vf = Symbol('Request internals'),
    nA = class t extends qAe {
      constructor(e, r = {}) {
        let n = e instanceof t ? e : null,
          i = n ? new URL(n.url) : new URL(e),
          o = r.method || (n && n.method) || 'GET'
        if (((o = o.toUpperCase()), (r.body != null || (n && n.body !== null)) && ['GET', 'HEAD'].includes(o)))
          throw new TypeError('Request with GET/HEAD method cannot have body')
        let s = r.body || (n && n.body ? HAe(n) : null),
          a = new GAe(r.headers || (n && n.headers) || {})
        if (zAe(s) && !a.has('content-type')) {
          let p = new $Ae(s)
          ;(s = p.stream()),
            a.set('content-type', p.contentType()),
            !a.has('transfer-encoding') && !a.has('content-length') && a.set('content-length', p.length())
        }
        if (!a.has('content-type'))
          if (VAe(s)) (s = JSON.stringify(s)), a.set('content-type', 'application/json')
          else {
            let p = jAe(s)
            p && a.set('content-type', p)
          }
        super(s)
        let l = n ? n.signal : null
        if (('signal' in r && (l = r.signal), l && !(l instanceof BAe)))
          throw new TypeError('signal needs to be an instance of AbortSignal')
        let c = r.redirect || (n && n.redirect) || 'follow'
        if (!['follow', 'error', 'manual'].includes(c)) throw new TypeError(`'${c}' is not a valid redirect option`)
        let u = r.cache || (n && n.cache) || 'default'
        if (!['default', 'no-store', 'reload', 'no-cache', 'force-cache', 'only-if-cached'].includes(u))
          throw new TypeError(`'${u}' is not a valid cache option`)
        ;(this[vf] = { init: { ...r }, method: o, redirect: c, cache: u, headers: a, parsedURL: i, signal: l }),
          r.follow === void 0
            ? !n || n.follow === void 0
              ? (this.follow = WAe)
              : (this.follow = n.follow)
            : (this.follow = r.follow),
          (this.counter = r.counter || (n && n.counter) || 0),
          r.compress === void 0
            ? !n || n.compress === void 0
              ? (this.compress = !0)
              : (this.compress = n.compress)
            : (this.compress = r.compress),
          r.decode === void 0
            ? !n || n.decode === void 0
              ? (this.decode = !0)
              : (this.decode = n.decode)
            : (this.decode = r.decode)
      }
      get method() {
        return this[vf].method
      }
      get url() {
        return this[vf].parsedURL.toString()
      }
      get headers() {
        return this[vf].headers
      }
      get redirect() {
        return this[vf].redirect
      }
      get cache() {
        return this[vf].cache
      }
      get signal() {
        return this[vf].signal
      }
      clone() {
        return new t(this)
      }
      get init() {
        return this[vf].init
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
    }
  Object.defineProperties(nA.prototype, {
    method: { enumerable: !0 },
    url: { enumerable: !0 },
    headers: { enumerable: !0 },
    redirect: { enumerable: !0 },
    cache: { enumerable: !0 },
    clone: { enumerable: !0 },
    signal: { enumerable: !0 },
  })
  pX.exports = { Request: nA }
})
var c8 = handleExports((Vmt, fX) => {
  'use strict'
  var { Body: KAe, cloneStream: YAe, guessContentType: QAe } = Jw(),
    { Headers: XAe } = u_(),
    { isPlainObject: JAe } = up(),
    { isFormData: ZAe, FormDataSerializer: e2e } = Lb(),
    kc = Symbol('Response internals'),
    iA = class t extends KAe {
      constructor(e = null, r = {}) {
        let n = new XAe(r.headers),
          i = e
        if (ZAe(i) && !n.has('content-type')) {
          let o = new e2e(i)
          ;(i = o.stream()),
            n.set('content-type', o.contentType()),
            !n.has('transfer-encoding') && !n.has('content-length') && n.set('content-length', o.length())
        }
        if (i !== null && !n.has('content-type'))
          if (JAe(i)) (i = JSON.stringify(i)), n.set('content-type', 'application/json')
          else {
            let o = QAe(i)
            o && n.set('content-type', o)
          }
        super(i),
          (this[kc] = {
            url: r.url,
            status: r.status || 200,
            statusText: r.statusText || '',
            headers: n,
            httpVersion: r.httpVersion,
            decoded: r.decoded,
            counter: r.counter,
          })
      }
      get url() {
        return this[kc].url || ''
      }
      get status() {
        return this[kc].status
      }
      get statusText() {
        return this[kc].statusText
      }
      get ok() {
        return this[kc].status >= 200 && this[kc].status < 300
      }
      get redirected() {
        return this[kc].counter > 0
      }
      get headers() {
        return this[kc].headers
      }
      get httpVersion() {
        return this[kc].httpVersion
      }
      get decoded() {
        return this[kc].decoded
      }
      static redirect(e, r = 302) {
        if (![301, 302, 303, 307, 308].includes(r)) throw new RangeError('Invalid status code')
        return new t(null, { headers: { location: new URL(e).toString() }, status: r })
      }
      clone() {
        if (this.bodyUsed) throw new TypeError('Cannot clone: already read')
        return new t(YAe(this), { ...this[kc] })
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
    }
  Object.defineProperties(iA.prototype, {
    url: { enumerable: !0 },
    status: { enumerable: !0 },
    ok: { enumerable: !0 },
    redirected: { enumerable: !0 },
    statusText: { enumerable: !0 },
    headers: { enumerable: !0 },
    clone: { enumerable: !0 },
  })
  fX.exports = { Response: iA }
})
var hX = handleExports(($mt, mX) => {
  'use strict'
  var t2e = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]),
    r2e = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]),
    n2e = new Set([500, 502, 503, 504]),
    i2e = {
      date: !0,
      connection: !0,
      'keep-alive': !0,
      'proxy-authenticate': !0,
      'proxy-authorization': !0,
      te: !0,
      trailer: !0,
      'transfer-encoding': !0,
      upgrade: !0,
    },
    o2e = { 'content-length': !0, 'content-encoding': !0, 'transfer-encoding': !0, 'content-range': !0 }
  function ag(t) {
    let e = parseInt(t, 10)
    return isFinite(e) ? e : 0
  }
  function s2e(t) {
    return t ? n2e.has(t.status) : !0
  }
  function l8(t) {
    let e = {}
    if (!t) return e
    let r = t.trim().split(/,/)
    for (let n of r) {
      let [i, o] = n.split(/=/, 2)
      e[i.trim()] = o === void 0 ? !0 : o.trim().replace(/^"|"$/g, '')
    }
    return e
  }
  function a2e(t) {
    let e = []
    for (let r in t) {
      let n = t[r]
      e.push(n === !0 ? r : r + '=' + n)
    }
    if (e.length) return e.join(', ')
  }
  mX.exports = class {
    constructor(
      e,
      r,
      { shared: n, cacheHeuristic: i, immutableMinTimeToLive: o, ignoreCargoCult: s, _fromObject: a } = {}
    ) {
      if (a) {
        this._fromObject(a)
        return
      }
      if (!r || !r.headers) throw Error('Response headers missing')
      this._assertRequestHasHeaders(e),
        (this._responseTime = this.now()),
        (this._isShared = n !== !1),
        (this._cacheHeuristic = i !== void 0 ? i : 0.1),
        (this._immutableMinTtl = o !== void 0 ? o : 24 * 3600 * 1e3),
        (this._status = 'status' in r ? r.status : 200),
        (this._resHeaders = r.headers),
        (this._rescc = l8(r.headers['cache-control'])),
        (this._method = 'method' in e ? e.method : 'GET'),
        (this._url = e.url),
        (this._host = e.headers.host),
        (this._noAuthorization = !e.headers.authorization),
        (this._reqHeaders = r.headers.vary ? e.headers : null),
        (this._reqcc = l8(e.headers['cache-control'])),
        s &&
          'pre-check' in this._rescc &&
          'post-check' in this._rescc &&
          (delete this._rescc['pre-check'],
          delete this._rescc['post-check'],
          delete this._rescc['no-cache'],
          delete this._rescc['no-store'],
          delete this._rescc['must-revalidate'],
          (this._resHeaders = Object.assign({}, this._resHeaders, { 'cache-control': a2e(this._rescc) })),
          delete this._resHeaders.expires,
          delete this._resHeaders.pragma),
        r.headers['cache-control'] == null && /no-cache/.test(r.headers.pragma) && (this._rescc['no-cache'] = !0)
    }
    now() {
      return Date.now()
    }
    storable() {
      return !!(
        !this._reqcc['no-store'] &&
        (this._method === 'GET' ||
          this._method === 'HEAD' ||
          (this._method === 'POST' && this._hasExplicitExpiration())) &&
        r2e.has(this._status) &&
        !this._rescc['no-store'] &&
        (!this._isShared || !this._rescc.private) &&
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) &&
        (this._resHeaders.expires ||
          this._rescc['max-age'] ||
          (this._isShared && this._rescc['s-maxage']) ||
          this._rescc.public ||
          t2e.has(this._status))
      )
    }
    _hasExplicitExpiration() {
      return (this._isShared && this._rescc['s-maxage']) || this._rescc['max-age'] || this._resHeaders.expires
    }
    _assertRequestHasHeaders(e) {
      if (!e || !e.headers) throw Error('Request headers missing')
    }
    satisfiesWithoutRevalidation(e) {
      this._assertRequestHasHeaders(e)
      let r = l8(e.headers['cache-control'])
      return r['no-cache'] ||
        /no-cache/.test(e.headers.pragma) ||
        (r['max-age'] && this.age() > r['max-age']) ||
        (r['min-fresh'] && this.timeToLive() < 1e3 * r['min-fresh']) ||
        (this.stale() &&
          !(
            r['max-stale'] &&
            !this._rescc['must-revalidate'] &&
            (r['max-stale'] === !0 || r['max-stale'] > this.age() - this.maxAge())
          ))
        ? !1
        : this._requestMatches(e, !1)
    }
    _requestMatches(e, r) {
      return (
        (!this._url || this._url === e.url) &&
        this._host === e.headers.host &&
        (!e.method || this._method === e.method || (r && e.method === 'HEAD')) &&
        this._varyMatches(e)
      )
    }
    _allowsStoringAuthenticated() {
      return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage']
    }
    _varyMatches(e) {
      if (!this._resHeaders.vary) return !0
      if (this._resHeaders.vary === '*') return !1
      let r = this._resHeaders.vary
        .trim()
        .toLowerCase()
        .split(/\s*,\s*/)
      for (let n of r) if (e.headers[n] !== this._reqHeaders[n]) return !1
      return !0
    }
    _copyWithoutHopByHopHeaders(e) {
      let r = {}
      for (let n in e) i2e[n] || (r[n] = e[n])
      if (e.connection) {
        let n = e.connection.trim().split(/\s*,\s*/)
        for (let i of n) delete r[i]
      }
      if (r.warning) {
        let n = r.warning.split(/,/).filter(i => !/^\s*1[0-9][0-9]/.test(i))
        n.length ? (r.warning = n.join(',').trim()) : delete r.warning
      }
      return r
    }
    responseHeaders() {
      let e = this._copyWithoutHopByHopHeaders(this._resHeaders),
        r = this.age()
      return (
        r > 3600 * 24 &&
          !this._hasExplicitExpiration() &&
          this.maxAge() > 3600 * 24 &&
          (e.warning = (e.warning ? `${e.warning}, ` : '') + '113 - "rfc7234 5.5.4"'),
        (e.age = `${Math.round(r)}`),
        (e.date = new Date(this.now()).toUTCString()),
        e
      )
    }
    date() {
      let e = Date.parse(this._resHeaders.date)
      return isFinite(e) ? e : this._responseTime
    }
    age() {
      let e = this._ageValue(),
        r = (this.now() - this._responseTime) / 1e3
      return e + r
    }
    _ageValue() {
      return ag(this._resHeaders.age)
    }
    maxAge() {
      if (
        !this.storable() ||
        this._rescc['no-cache'] ||
        (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) ||
        this._resHeaders.vary === '*'
      )
        return 0
      if (this._isShared) {
        if (this._rescc['proxy-revalidate']) return 0
        if (this._rescc['s-maxage']) return ag(this._rescc['s-maxage'])
      }
      if (this._rescc['max-age']) return ag(this._rescc['max-age'])
      let e = this._rescc.immutable ? this._immutableMinTtl : 0,
        r = this.date()
      if (this._resHeaders.expires) {
        let n = Date.parse(this._resHeaders.expires)
        return Number.isNaN(n) || n < r ? 0 : Math.max(e, (n - r) / 1e3)
      }
      if (this._resHeaders['last-modified']) {
        let n = Date.parse(this._resHeaders['last-modified'])
        if (isFinite(n) && r > n) return Math.max(e, ((r - n) / 1e3) * this._cacheHeuristic)
      }
      return e
    }
    timeToLive() {
      let e = this.maxAge() - this.age(),
        r = e + ag(this._rescc['stale-if-error']),
        n = e + ag(this._rescc['stale-while-revalidate'])
      return Math.max(0, e, r, n) * 1e3
    }
    stale() {
      return this.maxAge() <= this.age()
    }
    _useStaleIfError() {
      return this.maxAge() + ag(this._rescc['stale-if-error']) > this.age()
    }
    useStaleWhileRevalidate() {
      return this.maxAge() + ag(this._rescc['stale-while-revalidate']) > this.age()
    }
    static fromObject(e) {
      return new this(void 0, void 0, { _fromObject: e })
    }
    _fromObject(e) {
      if (this._responseTime) throw Error('Reinitialized')
      if (!e || e.v !== 1) throw Error('Invalid serialization')
      ;(this._responseTime = e.t),
        (this._isShared = e.sh),
        (this._cacheHeuristic = e.ch),
        (this._immutableMinTtl = e.imm !== void 0 ? e.imm : 24 * 3600 * 1e3),
        (this._status = e.st),
        (this._resHeaders = e.resh),
        (this._rescc = e.rescc),
        (this._method = e.m),
        (this._url = e.u),
        (this._host = e.h),
        (this._noAuthorization = e.a),
        (this._reqHeaders = e.reqh),
        (this._reqcc = e.reqcc)
    }
    toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc,
      }
    }
    revalidationHeaders(e) {
      this._assertRequestHasHeaders(e)
      let r = this._copyWithoutHopByHopHeaders(e.headers)
      if ((delete r['if-range'], !this._requestMatches(e, !0) || !this.storable()))
        return delete r['if-none-match'], delete r['if-modified-since'], r
      if (
        (this._resHeaders.etag &&
          (r['if-none-match'] = r['if-none-match']
            ? `${r['if-none-match']}, ${this._resHeaders.etag}`
            : this._resHeaders.etag),
        r['accept-ranges'] || r['if-match'] || r['if-unmodified-since'] || (this._method && this._method != 'GET'))
      ) {
        if ((delete r['if-modified-since'], r['if-none-match'])) {
          let i = r['if-none-match'].split(/,/).filter(o => !/^\s*W\//.test(o))
          i.length ? (r['if-none-match'] = i.join(',').trim()) : delete r['if-none-match']
        }
      } else
        this._resHeaders['last-modified'] &&
          !r['if-modified-since'] &&
          (r['if-modified-since'] = this._resHeaders['last-modified'])
      return r
    }
    revalidatedPolicy(e, r) {
      if ((this._assertRequestHasHeaders(e), this._useStaleIfError() && s2e(r)))
        return { modified: !1, matches: !1, policy: this }
      if (!r || !r.headers) throw Error('Response headers missing')
      let n = !1
      if (
        (r.status !== void 0 && r.status != 304
          ? (n = !1)
          : r.headers.etag && !/^\s*W\//.test(r.headers.etag)
          ? (n = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, '') === r.headers.etag)
          : this._resHeaders.etag && r.headers.etag
          ? (n = this._resHeaders.etag.replace(/^\s*W\//, '') === r.headers.etag.replace(/^\s*W\//, ''))
          : this._resHeaders['last-modified']
          ? (n = this._resHeaders['last-modified'] === r.headers['last-modified'])
          : !this._resHeaders.etag &&
            !this._resHeaders['last-modified'] &&
            !r.headers.etag &&
            !r.headers['last-modified'] &&
            (n = !0),
        !n)
      )
        return { policy: new this.constructor(e, r), modified: r.status != 304, matches: !1 }
      let i = {}
      for (let s in this._resHeaders) i[s] = s in r.headers && !o2e[s] ? r.headers[s] : this._resHeaders[s]
      let o = Object.assign({}, r, { status: this._status, method: this._method, headers: i })
      return {
        policy: new this.constructor(e, o, {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl,
        }),
        modified: !1,
        matches: !0,
      }
    }
  }
})
var yX = handleExports((Wmt, _X) => {
  'use strict'
  var c2e = hX(),
    { Headers: l2e } = u_(),
    gX = t => ({ url: t.url, method: t.method, headers: t.headers.plain() }),
    vX = t => ({ status: t.status, headers: t.headers.plain() }),
    u8 = class {
      constructor(e, r, n) {
        this.policy = new c2e(gX(e), vX(r), n)
      }
      storable() {
        return this.policy.storable()
      }
      satisfiesWithoutRevalidation(e) {
        return this.policy.satisfiesWithoutRevalidation(gX(e))
      }
      responseHeaders(e) {
        return new l2e(this.policy.responseHeaders(vX(e)))
      }
      timeToLive() {
        return this.policy.timeToLive()
      }
    }
  _X.exports = u8
})
var EX = handleExports((Kmt, bX) => {
  'use strict'
  var { Readable: u2e } = require('stream'),
    { Headers: xX } = u_(),
    { Response: p2e } = c8(),
    _f = Symbol('CacheableResponse internals'),
    d2e = t => t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength),
    p8 = class t extends p2e {
      constructor(e, r) {
        super(e, r)
        let n = new xX(r.headers)
        this[_f] = { headers: n, bufferedBody: e }
      }
      get headers() {
        return this[_f].headers
      }
      set headers(e) {
        if (e instanceof xX) this[_f].headers = e
        else throw new TypeError('instance of Headers expected')
      }
      get body() {
        return u2e.from(this[_f].bufferedBody)
      }
      get bodyUsed() {
        return !1
      }
      async buffer() {
        return this[_f].bufferedBody
      }
      async arrayBuffer() {
        return d2e(this[_f].bufferedBody)
      }
      async text() {
        return this[_f].bufferedBody.toString()
      }
      async json() {
        return JSON.parse(await this.text())
      }
      clone() {
        let { url: e, status: r, statusText: n, headers: i, httpVersion: o, decoded: s, counter: a } = this
        return new t(this[_f].bufferedBody, {
          url: e,
          status: r,
          statusText: n,
          headers: i,
          httpVersion: o,
          decoded: s,
          counter: a,
        })
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name
      }
    },
    f2e = async t => {
      let e = await t.buffer(),
        { url: r, status: n, statusText: i, headers: o, httpVersion: s, decoded: a, counter: l } = t
      return new p8(e, { url: r, status: n, statusText: i, headers: o, httpVersion: s, decoded: a, counter: l })
    }
  bX.exports = { cacheableResponse: f2e }
})
var oA = handleExports((Ymt, TX) => {
  'use strict'
  var d8 = class extends Error {
    get name() {
      return this.constructor.name
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name
    }
  }
  TX.exports = { RequestAbortedError: d8 }
})
var AX = handleExports((Qmt, wX) => {
  'use strict'
  var CX = require('http'),
    IX = require('https'),
    { Readable: m2e } = require('stream'),
    fp = La()('helix-fetch:h1'),
    { RequestAbortedError: SX } = oA(),
    { decodeStream: h2e } = up(),
    g2e = (t, e) => {
      let {
        h1: r,
        options: { h1: n, rejectUnauthorized: i },
      } = t
      return e === 'https:'
        ? r.httpsAgent
          ? r.httpsAgent
          : n || typeof i == 'boolean'
          ? ((r.httpsAgent = new IX.Agent(typeof i == 'boolean' ? { ...(n || {}), rejectUnauthorized: i } : n)),
            r.httpsAgent)
          : void 0
        : r.httpAgent
        ? r.httpAgent
        : n
        ? ((r.httpAgent = new CX.Agent(n)), r.httpAgent)
        : void 0
    },
    v2e = t => {
      t.h1 = {}
    },
    _2e = async ({ h1: t }) => {
      t.httpAgent && (fp('resetContext: destroying httpAgent'), t.httpAgent.destroy(), delete t.httpAgent),
        t.httpsAgent && (fp('resetContext: destroying httpsAgent'), t.httpsAgent.destroy(), delete t.httpsAgent)
    },
    y2e = (t, e, r) => {
      let { statusCode: n, statusMessage: i, httpVersion: o, httpVersionMajor: s, httpVersionMinor: a, headers: l } = t,
        c = e ? h2e(n, l, t, r) : t
      return {
        statusCode: n,
        statusText: i,
        httpVersion: o,
        httpVersionMajor: s,
        httpVersionMinor: a,
        headers: l,
        readable: c,
        decoded: !!(e && c !== t),
      }
    },
    x2e = async (t, e, r) => {
      let { request: n } = e.protocol === 'https:' ? IX : CX,
        i = g2e(t, e.protocol),
        o = { ...r, agent: i },
        { socket: s, body: a } = o
      return (
        s &&
          (delete o.socket,
          s.assigned ||
            ((s.assigned = !0),
            i
              ? (o.agent = new Proxy(i, {
                  get: (l, c) =>
                    c === 'createConnection' && !s.inUse
                      ? (u, p) => {
                          fp(`agent reusing socket #${s.id} (${s.servername})`), (s.inUse = !0), p(null, s)
                        }
                      : l[c],
                }))
              : (o.createConnection = (l, c) => {
                  fp(`reusing socket #${s.id} (${s.servername})`), (s.inUse = !0), c(null, s)
                }))),
        new Promise((l, c) => {
          fp(`${o.method} ${e.href}`)
          let u,
            { signal: p } = o,
            d = () => {
              p.removeEventListener('abort', d),
                s &&
                  !s.inUse &&
                  (fp(`discarding redundant socket used for ALPN: #${s.id} ${s.servername}`), s.destroy()),
                c(new SX()),
                u && u.abort()
            }
          if (p) {
            if (p.aborted) {
              c(new SX())
              return
            }
            p.addEventListener('abort', d)
          }
          ;(u = n(e, o)),
            u.once('response', f => {
              p && p.removeEventListener('abort', d),
                s &&
                  !s.inUse &&
                  (fp(`discarding redundant socket used for ALPN: #${s.id} ${s.servername}`), s.destroy()),
                l(y2e(f, o.decode, c))
            }),
            u.once('error', f => {
              p && p.removeEventListener('abort', d),
                s &&
                  !s.inUse &&
                  (fp(`discarding redundant socket used for ALPN: #${s.id} ${s.servername}`), s.destroy()),
                u.aborted || (fp(`${o.method} ${e.href} failed with: ${f.message}`), u.abort(), c(f))
            }),
            a instanceof m2e ? a.pipe(u) : (a && u.write(a), u.end())
        })
      )
    }
  wX.exports = { request: x2e, setupContext: v2e, resetContext: _2e }
})
var NX = handleExports((Xmt, PX) => {
  'use strict'
  var { connect: b2e, constants: E2e } = require('http2'),
    { Readable: T2e } = require('stream'),
    tn = La()('helix-fetch:h2'),
    { RequestAbortedError: RX } = oA(),
    { decodeStream: S2e } = up(),
    { NGHTTP2_CANCEL: Mb } = E2e,
    C2e = 5 * 60 * 1e3,
    I2e = 5e3,
    w2e = t => {
      t.h2 = { sessionCache: {} }
    },
    A2e = async ({ h2: t }) =>
      Promise.all(
        Object.values(t.sessionCache).map(
          e =>
            new Promise(r => {
              e.on('close', r),
                tn(
                  `resetContext: destroying session (socket #${e.socket && e.socket.id}, ${
                    e.socket && e.socket.servername
                  })`
                ),
                e.destroy()
            })
        )
      ),
    DX = (t, e, r, n = () => {}) => {
      let i = { ...t },
        o = i[':status']
      delete i[':status']
      let s = r ? S2e(o, t, e, n) : e
      return {
        statusCode: o,
        statusText: '',
        httpVersion: '2.0',
        httpVersionMajor: 2,
        httpVersionMinor: 0,
        headers: i,
        readable: s,
        decoded: !!(r && s !== e),
      }
    },
    R2e = (t, e, r, n, i, o) => {
      let {
          options: {
            h2: { pushPromiseHandler: s, pushHandler: a, pushedStreamIdleTimeout: l = I2e },
          },
        } = t,
        c = i[':path'],
        u = `${e}${c}`
      tn(`received PUSH_PROMISE: ${u}, stream #${n.id}, headers: ${JSON.stringify(i)}, flags: ${o}`),
        s &&
          s(u, i, () => {
            n.close(Mb)
          }),
        n.on('push', (p, d) => {
          tn(`received push headers for ${e}${c}, stream #${n.id}, headers: ${JSON.stringify(p)}, flags: ${d}`),
            n.setTimeout(l, () => {
              tn(`closing pushed stream #${n.id} after ${l} ms of inactivity`), n.close(Mb)
            }),
            a && a(u, i, DX(p, n, r))
        }),
        n.on('aborted', () => {
          tn(`pushed stream #${n.id} aborted`)
        }),
        n.on('error', p => {
          tn(`pushed stream #${n.id} encountered error: ${p}`)
        }),
        n.on('frameError', (p, d, f) => {
          tn(`pushed stream #${n.id} encountered frameError: type: ${p}, code: ${d}, id: ${f}`)
        })
    },
    D2e = async (t, e, r) => {
      let { origin: n, pathname: i, search: o, hash: s } = e,
        a = `${i}${o}${s}`,
        {
          options: { h2: l = {} },
          h2: { sessionCache: c },
        } = t,
        { idleSessionTimeout: u = C2e, pushPromiseHandler: p, pushHandler: d } = l,
        f = { ...r },
        { method: m, headers: h, socket: g, body: v, decode: _ } = f
      return (
        g && delete f.socket,
        h.host && ((h[':authority'] = h.host), delete h.host),
        new Promise((y, b) => {
          let x = c[n]
          if (!x || x.closed || x.destroyed) {
            let M = !(t.options.rejectUnauthorized === !1 || l.rejectUnauthorized === !1),
              F = { ...l, rejectUnauthorized: M }
            g &&
              !g.inUse &&
              (F.createConnection = () => (tn(`reusing socket #${g.id} (${g.servername})`), (g.inUse = !0), g)),
              (x = b2e(n, { ...F, settings: { enablePush: !!(p || d) } })),
              x.setMaxListeners(1e3),
              x.setTimeout(u, () => {
                tn(`closing session ${n} after ${u} ms of inactivity`), x.close()
              }),
              x.once('connect', () => {
                tn(`session ${n} established`), tn(`caching session ${n}`), (c[n] = x)
              }),
              x.on('localSettings', q => {
                tn(`session ${n} localSettings: ${JSON.stringify(q)}`)
              }),
              x.on('remoteSettings', q => {
                tn(`session ${n} remoteSettings: ${JSON.stringify(q)}`)
              }),
              x.once('close', () => {
                tn(`session ${n} closed`), c[n] === x && (tn(`discarding cached session ${n}`), delete c[n])
              }),
              x.once('error', q => {
                tn(`session ${n} encountered error: ${q}`),
                  c[n] === x && (tn(`discarding cached session ${n}`), delete c[n])
              }),
              x.on('frameError', (q, L, S) => {
                tn(`session ${n} encountered frameError: type: ${q}, code: ${L}, id: ${S}`)
              }),
              x.once('goaway', (q, L, S) => {
                tn(
                  `session ${n} received GOAWAY frame: errorCode: ${q}, lastStreamID: ${L}, opaqueData: ${
                    S ? S.toString() : void 0
                  }`
                )
              }),
              x.on('stream', (q, L, S) => {
                R2e(t, n, _, q, L, S)
              })
          } else
            g &&
              g.id !== x.socket.id &&
              !g.inUse &&
              (tn(`discarding redundant socket used for ALPN: #${g.id} ${g.servername}`), g.destroy())
          tn(`${m} ${e.host}${a}`)
          let P,
            { signal: U } = f,
            H = () => {
              U.removeEventListener('abort', H), b(new RX()), P && P.close(Mb)
            }
          if (U) {
            if (U.aborted) {
              b(new RX())
              return
            }
            U.addEventListener('abort', H)
          }
          let j = M => {
            tn(`session ${n} encountered error during ${f.method} ${e.href}: ${M}`), b(M)
          }
          x.once('error', j),
            (P = x.request({ ':method': m, ':path': a, ...h })),
            P.once('response', M => {
              x.off('error', j), U && U.removeEventListener('abort', H), y(DX(M, P, f.decode, b))
            }),
            P.once('error', M => {
              x.off('error', j),
                U && U.removeEventListener('abort', H),
                P.rstCode !== Mb && (tn(`${f.method} ${e.href} failed with: ${M.message}`), P.close(Mb), b(M))
            }),
            P.once('frameError', (M, F, z) => {
              x.off('error', j),
                tn(`encountered frameError during ${f.method} ${e.href}: type: ${M}, code: ${F}, id: ${z}`)
            }),
            P.on('push', (M, F) => {
              tn(`received 'push' event: headers: ${JSON.stringify(M)}, flags: ${F}`)
            }),
            v instanceof T2e ? v.pipe(P) : (v && P.write(v), P.end())
        })
      )
    }
  PX.exports = { request: D2e, setupContext: w2e, resetContext: A2e }
})
var OX = handleExports((Jmt, kX) => {
  'use strict'
  var { EventEmitter: P2e } = require('events'),
    N2e = () => {
      let t = {},
        e = new P2e()
      return (
        e.setMaxListeners(0),
        {
          acquire: r =>
            new Promise(n => {
              if (!t[r]) {
                ;(t[r] = !0), n()
                return
              }
              let i = o => {
                t[r] || ((t[r] = !0), e.removeListener(r, i), n(o))
              }
              e.on(r, i)
            }),
          release: (r, n) => {
            Reflect.deleteProperty(t, r), setImmediate(() => e.emit(r, n))
          },
        }
      )
    }
  kX.exports = N2e
})
var LX = handleExports((Zmt, k2e) => {
  k2e.exports = {
    name: '@adobe/helix-fetch',
    version: '3.1.1',
    description: 'Light-weight Fetch implementation transparently supporting both HTTP/1(.1) and HTTP/2',
    main: 'src/index.js',
    scripts: { test: 'nyc mocha', lint: './node_modules/.bin/eslint .', 'semantic-release': 'semantic-release' },
    mocha: {
      timeout: '5000',
      recursive: 'true',
      reporter: 'mocha-multi-reporters',
      'reporter-options': 'configFile=.mocha-multi.json',
    },
    engines: { node: '>=12.0' },
    types: 'src/index.d.ts',
    exports: { import: './src/index.mjs', require: './src/index.js' },
    repository: { type: 'git', url: 'https://github.com/adobe/helix-fetch' },
    author: '',
    license: 'Apache-2.0',
    bugs: { url: 'https://github.com/adobe/helix-fetch/issues' },
    homepage: 'https://github.com/adobe/helix-fetch#readme',
    keywords: [
      'fetch',
      'whatwg',
      'Fetch API',
      'http',
      'https',
      'http2',
      'h2',
      'promise',
      'async',
      'request',
      'RFC 7234',
      '7234',
      'caching',
      'cache',
    ],
    dependencies: { debug: '4.3.4', 'http-cache-semantics': '^4.1.1', 'lru-cache': '7.13.1' },
    devDependencies: {
      '@adobe/eslint-config-helix': '1.3.2',
      '@semantic-release/changelog': '6.0.1',
      '@semantic-release/git': '10.0.1',
      chai: '4.3.6',
      'chai-as-promised': '7.1.1',
      'chai-bytes': '0.1.2',
      'chai-iterator': '3.0.2',
      eslint: '8.21.0',
      'eslint-plugin-header': '3.1.1',
      'eslint-plugin-import': '2.26.0',
      'formdata-node': '4.3.3',
      'lint-staged': '13.0.3',
      mocha: '10.0.0',
      'mocha-multi-reporters': '1.5.1',
      nock: '13.2.9',
      nyc: '15.1.0',
      'parse-cache-control': '1.0.1',
      pem: '1.14.6',
      proxy: '^1.0.2',
      'semantic-release': '19.0.3',
      sinon: '14.0.0',
      'stream-buffers': '3.0.2',
      tunnel: '^0.0.6',
    },
    'lint-staged': { '*.js': 'eslint' },
    config: {
      commitizen: { path: 'node_modules/cz-conventional-changelog' },
      ghooks: { 'pre-commit': 'npx lint-staged' },
    },
  }
})
var qX = handleExports((eht, BX) => {
  'use strict'
  var { Readable: O2e } = require('stream'),
    L2e = require('tls'),
    {
      types: { isAnyArrayBuffer: M2e },
    } = require('util'),
    F2e = t8(),
    f8 = La()('helix-fetch:core'),
    { RequestAbortedError: sA } = oA(),
    m8 = AX(),
    aA = NX(),
    U2e = OX(),
    { isPlainObject: B2e } = up(),
    { isFormData: q2e, FormDataSerializer: H2e } = Lb(),
    { version: j2e } = LX(),
    h8 = 'h2',
    g8 = 'h2c',
    v8 = 'http/1.0',
    cg = 'http/1.1',
    G2e = 100,
    V2e = 60 * 60 * 1e3,
    z2e = [h8, cg, v8],
    $2e = `helix-fetch/${j2e}`,
    W2e = { method: 'GET', compress: !0, decode: !0 },
    MX = 0,
    FX = U2e(),
    UX = (t, e) =>
      new Promise((r, n) => {
        let { signal: i } = e,
          o,
          s = () => {
            i.removeEventListener('abort', s)
            let c = new sA()
            n(c), o && o.destroy(c)
          }
        if (i) {
          if (i.aborted) {
            n(new sA())
            return
          }
          i.addEventListener('abort', s)
        }
        let a = +t.port || 443,
          l = c => {
            i && i.removeEventListener('abort', s),
              c instanceof sA || (f8(`connecting to ${t.hostname}:${a} failed with: ${c.message}`), n(c))
          }
        ;(o = L2e.connect(a, t.hostname, e)),
          o.once('secureConnect', () => {
            i && i.removeEventListener('abort', s),
              o.off('error', l),
              (MX += 1),
              (o.id = MX),
              (o.secureConnecting = !1),
              f8(`established TLS connection: #${o.id} (${o.servername})`),
              r(o)
          }),
          o.once('error', l)
      }),
    K2e = async (t, e) => {
      let r = await FX.acquire(t.origin)
      try {
        return r || (r = await UX(t, e)), r
      } finally {
        FX.release(t.origin, r)
      }
    },
    Y2e = async (t, e, r) => {
      let n = `${e.protocol}//${e.host}`,
        i = t.alpnCache.get(n)
      if (i) return { protocol: i }
      switch (e.protocol) {
        case 'http:':
          return (i = cg), t.alpnCache.set(n, i), { protocol: i }
        case 'http2:':
          return (i = g8), t.alpnCache.set(n, i), { protocol: i }
        case 'https:':
          break
        default:
          throw new TypeError(`unsupported protocol: ${e.protocol}`)
      }
      let {
          options: { rejectUnauthorized: o, h1: s = {}, h2: a = {} },
        } = t,
        l = !(o === !1 || s.rejectUnauthorized === !1 || a.rejectUnauthorized === !1),
        c = { servername: e.hostname, ALPNProtocols: t.alpnProtocols, signal: r, rejectUnauthorized: l }
      t.options.ca && (c.ca = t.options.ca)
      let u = await K2e(e, c)
      return (i = u.alpnProtocol), i || (i = cg), t.alpnCache.set(n, i), { protocol: i, socket: u }
    },
    Q2e = t => {
      let e = {}
      return (
        Object.keys(t).forEach(r => {
          e[r.toLowerCase()] = t[r]
        }),
        e
      )
    },
    X2e = async (t, e, r, n) => {
      let i = e.protocol === 'https:',
        o
      e.port ? (o = e.port) : i ? (o = 443) : (o = 80)
      let s = { ...r, host: e.host, hostname: e.hostname, port: o },
        a = await t(s)
      if (i) {
        let c = { ...s, ALPNProtocols: n }
        ;(c.socket = a), (c.servername = s.host)
        let u = await UX(e, c)
        return { protocol: u.alpnProtocol || cg, socket: u }
      }
      return { protocol: a.alpnProtocol || cg, socket: a }
    },
    J2e = async (t, e, r) => {
      let n = new URL(e),
        i = { ...W2e, ...(r || {}) }
      typeof i.method == 'string' && (i.method = i.method.toUpperCase()),
        (i.headers = Q2e(i.headers || {})),
        i.headers.host === void 0 && (i.headers.host = n.host),
        t.userAgent && i.headers['user-agent'] === void 0 && (i.headers['user-agent'] = t.userAgent)
      let o
      if (i.body instanceof URLSearchParams)
        (o = 'application/x-www-form-urlencoded; charset=utf-8'), (i.body = i.body.toString())
      else if (q2e(i.body)) {
        let c = new H2e(i.body)
        ;(o = c.contentType()),
          (i.body = c.stream()),
          i.headers['transfer-encoding'] === void 0 &&
            i.headers['content-length'] === void 0 &&
            (i.headers['content-length'] = String(c.length()))
      } else
        typeof i.body == 'string' || i.body instanceof String
          ? (o = 'text/plain; charset=utf-8')
          : B2e(i.body)
          ? ((i.body = JSON.stringify(i.body)), (o = 'application/json'))
          : M2e(i.body) && (i.body = Buffer.from(i.body))
      i.headers['content-type'] === void 0 && o !== void 0 && (i.headers['content-type'] = o),
        i.body != null &&
          (i.body instanceof O2e ||
            (!(typeof i.body == 'string' || i.body instanceof String) &&
              !Buffer.isBuffer(i.body) &&
              (i.body = String(i.body)),
            i.headers['transfer-encoding'] === void 0 &&
              i.headers['content-length'] === void 0 &&
              (i.headers['content-length'] = String(
                Buffer.isBuffer(i.body) ? i.body.length : Buffer.byteLength(i.body, 'utf-8')
              )))),
        i.headers.accept === void 0 && (i.headers.accept = '*/*'),
        i.body == null && ['POST', 'PUT'].includes(i.method) && (i.headers['content-length'] = '0'),
        i.compress && i.headers['accept-encoding'] === void 0 && (i.headers['accept-encoding'] = 'gzip,deflate,br')
      let { signal: s } = i,
        { protocol: a, socket: l = null } = t.socketFactory
          ? await X2e(t.socketFactory, n, i, t.alpnProtocols)
          : await Y2e(t, n, s)
      switch ((f8(`${n.host} -> ${a}`), a)) {
        case h8:
          try {
            return await aA.request(t, n, l ? { ...i, socket: l } : i)
          } catch (c) {
            let { code: u, message: p } = c
            throw (
              (u === 'ERR_HTTP2_ERROR' && p === 'Protocol error' && t.alpnCache.delete(`${n.protocol}//${n.host}`), c)
            )
          }
        case g8:
          return aA.request(
            t,
            new URL(`http://${n.host}${n.pathname}${n.hash}${n.search}`),
            l ? { ...i, socket: l } : i
          )
        case v8:
        case cg:
          return m8.request(t, n, l ? { ...i, socket: l } : i)
        default:
          throw new TypeError(`unsupported protocol: ${a}`)
      }
    },
    Z2e = async t => (t.alpnCache.clear(), Promise.all([m8.resetContext(t), aA.resetContext(t)])),
    eRe = t => {
      let {
        options: {
          alpnProtocols: e = z2e,
          alpnCacheTTL: r = V2e,
          alpnCacheSize: n = G2e,
          userAgent: i = $2e,
          socketFactory: o,
        },
      } = t
      ;(t.alpnProtocols = e),
        (t.alpnCache = new F2e({ max: n, ttl: r })),
        (t.userAgent = i),
        (t.socketFactory = o),
        m8.setupContext(t),
        aA.setupContext(t)
    }
  BX.exports = {
    request: J2e,
    setupContext: eRe,
    resetContext: Z2e,
    RequestAbortedError: sA,
    ALPN_HTTP2: h8,
    ALPN_HTTP2C: g8,
    ALPN_HTTP1_1: cg,
    ALPN_HTTP1_0: v8,
  }
})
var jX = handleExports((tht, HX) => {
  'use strict'
  var tRe = La()('helix-fetch:core'),
    {
      request: rRe,
      setupContext: nRe,
      resetContext: iRe,
      RequestAbortedError: oRe,
      ALPN_HTTP2: sRe,
      ALPN_HTTP2C: aRe,
      ALPN_HTTP1_1: cRe,
      ALPN_HTTP1_0: lRe,
    } = qX(),
    _8 = class t {
      constructor(e) {
        ;(this.options = { ...(e || {}) }), nRe(this)
      }
      api() {
        return {
          request: async (e, r) => this.request(e, r),
          context: (e = {}) => new t(e).api(),
          setCA: e => this.setCA(e),
          reset: async () => this.reset(),
          RequestAbortedError: oRe,
          ALPN_HTTP2: sRe,
          ALPN_HTTP2C: aRe,
          ALPN_HTTP1_1: cRe,
          ALPN_HTTP1_0: lRe,
        }
      }
      async request(e, r) {
        return rRe(this, e, r)
      }
      setCA(e) {
        this.options.ca = e
      }
      async reset() {
        return tRe('resetting context'), iRe(this)
      }
    }
  HX.exports = new _8().api()
})
var WX = handleExports((rht, $X) => {
  'use strict'
  var { EventEmitter: uRe } = require('events'),
    { Readable: Fb } = require('stream'),
    y8 = La()('helix-fetch'),
    pRe = t8(),
    { Body: dRe } = Jw(),
    { Headers: T8 } = u_(),
    { Request: lg } = dX(),
    { Response: b8 } = c8(),
    { FetchBaseError: fRe, FetchError: Ub, AbortError: cA } = i8(),
    { AbortController: mRe, AbortSignal: hRe, TimeoutSignal: gRe } = o8(),
    vRe = yX(),
    { cacheableResponse: _Re } = EX(),
    { sizeof: yRe } = up(),
    { isFormData: xRe } = Lb(),
    { context: bRe, RequestAbortedError: ERe } = jX(),
    GX = ['GET', 'HEAD'],
    TRe = 500,
    SRe = 100 * 1024 * 1024,
    x8 = 'push',
    VX = async (t, e, r) => {
      let { request: n } = t.context,
        i = e instanceof lg && typeof r > 'u' ? e : new lg(e, r),
        {
          method: o,
          body: s,
          signal: a,
          compress: l,
          decode: c,
          follow: u,
          redirect: p,
          init: { body: d },
        } = i,
        f
      if (a && a.aborted) {
        let x = new cA('The operation was aborted.')
        throw (i.init.body instanceof Fb && i.init.body.destroy(x), x)
      }
      try {
        f = await n(i.url, {
          ...r,
          method: o,
          headers: i.headers.plain(),
          body: d && !(d instanceof Fb) && !xRe(d) ? d : s,
          compress: l,
          decode: c,
          follow: u,
          redirect: p,
          signal: a,
        })
      } catch (x) {
        throw (
          (d instanceof Fb && d.destroy(x),
          x instanceof TypeError
            ? x
            : x instanceof ERe
            ? new cA('The operation was aborted.')
            : new Ub(x.message, 'system', x))
        )
      }
      let m = () => {
        a.removeEventListener('abort', m)
        let x = new cA('The operation was aborted.')
        i.init.body instanceof Fb && i.init.body.destroy(x), f.readable.emit('error', x)
      }
      a && a.addEventListener('abort', m)
      let { statusCode: h, statusText: g, httpVersion: v, headers: _, readable: y, decoded: b } = f
      if ([301, 302, 303, 307, 308].includes(h)) {
        let { location: x } = _,
          P = x == null ? null : new URL(x, i.url)
        switch (i.redirect) {
          case 'manual':
            break
          case 'error':
            throw (
              (a && a.removeEventListener('abort', m),
              new Ub(
                `uri requested responds with a redirect, redirect mode is set to 'error': ${i.url}`,
                'no-redirect'
              ))
            )
          case 'follow': {
            if (P === null) break
            if (i.counter >= i.follow)
              throw (
                (a && a.removeEventListener('abort', m),
                new Ub(`maximum redirect reached at: ${i.url}`, 'max-redirect'))
              )
            let U = {
              headers: new T8(i.headers),
              follow: i.follow,
              compress: i.compress,
              decode: i.decode,
              counter: i.counter + 1,
              method: i.method,
              body: i.body,
              signal: i.signal,
            }
            if (h !== 303 && i.body && i.init.body instanceof Fb)
              throw (
                (a && a.removeEventListener('abort', m),
                new Ub('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'))
              )
            return (
              (h === 303 || ((h === 301 || h === 302) && i.method === 'POST')) &&
                ((U.method = 'GET'), (U.body = void 0), U.headers.delete('content-length')),
              a && a.removeEventListener('abort', m),
              VX(t, new lg(P, U))
            )
          }
          default:
        }
      }
      return (
        a &&
          (y.once('end', () => {
            a.removeEventListener('abort', m)
          }),
          y.once('error', () => {
            a.removeEventListener('abort', m)
          })),
        new b8(y, { url: i.url, status: h, statusText: g, headers: _, httpVersion: v, decoded: b, counter: i.counter })
      )
    },
    zX = async (t, e, r) => {
      if (t.options.maxCacheSize === 0 || !GX.includes(e.method)) return r
      let n = new vRe(e, r, { shared: !1 })
      if (n.storable()) {
        let i = await _Re(r)
        return t.cache.set(e.url, { policy: n, response: i }, n.timeToLive()), i
      } else return r
    },
    CRe = async (t, e, r) => {
      let n = new lg(e, r)
      if (t.options.maxCacheSize !== 0 && GX.includes(n.method) && !['no-store', 'reload'].includes(n.cache)) {
        let { policy: s, response: a } = t.cache.get(n.url) || {}
        if (s && s.satisfiesWithoutRevalidation(n)) {
          a.headers = new T8(s.responseHeaders(a))
          let l = a.clone()
          return (l.fromCache = !0), l
        }
      }
      let o = await VX(t, n)
      return n.cache !== 'no-store' ? zX(t, n, o) : o
    },
    IRe = (t, e = {}) => {
      let r = new URL(t)
      if (typeof e != 'object' || Array.isArray(e)) throw new TypeError('qs: object expected')
      return (
        Object.entries(e).forEach(([n, i]) => {
          Array.isArray(i) ? i.forEach(o => r.searchParams.append(n, o)) : r.searchParams.append(n, i)
        }),
        r.href
      )
    },
    wRe = t => new gRe(t),
    E8 = class t {
      constructor(e) {
        this.options = { ...e }
        let { maxCacheSize: r } = this.options,
          n = typeof r == 'number' && r >= 0 ? r : SRe,
          i = TRe
        n === 0 && ((n = 1), (i = 1))
        let o = ({ response: a }, l) => yRe(a)
        ;(this.cache = new pRe({ max: i, maxSize: n, sizeCalculation: o })),
          (this.eventEmitter = new uRe()),
          (this.options.h2 = this.options.h2 || {}),
          typeof this.options.h2.enablePush > 'u' && (this.options.h2.enablePush = !0)
        let { enablePush: s } = this.options.h2
        s &&
          ((this.options.h2.pushPromiseHandler = (a, l, c) => {
            let u = { ...l }
            Object.keys(u)
              .filter(p => p.startsWith(':'))
              .forEach(p => delete u[p]),
              this.pushPromiseHandler(a, u, c)
          }),
          (this.options.h2.pushHandler = (a, l, c) => {
            let u = { ...l }
            Object.keys(u)
              .filter(v => v.startsWith(':'))
              .forEach(v => delete u[v])
            let { statusCode: p, statusText: d, httpVersion: f, headers: m, readable: h, decoded: g } = c
            this.pushHandler(
              a,
              u,
              new b8(h, { url: a, status: p, statusText: d, headers: m, httpVersion: f, decoded: g })
            )
          })),
          (this.context = bRe(this.options))
      }
      api() {
        return {
          fetch: async (e, r) => this.fetch(e, r),
          Body: dRe,
          Headers: T8,
          Request: lg,
          Response: b8,
          AbortController: mRe,
          AbortSignal: hRe,
          FetchBaseError: fRe,
          FetchError: Ub,
          AbortError: cA,
          context: (e = {}) => new t(e).api(),
          setCA: e => this.setCA(e),
          noCache: (e = {}) => new t({ ...e, maxCacheSize: 0 }).api(),
          h1: (e = {}) => new t({ ...e, alpnProtocols: [this.context.ALPN_HTTP1_1] }).api(),
          keepAlive: (e = {}) =>
            new t({ ...e, alpnProtocols: [this.context.ALPN_HTTP1_1], h1: { keepAlive: !0 } }).api(),
          h1NoCache: (e = {}) => new t({ ...e, maxCacheSize: 0, alpnProtocols: [this.context.ALPN_HTTP1_1] }).api(),
          keepAliveNoCache: (e = {}) =>
            new t({ ...e, maxCacheSize: 0, alpnProtocols: [this.context.ALPN_HTTP1_1], h1: { keepAlive: !0 } }).api(),
          reset: async () => this.context.reset(),
          onPush: e => this.onPush(e),
          offPush: e => this.offPush(e),
          createUrl: IRe,
          timeoutSignal: wRe,
          clearCache: () => this.clearCache(),
          cacheStats: () => this.cacheStats(),
          ALPN_HTTP2: this.context.ALPN_HTTP2,
          ALPN_HTTP2C: this.context.ALPN_HTTP2C,
          ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,
          ALPN_HTTP1_0: this.context.ALPN_HTTP1_0,
        }
      }
      async fetch(e, r) {
        return CRe(this, e, r)
      }
      setCA(e) {
        ;(this.options.ca = e), this.context.setCA(e)
      }
      onPush(e) {
        return this.eventEmitter.on(x8, e)
      }
      offPush(e) {
        return this.eventEmitter.off(x8, e)
      }
      clearCache() {
        this.cache.clear()
      }
      cacheStats() {
        return { size: this.cache.calculatedSize, count: this.cache.size }
      }
      pushPromiseHandler(e, r, n) {
        y8(`received server push promise: ${e}, headers: ${JSON.stringify(r)}`)
        let i = new lg(e, { headers: r }),
          { policy: o } = this.cache.get(e) || {}
        o &&
          o.satisfiesWithoutRevalidation(i) &&
          (y8(`already cached, reject push promise: ${e}, headers: ${JSON.stringify(r)}`), n())
      }
      async pushHandler(e, r, n) {
        y8(
          `caching resource pushed by server: ${e}, reqHeaders: ${JSON.stringify(r)}, status: ${
            n.status
          }, respHeaders: ${JSON.stringify(n.headers)}`
        )
        let i = await zX(this, new lg(e, { headers: r }), n)
        this.eventEmitter.emit(x8, e, i)
      }
    }
  $X.exports = new E8().api()
})
var fetch = handleExports((nht, KX) => {
  'use strict'
  KX.exports = WX()
})
var Mt = handleExports((Dht, ZX) => {
  ZX.exports = { options: { usePureJavaScript: !1 } }
})
var rJ = handleExports((Pht, tJ) => {
  var C8 = {}
  tJ.exports = C8
  var eJ = {}
  C8.encode = function (t, e, r) {
    if (typeof e != 'string') throw new TypeError('"alphabet" must be a string.')
    if (r !== void 0 && typeof r != 'number') throw new TypeError('"maxline" must be a number.')
    var n = ''
    if (!(t instanceof Uint8Array)) n = RRe(t, e)
    else {
      var i = 0,
        o = e.length,
        s = e.charAt(0),
        a = [0]
      for (i = 0; i < t.length; ++i) {
        for (var l = 0, c = t[i]; l < a.length; ++l) (c += a[l] << 8), (a[l] = c % o), (c = (c / o) | 0)
        for (; c > 0; ) a.push(c % o), (c = (c / o) | 0)
      }
      for (i = 0; t[i] === 0 && i < t.length - 1; ++i) n += s
      for (i = a.length - 1; i >= 0; --i) n += e[a[i]]
    }
    if (r) {
      var u = new RegExp('.{1,' + r + '}', 'g')
      n = n.match(u).join(`\r
`)
    }
    return n
  }
  C8.decode = function (t, e) {
    if (typeof t != 'string') throw new TypeError('"input" must be a string.')
    if (typeof e != 'string') throw new TypeError('"alphabet" must be a string.')
    var r = eJ[e]
    if (!r) {
      r = eJ[e] = []
      for (var n = 0; n < e.length; ++n) r[e.charCodeAt(n)] = n
    }
    t = t.replace(/\s/g, '')
    for (var i = e.length, o = e.charAt(0), s = [0], n = 0; n < t.length; n++) {
      var a = r[t.charCodeAt(n)]
      if (a === void 0) return
      for (var l = 0, c = a; l < s.length; ++l) (c += s[l] * i), (s[l] = c & 255), (c >>= 8)
      for (; c > 0; ) s.push(c & 255), (c >>= 8)
    }
    for (var u = 0; t[u] === o && u < t.length - 1; ++u) s.push(0)
    return typeof Buffer < 'u' ? Buffer.from(s.reverse()) : new Uint8Array(s.reverse())
  }
  function RRe(t, e) {
    var r = 0,
      n = e.length,
      i = e.charAt(0),
      o = [0]
    for (r = 0; r < t.length(); ++r) {
      for (var s = 0, a = t.at(r); s < o.length; ++s) (a += o[s] << 8), (o[s] = a % n), (a = (a / n) | 0)
      for (; a > 0; ) o.push(a % n), (a = (a / n) | 0)
    }
    var l = ''
    for (r = 0; t.at(r) === 0 && r < t.length() - 1; ++r) l += i
    for (r = o.length - 1; r >= 0; --r) l += e[o[r]]
    return l
  }
})
var cr = handleExports((Nht, sJ) => {
  var nJ = Mt(),
    iJ = rJ(),
    Z = (sJ.exports = nJ.util = nJ.util || {})
  ;(function () {
    if (typeof process < 'u' && process.nextTick && !process.browser) {
      ;(Z.nextTick = process.nextTick),
        typeof setImmediate == 'function' ? (Z.setImmediate = setImmediate) : (Z.setImmediate = Z.nextTick)
      return
    }
    if (typeof setImmediate == 'function') {
      ;(Z.setImmediate = function () {
        return setImmediate.apply(void 0, arguments)
      }),
        (Z.nextTick = function (a) {
          return setImmediate(a)
        })
      return
    }
    if (
      ((Z.setImmediate = function (a) {
        setTimeout(a, 0)
      }),
      typeof window < 'u' && typeof window.postMessage == 'function')
    ) {
      let a = function (l) {
        if (l.source === window && l.data === t) {
          l.stopPropagation()
          var c = e.slice()
          ;(e.length = 0),
            c.forEach(function (u) {
              u()
            })
        }
      }
      var s = a,
        t = 'forge.setImmediate',
        e = []
      ;(Z.setImmediate = function (l) {
        e.push(l), e.length === 1 && window.postMessage(t, '*')
      }),
        window.addEventListener('message', a, !0)
    }
    if (typeof MutationObserver < 'u') {
      var r = Date.now(),
        n = !0,
        i = document.createElement('div'),
        e = []
      new MutationObserver(function () {
        var l = e.slice()
        ;(e.length = 0),
          l.forEach(function (c) {
            c()
          })
      }).observe(i, { attributes: !0 })
      var o = Z.setImmediate
      Z.setImmediate = function (l) {
        Date.now() - r > 15 ? ((r = Date.now()), o(l)) : (e.push(l), e.length === 1 && i.setAttribute('a', (n = !n)))
      }
    }
    Z.nextTick = Z.setImmediate
  })()
  Z.isNodejs = typeof process < 'u' && process.versions && process.versions.node
  Z.globalScope = (function () {
    return Z.isNodejs ? global : typeof self > 'u' ? window : self
  })()
  Z.isArray =
    Array.isArray ||
    function (t) {
      return Object.prototype.toString.call(t) === '[object Array]'
    }
  Z.isArrayBuffer = function (t) {
    return typeof ArrayBuffer < 'u' && t instanceof ArrayBuffer
  }
  Z.isArrayBufferView = function (t) {
    return t && Z.isArrayBuffer(t.buffer) && t.byteLength !== void 0
  }
  function Bb(t) {
    if (!(t === 8 || t === 16 || t === 24 || t === 32)) throw new Error('Only 8, 16, 24, or 32 bits supported: ' + t)
  }
  Z.ByteBuffer = I8
  function I8(t) {
    if (((this.data = ''), (this.read = 0), typeof t == 'string')) this.data = t
    else if (Z.isArrayBuffer(t) || Z.isArrayBufferView(t))
      if (typeof Buffer < 'u' && t instanceof Buffer) this.data = t.toString('binary')
      else {
        var e = new Uint8Array(t)
        try {
          this.data = String.fromCharCode.apply(null, e)
        } catch {
          for (var r = 0; r < e.length; ++r) this.putByte(e[r])
        }
      }
    else
      (t instanceof I8 || (typeof t == 'object' && typeof t.data == 'string' && typeof t.read == 'number')) &&
        ((this.data = t.data), (this.read = t.read))
    this._constructedStringLength = 0
  }
  Z.ByteStringBuffer = I8
  var DRe = 4096
  Z.ByteStringBuffer.prototype._optimizeConstructedString = function (t) {
    ;(this._constructedStringLength += t),
      this._constructedStringLength > DRe && (this.data.substr(0, 1), (this._constructedStringLength = 0))
  }
  Z.ByteStringBuffer.prototype.length = function () {
    return this.data.length - this.read
  }
  Z.ByteStringBuffer.prototype.isEmpty = function () {
    return this.length() <= 0
  }
  Z.ByteStringBuffer.prototype.putByte = function (t) {
    return this.putBytes(String.fromCharCode(t))
  }
  Z.ByteStringBuffer.prototype.fillWithByte = function (t, e) {
    t = String.fromCharCode(t)
    for (var r = this.data; e > 0; ) e & 1 && (r += t), (e >>>= 1), e > 0 && (t += t)
    return (this.data = r), this._optimizeConstructedString(e), this
  }
  Z.ByteStringBuffer.prototype.putBytes = function (t) {
    return (this.data += t), this._optimizeConstructedString(t.length), this
  }
  Z.ByteStringBuffer.prototype.putString = function (t) {
    return this.putBytes(Z.encodeUtf8(t))
  }
  Z.ByteStringBuffer.prototype.putInt16 = function (t) {
    return this.putBytes(String.fromCharCode((t >> 8) & 255) + String.fromCharCode(t & 255))
  }
  Z.ByteStringBuffer.prototype.putInt24 = function (t) {
    return this.putBytes(
      String.fromCharCode((t >> 16) & 255) + String.fromCharCode((t >> 8) & 255) + String.fromCharCode(t & 255)
    )
  }
  Z.ByteStringBuffer.prototype.putInt32 = function (t) {
    return this.putBytes(
      String.fromCharCode((t >> 24) & 255) +
        String.fromCharCode((t >> 16) & 255) +
        String.fromCharCode((t >> 8) & 255) +
        String.fromCharCode(t & 255)
    )
  }
  Z.ByteStringBuffer.prototype.putInt16Le = function (t) {
    return this.putBytes(String.fromCharCode(t & 255) + String.fromCharCode((t >> 8) & 255))
  }
  Z.ByteStringBuffer.prototype.putInt24Le = function (t) {
    return this.putBytes(
      String.fromCharCode(t & 255) + String.fromCharCode((t >> 8) & 255) + String.fromCharCode((t >> 16) & 255)
    )
  }
  Z.ByteStringBuffer.prototype.putInt32Le = function (t) {
    return this.putBytes(
      String.fromCharCode(t & 255) +
        String.fromCharCode((t >> 8) & 255) +
        String.fromCharCode((t >> 16) & 255) +
        String.fromCharCode((t >> 24) & 255)
    )
  }
  Z.ByteStringBuffer.prototype.putInt = function (t, e) {
    Bb(e)
    var r = ''
    do (e -= 8), (r += String.fromCharCode((t >> e) & 255))
    while (e > 0)
    return this.putBytes(r)
  }
  Z.ByteStringBuffer.prototype.putSignedInt = function (t, e) {
    return t < 0 && (t += 2 << (e - 1)), this.putInt(t, e)
  }
  Z.ByteStringBuffer.prototype.putBuffer = function (t) {
    return this.putBytes(t.getBytes())
  }
  Z.ByteStringBuffer.prototype.getByte = function () {
    return this.data.charCodeAt(this.read++)
  }
  Z.ByteStringBuffer.prototype.getInt16 = function () {
    var t = (this.data.charCodeAt(this.read) << 8) ^ this.data.charCodeAt(this.read + 1)
    return (this.read += 2), t
  }
  Z.ByteStringBuffer.prototype.getInt24 = function () {
    var t =
      (this.data.charCodeAt(this.read) << 16) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      this.data.charCodeAt(this.read + 2)
    return (this.read += 3), t
  }
  Z.ByteStringBuffer.prototype.getInt32 = function () {
    var t =
      (this.data.charCodeAt(this.read) << 24) ^
      (this.data.charCodeAt(this.read + 1) << 16) ^
      (this.data.charCodeAt(this.read + 2) << 8) ^
      this.data.charCodeAt(this.read + 3)
    return (this.read += 4), t
  }
  Z.ByteStringBuffer.prototype.getInt16Le = function () {
    var t = this.data.charCodeAt(this.read) ^ (this.data.charCodeAt(this.read + 1) << 8)
    return (this.read += 2), t
  }
  Z.ByteStringBuffer.prototype.getInt24Le = function () {
    var t =
      this.data.charCodeAt(this.read) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      (this.data.charCodeAt(this.read + 2) << 16)
    return (this.read += 3), t
  }
  Z.ByteStringBuffer.prototype.getInt32Le = function () {
    var t =
      this.data.charCodeAt(this.read) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      (this.data.charCodeAt(this.read + 2) << 16) ^
      (this.data.charCodeAt(this.read + 3) << 24)
    return (this.read += 4), t
  }
  Z.ByteStringBuffer.prototype.getInt = function (t) {
    Bb(t)
    var e = 0
    do (e = (e << 8) + this.data.charCodeAt(this.read++)), (t -= 8)
    while (t > 0)
    return e
  }
  Z.ByteStringBuffer.prototype.getSignedInt = function (t) {
    var e = this.getInt(t),
      r = 2 << (t - 2)
    return e >= r && (e -= r << 1), e
  }
  Z.ByteStringBuffer.prototype.getBytes = function (t) {
    var e
    return (
      t
        ? ((t = Math.min(this.length(), t)), (e = this.data.slice(this.read, this.read + t)), (this.read += t))
        : t === 0
        ? (e = '')
        : ((e = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
      e
    )
  }
  Z.ByteStringBuffer.prototype.bytes = function (t) {
    return typeof t > 'u' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t)
  }
  Z.ByteStringBuffer.prototype.at = function (t) {
    return this.data.charCodeAt(this.read + t)
  }
  Z.ByteStringBuffer.prototype.setAt = function (t, e) {
    return (
      (this.data = this.data.substr(0, this.read + t) + String.fromCharCode(e) + this.data.substr(this.read + t + 1)),
      this
    )
  }
  Z.ByteStringBuffer.prototype.last = function () {
    return this.data.charCodeAt(this.data.length - 1)
  }
  Z.ByteStringBuffer.prototype.copy = function () {
    var t = Z.createBuffer(this.data)
    return (t.read = this.read), t
  }
  Z.ByteStringBuffer.prototype.compact = function () {
    return this.read > 0 && ((this.data = this.data.slice(this.read)), (this.read = 0)), this
  }
  Z.ByteStringBuffer.prototype.clear = function () {
    return (this.data = ''), (this.read = 0), this
  }
  Z.ByteStringBuffer.prototype.truncate = function (t) {
    var e = Math.max(0, this.length() - t)
    return (this.data = this.data.substr(this.read, e)), (this.read = 0), this
  }
  Z.ByteStringBuffer.prototype.toHex = function () {
    for (var t = '', e = this.read; e < this.data.length; ++e) {
      var r = this.data.charCodeAt(e)
      r < 16 && (t += '0'), (t += r.toString(16))
    }
    return t
  }
  Z.ByteStringBuffer.prototype.toString = function () {
    return Z.decodeUtf8(this.bytes())
  }
  function PRe(t, e) {
    ;(e = e || {}), (this.read = e.readOffset || 0), (this.growSize = e.growSize || 1024)
    var r = Z.isArrayBuffer(t),
      n = Z.isArrayBufferView(t)
    if (r || n) {
      r ? (this.data = new DataView(t)) : (this.data = new DataView(t.buffer, t.byteOffset, t.byteLength)),
        (this.write = 'writeOffset' in e ? e.writeOffset : this.data.byteLength)
      return
    }
    ;(this.data = new DataView(new ArrayBuffer(0))),
      (this.write = 0),
      t != null && this.putBytes(t),
      'writeOffset' in e && (this.write = e.writeOffset)
  }
  Z.DataBuffer = PRe
  Z.DataBuffer.prototype.length = function () {
    return this.write - this.read
  }
  Z.DataBuffer.prototype.isEmpty = function () {
    return this.length() <= 0
  }
  Z.DataBuffer.prototype.accommodate = function (t, e) {
    if (this.length() >= t) return this
    e = Math.max(e || this.growSize, t)
    var r = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
      n = new Uint8Array(this.length() + e)
    return n.set(r), (this.data = new DataView(n.buffer)), this
  }
  Z.DataBuffer.prototype.putByte = function (t) {
    return this.accommodate(1), this.data.setUint8(this.write++, t), this
  }
  Z.DataBuffer.prototype.fillWithByte = function (t, e) {
    this.accommodate(e)
    for (var r = 0; r < e; ++r) this.data.setUint8(t)
    return this
  }
  Z.DataBuffer.prototype.putBytes = function (t, e) {
    if (Z.isArrayBufferView(t)) {
      var r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength),
        n = r.byteLength - r.byteOffset
      this.accommodate(n)
      var i = new Uint8Array(this.data.buffer, this.write)
      return i.set(r), (this.write += n), this
    }
    if (Z.isArrayBuffer(t)) {
      var r = new Uint8Array(t)
      this.accommodate(r.byteLength)
      var i = new Uint8Array(this.data.buffer)
      return i.set(r, this.write), (this.write += r.byteLength), this
    }
    if (
      t instanceof Z.DataBuffer ||
      (typeof t == 'object' && typeof t.read == 'number' && typeof t.write == 'number' && Z.isArrayBufferView(t.data))
    ) {
      var r = new Uint8Array(t.data.byteLength, t.read, t.length())
      this.accommodate(r.byteLength)
      var i = new Uint8Array(t.data.byteLength, this.write)
      return i.set(r), (this.write += r.byteLength), this
    }
    if (
      (t instanceof Z.ByteStringBuffer && ((t = t.data), (e = 'binary')), (e = e || 'binary'), typeof t == 'string')
    ) {
      var o
      if (e === 'hex')
        return (
          this.accommodate(Math.ceil(t.length / 2)),
          (o = new Uint8Array(this.data.buffer, this.write)),
          (this.write += Z.binary.hex.decode(t, o, this.write)),
          this
        )
      if (e === 'base64')
        return (
          this.accommodate(Math.ceil(t.length / 4) * 3),
          (o = new Uint8Array(this.data.buffer, this.write)),
          (this.write += Z.binary.base64.decode(t, o, this.write)),
          this
        )
      if ((e === 'utf8' && ((t = Z.encodeUtf8(t)), (e = 'binary')), e === 'binary' || e === 'raw'))
        return (
          this.accommodate(t.length),
          (o = new Uint8Array(this.data.buffer, this.write)),
          (this.write += Z.binary.raw.decode(o)),
          this
        )
      if (e === 'utf16')
        return (
          this.accommodate(t.length * 2),
          (o = new Uint16Array(this.data.buffer, this.write)),
          (this.write += Z.text.utf16.encode(o)),
          this
        )
      throw new Error('Invalid encoding: ' + e)
    }
    throw Error('Invalid parameter: ' + t)
  }
  Z.DataBuffer.prototype.putBuffer = function (t) {
    return this.putBytes(t), t.clear(), this
  }
  Z.DataBuffer.prototype.putString = function (t) {
    return this.putBytes(t, 'utf16')
  }
  Z.DataBuffer.prototype.putInt16 = function (t) {
    return this.accommodate(2), this.data.setInt16(this.write, t), (this.write += 2), this
  }
  Z.DataBuffer.prototype.putInt24 = function (t) {
    return (
      this.accommodate(3),
      this.data.setInt16(this.write, (t >> 8) & 65535),
      this.data.setInt8(this.write, (t >> 16) & 255),
      (this.write += 3),
      this
    )
  }
  Z.DataBuffer.prototype.putInt32 = function (t) {
    return this.accommodate(4), this.data.setInt32(this.write, t), (this.write += 4), this
  }
  Z.DataBuffer.prototype.putInt16Le = function (t) {
    return this.accommodate(2), this.data.setInt16(this.write, t, !0), (this.write += 2), this
  }
  Z.DataBuffer.prototype.putInt24Le = function (t) {
    return (
      this.accommodate(3),
      this.data.setInt8(this.write, (t >> 16) & 255),
      this.data.setInt16(this.write, (t >> 8) & 65535, !0),
      (this.write += 3),
      this
    )
  }
  Z.DataBuffer.prototype.putInt32Le = function (t) {
    return this.accommodate(4), this.data.setInt32(this.write, t, !0), (this.write += 4), this
  }
  Z.DataBuffer.prototype.putInt = function (t, e) {
    Bb(e), this.accommodate(e / 8)
    do (e -= 8), this.data.setInt8(this.write++, (t >> e) & 255)
    while (e > 0)
    return this
  }
  Z.DataBuffer.prototype.putSignedInt = function (t, e) {
    return Bb(e), this.accommodate(e / 8), t < 0 && (t += 2 << (e - 1)), this.putInt(t, e)
  }
  Z.DataBuffer.prototype.getByte = function () {
    return this.data.getInt8(this.read++)
  }
  Z.DataBuffer.prototype.getInt16 = function () {
    var t = this.data.getInt16(this.read)
    return (this.read += 2), t
  }
  Z.DataBuffer.prototype.getInt24 = function () {
    var t = (this.data.getInt16(this.read) << 8) ^ this.data.getInt8(this.read + 2)
    return (this.read += 3), t
  }
  Z.DataBuffer.prototype.getInt32 = function () {
    var t = this.data.getInt32(this.read)
    return (this.read += 4), t
  }
  Z.DataBuffer.prototype.getInt16Le = function () {
    var t = this.data.getInt16(this.read, !0)
    return (this.read += 2), t
  }
  Z.DataBuffer.prototype.getInt24Le = function () {
    var t = this.data.getInt8(this.read) ^ (this.data.getInt16(this.read + 1, !0) << 8)
    return (this.read += 3), t
  }
  Z.DataBuffer.prototype.getInt32Le = function () {
    var t = this.data.getInt32(this.read, !0)
    return (this.read += 4), t
  }
  Z.DataBuffer.prototype.getInt = function (t) {
    Bb(t)
    var e = 0
    do (e = (e << 8) + this.data.getInt8(this.read++)), (t -= 8)
    while (t > 0)
    return e
  }
  Z.DataBuffer.prototype.getSignedInt = function (t) {
    var e = this.getInt(t),
      r = 2 << (t - 2)
    return e >= r && (e -= r << 1), e
  }
  Z.DataBuffer.prototype.getBytes = function (t) {
    var e
    return (
      t
        ? ((t = Math.min(this.length(), t)), (e = this.data.slice(this.read, this.read + t)), (this.read += t))
        : t === 0
        ? (e = '')
        : ((e = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
      e
    )
  }
  Z.DataBuffer.prototype.bytes = function (t) {
    return typeof t > 'u' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t)
  }
  Z.DataBuffer.prototype.at = function (t) {
    return this.data.getUint8(this.read + t)
  }
  Z.DataBuffer.prototype.setAt = function (t, e) {
    return this.data.setUint8(t, e), this
  }
  Z.DataBuffer.prototype.last = function () {
    return this.data.getUint8(this.write - 1)
  }
  Z.DataBuffer.prototype.copy = function () {
    return new Z.DataBuffer(this)
  }
  Z.DataBuffer.prototype.compact = function () {
    if (this.read > 0) {
      var t = new Uint8Array(this.data.buffer, this.read),
        e = new Uint8Array(t.byteLength)
      e.set(t), (this.data = new DataView(e)), (this.write -= this.read), (this.read = 0)
    }
    return this
  }
  Z.DataBuffer.prototype.clear = function () {
    return (this.data = new DataView(new ArrayBuffer(0))), (this.read = this.write = 0), this
  }
  Z.DataBuffer.prototype.truncate = function (t) {
    return (this.write = Math.max(0, this.length() - t)), (this.read = Math.min(this.read, this.write)), this
  }
  Z.DataBuffer.prototype.toHex = function () {
    for (var t = '', e = this.read; e < this.data.byteLength; ++e) {
      var r = this.data.getUint8(e)
      r < 16 && (t += '0'), (t += r.toString(16))
    }
    return t
  }
  Z.DataBuffer.prototype.toString = function (t) {
    var e = new Uint8Array(this.data, this.read, this.length())
    if (((t = t || 'utf8'), t === 'binary' || t === 'raw')) return Z.binary.raw.encode(e)
    if (t === 'hex') return Z.binary.hex.encode(e)
    if (t === 'base64') return Z.binary.base64.encode(e)
    if (t === 'utf8') return Z.text.utf8.decode(e)
    if (t === 'utf16') return Z.text.utf16.decode(e)
    throw new Error('Invalid encoding: ' + t)
  }
  Z.createBuffer = function (t, e) {
    return (e = e || 'raw'), t !== void 0 && e === 'utf8' && (t = Z.encodeUtf8(t)), new Z.ByteBuffer(t)
  }
  Z.fillString = function (t, e) {
    for (var r = ''; e > 0; ) e & 1 && (r += t), (e >>>= 1), e > 0 && (t += t)
    return r
  }
  Z.xorBytes = function (t, e, r) {
    for (var n = '', i = '', o = '', s = 0, a = 0; r > 0; --r, ++s)
      (i = t.charCodeAt(s) ^ e.charCodeAt(s)),
        a >= 10 && ((n += o), (o = ''), (a = 0)),
        (o += String.fromCharCode(i)),
        ++a
    return (n += o), n
  }
  Z.hexToBytes = function (t) {
    var e = '',
      r = 0
    for (t.length & !0 && ((r = 1), (e += String.fromCharCode(parseInt(t[0], 16)))); r < t.length; r += 2)
      e += String.fromCharCode(parseInt(t.substr(r, 2), 16))
    return e
  }
  Z.bytesToHex = function (t) {
    return Z.createBuffer(t).toHex()
  }
  Z.int32ToBytes = function (t) {
    return (
      String.fromCharCode((t >> 24) & 255) +
      String.fromCharCode((t >> 16) & 255) +
      String.fromCharCode((t >> 8) & 255) +
      String.fromCharCode(t & 255)
    )
  }
  var bf = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    Ef = [
      62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8,
      9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31,
      32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
    ],
    oJ = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  Z.encode64 = function (t, e) {
    for (var r = '', n = '', i, o, s, a = 0; a < t.length; )
      (i = t.charCodeAt(a++)),
        (o = t.charCodeAt(a++)),
        (s = t.charCodeAt(a++)),
        (r += bf.charAt(i >> 2)),
        (r += bf.charAt(((i & 3) << 4) | (o >> 4))),
        isNaN(o)
          ? (r += '==')
          : ((r += bf.charAt(((o & 15) << 2) | (s >> 6))), (r += isNaN(s) ? '=' : bf.charAt(s & 63))),
        e &&
          r.length > e &&
          ((n +=
            r.substr(0, e) +
            `\r
`),
          (r = r.substr(e)))
    return (n += r), n
  }
  Z.decode64 = function (t) {
    t = t.replace(/[^A-Za-z0-9\+\/\=]/g, '')
    for (var e = '', r, n, i, o, s = 0; s < t.length; )
      (r = Ef[t.charCodeAt(s++) - 43]),
        (n = Ef[t.charCodeAt(s++) - 43]),
        (i = Ef[t.charCodeAt(s++) - 43]),
        (o = Ef[t.charCodeAt(s++) - 43]),
        (e += String.fromCharCode((r << 2) | (n >> 4))),
        i !== 64 &&
          ((e += String.fromCharCode(((n & 15) << 4) | (i >> 2))),
          o !== 64 && (e += String.fromCharCode(((i & 3) << 6) | o)))
    return e
  }
  Z.encodeUtf8 = function (t) {
    return unescape(encodeURIComponent(t))
  }
  Z.decodeUtf8 = function (t) {
    return decodeURIComponent(escape(t))
  }
  Z.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: iJ.encode, decode: iJ.decode } }
  Z.binary.raw.encode = function (t) {
    return String.fromCharCode.apply(null, t)
  }
  Z.binary.raw.decode = function (t, e, r) {
    var n = e
    n || (n = new Uint8Array(t.length)), (r = r || 0)
    for (var i = r, o = 0; o < t.length; ++o) n[i++] = t.charCodeAt(o)
    return e ? i - r : n
  }
  Z.binary.hex.encode = Z.bytesToHex
  Z.binary.hex.decode = function (t, e, r) {
    var n = e
    n || (n = new Uint8Array(Math.ceil(t.length / 2))), (r = r || 0)
    var i = 0,
      o = r
    for (t.length & 1 && ((i = 1), (n[o++] = parseInt(t[0], 16))); i < t.length; i += 2)
      n[o++] = parseInt(t.substr(i, 2), 16)
    return e ? o - r : n
  }
  Z.binary.base64.encode = function (t, e) {
    for (var r = '', n = '', i, o, s, a = 0; a < t.byteLength; )
      (i = t[a++]),
        (o = t[a++]),
        (s = t[a++]),
        (r += bf.charAt(i >> 2)),
        (r += bf.charAt(((i & 3) << 4) | (o >> 4))),
        isNaN(o)
          ? (r += '==')
          : ((r += bf.charAt(((o & 15) << 2) | (s >> 6))), (r += isNaN(s) ? '=' : bf.charAt(s & 63))),
        e &&
          r.length > e &&
          ((n +=
            r.substr(0, e) +
            `\r
`),
          (r = r.substr(e)))
    return (n += r), n
  }
  Z.binary.base64.decode = function (t, e, r) {
    var n = e
    n || (n = new Uint8Array(Math.ceil(t.length / 4) * 3)), (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, '')), (r = r || 0)
    for (var i, o, s, a, l = 0, c = r; l < t.length; )
      (i = Ef[t.charCodeAt(l++) - 43]),
        (o = Ef[t.charCodeAt(l++) - 43]),
        (s = Ef[t.charCodeAt(l++) - 43]),
        (a = Ef[t.charCodeAt(l++) - 43]),
        (n[c++] = (i << 2) | (o >> 4)),
        s !== 64 && ((n[c++] = ((o & 15) << 4) | (s >> 2)), a !== 64 && (n[c++] = ((s & 3) << 6) | a))
    return e ? c - r : n.subarray(0, c)
  }
  Z.binary.base58.encode = function (t, e) {
    return Z.binary.baseN.encode(t, oJ, e)
  }
  Z.binary.base58.decode = function (t, e) {
    return Z.binary.baseN.decode(t, oJ, e)
  }
  Z.text = { utf8: {}, utf16: {} }
  Z.text.utf8.encode = function (t, e, r) {
    t = Z.encodeUtf8(t)
    var n = e
    n || (n = new Uint8Array(t.length)), (r = r || 0)
    for (var i = r, o = 0; o < t.length; ++o) n[i++] = t.charCodeAt(o)
    return e ? i - r : n
  }
  Z.text.utf8.decode = function (t) {
    return Z.decodeUtf8(String.fromCharCode.apply(null, t))
  }
  Z.text.utf16.encode = function (t, e, r) {
    var n = e
    n || (n = new Uint8Array(t.length * 2))
    var i = new Uint16Array(n.buffer)
    r = r || 0
    for (var o = r, s = r, a = 0; a < t.length; ++a) (i[s++] = t.charCodeAt(a)), (o += 2)
    return e ? o - r : n
  }
  Z.text.utf16.decode = function (t) {
    return String.fromCharCode.apply(null, new Uint16Array(t.buffer))
  }
  Z.deflate = function (t, e, r) {
    if (((e = Z.decode64(t.deflate(Z.encode64(e)).rval)), r)) {
      var n = 2,
        i = e.charCodeAt(1)
      i & 32 && (n = 6), (e = e.substring(n, e.length - 4))
    }
    return e
  }
  Z.inflate = function (t, e, r) {
    var n = t.inflate(Z.encode64(e)).rval
    return n === null ? null : Z.decode64(n)
  }
  var w8 = function (t, e, r) {
      if (!t) throw new Error('WebStorage not available.')
      var n
      if (
        (r === null ? (n = t.removeItem(e)) : ((r = Z.encode64(JSON.stringify(r))), (n = t.setItem(e, r))),
        typeof n < 'u' && n.rval !== !0)
      ) {
        var i = new Error(n.error.message)
        throw ((i.id = n.error.id), (i.name = n.error.name), i)
      }
    },
    A8 = function (t, e) {
      if (!t) throw new Error('WebStorage not available.')
      var r = t.getItem(e)
      if (t.init)
        if (r.rval === null) {
          if (r.error) {
            var n = new Error(r.error.message)
            throw ((n.id = r.error.id), (n.name = r.error.name), n)
          }
          r = null
        } else r = r.rval
      return r !== null && (r = JSON.parse(Z.decode64(r))), r
    },
    NRe = function (t, e, r, n) {
      var i = A8(t, e)
      i === null && (i = {}), (i[r] = n), w8(t, e, i)
    },
    kRe = function (t, e, r) {
      var n = A8(t, e)
      return n !== null && (n = r in n ? n[r] : null), n
    },
    ORe = function (t, e, r) {
      var n = A8(t, e)
      if (n !== null && r in n) {
        delete n[r]
        var i = !0
        for (var o in n) {
          i = !1
          break
        }
        i && (n = null), w8(t, e, n)
      }
    },
    LRe = function (t, e) {
      w8(t, e, null)
    },
    lA = function (t, e, r) {
      var n = null
      typeof r > 'u' && (r = ['web', 'flash'])
      var i,
        o = !1,
        s = null
      for (var a in r) {
        i = r[a]
        try {
          if (i === 'flash' || i === 'both') {
            if (e[0] === null) throw new Error('Flash local storage not available.')
            ;(n = t.apply(this, e)), (o = i === 'flash')
          }
          ;(i === 'web' || i === 'both') && ((e[0] = localStorage), (n = t.apply(this, e)), (o = !0))
        } catch (l) {
          s = l
        }
        if (o) break
      }
      if (!o) throw s
      return n
    }
  Z.setItem = function (t, e, r, n, i) {
    lA(NRe, arguments, i)
  }
  Z.getItem = function (t, e, r, n) {
    return lA(kRe, arguments, n)
  }
  Z.removeItem = function (t, e, r, n) {
    lA(ORe, arguments, n)
  }
  Z.clearItems = function (t, e, r) {
    lA(LRe, arguments, r)
  }
  Z.isEmpty = function (t) {
    for (var e in t) if (t.hasOwnProperty(e)) return !1
    return !0
  }
  Z.format = function (t) {
    for (var e = /%./g, r, n, i = 0, o = [], s = 0; (r = e.exec(t)); ) {
      ;(n = t.substring(s, e.lastIndex - 2)), n.length > 0 && o.push(n), (s = e.lastIndex)
      var a = r[0][1]
      switch (a) {
        case 's':
        case 'o':
          i < arguments.length ? o.push(arguments[i++ + 1]) : o.push('<?>')
          break
        case '%':
          o.push('%')
          break
        default:
          o.push('<%' + a + '?>')
      }
    }
    return o.push(t.substring(s)), o.join('')
  }
  Z.formatNumber = function (t, e, r, n) {
    var i = t,
      o = isNaN((e = Math.abs(e))) ? 2 : e,
      s = r === void 0 ? ',' : r,
      a = n === void 0 ? '.' : n,
      l = i < 0 ? '-' : '',
      c = parseInt((i = Math.abs(+i || 0).toFixed(o)), 10) + '',
      u = c.length > 3 ? c.length % 3 : 0
    return (
      l +
      (u ? c.substr(0, u) + a : '') +
      c.substr(u).replace(/(\d{3})(?=\d)/g, '$1' + a) +
      (o
        ? s +
          Math.abs(i - c)
            .toFixed(o)
            .slice(2)
        : '')
    )
  }
  Z.formatSize = function (t) {
    return (
      t >= 1073741824
        ? (t = Z.formatNumber(t / 1073741824, 2, '.', '') + ' GiB')
        : t >= 1048576
        ? (t = Z.formatNumber(t / 1048576, 2, '.', '') + ' MiB')
        : t >= 1024
        ? (t = Z.formatNumber(t / 1024, 0) + ' KiB')
        : (t = Z.formatNumber(t, 0) + ' bytes'),
      t
    )
  }
  Z.bytesFromIP = function (t) {
    return t.indexOf('.') !== -1 ? Z.bytesFromIPv4(t) : t.indexOf(':') !== -1 ? Z.bytesFromIPv6(t) : null
  }
  Z.bytesFromIPv4 = function (t) {
    if (((t = t.split('.')), t.length !== 4)) return null
    for (var e = Z.createBuffer(), r = 0; r < t.length; ++r) {
      var n = parseInt(t[r], 10)
      if (isNaN(n)) return null
      e.putByte(n)
    }
    return e.getBytes()
  }
  Z.bytesFromIPv6 = function (t) {
    var e = 0
    t = t.split(':').filter(function (s) {
      return s.length === 0 && ++e, !0
    })
    for (var r = (8 - t.length + e) * 2, n = Z.createBuffer(), i = 0; i < 8; ++i) {
      if (!t[i] || t[i].length === 0) {
        n.fillWithByte(0, r), (r = 0)
        continue
      }
      var o = Z.hexToBytes(t[i])
      o.length < 2 && n.putByte(0), n.putBytes(o)
    }
    return n.getBytes()
  }
  Z.bytesToIP = function (t) {
    return t.length === 4 ? Z.bytesToIPv4(t) : t.length === 16 ? Z.bytesToIPv6(t) : null
  }
  Z.bytesToIPv4 = function (t) {
    if (t.length !== 4) return null
    for (var e = [], r = 0; r < t.length; ++r) e.push(t.charCodeAt(r))
    return e.join('.')
  }
  Z.bytesToIPv6 = function (t) {
    if (t.length !== 16) return null
    for (var e = [], r = [], n = 0, i = 0; i < t.length; i += 2) {
      for (var o = Z.bytesToHex(t[i] + t[i + 1]); o[0] === '0' && o !== '0'; ) o = o.substr(1)
      if (o === '0') {
        var s = r[r.length - 1],
          a = e.length
        !s || a !== s.end + 1
          ? r.push({ start: a, end: a })
          : ((s.end = a), s.end - s.start > r[n].end - r[n].start && (n = r.length - 1))
      }
      e.push(o)
    }
    if (r.length > 0) {
      var l = r[n]
      l.end - l.start > 0 &&
        (e.splice(l.start, l.end - l.start + 1, ''), l.start === 0 && e.unshift(''), l.end === 7 && e.push(''))
    }
    return e.join(':')
  }
  Z.estimateCores = function (t, e) {
    if ((typeof t == 'function' && ((e = t), (t = {})), (t = t || {}), 'cores' in Z && !t.update))
      return e(null, Z.cores)
    if (typeof navigator < 'u' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0)
      return (Z.cores = navigator.hardwareConcurrency), e(null, Z.cores)
    if (typeof Worker > 'u') return (Z.cores = 1), e(null, Z.cores)
    if (typeof Blob > 'u') return (Z.cores = 2), e(null, Z.cores)
    var r = URL.createObjectURL(
      new Blob(
        [
          '(',
          function () {
            self.addEventListener('message', function (s) {
              for (var a = Date.now(), l = a + 4; Date.now() < l; );
              self.postMessage({ st: a, et: l })
            })
          }.toString(),
          ')()',
        ],
        { type: 'application/javascript' }
      )
    )
    n([], 5, 16)
    function n(s, a, l) {
      if (a === 0) {
        var c = Math.floor(
          s.reduce(function (u, p) {
            return u + p
          }, 0) / s.length
        )
        return (Z.cores = Math.max(1, c)), URL.revokeObjectURL(r), e(null, Z.cores)
      }
      i(l, function (u, p) {
        s.push(o(l, p)), n(s, a - 1, l)
      })
    }
    function i(s, a) {
      for (var l = [], c = [], u = 0; u < s; ++u) {
        var p = new Worker(r)
        p.addEventListener('message', function (d) {
          if ((c.push(d.data), c.length === s)) {
            for (var f = 0; f < s; ++f) l[f].terminate()
            a(null, c)
          }
        }),
          l.push(p)
      }
      for (var u = 0; u < s; ++u) l[u].postMessage(u)
    }
    function o(s, a) {
      for (var l = [], c = 0; c < s; ++c)
        for (var u = a[c], p = (l[c] = []), d = 0; d < s; ++d)
          if (c !== d) {
            var f = a[d]
            ;((u.st > f.st && u.st < f.et) || (f.st > u.st && f.st < u.et)) && p.push(d)
          }
      return l.reduce(function (m, h) {
        return Math.max(m, h.length)
      }, 0)
    }
  }
})
var uA = handleExports((kht, aJ) => {
  var Li = Mt()
  cr()
  aJ.exports = Li.cipher = Li.cipher || {}
  Li.cipher.algorithms = Li.cipher.algorithms || {}
  Li.cipher.createCipher = function (t, e) {
    var r = t
    if ((typeof r == 'string' && ((r = Li.cipher.getAlgorithm(r)), r && (r = r())), !r))
      throw new Error('Unsupported algorithm: ' + t)
    return new Li.cipher.BlockCipher({ algorithm: r, key: e, decrypt: !1 })
  }
  Li.cipher.createDecipher = function (t, e) {
    var r = t
    if ((typeof r == 'string' && ((r = Li.cipher.getAlgorithm(r)), r && (r = r())), !r))
      throw new Error('Unsupported algorithm: ' + t)
    return new Li.cipher.BlockCipher({ algorithm: r, key: e, decrypt: !0 })
  }
  Li.cipher.registerAlgorithm = function (t, e) {
    ;(t = t.toUpperCase()), (Li.cipher.algorithms[t] = e)
  }
  Li.cipher.getAlgorithm = function (t) {
    return (t = t.toUpperCase()), t in Li.cipher.algorithms ? Li.cipher.algorithms[t] : null
  }
  var R8 = (Li.cipher.BlockCipher = function (t) {
    ;(this.algorithm = t.algorithm),
      (this.mode = this.algorithm.mode),
      (this.blockSize = this.mode.blockSize),
      (this._finish = !1),
      (this._input = null),
      (this.output = null),
      (this._op = t.decrypt ? this.mode.decrypt : this.mode.encrypt),
      (this._decrypt = t.decrypt),
      this.algorithm.initialize(t)
  })
  R8.prototype.start = function (t) {
    t = t || {}
    var e = {}
    for (var r in t) e[r] = t[r]
    ;(e.decrypt = this._decrypt),
      (this._finish = !1),
      (this._input = Li.util.createBuffer()),
      (this.output = t.output || Li.util.createBuffer()),
      this.mode.start(e)
  }
  R8.prototype.update = function (t) {
    for (
      t && this._input.putBuffer(t);
      !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;

    );
    this._input.compact()
  }
  R8.prototype.finish = function (t) {
    t &&
      (this.mode.name === 'ECB' || this.mode.name === 'CBC') &&
      ((this.mode.pad = function (r) {
        return t(this.blockSize, r, !1)
      }),
      (this.mode.unpad = function (r) {
        return t(this.blockSize, r, !0)
      }))
    var e = {}
    return (
      (e.decrypt = this._decrypt),
      (e.overflow = this._input.length() % this.blockSize),
      !(
        (!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e)) ||
        ((this._finish = !0), this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) ||
        (this.mode.afterFinish && !this.mode.afterFinish(this.output, e))
      )
    )
  }
})
var P8 = handleExports((Oht, cJ) => {
  var Mi = Mt()
  cr()
  Mi.cipher = Mi.cipher || {}
  var Gt = (cJ.exports = Mi.cipher.modes = Mi.cipher.modes || {})
  Gt.ecb = function (t) {
    ;(t = t || {}),
      (this.name = 'ECB'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints))
  }
  Gt.ecb.prototype.start = function (t) {}
  Gt.ecb.prototype.encrypt = function (t, e, r) {
    if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32()
    this.cipher.encrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n])
  }
  Gt.ecb.prototype.decrypt = function (t, e, r) {
    if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32()
    this.cipher.decrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n])
  }
  Gt.ecb.prototype.pad = function (t, e) {
    var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length()
    return t.fillWithByte(r, r), !0
  }
  Gt.ecb.prototype.unpad = function (t, e) {
    if (e.overflow > 0) return !1
    var r = t.length(),
      n = t.at(r - 1)
    return n > this.blockSize << 2 ? !1 : (t.truncate(n), !0)
  }
  Gt.cbc = function (t) {
    ;(t = t || {}),
      (this.name = 'CBC'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints))
  }
  Gt.cbc.prototype.start = function (t) {
    if (t.iv === null) {
      if (!this._prev) throw new Error('Invalid IV parameter.')
      this._iv = this._prev.slice(0)
    } else if ('iv' in t) (this._iv = pA(t.iv, this.blockSize)), (this._prev = this._iv.slice(0))
    else throw new Error('Invalid IV parameter.')
  }
  Gt.cbc.prototype.encrypt = function (t, e, r) {
    if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._prev[n] ^ t.getInt32()
    this.cipher.encrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n])
    this._prev = this._outBlock
  }
  Gt.cbc.prototype.decrypt = function (t, e, r) {
    if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32()
    this.cipher.decrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) e.putInt32(this._prev[n] ^ this._outBlock[n])
    this._prev = this._inBlock.slice(0)
  }
  Gt.cbc.prototype.pad = function (t, e) {
    var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length()
    return t.fillWithByte(r, r), !0
  }
  Gt.cbc.prototype.unpad = function (t, e) {
    if (e.overflow > 0) return !1
    var r = t.length(),
      n = t.at(r - 1)
    return n > this.blockSize << 2 ? !1 : (t.truncate(n), !0)
  }
  Gt.cfb = function (t) {
    ;(t = t || {}),
      (this.name = 'CFB'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialBlock = new Array(this._ints)),
      (this._partialOutput = Mi.util.createBuffer()),
      (this._partialBytes = 0)
  }
  Gt.cfb.prototype.start = function (t) {
    if (!('iv' in t)) throw new Error('Invalid IV parameter.')
    ;(this._iv = pA(t.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
  }
  Gt.cfb.prototype.encrypt = function (t, e, r) {
    var n = t.length()
    if (n === 0) return !0
    if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
      for (var i = 0; i < this._ints; ++i)
        (this._inBlock[i] = t.getInt32() ^ this._outBlock[i]), e.putInt32(this._inBlock[i])
      return
    }
    var o = (this.blockSize - n) % this.blockSize
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i)
      (this._partialBlock[i] = t.getInt32() ^ this._outBlock[i]), this._partialOutput.putInt32(this._partialBlock[i])
    if (o > 0) t.read -= this.blockSize
    else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i]
    if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r))
      return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), (this._partialBytes = o), !0
    e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
  }
  Gt.cfb.prototype.decrypt = function (t, e, r) {
    var n = t.length()
    if (n === 0) return !0
    if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
      for (var i = 0; i < this._ints; ++i)
        (this._inBlock[i] = t.getInt32()), e.putInt32(this._inBlock[i] ^ this._outBlock[i])
      return
    }
    var o = (this.blockSize - n) % this.blockSize
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i)
      (this._partialBlock[i] = t.getInt32()), this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i])
    if (o > 0) t.read -= this.blockSize
    else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i]
    if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r))
      return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), (this._partialBytes = o), !0
    e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
  }
  Gt.ofb = function (t) {
    ;(t = t || {}),
      (this.name = 'OFB'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = Mi.util.createBuffer()),
      (this._partialBytes = 0)
  }
  Gt.ofb.prototype.start = function (t) {
    if (!('iv' in t)) throw new Error('Invalid IV parameter.')
    ;(this._iv = pA(t.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
  }
  Gt.ofb.prototype.encrypt = function (t, e, r) {
    var n = t.length()
    if (t.length() === 0) return !0
    if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
      for (var i = 0; i < this._ints; ++i)
        e.putInt32(t.getInt32() ^ this._outBlock[i]), (this._inBlock[i] = this._outBlock[i])
      return
    }
    var o = (this.blockSize - n) % this.blockSize
    o > 0 && (o = this.blockSize - o), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i])
    if (o > 0) t.read -= this.blockSize
    else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i]
    if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r))
      return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), (this._partialBytes = o), !0
    e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
  }
  Gt.ofb.prototype.decrypt = Gt.ofb.prototype.encrypt
  Gt.ctr = function (t) {
    ;(t = t || {}),
      (this.name = 'CTR'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = Mi.util.createBuffer()),
      (this._partialBytes = 0)
  }
  Gt.ctr.prototype.start = function (t) {
    if (!('iv' in t)) throw new Error('Invalid IV parameter.')
    ;(this._iv = pA(t.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
  }
  Gt.ctr.prototype.encrypt = function (t, e, r) {
    var n = t.length()
    if (n === 0) return !0
    if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize))
      for (var i = 0; i < this._ints; ++i) e.putInt32(t.getInt32() ^ this._outBlock[i])
    else {
      var o = (this.blockSize - n) % this.blockSize
      o > 0 && (o = this.blockSize - o), this._partialOutput.clear()
      for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i])
      if (
        (o > 0 && (t.read -= this.blockSize),
        this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes),
        o > 0 && !r)
      )
        return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), (this._partialBytes = o), !0
      e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
    }
    dA(this._inBlock)
  }
  Gt.ctr.prototype.decrypt = Gt.ctr.prototype.encrypt
  Gt.gcm = function (t) {
    ;(t = t || {}),
      (this.name = 'GCM'),
      (this.cipher = t.cipher),
      (this.blockSize = t.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = Mi.util.createBuffer()),
      (this._partialBytes = 0),
      (this._R = 3774873600)
  }
  Gt.gcm.prototype.start = function (t) {
    if (!('iv' in t)) throw new Error('Invalid IV parameter.')
    var e = Mi.util.createBuffer(t.iv)
    this._cipherLength = 0
    var r
    if (
      ('additionalData' in t ? (r = Mi.util.createBuffer(t.additionalData)) : (r = Mi.util.createBuffer()),
      'tagLength' in t ? (this._tagLength = t.tagLength) : (this._tagLength = 128),
      (this._tag = null),
      t.decrypt && ((this._tag = Mi.util.createBuffer(t.tag).getBytes()), this._tag.length !== this._tagLength / 8))
    )
      throw new Error('Authentication tag does not match tag length.')
    ;(this._hashBlock = new Array(this._ints)),
      (this.tag = null),
      (this._hashSubkey = new Array(this._ints)),
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey),
      (this.componentBits = 4),
      (this._m = this.generateHashTable(this._hashSubkey, this.componentBits))
    var n = e.length()
    if (n === 12) this._j0 = [e.getInt32(), e.getInt32(), e.getInt32(), 1]
    else {
      for (this._j0 = [0, 0, 0, 0]; e.length() > 0; )
        this._j0 = this.ghash(this._hashSubkey, this._j0, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()])
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(D8(n * 8)))
    }
    ;(this._inBlock = this._j0.slice(0)),
      dA(this._inBlock),
      (this._partialBytes = 0),
      (r = Mi.util.createBuffer(r)),
      (this._aDataLength = D8(r.length() * 8))
    var i = r.length() % this.blockSize
    for (i && r.fillWithByte(0, this.blockSize - i), this._s = [0, 0, 0, 0]; r.length() > 0; )
      this._s = this.ghash(this._hashSubkey, this._s, [r.getInt32(), r.getInt32(), r.getInt32(), r.getInt32()])
  }
  Gt.gcm.prototype.encrypt = function (t, e, r) {
    var n = t.length()
    if (n === 0) return !0
    if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)) {
      for (var i = 0; i < this._ints; ++i) e.putInt32((this._outBlock[i] ^= t.getInt32()))
      this._cipherLength += this.blockSize
    } else {
      var o = (this.blockSize - n) % this.blockSize
      o > 0 && (o = this.blockSize - o), this._partialOutput.clear()
      for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i])
      if (o <= 0 || r) {
        if (r) {
          var s = n % this.blockSize
          ;(this._cipherLength += s), this._partialOutput.truncate(this.blockSize - s)
        } else this._cipherLength += this.blockSize
        for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32()
        this._partialOutput.read -= this.blockSize
      }
      if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r))
        return (
          (t.read -= this.blockSize),
          e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)),
          (this._partialBytes = o),
          !0
        )
      e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), (this._partialBytes = 0)
    }
    ;(this._s = this.ghash(this._hashSubkey, this._s, this._outBlock)), dA(this._inBlock)
  }
  Gt.gcm.prototype.decrypt = function (t, e, r) {
    var n = t.length()
    if (n < this.blockSize && !(r && n > 0)) return !0
    this.cipher.encrypt(this._inBlock, this._outBlock),
      dA(this._inBlock),
      (this._hashBlock[0] = t.getInt32()),
      (this._hashBlock[1] = t.getInt32()),
      (this._hashBlock[2] = t.getInt32()),
      (this._hashBlock[3] = t.getInt32()),
      (this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock))
    for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i] ^ this._hashBlock[i])
    n < this.blockSize ? (this._cipherLength += n % this.blockSize) : (this._cipherLength += this.blockSize)
  }
  Gt.gcm.prototype.afterFinish = function (t, e) {
    var r = !0
    e.decrypt && e.overflow && t.truncate(this.blockSize - e.overflow), (this.tag = Mi.util.createBuffer())
    var n = this._aDataLength.concat(D8(this._cipherLength * 8))
    this._s = this.ghash(this._hashSubkey, this._s, n)
    var i = []
    this.cipher.encrypt(this._j0, i)
    for (var o = 0; o < this._ints; ++o) this.tag.putInt32(this._s[o] ^ i[o])
    return (
      this.tag.truncate(this.tag.length() % (this._tagLength / 8)),
      e.decrypt && this.tag.bytes() !== this._tag && (r = !1),
      r
    )
  }
  Gt.gcm.prototype.multiply = function (t, e) {
    for (var r = [0, 0, 0, 0], n = e.slice(0), i = 0; i < 128; ++i) {
      var o = t[(i / 32) | 0] & (1 << (31 - (i % 32)))
      o && ((r[0] ^= n[0]), (r[1] ^= n[1]), (r[2] ^= n[2]), (r[3] ^= n[3])), this.pow(n, n)
    }
    return r
  }
  Gt.gcm.prototype.pow = function (t, e) {
    for (var r = t[3] & 1, n = 3; n > 0; --n) e[n] = (t[n] >>> 1) | ((t[n - 1] & 1) << 31)
    ;(e[0] = t[0] >>> 1), r && (e[0] ^= this._R)
  }
  Gt.gcm.prototype.tableMultiply = function (t) {
    for (var e = [0, 0, 0, 0], r = 0; r < 32; ++r) {
      var n = (r / 8) | 0,
        i = (t[n] >>> ((7 - (r % 8)) * 4)) & 15,
        o = this._m[r][i]
      ;(e[0] ^= o[0]), (e[1] ^= o[1]), (e[2] ^= o[2]), (e[3] ^= o[3])
    }
    return e
  }
  Gt.gcm.prototype.ghash = function (t, e, r) {
    return (e[0] ^= r[0]), (e[1] ^= r[1]), (e[2] ^= r[2]), (e[3] ^= r[3]), this.tableMultiply(e)
  }
  Gt.gcm.prototype.generateHashTable = function (t, e) {
    for (var r = 8 / e, n = 4 * r, i = 16 * r, o = new Array(i), s = 0; s < i; ++s) {
      var a = [0, 0, 0, 0],
        l = (s / n) | 0,
        c = (n - 1 - (s % n)) * e
      ;(a[l] = (1 << (e - 1)) << c), (o[s] = this.generateSubHashTable(this.multiply(a, t), e))
    }
    return o
  }
  Gt.gcm.prototype.generateSubHashTable = function (t, e) {
    var r = 1 << e,
      n = r >>> 1,
      i = new Array(r)
    i[n] = t.slice(0)
    for (var o = n >>> 1; o > 0; ) this.pow(i[2 * o], (i[o] = [])), (o >>= 1)
    for (o = 2; o < n; ) {
      for (var s = 1; s < o; ++s) {
        var a = i[o],
          l = i[s]
        i[o + s] = [a[0] ^ l[0], a[1] ^ l[1], a[2] ^ l[2], a[3] ^ l[3]]
      }
      o *= 2
    }
    for (i[0] = [0, 0, 0, 0], o = n + 1; o < r; ++o) {
      var c = i[o ^ n]
      i[o] = [t[0] ^ c[0], t[1] ^ c[1], t[2] ^ c[2], t[3] ^ c[3]]
    }
    return i
  }
  function pA(t, e) {
    if ((typeof t == 'string' && (t = Mi.util.createBuffer(t)), Mi.util.isArray(t) && t.length > 4)) {
      var r = t
      t = Mi.util.createBuffer()
      for (var n = 0; n < r.length; ++n) t.putByte(r[n])
    }
    if (t.length() < e) throw new Error('Invalid IV length; got ' + t.length() + ' bytes and expected ' + e + ' bytes.')
    if (!Mi.util.isArray(t)) {
      for (var i = [], o = e / 4, n = 0; n < o; ++n) i.push(t.getInt32())
      t = i
    }
    return t
  }
  function dA(t) {
    t[t.length - 1] = (t[t.length - 1] + 1) & 4294967295
  }
  function D8(t) {
    return [(t / 4294967296) | 0, t & 4294967295]
  }
})
var Tf = handleExports((Lht, dJ) => {
  var Hr = Mt()
  uA()
  P8()
  cr()
  dJ.exports = Hr.aes = Hr.aes || {}
  Hr.aes.startEncrypting = function (t, e, r, n) {
    var i = fA({ key: t, output: r, decrypt: !1, mode: n })
    return i.start(e), i
  }
  Hr.aes.createEncryptionCipher = function (t, e) {
    return fA({ key: t, output: null, decrypt: !1, mode: e })
  }
  Hr.aes.startDecrypting = function (t, e, r, n) {
    var i = fA({ key: t, output: r, decrypt: !0, mode: n })
    return i.start(e), i
  }
  Hr.aes.createDecryptionCipher = function (t, e) {
    return fA({ key: t, output: null, decrypt: !0, mode: e })
  }
  Hr.aes.Algorithm = function (t, e) {
    O8 || uJ()
    var r = this
    ;(r.name = t),
      (r.mode = new e({
        blockSize: 16,
        cipher: {
          encrypt: function (n, i) {
            return k8(r._w, n, i, !1)
          },
          decrypt: function (n, i) {
            return k8(r._w, n, i, !0)
          },
        },
      })),
      (r._init = !1)
  }
  Hr.aes.Algorithm.prototype.initialize = function (t) {
    if (!this._init) {
      var e = t.key,
        r
      if (typeof e == 'string' && (e.length === 16 || e.length === 24 || e.length === 32)) e = Hr.util.createBuffer(e)
      else if (Hr.util.isArray(e) && (e.length === 16 || e.length === 24 || e.length === 32)) {
        ;(r = e), (e = Hr.util.createBuffer())
        for (var n = 0; n < r.length; ++n) e.putByte(r[n])
      }
      if (!Hr.util.isArray(e)) {
        ;(r = e), (e = [])
        var i = r.length()
        if (i === 16 || i === 24 || i === 32) {
          i = i >>> 2
          for (var n = 0; n < i; ++n) e.push(r.getInt32())
        }
      }
      if (!Hr.util.isArray(e) || !(e.length === 4 || e.length === 6 || e.length === 8))
        throw new Error('Invalid key parameter.')
      var o = this.mode.name,
        s = ['CFB', 'OFB', 'CTR', 'GCM'].indexOf(o) !== -1
      ;(this._w = pJ(e, t.decrypt && !s)), (this._init = !0)
    }
  }
  Hr.aes._expandKey = function (t, e) {
    return O8 || uJ(), pJ(t, e)
  }
  Hr.aes._updateBlock = k8
  m_('AES-ECB', Hr.cipher.modes.ecb)
  m_('AES-CBC', Hr.cipher.modes.cbc)
  m_('AES-CFB', Hr.cipher.modes.cfb)
  m_('AES-OFB', Hr.cipher.modes.ofb)
  m_('AES-CTR', Hr.cipher.modes.ctr)
  m_('AES-GCM', Hr.cipher.modes.gcm)
  function m_(t, e) {
    var r = function () {
      return new Hr.aes.Algorithm(t, e)
    }
    Hr.cipher.registerAlgorithm(t, r)
  }
  var O8 = !1,
    f_ = 4,
    $o,
    N8,
    lJ,
    ug,
    Oc
  function uJ() {
    ;(O8 = !0), (lJ = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54])
    for (var t = new Array(256), e = 0; e < 128; ++e) (t[e] = e << 1), (t[e + 128] = ((e + 128) << 1) ^ 283)
    ;($o = new Array(256)), (N8 = new Array(256)), (ug = new Array(4)), (Oc = new Array(4))
    for (var e = 0; e < 4; ++e) (ug[e] = new Array(256)), (Oc[e] = new Array(256))
    for (var r = 0, n = 0, i, o, s, a, l, c, u, e = 0; e < 256; ++e) {
      ;(a = n ^ (n << 1) ^ (n << 2) ^ (n << 3) ^ (n << 4)),
        (a = (a >> 8) ^ (a & 255) ^ 99),
        ($o[r] = a),
        (N8[a] = r),
        (l = t[a]),
        (i = t[r]),
        (o = t[i]),
        (s = t[o]),
        (c = (l << 24) ^ (a << 16) ^ (a << 8) ^ (a ^ l)),
        (u = ((i ^ o ^ s) << 24) ^ ((r ^ s) << 16) ^ ((r ^ o ^ s) << 8) ^ (r ^ i ^ s))
      for (var p = 0; p < 4; ++p)
        (ug[p][r] = c), (Oc[p][a] = u), (c = (c << 24) | (c >>> 8)), (u = (u << 24) | (u >>> 8))
      r === 0 ? (r = n = 1) : ((r = i ^ t[t[t[i ^ s]]]), (n ^= t[t[n]]))
    }
  }
  function pJ(t, e) {
    for (var r = t.slice(0), n, i = 1, o = r.length, s = o + 6 + 1, a = f_ * s, l = o; l < a; ++l)
      (n = r[l - 1]),
        l % o === 0
          ? ((n =
              ($o[(n >>> 16) & 255] << 24) ^
              ($o[(n >>> 8) & 255] << 16) ^
              ($o[n & 255] << 8) ^
              $o[n >>> 24] ^
              (lJ[i] << 24)),
            i++)
          : o > 6 &&
            l % o === 4 &&
            (n = ($o[n >>> 24] << 24) ^ ($o[(n >>> 16) & 255] << 16) ^ ($o[(n >>> 8) & 255] << 8) ^ $o[n & 255]),
        (r[l] = r[l - o] ^ n)
    if (e) {
      var c,
        u = Oc[0],
        p = Oc[1],
        d = Oc[2],
        f = Oc[3],
        m = r.slice(0)
      a = r.length
      for (var l = 0, h = a - f_; l < a; l += f_, h -= f_)
        if (l === 0 || l === a - f_) (m[l] = r[h]), (m[l + 1] = r[h + 3]), (m[l + 2] = r[h + 2]), (m[l + 3] = r[h + 1])
        else
          for (var g = 0; g < f_; ++g)
            (c = r[h + g]),
              (m[l + (3 & -g)] = u[$o[c >>> 24]] ^ p[$o[(c >>> 16) & 255]] ^ d[$o[(c >>> 8) & 255]] ^ f[$o[c & 255]])
      r = m
    }
    return r
  }
  function k8(t, e, r, n) {
    var i = t.length / 4 - 1,
      o,
      s,
      a,
      l,
      c
    n
      ? ((o = Oc[0]), (s = Oc[1]), (a = Oc[2]), (l = Oc[3]), (c = N8))
      : ((o = ug[0]), (s = ug[1]), (a = ug[2]), (l = ug[3]), (c = $o))
    var u, p, d, f, m, h, g
    ;(u = e[0] ^ t[0]), (p = e[n ? 3 : 1] ^ t[1]), (d = e[2] ^ t[2]), (f = e[n ? 1 : 3] ^ t[3])
    for (var v = 3, _ = 1; _ < i; ++_)
      (m = o[u >>> 24] ^ s[(p >>> 16) & 255] ^ a[(d >>> 8) & 255] ^ l[f & 255] ^ t[++v]),
        (h = o[p >>> 24] ^ s[(d >>> 16) & 255] ^ a[(f >>> 8) & 255] ^ l[u & 255] ^ t[++v]),
        (g = o[d >>> 24] ^ s[(f >>> 16) & 255] ^ a[(u >>> 8) & 255] ^ l[p & 255] ^ t[++v]),
        (f = o[f >>> 24] ^ s[(u >>> 16) & 255] ^ a[(p >>> 8) & 255] ^ l[d & 255] ^ t[++v]),
        (u = m),
        (p = h),
        (d = g)
    ;(r[0] = (c[u >>> 24] << 24) ^ (c[(p >>> 16) & 255] << 16) ^ (c[(d >>> 8) & 255] << 8) ^ c[f & 255] ^ t[++v]),
      (r[n ? 3 : 1] =
        (c[p >>> 24] << 24) ^ (c[(d >>> 16) & 255] << 16) ^ (c[(f >>> 8) & 255] << 8) ^ c[u & 255] ^ t[++v]),
      (r[2] = (c[d >>> 24] << 24) ^ (c[(f >>> 16) & 255] << 16) ^ (c[(u >>> 8) & 255] << 8) ^ c[p & 255] ^ t[++v]),
      (r[n ? 1 : 3] =
        (c[f >>> 24] << 24) ^ (c[(u >>> 16) & 255] << 16) ^ (c[(p >>> 8) & 255] << 8) ^ c[d & 255] ^ t[++v])
  }
  function fA(t) {
    t = t || {}
    var e = (t.mode || 'CBC').toUpperCase(),
      r = 'AES-' + e,
      n
    t.decrypt ? (n = Hr.cipher.createDecipher(r, t.key)) : (n = Hr.cipher.createCipher(r, t.key))
    var i = n.start
    return (
      (n.start = function (o, s) {
        var a = null
        s instanceof Hr.util.ByteBuffer && ((a = s), (s = {})), (s = s || {}), (s.output = a), (s.iv = o), i.call(n, s)
      }),
      n
    )
  }
})
var Sf = handleExports((Mht, fJ) => {
  var qb = Mt()
  qb.pki = qb.pki || {}
  var L8 = (fJ.exports = qb.pki.oids = qb.oids = qb.oids || {})
  function Pe(t, e) {
    ;(L8[t] = e), (L8[e] = t)
  }
  function Sr(t, e) {
    L8[t] = e
  }
  Pe('1.2.840.113549.1.1.1', 'rsaEncryption')
  Pe('1.2.840.113549.1.1.4', 'md5WithRSAEncryption')
  Pe('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption')
  Pe('1.2.840.113549.1.1.7', 'RSAES-OAEP')
  Pe('1.2.840.113549.1.1.8', 'mgf1')
  Pe('1.2.840.113549.1.1.9', 'pSpecified')
  Pe('1.2.840.113549.1.1.10', 'RSASSA-PSS')
  Pe('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption')
  Pe('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption')
  Pe('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption')
  Pe('1.3.101.112', 'EdDSA25519')
  Pe('1.2.840.10040.4.3', 'dsa-with-sha1')
  Pe('1.3.14.3.2.7', 'desCBC')
  Pe('1.3.14.3.2.26', 'sha1')
  Pe('1.3.14.3.2.29', 'sha1WithRSASignature')
  Pe('2.16.840.1.101.3.4.2.1', 'sha256')
  Pe('2.16.840.1.101.3.4.2.2', 'sha384')
  Pe('2.16.840.1.101.3.4.2.3', 'sha512')
  Pe('2.16.840.1.101.3.4.2.4', 'sha224')
  Pe('2.16.840.1.101.3.4.2.5', 'sha512-224')
  Pe('2.16.840.1.101.3.4.2.6', 'sha512-256')
  Pe('1.2.840.113549.2.2', 'md2')
  Pe('1.2.840.113549.2.5', 'md5')
  Pe('1.2.840.113549.1.7.1', 'data')
  Pe('1.2.840.113549.1.7.2', 'signedData')
  Pe('1.2.840.113549.1.7.3', 'envelopedData')
  Pe('1.2.840.113549.1.7.4', 'signedAndEnvelopedData')
  Pe('1.2.840.113549.1.7.5', 'digestedData')
  Pe('1.2.840.113549.1.7.6', 'encryptedData')
  Pe('1.2.840.113549.1.9.1', 'emailAddress')
  Pe('1.2.840.113549.1.9.2', 'unstructuredName')
  Pe('1.2.840.113549.1.9.3', 'contentType')
  Pe('1.2.840.113549.1.9.4', 'messageDigest')
  Pe('1.2.840.113549.1.9.5', 'signingTime')
  Pe('1.2.840.113549.1.9.6', 'counterSignature')
  Pe('1.2.840.113549.1.9.7', 'challengePassword')
  Pe('1.2.840.113549.1.9.8', 'unstructuredAddress')
  Pe('1.2.840.113549.1.9.14', 'extensionRequest')
  Pe('1.2.840.113549.1.9.20', 'friendlyName')
  Pe('1.2.840.113549.1.9.21', 'localKeyId')
  Pe('1.2.840.113549.1.9.22.1', 'x509Certificate')
  Pe('1.2.840.113549.1.12.10.1.1', 'keyBag')
  Pe('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag')
  Pe('1.2.840.113549.1.12.10.1.3', 'certBag')
  Pe('1.2.840.113549.1.12.10.1.4', 'crlBag')
  Pe('1.2.840.113549.1.12.10.1.5', 'secretBag')
  Pe('1.2.840.113549.1.12.10.1.6', 'safeContentsBag')
  Pe('1.2.840.113549.1.5.13', 'pkcs5PBES2')
  Pe('1.2.840.113549.1.5.12', 'pkcs5PBKDF2')
  Pe('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4')
  Pe('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4')
  Pe('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC')
  Pe('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC')
  Pe('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC')
  Pe('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC')
  Pe('1.2.840.113549.2.7', 'hmacWithSHA1')
  Pe('1.2.840.113549.2.8', 'hmacWithSHA224')
  Pe('1.2.840.113549.2.9', 'hmacWithSHA256')
  Pe('1.2.840.113549.2.10', 'hmacWithSHA384')
  Pe('1.2.840.113549.2.11', 'hmacWithSHA512')
  Pe('1.2.840.113549.3.7', 'des-EDE3-CBC')
  Pe('2.16.840.1.101.3.4.1.2', 'aes128-CBC')
  Pe('2.16.840.1.101.3.4.1.22', 'aes192-CBC')
  Pe('2.16.840.1.101.3.4.1.42', 'aes256-CBC')
  Pe('2.5.4.3', 'commonName')
  Pe('2.5.4.4', 'surname')
  Pe('2.5.4.5', 'serialNumber')
  Pe('2.5.4.6', 'countryName')
  Pe('2.5.4.7', 'localityName')
  Pe('2.5.4.8', 'stateOrProvinceName')
  Pe('2.5.4.9', 'streetAddress')
  Pe('2.5.4.10', 'organizationName')
  Pe('2.5.4.11', 'organizationalUnitName')
  Pe('2.5.4.12', 'title')
  Pe('2.5.4.13', 'description')
  Pe('2.5.4.15', 'businessCategory')
  Pe('2.5.4.17', 'postalCode')
  Pe('2.5.4.42', 'givenName')
  Pe('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName')
  Pe('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName')
  Pe('2.16.840.1.113730.1.1', 'nsCertType')
  Pe('2.16.840.1.113730.1.13', 'nsComment')
  Sr('2.5.29.1', 'authorityKeyIdentifier')
  Sr('2.5.29.2', 'keyAttributes')
  Sr('2.5.29.3', 'certificatePolicies')
  Sr('2.5.29.4', 'keyUsageRestriction')
  Sr('2.5.29.5', 'policyMapping')
  Sr('2.5.29.6', 'subtreesConstraint')
  Sr('2.5.29.7', 'subjectAltName')
  Sr('2.5.29.8', 'issuerAltName')
  Sr('2.5.29.9', 'subjectDirectoryAttributes')
  Sr('2.5.29.10', 'basicConstraints')
  Sr('2.5.29.11', 'nameConstraints')
  Sr('2.5.29.12', 'policyConstraints')
  Sr('2.5.29.13', 'basicConstraints')
  Pe('2.5.29.14', 'subjectKeyIdentifier')
  Pe('2.5.29.15', 'keyUsage')
  Sr('2.5.29.16', 'privateKeyUsagePeriod')
  Pe('2.5.29.17', 'subjectAltName')
  Pe('2.5.29.18', 'issuerAltName')
  Pe('2.5.29.19', 'basicConstraints')
  Sr('2.5.29.20', 'cRLNumber')
  Sr('2.5.29.21', 'cRLReason')
  Sr('2.5.29.22', 'expirationDate')
  Sr('2.5.29.23', 'instructionCode')
  Sr('2.5.29.24', 'invalidityDate')
  Sr('2.5.29.25', 'cRLDistributionPoints')
  Sr('2.5.29.26', 'issuingDistributionPoint')
  Sr('2.5.29.27', 'deltaCRLIndicator')
  Sr('2.5.29.28', 'issuingDistributionPoint')
  Sr('2.5.29.29', 'certificateIssuer')
  Sr('2.5.29.30', 'nameConstraints')
  Pe('2.5.29.31', 'cRLDistributionPoints')
  Pe('2.5.29.32', 'certificatePolicies')
  Sr('2.5.29.33', 'policyMappings')
  Sr('2.5.29.34', 'policyConstraints')
  Pe('2.5.29.35', 'authorityKeyIdentifier')
  Sr('2.5.29.36', 'policyConstraints')
  Pe('2.5.29.37', 'extKeyUsage')
  Sr('2.5.29.46', 'freshestCRL')
  Sr('2.5.29.54', 'inhibitAnyPolicy')
  Pe('1.3.6.1.4.1.11129.2.4.2', 'timestampList')
  Pe('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess')
  Pe('1.3.6.1.5.5.7.3.1', 'serverAuth')
  Pe('1.3.6.1.5.5.7.3.2', 'clientAuth')
  Pe('1.3.6.1.5.5.7.3.3', 'codeSigning')
  Pe('1.3.6.1.5.5.7.3.4', 'emailProtection')
  Pe('1.3.6.1.5.5.7.3.8', 'timeStamping')
})
var Lc = handleExports((Fht, hJ) => {
  var rn = Mt()
  cr()
  Sf()
  var He = (hJ.exports = rn.asn1 = rn.asn1 || {})
  He.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 }
  He.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30,
  }
  He.create = function (t, e, r, n, i) {
    if (rn.util.isArray(n)) {
      for (var o = [], s = 0; s < n.length; ++s) n[s] !== void 0 && o.push(n[s])
      n = o
    }
    var a = { tagClass: t, type: e, constructed: r, composed: r || rn.util.isArray(n), value: n }
    return i && 'bitStringContents' in i && ((a.bitStringContents = i.bitStringContents), (a.original = He.copy(a))), a
  }
  He.copy = function (t, e) {
    var r
    if (rn.util.isArray(t)) {
      r = []
      for (var n = 0; n < t.length; ++n) r.push(He.copy(t[n], e))
      return r
    }
    return typeof t == 'string'
      ? t
      : ((r = {
          tagClass: t.tagClass,
          type: t.type,
          constructed: t.constructed,
          composed: t.composed,
          value: He.copy(t.value, e),
        }),
        e && !e.excludeBitStringContents && (r.bitStringContents = t.bitStringContents),
        r)
  }
  He.equals = function (t, e, r) {
    if (rn.util.isArray(t)) {
      if (!rn.util.isArray(e) || t.length !== e.length) return !1
      for (var n = 0; n < t.length; ++n) if (!He.equals(t[n], e[n])) return !1
      return !0
    }
    if (typeof t != typeof e) return !1
    if (typeof t == 'string') return t === e
    var i =
      t.tagClass === e.tagClass &&
      t.type === e.type &&
      t.constructed === e.constructed &&
      t.composed === e.composed &&
      He.equals(t.value, e.value)
    return r && r.includeBitStringContents && (i = i && t.bitStringContents === e.bitStringContents), i
  }
  He.getBerValueLength = function (t) {
    var e = t.getByte()
    if (e !== 128) {
      var r,
        n = e & 128
      return n ? (r = t.getInt((e & 127) << 3)) : (r = e), r
    }
  }
  function Hb(t, e, r) {
    if (r > e) {
      var n = new Error('Too few bytes to parse DER.')
      throw ((n.available = t.length()), (n.remaining = e), (n.requested = r), n)
    }
  }
  var MRe = function (t, e) {
    var r = t.getByte()
    if ((e--, r !== 128)) {
      var n,
        i = r & 128
      if (!i) n = r
      else {
        var o = r & 127
        Hb(t, e, o), (n = t.getInt(o << 3))
      }
      if (n < 0) throw new Error('Negative length: ' + n)
      return n
    }
  }
  He.fromDer = function (t, e) {
    e === void 0 && (e = { strict: !0, parseAllBytes: !0, decodeBitStrings: !0 }),
      typeof e == 'boolean' && (e = { strict: e, parseAllBytes: !0, decodeBitStrings: !0 }),
      'strict' in e || (e.strict = !0),
      'parseAllBytes' in e || (e.parseAllBytes = !0),
      'decodeBitStrings' in e || (e.decodeBitStrings = !0),
      typeof t == 'string' && (t = rn.util.createBuffer(t))
    var r = t.length(),
      n = mA(t, t.length(), 0, e)
    if (e.parseAllBytes && t.length() !== 0) {
      var i = new Error('Unparsed DER bytes remain after ASN.1 parsing.')
      throw ((i.byteCount = r), (i.remaining = t.length()), i)
    }
    return n
  }
  function mA(t, e, r, n) {
    var i
    Hb(t, e, 2)
    var o = t.getByte()
    e--
    var s = o & 192,
      a = o & 31
    i = t.length()
    var l = MRe(t, e)
    if (((e -= i - t.length()), l !== void 0 && l > e)) {
      if (n.strict) {
        var c = new Error('Too few bytes to read ASN.1 value.')
        throw ((c.available = t.length()), (c.remaining = e), (c.requested = l), c)
      }
      l = e
    }
    var u,
      p,
      d = (o & 32) === 32
    if (d)
      if (((u = []), l === void 0))
        for (;;) {
          if ((Hb(t, e, 2), t.bytes(2) === String.fromCharCode(0, 0))) {
            t.getBytes(2), (e -= 2)
            break
          }
          ;(i = t.length()), u.push(mA(t, e, r + 1, n)), (e -= i - t.length())
        }
      else for (; l > 0; ) (i = t.length()), u.push(mA(t, l, r + 1, n)), (e -= i - t.length()), (l -= i - t.length())
    if (
      (u === void 0 && s === He.Class.UNIVERSAL && a === He.Type.BITSTRING && (p = t.bytes(l)),
      u === void 0 && n.decodeBitStrings && s === He.Class.UNIVERSAL && a === He.Type.BITSTRING && l > 1)
    ) {
      var f = t.read,
        m = e,
        h = 0
      if ((a === He.Type.BITSTRING && (Hb(t, e, 1), (h = t.getByte()), e--), h === 0))
        try {
          i = t.length()
          var g = { strict: !0, decodeBitStrings: !0 },
            v = mA(t, e, r + 1, g),
            _ = i - t.length()
          ;(e -= _), a == He.Type.BITSTRING && _++
          var y = v.tagClass
          _ === l && (y === He.Class.UNIVERSAL || y === He.Class.CONTEXT_SPECIFIC) && (u = [v])
        } catch {}
      u === void 0 && ((t.read = f), (e = m))
    }
    if (u === void 0) {
      if (l === void 0) {
        if (n.strict) throw new Error('Non-constructed ASN.1 object of indefinite length.')
        l = e
      }
      if (a === He.Type.BMPSTRING)
        for (u = ''; l > 0; l -= 2) Hb(t, e, 2), (u += String.fromCharCode(t.getInt16())), (e -= 2)
      else (u = t.getBytes(l)), (e -= l)
    }
    var b = p === void 0 ? null : { bitStringContents: p }
    return He.create(s, a, d, u, b)
  }
  He.toDer = function (t) {
    var e = rn.util.createBuffer(),
      r = t.tagClass | t.type,
      n = rn.util.createBuffer(),
      i = !1
    if (('bitStringContents' in t && ((i = !0), t.original && (i = He.equals(t, t.original))), i))
      n.putBytes(t.bitStringContents)
    else if (t.composed) {
      t.constructed ? (r |= 32) : n.putByte(0)
      for (var o = 0; o < t.value.length; ++o) t.value[o] !== void 0 && n.putBuffer(He.toDer(t.value[o]))
    } else if (t.type === He.Type.BMPSTRING) for (var o = 0; o < t.value.length; ++o) n.putInt16(t.value.charCodeAt(o))
    else
      t.type === He.Type.INTEGER &&
      t.value.length > 1 &&
      ((t.value.charCodeAt(0) === 0 && !(t.value.charCodeAt(1) & 128)) ||
        (t.value.charCodeAt(0) === 255 && (t.value.charCodeAt(1) & 128) === 128))
        ? n.putBytes(t.value.substr(1))
        : n.putBytes(t.value)
    if ((e.putByte(r), n.length() <= 127)) e.putByte(n.length() & 127)
    else {
      var s = n.length(),
        a = ''
      do (a += String.fromCharCode(s & 255)), (s = s >>> 8)
      while (s > 0)
      e.putByte(a.length | 128)
      for (var o = a.length - 1; o >= 0; --o) e.putByte(a.charCodeAt(o))
    }
    return e.putBuffer(n), e
  }
  He.oidToDer = function (t) {
    var e = t.split('.'),
      r = rn.util.createBuffer()
    r.putByte(40 * parseInt(e[0], 10) + parseInt(e[1], 10))
    for (var n, i, o, s, a = 2; a < e.length; ++a) {
      ;(n = !0), (i = []), (o = parseInt(e[a], 10))
      do (s = o & 127), (o = o >>> 7), n || (s |= 128), i.push(s), (n = !1)
      while (o > 0)
      for (var l = i.length - 1; l >= 0; --l) r.putByte(i[l])
    }
    return r
  }
  He.derToOid = function (t) {
    var e
    typeof t == 'string' && (t = rn.util.createBuffer(t))
    var r = t.getByte()
    e = Math.floor(r / 40) + '.' + (r % 40)
    for (var n = 0; t.length() > 0; )
      (r = t.getByte()), (n = n << 7), r & 128 ? (n += r & 127) : ((e += '.' + (n + r)), (n = 0))
    return e
  }
  He.utcTimeToDate = function (t) {
    var e = new Date(),
      r = parseInt(t.substr(0, 2), 10)
    r = r >= 50 ? 1900 + r : 2e3 + r
    var n = parseInt(t.substr(2, 2), 10) - 1,
      i = parseInt(t.substr(4, 2), 10),
      o = parseInt(t.substr(6, 2), 10),
      s = parseInt(t.substr(8, 2), 10),
      a = 0
    if (t.length > 11) {
      var l = t.charAt(10),
        c = 10
      l !== '+' && l !== '-' && ((a = parseInt(t.substr(10, 2), 10)), (c += 2))
    }
    if ((e.setUTCFullYear(r, n, i), e.setUTCHours(o, s, a, 0), c && ((l = t.charAt(c)), l === '+' || l === '-'))) {
      var u = parseInt(t.substr(c + 1, 2), 10),
        p = parseInt(t.substr(c + 4, 2), 10),
        d = u * 60 + p
      ;(d *= 6e4), l === '+' ? e.setTime(+e - d) : e.setTime(+e + d)
    }
    return e
  }
  He.generalizedTimeToDate = function (t) {
    var e = new Date(),
      r = parseInt(t.substr(0, 4), 10),
      n = parseInt(t.substr(4, 2), 10) - 1,
      i = parseInt(t.substr(6, 2), 10),
      o = parseInt(t.substr(8, 2), 10),
      s = parseInt(t.substr(10, 2), 10),
      a = parseInt(t.substr(12, 2), 10),
      l = 0,
      c = 0,
      u = !1
    t.charAt(t.length - 1) === 'Z' && (u = !0)
    var p = t.length - 5,
      d = t.charAt(p)
    if (d === '+' || d === '-') {
      var f = parseInt(t.substr(p + 1, 2), 10),
        m = parseInt(t.substr(p + 4, 2), 10)
      ;(c = f * 60 + m), (c *= 6e4), d === '+' && (c *= -1), (u = !0)
    }
    return (
      t.charAt(14) === '.' && (l = parseFloat(t.substr(14), 10) * 1e3),
      u
        ? (e.setUTCFullYear(r, n, i), e.setUTCHours(o, s, a, l), e.setTime(+e + c))
        : (e.setFullYear(r, n, i), e.setHours(o, s, a, l)),
      e
    )
  }
  He.dateToUtcTime = function (t) {
    if (typeof t == 'string') return t
    var e = '',
      r = []
    r.push(('' + t.getUTCFullYear()).substr(2)),
      r.push('' + (t.getUTCMonth() + 1)),
      r.push('' + t.getUTCDate()),
      r.push('' + t.getUTCHours()),
      r.push('' + t.getUTCMinutes()),
      r.push('' + t.getUTCSeconds())
    for (var n = 0; n < r.length; ++n) r[n].length < 2 && (e += '0'), (e += r[n])
    return (e += 'Z'), e
  }
  He.dateToGeneralizedTime = function (t) {
    if (typeof t == 'string') return t
    var e = '',
      r = []
    r.push('' + t.getUTCFullYear()),
      r.push('' + (t.getUTCMonth() + 1)),
      r.push('' + t.getUTCDate()),
      r.push('' + t.getUTCHours()),
      r.push('' + t.getUTCMinutes()),
      r.push('' + t.getUTCSeconds())
    for (var n = 0; n < r.length; ++n) r[n].length < 2 && (e += '0'), (e += r[n])
    return (e += 'Z'), e
  }
  He.integerToDer = function (t) {
    var e = rn.util.createBuffer()
    if (t >= -128 && t < 128) return e.putSignedInt(t, 8)
    if (t >= -32768 && t < 32768) return e.putSignedInt(t, 16)
    if (t >= -8388608 && t < 8388608) return e.putSignedInt(t, 24)
    if (t >= -2147483648 && t < 2147483648) return e.putSignedInt(t, 32)
    var r = new Error('Integer too large; max is 32-bits.')
    throw ((r.integer = t), r)
  }
  He.derToInteger = function (t) {
    typeof t == 'string' && (t = rn.util.createBuffer(t))
    var e = t.length() * 8
    if (e > 32) throw new Error('Integer too large; max is 32-bits.')
    return t.getSignedInt(e)
  }
  He.validate = function (t, e, r, n) {
    var i = !1
    if ((t.tagClass === e.tagClass || typeof e.tagClass > 'u') && (t.type === e.type || typeof e.type > 'u'))
      if (t.constructed === e.constructed || typeof e.constructed > 'u') {
        if (((i = !0), e.value && rn.util.isArray(e.value)))
          for (var o = 0, s = 0; i && s < e.value.length; ++s)
            (i = e.value[s].optional || !1),
              t.value[o] &&
                ((i = He.validate(t.value[o], e.value[s], r, n)), i ? ++o : e.value[s].optional && (i = !0)),
              !i &&
                n &&
                n.push(
                  '[' +
                    e.name +
                    '] Tag class "' +
                    e.tagClass +
                    '", type "' +
                    e.type +
                    '" expected value length "' +
                    e.value.length +
                    '", got "' +
                    t.value.length +
                    '"'
                )
        if (
          i &&
          r &&
          (e.capture && (r[e.capture] = t.value),
          e.captureAsn1 && (r[e.captureAsn1] = t),
          e.captureBitStringContents &&
            'bitStringContents' in t &&
            (r[e.captureBitStringContents] = t.bitStringContents),
          e.captureBitStringValue && 'bitStringContents' in t)
        ) {
          var a
          if (t.bitStringContents.length < 2) r[e.captureBitStringValue] = ''
          else {
            var l = t.bitStringContents.charCodeAt(0)
            if (l !== 0) throw new Error('captureBitStringValue only supported for zero unused bits')
            r[e.captureBitStringValue] = t.bitStringContents.slice(1)
          }
        }
      } else n && n.push('[' + e.name + '] Expected constructed "' + e.constructed + '", got "' + t.constructed + '"')
    else
      n &&
        (t.tagClass !== e.tagClass &&
          n.push('[' + e.name + '] Expected tag class "' + e.tagClass + '", got "' + t.tagClass + '"'),
        t.type !== e.type && n.push('[' + e.name + '] Expected type "' + e.type + '", got "' + t.type + '"'))
    return i
  }
  var mJ = /[^\\u0000-\\u00ff]/
  He.prettyPrint = function (t, e, r) {
    var n = ''
    ;(e = e || 0),
      (r = r || 2),
      e > 0 &&
        (n += `
`)
    for (var i = '', o = 0; o < e * r; ++o) i += ' '
    switch (((n += i + 'Tag: '), t.tagClass)) {
      case He.Class.UNIVERSAL:
        n += 'Universal:'
        break
      case He.Class.APPLICATION:
        n += 'Application:'
        break
      case He.Class.CONTEXT_SPECIFIC:
        n += 'Context-Specific:'
        break
      case He.Class.PRIVATE:
        n += 'Private:'
        break
    }
    if (t.tagClass === He.Class.UNIVERSAL)
      switch (((n += t.type), t.type)) {
        case He.Type.NONE:
          n += ' (None)'
          break
        case He.Type.BOOLEAN:
          n += ' (Boolean)'
          break
        case He.Type.INTEGER:
          n += ' (Integer)'
          break
        case He.Type.BITSTRING:
          n += ' (Bit string)'
          break
        case He.Type.OCTETSTRING:
          n += ' (Octet string)'
          break
        case He.Type.NULL:
          n += ' (Null)'
          break
        case He.Type.OID:
          n += ' (Object Identifier)'
          break
        case He.Type.ODESC:
          n += ' (Object Descriptor)'
          break
        case He.Type.EXTERNAL:
          n += ' (External or Instance of)'
          break
        case He.Type.REAL:
          n += ' (Real)'
          break
        case He.Type.ENUMERATED:
          n += ' (Enumerated)'
          break
        case He.Type.EMBEDDED:
          n += ' (Embedded PDV)'
          break
        case He.Type.UTF8:
          n += ' (UTF8)'
          break
        case He.Type.ROID:
          n += ' (Relative Object Identifier)'
          break
        case He.Type.SEQUENCE:
          n += ' (Sequence)'
          break
        case He.Type.SET:
          n += ' (Set)'
          break
        case He.Type.PRINTABLESTRING:
          n += ' (Printable String)'
          break
        case He.Type.IA5String:
          n += ' (IA5String (ASCII))'
          break
        case He.Type.UTCTIME:
          n += ' (UTC time)'
          break
        case He.Type.GENERALIZEDTIME:
          n += ' (Generalized time)'
          break
        case He.Type.BMPSTRING:
          n += ' (BMP String)'
          break
      }
    else n += t.type
    if (
      ((n += `
`),
      (n +=
        i +
        'Constructed: ' +
        t.constructed +
        `
`),
      t.composed)
    ) {
      for (var s = 0, a = '', o = 0; o < t.value.length; ++o)
        t.value[o] !== void 0 &&
          ((s += 1), (a += He.prettyPrint(t.value[o], e + 1, r)), o + 1 < t.value.length && (a += ','))
      n += i + 'Sub values: ' + s + a
    } else {
      if (((n += i + 'Value: '), t.type === He.Type.OID)) {
        var l = He.derToOid(t.value)
        ;(n += l), rn.pki && rn.pki.oids && l in rn.pki.oids && (n += ' (' + rn.pki.oids[l] + ') ')
      }
      if (t.type === He.Type.INTEGER)
        try {
          n += He.derToInteger(t.value)
        } catch {
          n += '0x' + rn.util.bytesToHex(t.value)
        }
      else if (t.type === He.Type.BITSTRING) {
        if (
          (t.value.length > 1 ? (n += '0x' + rn.util.bytesToHex(t.value.slice(1))) : (n += '(none)'),
          t.value.length > 0)
        ) {
          var c = t.value.charCodeAt(0)
          c == 1 ? (n += ' (1 unused bit shown)') : c > 1 && (n += ' (' + c + ' unused bits shown)')
        }
      } else if (t.type === He.Type.OCTETSTRING)
        mJ.test(t.value) || (n += '(' + t.value + ') '), (n += '0x' + rn.util.bytesToHex(t.value))
      else if (t.type === He.Type.UTF8)
        try {
          n += rn.util.decodeUtf8(t.value)
        } catch (u) {
          if (u.message === 'URI malformed') n += '0x' + rn.util.bytesToHex(t.value) + ' (malformed UTF8)'
          else throw u
        }
      else
        t.type === He.Type.PRINTABLESTRING || t.type === He.Type.IA5String
          ? (n += t.value)
          : mJ.test(t.value)
          ? (n += '0x' + rn.util.bytesToHex(t.value))
          : t.value.length === 0
          ? (n += '[null]')
          : (n += t.value)
    }
    return n
  }
})
var Ll = handleExports((Uht, gJ) => {
  var hA = Mt()
  gJ.exports = hA.md = hA.md || {}
  hA.md.algorithms = hA.md.algorithms || {}
})
var h_ = handleExports((Bht, vJ) => {
  var mp = Mt()
  Ll()
  cr()
  var FRe = (vJ.exports = mp.hmac = mp.hmac || {})
  FRe.create = function () {
    var t = null,
      e = null,
      r = null,
      n = null,
      i = {}
    return (
      (i.start = function (o, s) {
        if (o !== null)
          if (typeof o == 'string')
            if (((o = o.toLowerCase()), o in mp.md.algorithms)) e = mp.md.algorithms[o].create()
            else throw new Error('Unknown hash algorithm "' + o + '"')
          else e = o
        if (s === null) s = t
        else {
          if (typeof s == 'string') s = mp.util.createBuffer(s)
          else if (mp.util.isArray(s)) {
            var a = s
            s = mp.util.createBuffer()
            for (var l = 0; l < a.length; ++l) s.putByte(a[l])
          }
          var c = s.length()
          c > e.blockLength && (e.start(), e.update(s.bytes()), (s = e.digest())),
            (r = mp.util.createBuffer()),
            (n = mp.util.createBuffer()),
            (c = s.length())
          for (var l = 0; l < c; ++l) {
            var a = s.at(l)
            r.putByte(54 ^ a), n.putByte(92 ^ a)
          }
          if (c < e.blockLength) for (var a = e.blockLength - c, l = 0; l < a; ++l) r.putByte(54), n.putByte(92)
          ;(t = s), (r = r.bytes()), (n = n.bytes())
        }
        e.start(), e.update(r)
      }),
      (i.update = function (o) {
        e.update(o)
      }),
      (i.getMac = function () {
        var o = e.digest().bytes()
        return e.start(), e.update(n), e.update(o), e.digest()
      }),
      (i.digest = i.getMac),
      i
    )
  }
})
var vA = handleExports((qht, bJ) => {
  var Ml = Mt()
  Ll()
  cr()
  var yJ = (bJ.exports = Ml.md5 = Ml.md5 || {})
  Ml.md.md5 = Ml.md.algorithms.md5 = yJ
  yJ.create = function () {
    xJ || URe()
    var t = null,
      e = Ml.util.createBuffer(),
      r = new Array(16),
      n = {
        algorithm: 'md5',
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, o = 0; o < i; ++o) n.fullMessageLength.push(0)
        return (e = Ml.util.createBuffer()), (t = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878 }), n
      }),
      n.start(),
      (n.update = function (i, o) {
        o === 'utf8' && (i = Ml.util.encodeUtf8(i))
        var s = i.length
        ;(n.messageLength += s), (s = [(s / 4294967296) >>> 0, s >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += s[1]),
            (s[1] = s[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (s[0] = (s[1] / 4294967296) >>> 0)
        return e.putBytes(i), _J(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n
      }),
      (n.digest = function () {
        var i = Ml.util.createBuffer()
        i.putBytes(e.bytes())
        var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
          s = o & (n.blockLength - 1)
        i.putBytes(M8.substr(0, n.blockLength - s))
        for (var a, l = 0, c = n.fullMessageLength.length - 1; c >= 0; --c)
          (a = n.fullMessageLength[c] * 8 + l), (l = (a / 4294967296) >>> 0), i.putInt32Le(a >>> 0)
        var u = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3 }
        _J(u, r, i)
        var p = Ml.util.createBuffer()
        return p.putInt32Le(u.h0), p.putInt32Le(u.h1), p.putInt32Le(u.h2), p.putInt32Le(u.h3), p
      }),
      n
    )
  }
  var M8 = null,
    gA = null,
    jb = null,
    g_ = null,
    xJ = !1
  function URe() {
    ;(M8 = String.fromCharCode(128)),
      (M8 += Ml.util.fillString(String.fromCharCode(0), 64)),
      (gA = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5,
        8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9,
      ]),
      (jb = [
        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14,
        20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6,
        10, 15, 21,
      ]),
      (g_ = new Array(64))
    for (var t = 0; t < 64; ++t) g_[t] = Math.floor(Math.abs(Math.sin(t + 1)) * 4294967296)
    xJ = !0
  }
  function _J(t, e, r) {
    for (var n, i, o, s, a, l, c, u, p = r.length(); p >= 64; ) {
      for (i = t.h0, o = t.h1, s = t.h2, a = t.h3, u = 0; u < 16; ++u)
        (e[u] = r.getInt32Le()),
          (l = a ^ (o & (s ^ a))),
          (n = i + l + g_[u] + e[u]),
          (c = jb[u]),
          (i = a),
          (a = s),
          (s = o),
          (o += (n << c) | (n >>> (32 - c)))
      for (; u < 32; ++u)
        (l = s ^ (a & (o ^ s))),
          (n = i + l + g_[u] + e[gA[u]]),
          (c = jb[u]),
          (i = a),
          (a = s),
          (s = o),
          (o += (n << c) | (n >>> (32 - c)))
      for (; u < 48; ++u)
        (l = o ^ s ^ a),
          (n = i + l + g_[u] + e[gA[u]]),
          (c = jb[u]),
          (i = a),
          (a = s),
          (s = o),
          (o += (n << c) | (n >>> (32 - c)))
      for (; u < 64; ++u)
        (l = s ^ (o | ~a)),
          (n = i + l + g_[u] + e[gA[u]]),
          (c = jb[u]),
          (i = a),
          (a = s),
          (s = o),
          (o += (n << c) | (n >>> (32 - c)))
      ;(t.h0 = (t.h0 + i) | 0), (t.h1 = (t.h1 + o) | 0), (t.h2 = (t.h2 + s) | 0), (t.h3 = (t.h3 + a) | 0), (p -= 64)
    }
  }
})
var pg = handleExports((Hht, TJ) => {
  var yA = Mt()
  cr()
  var EJ = (TJ.exports = yA.pem = yA.pem || {})
  EJ.encode = function (t, e) {
    e = e || {}
    var r =
        '-----BEGIN ' +
        t.type +
        `-----\r
`,
      n
    if (
      (t.procType && ((n = { name: 'Proc-Type', values: [String(t.procType.version), t.procType.type] }), (r += _A(n))),
      t.contentDomain && ((n = { name: 'Content-Domain', values: [t.contentDomain] }), (r += _A(n))),
      t.dekInfo &&
        ((n = { name: 'DEK-Info', values: [t.dekInfo.algorithm] }),
        t.dekInfo.parameters && n.values.push(t.dekInfo.parameters),
        (r += _A(n))),
      t.headers)
    )
      for (var i = 0; i < t.headers.length; ++i) r += _A(t.headers[i])
    return (
      t.procType &&
        (r += `\r
`),
      (r +=
        yA.util.encode64(t.body, e.maxline || 64) +
        `\r
`),
      (r +=
        '-----END ' +
        t.type +
        `-----\r
`),
      r
    )
  }
  EJ.decode = function (t) {
    for (
      var e = [],
        r =
          /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
        n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
        i = /\r?\n/,
        o;
      (o = r.exec(t)), !!o;

    ) {
      var s = o[1]
      s === 'NEW CERTIFICATE REQUEST' && (s = 'CERTIFICATE REQUEST')
      var a = { type: s, procType: null, contentDomain: null, dekInfo: null, headers: [], body: yA.util.decode64(o[3]) }
      if ((e.push(a), !!o[2])) {
        for (var l = o[2].split(i), c = 0; o && c < l.length; ) {
          for (var u = l[c].replace(/\s+$/, ''), p = c + 1; p < l.length; ++p) {
            var d = l[p]
            if (!/\s/.test(d[0])) break
            ;(u += d), (c = p)
          }
          if (((o = u.match(n)), o)) {
            for (var f = { name: o[1], values: [] }, m = o[2].split(','), h = 0; h < m.length; ++h)
              f.values.push(BRe(m[h]))
            if (a.procType)
              if (!a.contentDomain && f.name === 'Content-Domain') a.contentDomain = m[0] || ''
              else if (!a.dekInfo && f.name === 'DEK-Info') {
                if (f.values.length === 0)
                  throw new Error(
                    'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'
                  )
                a.dekInfo = { algorithm: m[0], parameters: m[1] || null }
              } else a.headers.push(f)
            else {
              if (f.name !== 'Proc-Type')
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".')
              if (f.values.length !== 2)
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.')
              a.procType = { version: m[0], type: m[1] }
            }
          }
          ++c
        }
        if (a.procType === 'ENCRYPTED' && !a.dekInfo)
          throw new Error(
            'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'
          )
      }
    }
    if (e.length === 0) throw new Error('Invalid PEM formatted message.')
    return e
  }
  function _A(t) {
    for (
      var e = t.name + ': ',
        r = [],
        n = function (l, c) {
          return ' ' + c
        },
        i = 0;
      i < t.values.length;
      ++i
    )
      r.push(t.values[i].replace(/^(\S+\r\n)/, n))
    e +=
      r.join(',') +
      `\r
`
    for (var o = 0, s = -1, i = 0; i < e.length; ++i, ++o)
      if (o > 65 && s !== -1) {
        var a = e[s]
        a === ','
          ? (++s,
            (e =
              e.substr(0, s) +
              `\r
 ` +
              e.substr(s)))
          : (e =
              e.substr(0, s) +
              `\r
` +
              a +
              e.substr(s + 1)),
          (o = i - s - 1),
          (s = -1),
          ++i
      } else (e[i] === ' ' || e[i] === '	' || e[i] === ',') && (s = i)
    return e
  }
  function BRe(t) {
    return t.replace(/^\s+/, '')
  }
})
var Gb = handleExports((jht, CJ) => {
  var un = Mt()
  uA()
  P8()
  cr()
  CJ.exports = un.des = un.des || {}
  un.des.startEncrypting = function (t, e, r, n) {
    var i = xA({ key: t, output: r, decrypt: !1, mode: n || (e === null ? 'ECB' : 'CBC') })
    return i.start(e), i
  }
  un.des.createEncryptionCipher = function (t, e) {
    return xA({ key: t, output: null, decrypt: !1, mode: e })
  }
  un.des.startDecrypting = function (t, e, r, n) {
    var i = xA({ key: t, output: r, decrypt: !0, mode: n || (e === null ? 'ECB' : 'CBC') })
    return i.start(e), i
  }
  un.des.createDecryptionCipher = function (t, e) {
    return xA({ key: t, output: null, decrypt: !0, mode: e })
  }
  un.des.Algorithm = function (t, e) {
    var r = this
    ;(r.name = t),
      (r.mode = new e({
        blockSize: 8,
        cipher: {
          encrypt: function (n, i) {
            return SJ(r._keys, n, i, !1)
          },
          decrypt: function (n, i) {
            return SJ(r._keys, n, i, !0)
          },
        },
      })),
      (r._init = !1)
  }
  un.des.Algorithm.prototype.initialize = function (t) {
    if (!this._init) {
      var e = un.util.createBuffer(t.key)
      if (this.name.indexOf('3DES') === 0 && e.length() !== 24)
        throw new Error('Invalid Triple-DES key size: ' + e.length() * 8)
      ;(this._keys = KRe(e)), (this._init = !0)
    }
  }
  Fl('DES-ECB', un.cipher.modes.ecb)
  Fl('DES-CBC', un.cipher.modes.cbc)
  Fl('DES-CFB', un.cipher.modes.cfb)
  Fl('DES-OFB', un.cipher.modes.ofb)
  Fl('DES-CTR', un.cipher.modes.ctr)
  Fl('3DES-ECB', un.cipher.modes.ecb)
  Fl('3DES-CBC', un.cipher.modes.cbc)
  Fl('3DES-CFB', un.cipher.modes.cfb)
  Fl('3DES-OFB', un.cipher.modes.ofb)
  Fl('3DES-CTR', un.cipher.modes.ctr)
  function Fl(t, e) {
    var r = function () {
      return new un.des.Algorithm(t, e)
    }
    un.cipher.registerAlgorithm(t, r)
  }
  var qRe = [
      16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756,
      16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220,
      65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756,
      65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564,
      16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756,
    ],
    HRe = [
      -2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272,
      -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648,
      32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376,
      -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272,
      1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616,
      1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344,
    ],
    jRe = [
      520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320,
      131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584,
      131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240,
      0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8,
      131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584,
    ],
    GRe = [
      8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609,
      1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129,
      8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128,
      8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928,
    ],
    VRe = [
      256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368,
      1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800,
      1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288,
      1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544,
      34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0,
      1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080,
    ],
    zRe = [
      536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928,
      4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232,
      0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616,
      4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216,
      4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600,
      536870912, 4194320, 536887312,
    ],
    $Re = [
      2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864,
      69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050,
      69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2,
      2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016,
      2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154,
    ],
    WRe = [
      268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240,
      268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0,
      0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304,
      268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520,
      268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696,
    ]
  function KRe(t) {
    for (
      var e = [
          0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052,
          536936960, 536936964,
        ],
        r = [
          0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120,
          67109121, 68157696, 68157697,
        ],
        n = [
          0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264,
          16779272,
        ],
        i = [
          0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952,
          139264, 2236416, 134356992, 136454144,
        ],
        o = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256],
        s = [
          0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464,
          33555488,
        ],
        a = [
          0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2,
          268435458, 524290, 268959746,
        ],
        l = [
          0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984,
          537067520, 537004032, 537069568,
        ],
        c = [
          0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578,
          33554434, 33816578,
        ],
        u = [
          0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480,
          1032, 268436488,
        ],
        p = [
          0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800,
        ],
        d = [
          0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592,
          69206016, 85983232, 69206528, 85983744,
        ],
        f = [
          0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304,
          528400, 134742032, 134746128,
        ],
        m = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
        h = t.length() > 8 ? 3 : 1,
        g = [],
        v = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
        _ = 0,
        y,
        b = 0;
      b < h;
      b++
    ) {
      var x = t.getInt32(),
        P = t.getInt32()
      ;(y = ((x >>> 4) ^ P) & 252645135),
        (P ^= y),
        (x ^= y << 4),
        (y = ((P >>> -16) ^ x) & 65535),
        (x ^= y),
        (P ^= y << -16),
        (y = ((x >>> 2) ^ P) & 858993459),
        (P ^= y),
        (x ^= y << 2),
        (y = ((P >>> -16) ^ x) & 65535),
        (x ^= y),
        (P ^= y << -16),
        (y = ((x >>> 1) ^ P) & 1431655765),
        (P ^= y),
        (x ^= y << 1),
        (y = ((P >>> 8) ^ x) & 16711935),
        (x ^= y),
        (P ^= y << 8),
        (y = ((x >>> 1) ^ P) & 1431655765),
        (P ^= y),
        (x ^= y << 1),
        (y = (x << 8) | ((P >>> 20) & 240)),
        (x = (P << 24) | ((P << 8) & 16711680) | ((P >>> 8) & 65280) | ((P >>> 24) & 240)),
        (P = y)
      for (var U = 0; U < v.length; ++U) {
        v[U]
          ? ((x = (x << 2) | (x >>> 26)), (P = (P << 2) | (P >>> 26)))
          : ((x = (x << 1) | (x >>> 27)), (P = (P << 1) | (P >>> 27))),
          (x &= -15),
          (P &= -15)
        var H =
            e[x >>> 28] |
            r[(x >>> 24) & 15] |
            n[(x >>> 20) & 15] |
            i[(x >>> 16) & 15] |
            o[(x >>> 12) & 15] |
            s[(x >>> 8) & 15] |
            a[(x >>> 4) & 15],
          j =
            l[P >>> 28] |
            c[(P >>> 24) & 15] |
            u[(P >>> 20) & 15] |
            p[(P >>> 16) & 15] |
            d[(P >>> 12) & 15] |
            f[(P >>> 8) & 15] |
            m[(P >>> 4) & 15]
        ;(y = ((j >>> 16) ^ H) & 65535), (g[_++] = H ^ y), (g[_++] = j ^ (y << 16))
      }
    }
    return g
  }
  function SJ(t, e, r, n) {
    var i = t.length === 32 ? 3 : 9,
      o
    i === 3
      ? (o = n ? [30, -2, -2] : [0, 32, 2])
      : (o = n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2])
    var s,
      a = e[0],
      l = e[1]
    ;(s = ((a >>> 4) ^ l) & 252645135),
      (l ^= s),
      (a ^= s << 4),
      (s = ((a >>> 16) ^ l) & 65535),
      (l ^= s),
      (a ^= s << 16),
      (s = ((l >>> 2) ^ a) & 858993459),
      (a ^= s),
      (l ^= s << 2),
      (s = ((l >>> 8) ^ a) & 16711935),
      (a ^= s),
      (l ^= s << 8),
      (s = ((a >>> 1) ^ l) & 1431655765),
      (l ^= s),
      (a ^= s << 1),
      (a = (a << 1) | (a >>> 31)),
      (l = (l << 1) | (l >>> 31))
    for (var c = 0; c < i; c += 3) {
      for (var u = o[c + 1], p = o[c + 2], d = o[c]; d != u; d += p) {
        var f = l ^ t[d],
          m = ((l >>> 4) | (l << 28)) ^ t[d + 1]
        ;(s = a),
          (a = l),
          (l =
            s ^
            (HRe[(f >>> 24) & 63] |
              GRe[(f >>> 16) & 63] |
              zRe[(f >>> 8) & 63] |
              WRe[f & 63] |
              qRe[(m >>> 24) & 63] |
              jRe[(m >>> 16) & 63] |
              VRe[(m >>> 8) & 63] |
              $Re[m & 63]))
      }
      ;(s = a), (a = l), (l = s)
    }
    ;(a = (a >>> 1) | (a << 31)),
      (l = (l >>> 1) | (l << 31)),
      (s = ((a >>> 1) ^ l) & 1431655765),
      (l ^= s),
      (a ^= s << 1),
      (s = ((l >>> 8) ^ a) & 16711935),
      (a ^= s),
      (l ^= s << 8),
      (s = ((l >>> 2) ^ a) & 858993459),
      (a ^= s),
      (l ^= s << 2),
      (s = ((a >>> 16) ^ l) & 65535),
      (l ^= s),
      (a ^= s << 16),
      (s = ((a >>> 4) ^ l) & 252645135),
      (l ^= s),
      (a ^= s << 4),
      (r[0] = a),
      (r[1] = l)
  }
  function xA(t) {
    t = t || {}
    var e = (t.mode || 'CBC').toUpperCase(),
      r = 'DES-' + e,
      n
    t.decrypt ? (n = un.cipher.createDecipher(r, t.key)) : (n = un.cipher.createCipher(r, t.key))
    var i = n.start
    return (
      (n.start = function (o, s) {
        var a = null
        s instanceof un.util.ByteBuffer && ((a = s), (s = {})), (s = s || {}), (s.output = a), (s.iv = o), i.call(n, s)
      }),
      n
    )
  }
})
var bA = handleExports((Ght, IJ) => {
  var Wo = Mt()
  h_()
  Ll()
  cr()
  var YRe = (Wo.pkcs5 = Wo.pkcs5 || {}),
    hp
  Wo.util.isNodejs && !Wo.options.usePureJavaScript && (hp = require('crypto'))
  IJ.exports =
    Wo.pbkdf2 =
    YRe.pbkdf2 =
      function (t, e, r, n, i, o) {
        if (
          (typeof i == 'function' && ((o = i), (i = null)),
          Wo.util.isNodejs &&
            !Wo.options.usePureJavaScript &&
            hp.pbkdf2 &&
            (i === null || typeof i != 'object') &&
            (hp.pbkdf2Sync.length > 4 || !i || i === 'sha1'))
        )
          return (
            typeof i != 'string' && (i = 'sha1'),
            (t = Buffer.from(t, 'binary')),
            (e = Buffer.from(e, 'binary')),
            o
              ? hp.pbkdf2Sync.length === 4
                ? hp.pbkdf2(t, e, r, n, function (y, b) {
                    if (y) return o(y)
                    o(null, b.toString('binary'))
                  })
                : hp.pbkdf2(t, e, r, n, i, function (y, b) {
                    if (y) return o(y)
                    o(null, b.toString('binary'))
                  })
              : hp.pbkdf2Sync.length === 4
              ? hp.pbkdf2Sync(t, e, r, n).toString('binary')
              : hp.pbkdf2Sync(t, e, r, n, i).toString('binary')
          )
        if (((typeof i > 'u' || i === null) && (i = 'sha1'), typeof i == 'string')) {
          if (!(i in Wo.md.algorithms)) throw new Error('Unknown hash algorithm: ' + i)
          i = Wo.md[i].create()
        }
        var s = i.digestLength
        if (n > 4294967295 * s) {
          var a = new Error('Derived key is too long.')
          if (o) return o(a)
          throw a
        }
        var l = Math.ceil(n / s),
          c = n - (l - 1) * s,
          u = Wo.hmac.create()
        u.start(i, t)
        var p = '',
          d,
          f,
          m
        if (!o) {
          for (var h = 1; h <= l; ++h) {
            u.start(null, null), u.update(e), u.update(Wo.util.int32ToBytes(h)), (d = m = u.digest().getBytes())
            for (var g = 2; g <= r; ++g)
              u.start(null, null), u.update(m), (f = u.digest().getBytes()), (d = Wo.util.xorBytes(d, f, s)), (m = f)
            p += h < l ? d : d.substr(0, c)
          }
          return p
        }
        var h = 1,
          g
        function v() {
          if (h > l) return o(null, p)
          u.start(null, null),
            u.update(e),
            u.update(Wo.util.int32ToBytes(h)),
            (d = m = u.digest().getBytes()),
            (g = 2),
            _()
        }
        function _() {
          if (g <= r)
            return (
              u.start(null, null),
              u.update(m),
              (f = u.digest().getBytes()),
              (d = Wo.util.xorBytes(d, f, s)),
              (m = f),
              ++g,
              Wo.util.setImmediate(_)
            )
          ;(p += h < l ? d : d.substr(0, c)), ++h, v()
        }
        v()
      }
})
var U8 = handleExports((Vht, PJ) => {
  var Ul = Mt()
  Ll()
  cr()
  var AJ = (PJ.exports = Ul.sha256 = Ul.sha256 || {})
  Ul.md.sha256 = Ul.md.algorithms.sha256 = AJ
  AJ.create = function () {
    RJ || QRe()
    var t = null,
      e = Ul.util.createBuffer(),
      r = new Array(64),
      n = {
        algorithm: 'sha256',
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, o = 0; o < i; ++o) n.fullMessageLength.push(0)
        return (
          (e = Ul.util.createBuffer()),
          (t = {
            h0: 1779033703,
            h1: 3144134277,
            h2: 1013904242,
            h3: 2773480762,
            h4: 1359893119,
            h5: 2600822924,
            h6: 528734635,
            h7: 1541459225,
          }),
          n
        )
      }),
      n.start(),
      (n.update = function (i, o) {
        o === 'utf8' && (i = Ul.util.encodeUtf8(i))
        var s = i.length
        ;(n.messageLength += s), (s = [(s / 4294967296) >>> 0, s >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += s[1]),
            (s[1] = s[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (s[0] = (s[1] / 4294967296) >>> 0)
        return e.putBytes(i), wJ(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n
      }),
      (n.digest = function () {
        var i = Ul.util.createBuffer()
        i.putBytes(e.bytes())
        var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
          s = o & (n.blockLength - 1)
        i.putBytes(F8.substr(0, n.blockLength - s))
        for (var a, l, c = n.fullMessageLength[0] * 8, u = 0; u < n.fullMessageLength.length - 1; ++u)
          (a = n.fullMessageLength[u + 1] * 8),
            (l = (a / 4294967296) >>> 0),
            (c += l),
            i.putInt32(c >>> 0),
            (c = a >>> 0)
        i.putInt32(c)
        var p = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3, h4: t.h4, h5: t.h5, h6: t.h6, h7: t.h7 }
        wJ(p, r, i)
        var d = Ul.util.createBuffer()
        return (
          d.putInt32(p.h0),
          d.putInt32(p.h1),
          d.putInt32(p.h2),
          d.putInt32(p.h3),
          d.putInt32(p.h4),
          d.putInt32(p.h5),
          d.putInt32(p.h6),
          d.putInt32(p.h7),
          d
        )
      }),
      n
    )
  }
  var F8 = null,
    RJ = !1,
    DJ = null
  function QRe() {
    ;(F8 = String.fromCharCode(128)),
      (F8 += Ul.util.fillString(String.fromCharCode(0), 64)),
      (DJ = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080,
        310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808,
        3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817,
        3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
        3329325298,
      ]),
      (RJ = !0)
  }
  function wJ(t, e, r) {
    for (var n, i, o, s, a, l, c, u, p, d, f, m, h, g, v, _ = r.length(); _ >= 64; ) {
      for (c = 0; c < 16; ++c) e[c] = r.getInt32()
      for (; c < 64; ++c)
        (n = e[c - 2]),
          (n = ((n >>> 17) | (n << 15)) ^ ((n >>> 19) | (n << 13)) ^ (n >>> 10)),
          (i = e[c - 15]),
          (i = ((i >>> 7) | (i << 25)) ^ ((i >>> 18) | (i << 14)) ^ (i >>> 3)),
          (e[c] = (n + e[c - 7] + i + e[c - 16]) | 0)
      for (u = t.h0, p = t.h1, d = t.h2, f = t.h3, m = t.h4, h = t.h5, g = t.h6, v = t.h7, c = 0; c < 64; ++c)
        (s = ((m >>> 6) | (m << 26)) ^ ((m >>> 11) | (m << 21)) ^ ((m >>> 25) | (m << 7))),
          (a = g ^ (m & (h ^ g))),
          (o = ((u >>> 2) | (u << 30)) ^ ((u >>> 13) | (u << 19)) ^ ((u >>> 22) | (u << 10))),
          (l = (u & p) | (d & (u ^ p))),
          (n = v + s + a + DJ[c] + e[c]),
          (i = o + l),
          (v = g),
          (g = h),
          (h = m),
          (m = (f + n) >>> 0),
          (f = d),
          (d = p),
          (p = u),
          (u = (n + i) >>> 0)
      ;(t.h0 = (t.h0 + u) | 0),
        (t.h1 = (t.h1 + p) | 0),
        (t.h2 = (t.h2 + d) | 0),
        (t.h3 = (t.h3 + f) | 0),
        (t.h4 = (t.h4 + m) | 0),
        (t.h5 = (t.h5 + h) | 0),
        (t.h6 = (t.h6 + g) | 0),
        (t.h7 = (t.h7 + v) | 0),
        (_ -= 64)
    }
  }
})
var B8 = handleExports((zht, NJ) => {
  var Bl = Mt()
  cr()
  var EA = null
  Bl.util.isNodejs && !Bl.options.usePureJavaScript && !process.versions['node-webkit'] && (EA = require('crypto'))
  var XRe = (NJ.exports = Bl.prng = Bl.prng || {})
  XRe.create = function (t) {
    for (
      var e = { plugin: t, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: '' },
        r = t.md,
        n = new Array(32),
        i = 0;
      i < 32;
      ++i
    )
      n[i] = r.create()
    ;(e.pools = n),
      (e.pool = 0),
      (e.generate = function (c, u) {
        if (!u) return e.generateSync(c)
        var p = e.plugin.cipher,
          d = e.plugin.increment,
          f = e.plugin.formatKey,
          m = e.plugin.formatSeed,
          h = Bl.util.createBuffer()
        ;(e.key = null), g()
        function g(v) {
          if (v) return u(v)
          if (h.length() >= c) return u(null, h.getBytes(c))
          if ((e.generated > 1048575 && (e.key = null), e.key === null))
            return Bl.util.nextTick(function () {
              o(g)
            })
          var _ = p(e.key, e.seed)
          ;(e.generated += _.length),
            h.putBytes(_),
            (e.key = f(p(e.key, d(e.seed)))),
            (e.seed = m(p(e.key, e.seed))),
            Bl.util.setImmediate(g)
        }
      }),
      (e.generateSync = function (c) {
        var u = e.plugin.cipher,
          p = e.plugin.increment,
          d = e.plugin.formatKey,
          f = e.plugin.formatSeed
        e.key = null
        for (var m = Bl.util.createBuffer(); m.length() < c; ) {
          e.generated > 1048575 && (e.key = null), e.key === null && s()
          var h = u(e.key, e.seed)
          ;(e.generated += h.length), m.putBytes(h), (e.key = d(u(e.key, p(e.seed)))), (e.seed = f(u(e.key, e.seed)))
        }
        return m.getBytes(c)
      })
    function o(c) {
      if (e.pools[0].messageLength >= 32) return a(), c()
      var u = (32 - e.pools[0].messageLength) << 5
      e.seedFile(u, function (p, d) {
        if (p) return c(p)
        e.collect(d), a(), c()
      })
    }
    function s() {
      if (e.pools[0].messageLength >= 32) return a()
      var c = (32 - e.pools[0].messageLength) << 5
      e.collect(e.seedFileSync(c)), a()
    }
    function a() {
      e.reseeds = e.reseeds === 4294967295 ? 0 : e.reseeds + 1
      var c = e.plugin.md.create()
      c.update(e.keyBytes)
      for (var u = 1, p = 0; p < 32; ++p)
        e.reseeds % u === 0 && (c.update(e.pools[p].digest().getBytes()), e.pools[p].start()), (u = u << 1)
      ;(e.keyBytes = c.digest().getBytes()), c.start(), c.update(e.keyBytes)
      var d = c.digest().getBytes()
      ;(e.key = e.plugin.formatKey(e.keyBytes)), (e.seed = e.plugin.formatSeed(d)), (e.generated = 0)
    }
    function l(c) {
      var u = null,
        p = Bl.util.globalScope,
        d = p.crypto || p.msCrypto
      d &&
        d.getRandomValues &&
        (u = function (x) {
          return d.getRandomValues(x)
        })
      var f = Bl.util.createBuffer()
      if (u)
        for (; f.length() < c; ) {
          var m = Math.max(1, Math.min(c - f.length(), 65536) / 4),
            h = new Uint32Array(Math.floor(m))
          try {
            u(h)
            for (var g = 0; g < h.length; ++g) f.putInt32(h[g])
          } catch (x) {
            if (!(typeof QuotaExceededError < 'u' && x instanceof QuotaExceededError)) throw x
          }
        }
      if (f.length() < c)
        for (var v, _, y, b = Math.floor(Math.random() * 65536); f.length() < c; ) {
          ;(_ = 16807 * (b & 65535)),
            (v = 16807 * (b >> 16)),
            (_ += (v & 32767) << 16),
            (_ += v >> 15),
            (_ = (_ & 2147483647) + (_ >> 31)),
            (b = _ & 4294967295)
          for (var g = 0; g < 3; ++g) (y = b >>> (g << 3)), (y ^= Math.floor(Math.random() * 256)), f.putByte(y & 255)
        }
      return f.getBytes(c)
    }
    return (
      EA
        ? ((e.seedFile = function (c, u) {
            EA.randomBytes(c, function (p, d) {
              if (p) return u(p)
              u(null, d.toString())
            })
          }),
          (e.seedFileSync = function (c) {
            return EA.randomBytes(c).toString()
          }))
        : ((e.seedFile = function (c, u) {
            try {
              u(null, l(c))
            } catch (p) {
              u(p)
            }
          }),
          (e.seedFileSync = l)),
      (e.collect = function (c) {
        for (var u = c.length, p = 0; p < u; ++p)
          e.pools[e.pool].update(c.substr(p, 1)), (e.pool = e.pool === 31 ? 0 : e.pool + 1)
      }),
      (e.collectInt = function (c, u) {
        for (var p = '', d = 0; d < u; d += 8) p += String.fromCharCode((c >> d) & 255)
        e.collect(p)
      }),
      (e.registerWorker = function (c) {
        if (c === self)
          e.seedFile = function (p, d) {
            function f(m) {
              var h = m.data
              h.forge &&
                h.forge.prng &&
                (self.removeEventListener('message', f), d(h.forge.prng.err, h.forge.prng.bytes))
            }
            self.addEventListener('message', f), self.postMessage({ forge: { prng: { needed: p } } })
          }
        else {
          var u = function (p) {
            var d = p.data
            d.forge &&
              d.forge.prng &&
              e.seedFile(d.forge.prng.needed, function (f, m) {
                c.postMessage({ forge: { prng: { err: f, bytes: m } } })
              })
          }
          c.addEventListener('message', u)
        }
      }),
      e
    )
  }
})
var Fa = handleExports(($ht, q8) => {
  var Fi = Mt()
  Tf()
  U8()
  B8()
  cr()
  ;(function () {
    if (Fi.random && Fi.random.getBytes) {
      q8.exports = Fi.random
      return
    }
    ;(function (t) {
      var e = {},
        r = new Array(4),
        n = Fi.util.createBuffer()
      ;(e.formatKey = function (p) {
        var d = Fi.util.createBuffer(p)
        return (
          (p = new Array(4)),
          (p[0] = d.getInt32()),
          (p[1] = d.getInt32()),
          (p[2] = d.getInt32()),
          (p[3] = d.getInt32()),
          Fi.aes._expandKey(p, !1)
        )
      }),
        (e.formatSeed = function (p) {
          var d = Fi.util.createBuffer(p)
          return (
            (p = new Array(4)),
            (p[0] = d.getInt32()),
            (p[1] = d.getInt32()),
            (p[2] = d.getInt32()),
            (p[3] = d.getInt32()),
            p
          )
        }),
        (e.cipher = function (p, d) {
          return (
            Fi.aes._updateBlock(p, d, r, !1),
            n.putInt32(r[0]),
            n.putInt32(r[1]),
            n.putInt32(r[2]),
            n.putInt32(r[3]),
            n.getBytes()
          )
        }),
        (e.increment = function (p) {
          return ++p[3], p
        }),
        (e.md = Fi.md.sha256)
      function i() {
        var p = Fi.prng.create(e)
        return (
          (p.getBytes = function (d, f) {
            return p.generate(d, f)
          }),
          (p.getBytesSync = function (d) {
            return p.generate(d)
          }),
          p
        )
      }
      var o = i(),
        s = null,
        a = Fi.util.globalScope,
        l = a.crypto || a.msCrypto
      if (
        (l &&
          l.getRandomValues &&
          (s = function (p) {
            return l.getRandomValues(p)
          }),
        Fi.options.usePureJavaScript || (!Fi.util.isNodejs && !s))
      ) {
        if ((typeof window > 'u' || window.document, o.collectInt(+new Date(), 32), typeof navigator < 'u')) {
          var c = ''
          for (var u in navigator)
            try {
              typeof navigator[u] == 'string' && (c += navigator[u])
            } catch {}
          o.collect(c), (c = null)
        }
        t &&
          (t().mousemove(function (p) {
            o.collectInt(p.clientX, 16), o.collectInt(p.clientY, 16)
          }),
          t().keypress(function (p) {
            o.collectInt(p.charCode, 8)
          }))
      }
      if (!Fi.random) Fi.random = o
      else for (var u in o) Fi.random[u] = o[u]
      ;(Fi.random.createInstance = i), (q8.exports = Fi.random)
    })(typeof jQuery < 'u' ? jQuery : null)
  })()
})
var j8 = handleExports((Wht, LJ) => {
  var Es = Mt()
  cr()
  var H8 = [
      217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142,
      98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189,
      143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86,
      192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14,
      218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47,
      200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113,
      90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161,
      244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138,
      146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137,
      169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119,
      10, 166, 32, 104, 254, 127, 193, 173,
    ],
    kJ = [1, 2, 3, 5],
    JRe = function (t, e) {
      return ((t << e) & 65535) | ((t & 65535) >> (16 - e))
    },
    ZRe = function (t, e) {
      return ((t & 65535) >> e) | ((t << (16 - e)) & 65535)
    }
  LJ.exports = Es.rc2 = Es.rc2 || {}
  Es.rc2.expandKey = function (t, e) {
    typeof t == 'string' && (t = Es.util.createBuffer(t)), (e = e || 128)
    var r = t,
      n = t.length(),
      i = e,
      o = Math.ceil(i / 8),
      s = 255 >> (i & 7),
      a
    for (a = n; a < 128; a++) r.putByte(H8[(r.at(a - 1) + r.at(a - n)) & 255])
    for (r.setAt(128 - o, H8[r.at(128 - o) & s]), a = 127 - o; a >= 0; a--) r.setAt(a, H8[r.at(a + 1) ^ r.at(a + o)])
    return r
  }
  var OJ = function (t, e, r) {
    var n = !1,
      i = null,
      o = null,
      s = null,
      a,
      l,
      c,
      u,
      p = []
    for (t = Es.rc2.expandKey(t, e), c = 0; c < 64; c++) p.push(t.getInt16Le())
    r
      ? ((a = function (m) {
          for (c = 0; c < 4; c++)
            (m[c] += p[u] + (m[(c + 3) % 4] & m[(c + 2) % 4]) + (~m[(c + 3) % 4] & m[(c + 1) % 4])),
              (m[c] = JRe(m[c], kJ[c])),
              u++
        }),
        (l = function (m) {
          for (c = 0; c < 4; c++) m[c] += p[m[(c + 3) % 4] & 63]
        }))
      : ((a = function (m) {
          for (c = 3; c >= 0; c--)
            (m[c] = ZRe(m[c], kJ[c])),
              (m[c] -= p[u] + (m[(c + 3) % 4] & m[(c + 2) % 4]) + (~m[(c + 3) % 4] & m[(c + 1) % 4])),
              u--
        }),
        (l = function (m) {
          for (c = 3; c >= 0; c--) m[c] -= p[m[(c + 3) % 4] & 63]
        }))
    var d = function (m) {
        var h = []
        for (c = 0; c < 4; c++) {
          var g = i.getInt16Le()
          s !== null && (r ? (g ^= s.getInt16Le()) : s.putInt16Le(g)), h.push(g & 65535)
        }
        u = r ? 0 : 63
        for (var v = 0; v < m.length; v++) for (var _ = 0; _ < m[v][0]; _++) m[v][1](h)
        for (c = 0; c < 4; c++) s !== null && (r ? s.putInt16Le(h[c]) : (h[c] ^= s.getInt16Le())), o.putInt16Le(h[c])
      },
      f = null
    return (
      (f = {
        start: function (m, h) {
          m && typeof m == 'string' && (m = Es.util.createBuffer(m)),
            (n = !1),
            (i = Es.util.createBuffer()),
            (o = h || new Es.util.createBuffer()),
            (s = m),
            (f.output = o)
        },
        update: function (m) {
          for (n || i.putBuffer(m); i.length() >= 8; )
            d([
              [5, a],
              [1, l],
              [6, a],
              [1, l],
              [5, a],
            ])
        },
        finish: function (m) {
          var h = !0
          if (r)
            if (m) h = m(8, i, !r)
            else {
              var g = i.length() === 8 ? 8 : 8 - i.length()
              i.fillWithByte(g, g)
            }
          if ((h && ((n = !0), f.update()), !r && ((h = i.length() === 0), h)))
            if (m) h = m(8, o, !r)
            else {
              var v = o.length(),
                _ = o.at(v - 1)
              _ > v ? (h = !1) : o.truncate(_)
            }
          return h
        },
      }),
      f
    )
  }
  Es.rc2.startEncrypting = function (t, e, r) {
    var n = Es.rc2.createEncryptionCipher(t, 128)
    return n.start(e, r), n
  }
  Es.rc2.createEncryptionCipher = function (t, e) {
    return OJ(t, e, !0)
  }
  Es.rc2.startDecrypting = function (t, e, r) {
    var n = Es.rc2.createDecryptionCipher(t, 128)
    return n.start(e, r), n
  }
  Es.rc2.createDecryptionCipher = function (t, e) {
    return OJ(t, e, !1)
  }
})
var zb = handleExports((Kht, GJ) => {
  var G8 = Mt()
  GJ.exports = G8.jsbn = G8.jsbn || {}
  var gp,
    eDe = 0xdeadbeefcafe,
    MJ = (eDe & 16777215) == 15715070
  function Se(t, e, r) {
    ;(this.data = []),
      t != null &&
        (typeof t == 'number'
          ? this.fromNumber(t, e, r)
          : e == null && typeof t != 'string'
          ? this.fromString(t, 256)
          : this.fromString(t, e))
  }
  G8.jsbn.BigInteger = Se
  function lr() {
    return new Se(null)
  }
  function tDe(t, e, r, n, i, o) {
    for (; --o >= 0; ) {
      var s = e * this.data[t++] + r.data[n] + i
      ;(i = Math.floor(s / 67108864)), (r.data[n++] = s & 67108863)
    }
    return i
  }
  function rDe(t, e, r, n, i, o) {
    for (var s = e & 32767, a = e >> 15; --o >= 0; ) {
      var l = this.data[t] & 32767,
        c = this.data[t++] >> 15,
        u = a * l + c * s
      ;(l = s * l + ((u & 32767) << 15) + r.data[n] + (i & 1073741823)),
        (i = (l >>> 30) + (u >>> 15) + a * c + (i >>> 30)),
        (r.data[n++] = l & 1073741823)
    }
    return i
  }
  function FJ(t, e, r, n, i, o) {
    for (var s = e & 16383, a = e >> 14; --o >= 0; ) {
      var l = this.data[t] & 16383,
        c = this.data[t++] >> 14,
        u = a * l + c * s
      ;(l = s * l + ((u & 16383) << 14) + r.data[n] + i),
        (i = (l >> 28) + (u >> 14) + a * c),
        (r.data[n++] = l & 268435455)
    }
    return i
  }
  typeof navigator > 'u'
    ? ((Se.prototype.am = FJ), (gp = 28))
    : MJ && navigator.appName == 'Microsoft Internet Explorer'
    ? ((Se.prototype.am = rDe), (gp = 30))
    : MJ && navigator.appName != 'Netscape'
    ? ((Se.prototype.am = tDe), (gp = 26))
    : ((Se.prototype.am = FJ), (gp = 28))
  Se.prototype.DB = gp
  Se.prototype.DM = (1 << gp) - 1
  Se.prototype.DV = 1 << gp
  var V8 = 52
  Se.prototype.FV = Math.pow(2, V8)
  Se.prototype.F1 = V8 - gp
  Se.prototype.F2 = 2 * gp - V8
  var nDe = '0123456789abcdefghijklmnopqrstuvwxyz',
    TA = new Array(),
    v_,
    Ua
  v_ = '0'.charCodeAt(0)
  for (Ua = 0; Ua <= 9; ++Ua) TA[v_++] = Ua
  v_ = 'a'.charCodeAt(0)
  for (Ua = 10; Ua < 36; ++Ua) TA[v_++] = Ua
  v_ = 'A'.charCodeAt(0)
  for (Ua = 10; Ua < 36; ++Ua) TA[v_++] = Ua
  function UJ(t) {
    return nDe.charAt(t)
  }
  function BJ(t, e) {
    var r = TA[t.charCodeAt(e)]
    return r ?? -1
  }
  function iDe(t) {
    for (var e = this.t - 1; e >= 0; --e) t.data[e] = this.data[e]
    ;(t.t = this.t), (t.s = this.s)
  }
  function oDe(t) {
    ;(this.t = 1),
      (this.s = t < 0 ? -1 : 0),
      t > 0 ? (this.data[0] = t) : t < -1 ? (this.data[0] = t + this.DV) : (this.t = 0)
  }
  function Cf(t) {
    var e = lr()
    return e.fromInt(t), e
  }
  function sDe(t, e) {
    var r
    if (e == 16) r = 4
    else if (e == 8) r = 3
    else if (e == 256) r = 8
    else if (e == 2) r = 1
    else if (e == 32) r = 5
    else if (e == 4) r = 2
    else {
      this.fromRadix(t, e)
      return
    }
    ;(this.t = 0), (this.s = 0)
    for (var n = t.length, i = !1, o = 0; --n >= 0; ) {
      var s = r == 8 ? t[n] & 255 : BJ(t, n)
      if (s < 0) {
        t.charAt(n) == '-' && (i = !0)
        continue
      }
      ;(i = !1),
        o == 0
          ? (this.data[this.t++] = s)
          : o + r > this.DB
          ? ((this.data[this.t - 1] |= (s & ((1 << (this.DB - o)) - 1)) << o),
            (this.data[this.t++] = s >> (this.DB - o)))
          : (this.data[this.t - 1] |= s << o),
        (o += r),
        o >= this.DB && (o -= this.DB)
    }
    r == 8 && t[0] & 128 && ((this.s = -1), o > 0 && (this.data[this.t - 1] |= ((1 << (this.DB - o)) - 1) << o)),
      this.clamp(),
      i && Se.ZERO.subTo(this, this)
  }
  function aDe() {
    for (var t = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t; ) --this.t
  }
  function cDe(t) {
    if (this.s < 0) return '-' + this.negate().toString(t)
    var e
    if (t == 16) e = 4
    else if (t == 8) e = 3
    else if (t == 2) e = 1
    else if (t == 32) e = 5
    else if (t == 4) e = 2
    else return this.toRadix(t)
    var r = (1 << e) - 1,
      n,
      i = !1,
      o = '',
      s = this.t,
      a = this.DB - ((s * this.DB) % e)
    if (s-- > 0)
      for (a < this.DB && (n = this.data[s] >> a) > 0 && ((i = !0), (o = UJ(n))); s >= 0; )
        a < e
          ? ((n = (this.data[s] & ((1 << a) - 1)) << (e - a)), (n |= this.data[--s] >> (a += this.DB - e)))
          : ((n = (this.data[s] >> (a -= e)) & r), a <= 0 && ((a += this.DB), --s)),
          n > 0 && (i = !0),
          i && (o += UJ(n))
    return i ? o : '0'
  }
  function lDe() {
    var t = lr()
    return Se.ZERO.subTo(this, t), t
  }
  function uDe() {
    return this.s < 0 ? this.negate() : this
  }
  function pDe(t) {
    var e = this.s - t.s
    if (e != 0) return e
    var r = this.t
    if (((e = r - t.t), e != 0)) return this.s < 0 ? -e : e
    for (; --r >= 0; ) if ((e = this.data[r] - t.data[r]) != 0) return e
    return 0
  }
  function SA(t) {
    var e = 1,
      r
    return (
      (r = t >>> 16) != 0 && ((t = r), (e += 16)),
      (r = t >> 8) != 0 && ((t = r), (e += 8)),
      (r = t >> 4) != 0 && ((t = r), (e += 4)),
      (r = t >> 2) != 0 && ((t = r), (e += 2)),
      (r = t >> 1) != 0 && ((t = r), (e += 1)),
      e
    )
  }
  function dDe() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + SA(this.data[this.t - 1] ^ (this.s & this.DM))
  }
  function fDe(t, e) {
    var r
    for (r = this.t - 1; r >= 0; --r) e.data[r + t] = this.data[r]
    for (r = t - 1; r >= 0; --r) e.data[r] = 0
    ;(e.t = this.t + t), (e.s = this.s)
  }
  function mDe(t, e) {
    for (var r = t; r < this.t; ++r) e.data[r - t] = this.data[r]
    ;(e.t = Math.max(this.t - t, 0)), (e.s = this.s)
  }
  function hDe(t, e) {
    var r = t % this.DB,
      n = this.DB - r,
      i = (1 << n) - 1,
      o = Math.floor(t / this.DB),
      s = (this.s << r) & this.DM,
      a
    for (a = this.t - 1; a >= 0; --a) (e.data[a + o + 1] = (this.data[a] >> n) | s), (s = (this.data[a] & i) << r)
    for (a = o - 1; a >= 0; --a) e.data[a] = 0
    ;(e.data[o] = s), (e.t = this.t + o + 1), (e.s = this.s), e.clamp()
  }
  function gDe(t, e) {
    e.s = this.s
    var r = Math.floor(t / this.DB)
    if (r >= this.t) {
      e.t = 0
      return
    }
    var n = t % this.DB,
      i = this.DB - n,
      o = (1 << n) - 1
    e.data[0] = this.data[r] >> n
    for (var s = r + 1; s < this.t; ++s)
      (e.data[s - r - 1] |= (this.data[s] & o) << i), (e.data[s - r] = this.data[s] >> n)
    n > 0 && (e.data[this.t - r - 1] |= (this.s & o) << i), (e.t = this.t - r), e.clamp()
  }
  function vDe(t, e) {
    for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i; )
      (n += this.data[r] - t.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
    if (t.t < this.t) {
      for (n -= t.s; r < this.t; ) (n += this.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
      n += this.s
    } else {
      for (n += this.s; r < t.t; ) (n -= t.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
      n -= t.s
    }
    ;(e.s = n < 0 ? -1 : 0), n < -1 ? (e.data[r++] = this.DV + n) : n > 0 && (e.data[r++] = n), (e.t = r), e.clamp()
  }
  function _De(t, e) {
    var r = this.abs(),
      n = t.abs(),
      i = r.t
    for (e.t = i + n.t; --i >= 0; ) e.data[i] = 0
    for (i = 0; i < n.t; ++i) e.data[i + r.t] = r.am(0, n.data[i], e, i, 0, r.t)
    ;(e.s = 0), e.clamp(), this.s != t.s && Se.ZERO.subTo(e, e)
  }
  function yDe(t) {
    for (var e = this.abs(), r = (t.t = 2 * e.t); --r >= 0; ) t.data[r] = 0
    for (r = 0; r < e.t - 1; ++r) {
      var n = e.am(r, e.data[r], t, 2 * r, 0, 1)
      ;(t.data[r + e.t] += e.am(r + 1, 2 * e.data[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV &&
        ((t.data[r + e.t] -= e.DV), (t.data[r + e.t + 1] = 1))
    }
    t.t > 0 && (t.data[t.t - 1] += e.am(r, e.data[r], t, 2 * r, 0, 1)), (t.s = 0), t.clamp()
  }
  function xDe(t, e, r) {
    var n = t.abs()
    if (!(n.t <= 0)) {
      var i = this.abs()
      if (i.t < n.t) {
        e?.fromInt(0), r != null && this.copyTo(r)
        return
      }
      r == null && (r = lr())
      var o = lr(),
        s = this.s,
        a = t.s,
        l = this.DB - SA(n.data[n.t - 1])
      l > 0 ? (n.lShiftTo(l, o), i.lShiftTo(l, r)) : (n.copyTo(o), i.copyTo(r))
      var c = o.t,
        u = o.data[c - 1]
      if (u != 0) {
        var p = u * (1 << this.F1) + (c > 1 ? o.data[c - 2] >> this.F2 : 0),
          d = this.FV / p,
          f = (1 << this.F1) / p,
          m = 1 << this.F2,
          h = r.t,
          g = h - c,
          v = e ?? lr()
        for (
          o.dlShiftTo(g, v),
            r.compareTo(v) >= 0 && ((r.data[r.t++] = 1), r.subTo(v, r)),
            Se.ONE.dlShiftTo(c, v),
            v.subTo(o, o);
          o.t < c;

        )
          o.data[o.t++] = 0
        for (; --g >= 0; ) {
          var _ = r.data[--h] == u ? this.DM : Math.floor(r.data[h] * d + (r.data[h - 1] + m) * f)
          if ((r.data[h] += o.am(0, _, r, g, 0, c)) < _)
            for (o.dlShiftTo(g, v), r.subTo(v, r); r.data[h] < --_; ) r.subTo(v, r)
        }
        e != null && (r.drShiftTo(c, e), s != a && Se.ZERO.subTo(e, e)),
          (r.t = c),
          r.clamp(),
          l > 0 && r.rShiftTo(l, r),
          s < 0 && Se.ZERO.subTo(r, r)
      }
    }
  }
  function bDe(t) {
    var e = lr()
    return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(Se.ZERO) > 0 && t.subTo(e, e), e
  }
  function dg(t) {
    this.m = t
  }
  function EDe(t) {
    return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
  }
  function TDe(t) {
    return t
  }
  function SDe(t) {
    t.divRemTo(this.m, null, t)
  }
  function CDe(t, e, r) {
    t.multiplyTo(e, r), this.reduce(r)
  }
  function IDe(t, e) {
    t.squareTo(e), this.reduce(e)
  }
  dg.prototype.convert = EDe
  dg.prototype.revert = TDe
  dg.prototype.reduce = SDe
  dg.prototype.mulTo = CDe
  dg.prototype.sqrTo = IDe
  function wDe() {
    if (this.t < 1) return 0
    var t = this.data[0]
    if (!(t & 1)) return 0
    var e = t & 3
    return (
      (e = (e * (2 - (t & 15) * e)) & 15),
      (e = (e * (2 - (t & 255) * e)) & 255),
      (e = (e * (2 - (((t & 65535) * e) & 65535))) & 65535),
      (e = (e * (2 - ((t * e) % this.DV))) % this.DV),
      e > 0 ? this.DV - e : -e
    )
  }
  function fg(t) {
    ;(this.m = t),
      (this.mp = t.invDigit()),
      (this.mpl = this.mp & 32767),
      (this.mph = this.mp >> 15),
      (this.um = (1 << (t.DB - 15)) - 1),
      (this.mt2 = 2 * t.t)
  }
  function ADe(t) {
    var e = lr()
    return (
      t.abs().dlShiftTo(this.m.t, e),
      e.divRemTo(this.m, null, e),
      t.s < 0 && e.compareTo(Se.ZERO) > 0 && this.m.subTo(e, e),
      e
    )
  }
  function RDe(t) {
    var e = lr()
    return t.copyTo(e), this.reduce(e), e
  }
  function DDe(t) {
    for (; t.t <= this.mt2; ) t.data[t.t++] = 0
    for (var e = 0; e < this.m.t; ++e) {
      var r = t.data[e] & 32767,
        n = (r * this.mpl + (((r * this.mph + (t.data[e] >> 15) * this.mpl) & this.um) << 15)) & t.DM
      for (r = e + this.m.t, t.data[r] += this.m.am(0, n, t, e, 0, this.m.t); t.data[r] >= t.DV; )
        (t.data[r] -= t.DV), t.data[++r]++
    }
    t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
  }
  function PDe(t, e) {
    t.squareTo(e), this.reduce(e)
  }
  function NDe(t, e, r) {
    t.multiplyTo(e, r), this.reduce(r)
  }
  fg.prototype.convert = ADe
  fg.prototype.revert = RDe
  fg.prototype.reduce = DDe
  fg.prototype.mulTo = NDe
  fg.prototype.sqrTo = PDe
  function kDe() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0
  }
  function ODe(t, e) {
    if (t > 4294967295 || t < 1) return Se.ONE
    var r = lr(),
      n = lr(),
      i = e.convert(this),
      o = SA(t) - 1
    for (i.copyTo(r); --o >= 0; )
      if ((e.sqrTo(r, n), (t & (1 << o)) > 0)) e.mulTo(n, i, r)
      else {
        var s = r
        ;(r = n), (n = s)
      }
    return e.revert(r)
  }
  function LDe(t, e) {
    var r
    return t < 256 || e.isEven() ? (r = new dg(e)) : (r = new fg(e)), this.exp(t, r)
  }
  Se.prototype.copyTo = iDe
  Se.prototype.fromInt = oDe
  Se.prototype.fromString = sDe
  Se.prototype.clamp = aDe
  Se.prototype.dlShiftTo = fDe
  Se.prototype.drShiftTo = mDe
  Se.prototype.lShiftTo = hDe
  Se.prototype.rShiftTo = gDe
  Se.prototype.subTo = vDe
  Se.prototype.multiplyTo = _De
  Se.prototype.squareTo = yDe
  Se.prototype.divRemTo = xDe
  Se.prototype.invDigit = wDe
  Se.prototype.isEven = kDe
  Se.prototype.exp = ODe
  Se.prototype.toString = cDe
  Se.prototype.negate = lDe
  Se.prototype.abs = uDe
  Se.prototype.compareTo = pDe
  Se.prototype.bitLength = dDe
  Se.prototype.mod = bDe
  Se.prototype.modPowInt = LDe
  Se.ZERO = Cf(0)
  Se.ONE = Cf(1)
  function MDe() {
    var t = lr()
    return this.copyTo(t), t
  }
  function FDe() {
    if (this.s < 0) {
      if (this.t == 1) return this.data[0] - this.DV
      if (this.t == 0) return -1
    } else {
      if (this.t == 1) return this.data[0]
      if (this.t == 0) return 0
    }
    return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0]
  }
  function UDe() {
    return this.t == 0 ? this.s : (this.data[0] << 24) >> 24
  }
  function BDe() {
    return this.t == 0 ? this.s : (this.data[0] << 16) >> 16
  }
  function qDe(t) {
    return Math.floor((Math.LN2 * this.DB) / Math.log(t))
  }
  function HDe() {
    return this.s < 0 ? -1 : this.t <= 0 || (this.t == 1 && this.data[0] <= 0) ? 0 : 1
  }
  function jDe(t) {
    if ((t == null && (t = 10), this.signum() == 0 || t < 2 || t > 36)) return '0'
    var e = this.chunkSize(t),
      r = Math.pow(t, e),
      n = Cf(r),
      i = lr(),
      o = lr(),
      s = ''
    for (this.divRemTo(n, i, o); i.signum() > 0; )
      (s = (r + o.intValue()).toString(t).substr(1) + s), i.divRemTo(n, i, o)
    return o.intValue().toString(t) + s
  }
  function GDe(t, e) {
    this.fromInt(0), e == null && (e = 10)
    for (var r = this.chunkSize(e), n = Math.pow(e, r), i = !1, o = 0, s = 0, a = 0; a < t.length; ++a) {
      var l = BJ(t, a)
      if (l < 0) {
        t.charAt(a) == '-' && this.signum() == 0 && (i = !0)
        continue
      }
      ;(s = e * s + l), ++o >= r && (this.dMultiply(n), this.dAddOffset(s, 0), (o = 0), (s = 0))
    }
    o > 0 && (this.dMultiply(Math.pow(e, o)), this.dAddOffset(s, 0)), i && Se.ZERO.subTo(this, this)
  }
  function VDe(t, e, r) {
    if (typeof e == 'number')
      if (t < 2) this.fromInt(1)
      else
        for (
          this.fromNumber(t, r),
            this.testBit(t - 1) || this.bitwiseTo(Se.ONE.shiftLeft(t - 1), z8, this),
            this.isEven() && this.dAddOffset(1, 0);
          !this.isProbablePrime(e);

        )
          this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(Se.ONE.shiftLeft(t - 1), this)
    else {
      var n = new Array(),
        i = t & 7
      ;(n.length = (t >> 3) + 1), e.nextBytes(n), i > 0 ? (n[0] &= (1 << i) - 1) : (n[0] = 0), this.fromString(n, 256)
    }
  }
  function zDe() {
    var t = this.t,
      e = new Array()
    e[0] = this.s
    var r = this.DB - ((t * this.DB) % 8),
      n,
      i = 0
    if (t-- > 0)
      for (
        r < this.DB && (n = this.data[t] >> r) != (this.s & this.DM) >> r && (e[i++] = n | (this.s << (this.DB - r)));
        t >= 0;

      )
        r < 8
          ? ((n = (this.data[t] & ((1 << r) - 1)) << (8 - r)), (n |= this.data[--t] >> (r += this.DB - 8)))
          : ((n = (this.data[t] >> (r -= 8)) & 255), r <= 0 && ((r += this.DB), --t)),
          n & 128 && (n |= -256),
          i == 0 && (this.s & 128) != (n & 128) && ++i,
          (i > 0 || n != this.s) && (e[i++] = n)
    return e
  }
  function $De(t) {
    return this.compareTo(t) == 0
  }
  function WDe(t) {
    return this.compareTo(t) < 0 ? this : t
  }
  function KDe(t) {
    return this.compareTo(t) > 0 ? this : t
  }
  function YDe(t, e, r) {
    var n,
      i,
      o = Math.min(t.t, this.t)
    for (n = 0; n < o; ++n) r.data[n] = e(this.data[n], t.data[n])
    if (t.t < this.t) {
      for (i = t.s & this.DM, n = o; n < this.t; ++n) r.data[n] = e(this.data[n], i)
      r.t = this.t
    } else {
      for (i = this.s & this.DM, n = o; n < t.t; ++n) r.data[n] = e(i, t.data[n])
      r.t = t.t
    }
    ;(r.s = e(this.s, t.s)), r.clamp()
  }
  function QDe(t, e) {
    return t & e
  }
  function XDe(t) {
    var e = lr()
    return this.bitwiseTo(t, QDe, e), e
  }
  function z8(t, e) {
    return t | e
  }
  function JDe(t) {
    var e = lr()
    return this.bitwiseTo(t, z8, e), e
  }
  function qJ(t, e) {
    return t ^ e
  }
  function ZDe(t) {
    var e = lr()
    return this.bitwiseTo(t, qJ, e), e
  }
  function HJ(t, e) {
    return t & ~e
  }
  function ePe(t) {
    var e = lr()
    return this.bitwiseTo(t, HJ, e), e
  }
  function tPe() {
    for (var t = lr(), e = 0; e < this.t; ++e) t.data[e] = this.DM & ~this.data[e]
    return (t.t = this.t), (t.s = ~this.s), t
  }
  function rPe(t) {
    var e = lr()
    return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e
  }
  function nPe(t) {
    var e = lr()
    return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e
  }
  function iPe(t) {
    if (t == 0) return -1
    var e = 0
    return (
      t & 65535 || ((t >>= 16), (e += 16)),
      t & 255 || ((t >>= 8), (e += 8)),
      t & 15 || ((t >>= 4), (e += 4)),
      t & 3 || ((t >>= 2), (e += 2)),
      t & 1 || ++e,
      e
    )
  }
  function oPe() {
    for (var t = 0; t < this.t; ++t) if (this.data[t] != 0) return t * this.DB + iPe(this.data[t])
    return this.s < 0 ? this.t * this.DB : -1
  }
  function sPe(t) {
    for (var e = 0; t != 0; ) (t &= t - 1), ++e
    return e
  }
  function aPe() {
    for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r) t += sPe(this.data[r] ^ e)
    return t
  }
  function cPe(t) {
    var e = Math.floor(t / this.DB)
    return e >= this.t ? this.s != 0 : (this.data[e] & (1 << t % this.DB)) != 0
  }
  function lPe(t, e) {
    var r = Se.ONE.shiftLeft(t)
    return this.bitwiseTo(r, e, r), r
  }
  function uPe(t) {
    return this.changeBit(t, z8)
  }
  function pPe(t) {
    return this.changeBit(t, HJ)
  }
  function dPe(t) {
    return this.changeBit(t, qJ)
  }
  function fPe(t, e) {
    for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i; )
      (n += this.data[r] + t.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
    if (t.t < this.t) {
      for (n += t.s; r < this.t; ) (n += this.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
      n += this.s
    } else {
      for (n += this.s; r < t.t; ) (n += t.data[r]), (e.data[r++] = n & this.DM), (n >>= this.DB)
      n += t.s
    }
    ;(e.s = n < 0 ? -1 : 0), n > 0 ? (e.data[r++] = n) : n < -1 && (e.data[r++] = this.DV + n), (e.t = r), e.clamp()
  }
  function mPe(t) {
    var e = lr()
    return this.addTo(t, e), e
  }
  function hPe(t) {
    var e = lr()
    return this.subTo(t, e), e
  }
  function gPe(t) {
    var e = lr()
    return this.multiplyTo(t, e), e
  }
  function vPe(t) {
    var e = lr()
    return this.divRemTo(t, e, null), e
  }
  function _Pe(t) {
    var e = lr()
    return this.divRemTo(t, null, e), e
  }
  function yPe(t) {
    var e = lr(),
      r = lr()
    return this.divRemTo(t, e, r), new Array(e, r)
  }
  function xPe(t) {
    ;(this.data[this.t] = this.am(0, t - 1, this, 0, 0, this.t)), ++this.t, this.clamp()
  }
  function bPe(t, e) {
    if (t != 0) {
      for (; this.t <= e; ) this.data[this.t++] = 0
      for (this.data[e] += t; this.data[e] >= this.DV; )
        (this.data[e] -= this.DV), ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e]
    }
  }
  function Vb() {}
  function jJ(t) {
    return t
  }
  function EPe(t, e, r) {
    t.multiplyTo(e, r)
  }
  function TPe(t, e) {
    t.squareTo(e)
  }
  Vb.prototype.convert = jJ
  Vb.prototype.revert = jJ
  Vb.prototype.mulTo = EPe
  Vb.prototype.sqrTo = TPe
  function SPe(t) {
    return this.exp(t, new Vb())
  }
  function CPe(t, e, r) {
    var n = Math.min(this.t + t.t, e)
    for (r.s = 0, r.t = n; n > 0; ) r.data[--n] = 0
    var i
    for (i = r.t - this.t; n < i; ++n) r.data[n + this.t] = this.am(0, t.data[n], r, n, 0, this.t)
    for (i = Math.min(t.t, e); n < i; ++n) this.am(0, t.data[n], r, n, 0, e - n)
    r.clamp()
  }
  function IPe(t, e, r) {
    --e
    var n = (r.t = this.t + t.t - e)
    for (r.s = 0; --n >= 0; ) r.data[n] = 0
    for (n = Math.max(e - this.t, 0); n < t.t; ++n)
      r.data[this.t + n - e] = this.am(e - n, t.data[n], r, 0, 0, this.t + n - e)
    r.clamp(), r.drShiftTo(1, r)
  }
  function __(t) {
    ;(this.r2 = lr()), (this.q3 = lr()), Se.ONE.dlShiftTo(2 * t.t, this.r2), (this.mu = this.r2.divide(t)), (this.m = t)
  }
  function wPe(t) {
    if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m)
    if (t.compareTo(this.m) < 0) return t
    var e = lr()
    return t.copyTo(e), this.reduce(e), e
  }
  function APe(t) {
    return t
  }
  function RPe(t) {
    for (
      t.drShiftTo(this.m.t - 1, this.r2),
        t.t > this.m.t + 1 && ((t.t = this.m.t + 1), t.clamp()),
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      t.compareTo(this.r2) < 0;

    )
      t.dAddOffset(1, this.m.t + 1)
    for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; ) t.subTo(this.m, t)
  }
  function DPe(t, e) {
    t.squareTo(e), this.reduce(e)
  }
  function PPe(t, e, r) {
    t.multiplyTo(e, r), this.reduce(r)
  }
  __.prototype.convert = wPe
  __.prototype.revert = APe
  __.prototype.reduce = RPe
  __.prototype.mulTo = PPe
  __.prototype.sqrTo = DPe
  function NPe(t, e) {
    var r = t.bitLength(),
      n,
      i = Cf(1),
      o
    if (r <= 0) return i
    r < 18 ? (n = 1) : r < 48 ? (n = 3) : r < 144 ? (n = 4) : r < 768 ? (n = 5) : (n = 6),
      r < 8 ? (o = new dg(e)) : e.isEven() ? (o = new __(e)) : (o = new fg(e))
    var s = new Array(),
      a = 3,
      l = n - 1,
      c = (1 << n) - 1
    if (((s[1] = o.convert(this)), n > 1)) {
      var u = lr()
      for (o.sqrTo(s[1], u); a <= c; ) (s[a] = lr()), o.mulTo(u, s[a - 2], s[a]), (a += 2)
    }
    var p = t.t - 1,
      d,
      f = !0,
      m = lr(),
      h
    for (r = SA(t.data[p]) - 1; p >= 0; ) {
      for (
        r >= l
          ? (d = (t.data[p] >> (r - l)) & c)
          : ((d = (t.data[p] & ((1 << (r + 1)) - 1)) << (l - r)), p > 0 && (d |= t.data[p - 1] >> (this.DB + r - l))),
          a = n;
        !(d & 1);

      )
        (d >>= 1), --a
      if (((r -= a) < 0 && ((r += this.DB), --p), f)) s[d].copyTo(i), (f = !1)
      else {
        for (; a > 1; ) o.sqrTo(i, m), o.sqrTo(m, i), (a -= 2)
        a > 0 ? o.sqrTo(i, m) : ((h = i), (i = m), (m = h)), o.mulTo(m, s[d], i)
      }
      for (; p >= 0 && !(t.data[p] & (1 << r)); )
        o.sqrTo(i, m), (h = i), (i = m), (m = h), --r < 0 && ((r = this.DB - 1), --p)
    }
    return o.revert(i)
  }
  function kPe(t) {
    var e = this.s < 0 ? this.negate() : this.clone(),
      r = t.s < 0 ? t.negate() : t.clone()
    if (e.compareTo(r) < 0) {
      var n = e
      ;(e = r), (r = n)
    }
    var i = e.getLowestSetBit(),
      o = r.getLowestSetBit()
    if (o < 0) return e
    for (i < o && (o = i), o > 0 && (e.rShiftTo(o, e), r.rShiftTo(o, r)); e.signum() > 0; )
      (i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e),
        (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r),
        e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r))
    return o > 0 && r.lShiftTo(o, r), r
  }
  function OPe(t) {
    if (t <= 0) return 0
    var e = this.DV % t,
      r = this.s < 0 ? t - 1 : 0
    if (this.t > 0)
      if (e == 0) r = this.data[0] % t
      else for (var n = this.t - 1; n >= 0; --n) r = (e * r + this.data[n]) % t
    return r
  }
  function LPe(t) {
    var e = t.isEven()
    if ((this.isEven() && e) || t.signum() == 0) return Se.ZERO
    for (var r = t.clone(), n = this.clone(), i = Cf(1), o = Cf(0), s = Cf(0), a = Cf(1); r.signum() != 0; ) {
      for (; r.isEven(); )
        r.rShiftTo(1, r),
          e
            ? ((!i.isEven() || !o.isEven()) && (i.addTo(this, i), o.subTo(t, o)), i.rShiftTo(1, i))
            : o.isEven() || o.subTo(t, o),
          o.rShiftTo(1, o)
      for (; n.isEven(); )
        n.rShiftTo(1, n),
          e
            ? ((!s.isEven() || !a.isEven()) && (s.addTo(this, s), a.subTo(t, a)), s.rShiftTo(1, s))
            : a.isEven() || a.subTo(t, a),
          a.rShiftTo(1, a)
      r.compareTo(n) >= 0
        ? (r.subTo(n, r), e && i.subTo(s, i), o.subTo(a, o))
        : (n.subTo(r, n), e && s.subTo(i, s), a.subTo(o, a))
    }
    if (n.compareTo(Se.ONE) != 0) return Se.ZERO
    if (a.compareTo(t) >= 0) return a.subtract(t)
    if (a.signum() < 0) a.addTo(t, a)
    else return a
    return a.signum() < 0 ? a.add(t) : a
  }
  var Mc = [
      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,
      109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
      239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373,
      379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,
    ],
    MPe = (1 << 26) / Mc[Mc.length - 1]
  function FPe(t) {
    var e,
      r = this.abs()
    if (r.t == 1 && r.data[0] <= Mc[Mc.length - 1]) {
      for (e = 0; e < Mc.length; ++e) if (r.data[0] == Mc[e]) return !0
      return !1
    }
    if (r.isEven()) return !1
    for (e = 1; e < Mc.length; ) {
      for (var n = Mc[e], i = e + 1; i < Mc.length && n < MPe; ) n *= Mc[i++]
      for (n = r.modInt(n); e < i; ) if (n % Mc[e++] == 0) return !1
    }
    return r.millerRabin(t)
  }
  function UPe(t) {
    var e = this.subtract(Se.ONE),
      r = e.getLowestSetBit()
    if (r <= 0) return !1
    for (var n = e.shiftRight(r), i = BPe(), o, s = 0; s < t; ++s) {
      do o = new Se(this.bitLength(), i)
      while (o.compareTo(Se.ONE) <= 0 || o.compareTo(e) >= 0)
      var a = o.modPow(n, this)
      if (a.compareTo(Se.ONE) != 0 && a.compareTo(e) != 0) {
        for (var l = 1; l++ < r && a.compareTo(e) != 0; )
          if (((a = a.modPowInt(2, this)), a.compareTo(Se.ONE) == 0)) return !1
        if (a.compareTo(e) != 0) return !1
      }
    }
    return !0
  }
  function BPe() {
    return {
      nextBytes: function (t) {
        for (var e = 0; e < t.length; ++e) t[e] = Math.floor(Math.random() * 256)
      },
    }
  }
  Se.prototype.chunkSize = qDe
  Se.prototype.toRadix = jDe
  Se.prototype.fromRadix = GDe
  Se.prototype.fromNumber = VDe
  Se.prototype.bitwiseTo = YDe
  Se.prototype.changeBit = lPe
  Se.prototype.addTo = fPe
  Se.prototype.dMultiply = xPe
  Se.prototype.dAddOffset = bPe
  Se.prototype.multiplyLowerTo = CPe
  Se.prototype.multiplyUpperTo = IPe
  Se.prototype.modInt = OPe
  Se.prototype.millerRabin = UPe
  Se.prototype.clone = MDe
  Se.prototype.intValue = FDe
  Se.prototype.byteValue = UDe
  Se.prototype.shortValue = BDe
  Se.prototype.signum = HDe
  Se.prototype.toByteArray = zDe
  Se.prototype.equals = $De
  Se.prototype.min = WDe
  Se.prototype.max = KDe
  Se.prototype.and = XDe
  Se.prototype.or = JDe
  Se.prototype.xor = ZDe
  Se.prototype.andNot = ePe
  Se.prototype.not = tPe
  Se.prototype.shiftLeft = rPe
  Se.prototype.shiftRight = nPe
  Se.prototype.getLowestSetBit = oPe
  Se.prototype.bitCount = aPe
  Se.prototype.testBit = cPe
  Se.prototype.setBit = uPe
  Se.prototype.clearBit = pPe
  Se.prototype.flipBit = dPe
  Se.prototype.add = mPe
  Se.prototype.subtract = hPe
  Se.prototype.multiply = gPe
  Se.prototype.divide = vPe
  Se.prototype.remainder = _Pe
  Se.prototype.divideAndRemainder = yPe
  Se.prototype.modPow = NPe
  Se.prototype.modInverse = LPe
  Se.prototype.pow = SPe
  Se.prototype.gcd = kPe
  Se.prototype.isProbablePrime = FPe
})
var y_ = handleExports((Yht, WJ) => {
  var ql = Mt()
  Ll()
  cr()
  var zJ = (WJ.exports = ql.sha1 = ql.sha1 || {})
  ql.md.sha1 = ql.md.algorithms.sha1 = zJ
  zJ.create = function () {
    $J || qPe()
    var t = null,
      e = ql.util.createBuffer(),
      r = new Array(80),
      n = {
        algorithm: 'sha1',
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, o = 0; o < i; ++o) n.fullMessageLength.push(0)
        return (
          (e = ql.util.createBuffer()),
          (t = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }),
          n
        )
      }),
      n.start(),
      (n.update = function (i, o) {
        o === 'utf8' && (i = ql.util.encodeUtf8(i))
        var s = i.length
        ;(n.messageLength += s), (s = [(s / 4294967296) >>> 0, s >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += s[1]),
            (s[1] = s[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (s[0] = (s[1] / 4294967296) >>> 0)
        return e.putBytes(i), VJ(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n
      }),
      (n.digest = function () {
        var i = ql.util.createBuffer()
        i.putBytes(e.bytes())
        var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize,
          s = o & (n.blockLength - 1)
        i.putBytes($8.substr(0, n.blockLength - s))
        for (var a, l, c = n.fullMessageLength[0] * 8, u = 0; u < n.fullMessageLength.length - 1; ++u)
          (a = n.fullMessageLength[u + 1] * 8),
            (l = (a / 4294967296) >>> 0),
            (c += l),
            i.putInt32(c >>> 0),
            (c = a >>> 0)
        i.putInt32(c)
        var p = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3, h4: t.h4 }
        VJ(p, r, i)
        var d = ql.util.createBuffer()
        return d.putInt32(p.h0), d.putInt32(p.h1), d.putInt32(p.h2), d.putInt32(p.h3), d.putInt32(p.h4), d
      }),
      n
    )
  }
  var $8 = null,
    $J = !1
  function qPe() {
    ;($8 = String.fromCharCode(128)), ($8 += ql.util.fillString(String.fromCharCode(0), 64)), ($J = !0)
  }
  function VJ(t, e, r) {
    for (var n, i, o, s, a, l, c, u, p = r.length(); p >= 64; ) {
      for (i = t.h0, o = t.h1, s = t.h2, a = t.h3, l = t.h4, u = 0; u < 16; ++u)
        (n = r.getInt32()),
          (e[u] = n),
          (c = a ^ (o & (s ^ a))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      for (; u < 20; ++u)
        (n = e[u - 3] ^ e[u - 8] ^ e[u - 14] ^ e[u - 16]),
          (n = (n << 1) | (n >>> 31)),
          (e[u] = n),
          (c = a ^ (o & (s ^ a))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      for (; u < 32; ++u)
        (n = e[u - 3] ^ e[u - 8] ^ e[u - 14] ^ e[u - 16]),
          (n = (n << 1) | (n >>> 31)),
          (e[u] = n),
          (c = o ^ s ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      for (; u < 40; ++u)
        (n = e[u - 6] ^ e[u - 16] ^ e[u - 28] ^ e[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (e[u] = n),
          (c = o ^ s ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      for (; u < 60; ++u)
        (n = e[u - 6] ^ e[u - 16] ^ e[u - 28] ^ e[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (e[u] = n),
          (c = (o & s) | (a & (o ^ s))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 2400959708 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      for (; u < 80; ++u)
        (n = e[u - 6] ^ e[u - 16] ^ e[u - 28] ^ e[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (e[u] = n),
          (c = o ^ s ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 3395469782 + n),
          (l = a),
          (a = s),
          (s = ((o << 30) | (o >>> 2)) >>> 0),
          (o = i),
          (i = n)
      ;(t.h0 = (t.h0 + i) | 0),
        (t.h1 = (t.h1 + o) | 0),
        (t.h2 = (t.h2 + s) | 0),
        (t.h3 = (t.h3 + a) | 0),
        (t.h4 = (t.h4 + l) | 0),
        (p -= 64)
    }
  }
})
var W8 = handleExports((Qht, YJ) => {
  var Hl = Mt()
  cr()
  Fa()
  y_()
  var KJ = (YJ.exports = Hl.pkcs1 = Hl.pkcs1 || {})
  KJ.encode_rsa_oaep = function (t, e, r) {
    var n, i, o, s
    typeof r == 'string'
      ? ((n = r), (i = arguments[3] || void 0), (o = arguments[4] || void 0))
      : r &&
        ((n = r.label || void 0), (i = r.seed || void 0), (o = r.md || void 0), r.mgf1 && r.mgf1.md && (s = r.mgf1.md)),
      o ? o.start() : (o = Hl.md.sha1.create()),
      s || (s = o)
    var a = Math.ceil(t.n.bitLength() / 8),
      l = a - 2 * o.digestLength - 2
    if (e.length > l) {
      var c = new Error('RSAES-OAEP input message length is too long.')
      throw ((c.length = e.length), (c.maxLength = l), c)
    }
    n || (n = ''), o.update(n, 'raw')
    for (var u = o.digest(), p = '', d = l - e.length, f = 0; f < d; f++) p += '\0'
    var m = u.getBytes() + p + '' + e
    if (!i) i = Hl.random.getBytes(o.digestLength)
    else if (i.length !== o.digestLength) {
      var c = new Error('Invalid RSAES-OAEP seed. The seed length must match the digest length.')
      throw ((c.seedLength = i.length), (c.digestLength = o.digestLength), c)
    }
    var h = CA(i, a - o.digestLength - 1, s),
      g = Hl.util.xorBytes(m, h, m.length),
      v = CA(g, o.digestLength, s),
      _ = Hl.util.xorBytes(i, v, i.length)
    return '\0' + _ + g
  }
  KJ.decode_rsa_oaep = function (t, e, r) {
    var n, i, o
    typeof r == 'string'
      ? ((n = r), (i = arguments[3] || void 0))
      : r && ((n = r.label || void 0), (i = r.md || void 0), r.mgf1 && r.mgf1.md && (o = r.mgf1.md))
    var s = Math.ceil(t.n.bitLength() / 8)
    if (e.length !== s) {
      var g = new Error('RSAES-OAEP encoded message length is invalid.')
      throw ((g.length = e.length), (g.expectedLength = s), g)
    }
    if ((i === void 0 ? (i = Hl.md.sha1.create()) : i.start(), o || (o = i), s < 2 * i.digestLength + 2))
      throw new Error('RSAES-OAEP key is too short for the hash function.')
    n || (n = ''), i.update(n, 'raw')
    for (
      var a = i.digest().getBytes(),
        l = e.charAt(0),
        c = e.substring(1, i.digestLength + 1),
        u = e.substring(1 + i.digestLength),
        p = CA(u, i.digestLength, o),
        d = Hl.util.xorBytes(c, p, c.length),
        f = CA(d, s - i.digestLength - 1, o),
        m = Hl.util.xorBytes(u, f, u.length),
        h = m.substring(0, i.digestLength),
        g = l !== '\0',
        v = 0;
      v < i.digestLength;
      ++v
    )
      g |= a.charAt(v) !== h.charAt(v)
    for (var _ = 1, y = i.digestLength, b = i.digestLength; b < m.length; b++) {
      var x = m.charCodeAt(b),
        P = (x & 1) ^ 1,
        U = _ ? 65534 : 0
      ;(g |= x & U), (_ = _ & P), (y += _)
    }
    if (g || m.charCodeAt(y) !== 1) throw new Error('Invalid RSAES-OAEP padding.')
    return m.substring(y + 1)
  }
  function CA(t, e, r) {
    r || (r = Hl.md.sha1.create())
    for (var n = '', i = Math.ceil(e / r.digestLength), o = 0; o < i; ++o) {
      var s = String.fromCharCode((o >> 24) & 255, (o >> 16) & 255, (o >> 8) & 255, o & 255)
      r.start(), r.update(t + s), (n += r.digest().getBytes())
    }
    return n.substring(0, e)
  }
})
var Y8 = handleExports((Xht, K8) => {
  var If = Mt()
  cr()
  zb()
  Fa()
  ;(function () {
    if (If.prime) {
      K8.exports = If.prime
      return
    }
    var t = (K8.exports = If.prime = If.prime || {}),
      e = If.jsbn.BigInteger,
      r = [6, 4, 2, 4, 2, 4, 6, 2],
      n = new e(null)
    n.fromInt(30)
    var i = function (p, d) {
      return p | d
    }
    t.generateProbablePrime = function (p, d, f) {
      typeof d == 'function' && ((f = d), (d = {})), (d = d || {})
      var m = d.algorithm || 'PRIMEINC'
      typeof m == 'string' && (m = { name: m }), (m.options = m.options || {})
      var h = d.prng || If.random,
        g = {
          nextBytes: function (v) {
            for (var _ = h.getBytesSync(v.length), y = 0; y < v.length; ++y) v[y] = _.charCodeAt(y)
          },
        }
      if (m.name === 'PRIMEINC') return o(p, g, m.options, f)
      throw new Error('Invalid prime generation algorithm: ' + m.name)
    }
    function o(p, d, f, m) {
      return 'workers' in f ? l(p, d, f, m) : s(p, d, f, m)
    }
    function s(p, d, f, m) {
      var h = c(p, d),
        g = 0,
        v = u(h.bitLength())
      'millerRabinTests' in f && (v = f.millerRabinTests)
      var _ = 10
      'maxBlockTime' in f && (_ = f.maxBlockTime), a(h, p, d, g, v, _, m)
    }
    function a(p, d, f, m, h, g, v) {
      var _ = +new Date()
      do {
        if ((p.bitLength() > d && (p = c(d, f)), p.isProbablePrime(h))) return v(null, p)
        p.dAddOffset(r[m++ % 8], 0)
      } while (g < 0 || +new Date() - _ < g)
      If.util.setImmediate(function () {
        a(p, d, f, m, h, g, v)
      })
    }
    function l(p, d, f, m) {
      if (typeof Worker > 'u') return s(p, d, f, m)
      var h = c(p, d),
        g = f.workers,
        v = f.workLoad || 100,
        _ = (v * 30) / 8,
        y = f.workerScript || 'forge/prime.worker.js'
      if (g === -1)
        return If.util.estimateCores(function (x, P) {
          x && (P = 2), (g = P - 1), b()
        })
      b()
      function b() {
        g = Math.max(1, g)
        for (var x = [], P = 0; P < g; ++P) x[P] = new Worker(y)
        for (var U = g, P = 0; P < g; ++P) x[P].addEventListener('message', j)
        var H = !1
        function j(M) {
          if (!H) {
            --U
            var F = M.data
            if (F.found) {
              for (var z = 0; z < x.length; ++z) x[z].terminate()
              return (H = !0), m(null, new e(F.prime, 16))
            }
            h.bitLength() > p && (h = c(p, d))
            var q = h.toString(16)
            M.target.postMessage({ hex: q, workLoad: v }), h.dAddOffset(_, 0)
          }
        }
      }
    }
    function c(p, d) {
      var f = new e(p, d),
        m = p - 1
      return f.testBit(m) || f.bitwiseTo(e.ONE.shiftLeft(m), i, f), f.dAddOffset(31 - f.mod(n).byteValue(), 0), f
    }
    function u(p) {
      return p <= 100
        ? 27
        : p <= 150
        ? 18
        : p <= 200
        ? 15
        : p <= 250
        ? 12
        : p <= 300
        ? 9
        : p <= 350
        ? 8
        : p <= 400
        ? 7
        : p <= 500
        ? 6
        : p <= 600
        ? 5
        : p <= 800
        ? 4
        : p <= 1250
        ? 3
        : 2
    }
  })()
})
var $b = handleExports((Jht, rZ) => {
  var lt = Mt()
  Lc()
  zb()
  Sf()
  W8()
  Y8()
  Fa()
  cr()
  typeof rr > 'u' && (rr = lt.jsbn.BigInteger)
  var rr,
    Q8 = lt.util.isNodejs ? require('crypto') : null,
    ue = lt.asn1,
    Ba = lt.util
  lt.pki = lt.pki || {}
  rZ.exports = lt.pki.rsa = lt.rsa = lt.rsa || {}
  var Dt = lt.pki,
    HPe = [6, 4, 2, 4, 2, 4, 6, 2],
    jPe = {
      name: 'PrivateKeyInfo',
      tagClass: ue.Class.UNIVERSAL,
      type: ue.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'PrivateKeyInfo.version',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyVersion',
        },
        {
          name: 'PrivateKeyInfo.privateKeyAlgorithm',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'AlgorithmIdentifier.algorithm',
              tagClass: ue.Class.UNIVERSAL,
              type: ue.Type.OID,
              constructed: !1,
              capture: 'privateKeyOid',
            },
          ],
        },
        {
          name: 'PrivateKeyInfo',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.OCTETSTRING,
          constructed: !1,
          capture: 'privateKey',
        },
      ],
    },
    GPe = {
      name: 'RSAPrivateKey',
      tagClass: ue.Class.UNIVERSAL,
      type: ue.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'RSAPrivateKey.version',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyVersion',
        },
        {
          name: 'RSAPrivateKey.modulus',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyModulus',
        },
        {
          name: 'RSAPrivateKey.publicExponent',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyPublicExponent',
        },
        {
          name: 'RSAPrivateKey.privateExponent',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyPrivateExponent',
        },
        {
          name: 'RSAPrivateKey.prime1',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyPrime1',
        },
        {
          name: 'RSAPrivateKey.prime2',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyPrime2',
        },
        {
          name: 'RSAPrivateKey.exponent1',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyExponent1',
        },
        {
          name: 'RSAPrivateKey.exponent2',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyExponent2',
        },
        {
          name: 'RSAPrivateKey.coefficient',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'privateKeyCoefficient',
        },
      ],
    },
    VPe = {
      name: 'RSAPublicKey',
      tagClass: ue.Class.UNIVERSAL,
      type: ue.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'RSAPublicKey.modulus',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'publicKeyModulus',
        },
        {
          name: 'RSAPublicKey.exponent',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.INTEGER,
          constructed: !1,
          capture: 'publicKeyExponent',
        },
      ],
    },
    zPe = (lt.pki.rsa.publicKeyValidator = {
      name: 'SubjectPublicKeyInfo',
      tagClass: ue.Class.UNIVERSAL,
      type: ue.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: 'subjectPublicKeyInfo',
      value: [
        {
          name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'AlgorithmIdentifier.algorithm',
              tagClass: ue.Class.UNIVERSAL,
              type: ue.Type.OID,
              constructed: !1,
              capture: 'publicKeyOid',
            },
          ],
        },
        {
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.BITSTRING,
          constructed: !1,
          value: [
            {
              name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
              tagClass: ue.Class.UNIVERSAL,
              type: ue.Type.SEQUENCE,
              constructed: !0,
              optional: !0,
              captureAsn1: 'rsaPublicKey',
            },
          ],
        },
      ],
    }),
    $Pe = {
      name: 'DigestInfo',
      tagClass: ue.Class.UNIVERSAL,
      type: ue.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'DigestInfo.DigestAlgorithm',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'DigestInfo.DigestAlgorithm.algorithmIdentifier',
              tagClass: ue.Class.UNIVERSAL,
              type: ue.Type.OID,
              constructed: !1,
              capture: 'algorithmIdentifier',
            },
            {
              name: 'DigestInfo.DigestAlgorithm.parameters',
              tagClass: ue.Class.UNIVERSAL,
              type: ue.Type.NULL,
              capture: 'parameters',
              optional: !0,
              constructed: !1,
            },
          ],
        },
        {
          name: 'DigestInfo.digest',
          tagClass: ue.Class.UNIVERSAL,
          type: ue.Type.OCTETSTRING,
          constructed: !1,
          capture: 'digest',
        },
      ],
    },
    WPe = function (t) {
      var e
      if (t.algorithm in Dt.oids) e = Dt.oids[t.algorithm]
      else {
        var r = new Error('Unknown message digest algorithm.')
        throw ((r.algorithm = t.algorithm), r)
      }
      var n = ue.oidToDer(e).getBytes(),
        i = ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, []),
        o = ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [])
      o.value.push(ue.create(ue.Class.UNIVERSAL, ue.Type.OID, !1, n)),
        o.value.push(ue.create(ue.Class.UNIVERSAL, ue.Type.NULL, !1, ''))
      var s = ue.create(ue.Class.UNIVERSAL, ue.Type.OCTETSTRING, !1, t.digest().getBytes())
      return i.value.push(o), i.value.push(s), ue.toDer(i).getBytes()
    },
    eZ = function (t, e, r) {
      if (r) return t.modPow(e.e, e.n)
      if (!e.p || !e.q) return t.modPow(e.d, e.n)
      e.dP || (e.dP = e.d.mod(e.p.subtract(rr.ONE))),
        e.dQ || (e.dQ = e.d.mod(e.q.subtract(rr.ONE))),
        e.qInv || (e.qInv = e.q.modInverse(e.p))
      var n
      do n = new rr(lt.util.bytesToHex(lt.random.getBytes(e.n.bitLength() / 8)), 16)
      while (n.compareTo(e.n) >= 0 || !n.gcd(e.n).equals(rr.ONE))
      t = t.multiply(n.modPow(e.e, e.n)).mod(e.n)
      for (var i = t.mod(e.p).modPow(e.dP, e.p), o = t.mod(e.q).modPow(e.dQ, e.q); i.compareTo(o) < 0; ) i = i.add(e.p)
      var s = i.subtract(o).multiply(e.qInv).mod(e.p).multiply(e.q).add(o)
      return (s = s.multiply(n.modInverse(e.n)).mod(e.n)), s
    }
  Dt.rsa.encrypt = function (t, e, r) {
    var n = r,
      i,
      o = Math.ceil(e.n.bitLength() / 8)
    r !== !1 && r !== !0 ? ((n = r === 2), (i = tZ(t, e, r))) : ((i = lt.util.createBuffer()), i.putBytes(t))
    for (
      var s = new rr(i.toHex(), 16),
        a = eZ(s, e, n),
        l = a.toString(16),
        c = lt.util.createBuffer(),
        u = o - Math.ceil(l.length / 2);
      u > 0;

    )
      c.putByte(0), --u
    return c.putBytes(lt.util.hexToBytes(l)), c.getBytes()
  }
  Dt.rsa.decrypt = function (t, e, r, n) {
    var i = Math.ceil(e.n.bitLength() / 8)
    if (t.length !== i) {
      var o = new Error('Encrypted message length is invalid.')
      throw ((o.length = t.length), (o.expected = i), o)
    }
    var s = new rr(lt.util.createBuffer(t).toHex(), 16)
    if (s.compareTo(e.n) >= 0) throw new Error('Encrypted message is invalid.')
    for (var a = eZ(s, e, r), l = a.toString(16), c = lt.util.createBuffer(), u = i - Math.ceil(l.length / 2); u > 0; )
      c.putByte(0), --u
    return c.putBytes(lt.util.hexToBytes(l)), n !== !1 ? IA(c.getBytes(), e, r) : c.getBytes()
  }
  Dt.rsa.createKeyPairGenerationState = function (t, e, r) {
    typeof t == 'string' && (t = parseInt(t, 10)), (t = t || 2048), (r = r || {})
    var n = r.prng || lt.random,
      i = {
        nextBytes: function (a) {
          for (var l = n.getBytesSync(a.length), c = 0; c < a.length; ++c) a[c] = l.charCodeAt(c)
        },
      },
      o = r.algorithm || 'PRIMEINC',
      s
    if (o === 'PRIMEINC')
      (s = {
        algorithm: o,
        state: 0,
        bits: t,
        rng: i,
        eInt: e || 65537,
        e: new rr(null),
        p: null,
        q: null,
        qBits: t >> 1,
        pBits: t - (t >> 1),
        pqState: 0,
        num: null,
        keys: null,
      }),
        s.e.fromInt(s.eInt)
    else throw new Error('Invalid key generation algorithm: ' + o)
    return s
  }
  Dt.rsa.stepKeyPairGenerationState = function (t, e) {
    'algorithm' in t || (t.algorithm = 'PRIMEINC')
    var r = new rr(null)
    r.fromInt(30)
    for (
      var n = 0,
        i = function (p, d) {
          return p | d
        },
        o = +new Date(),
        s,
        a = 0;
      t.keys === null && (e <= 0 || a < e);

    ) {
      if (t.state === 0) {
        var l = t.p === null ? t.pBits : t.qBits,
          c = l - 1
        t.pqState === 0
          ? ((t.num = new rr(l, t.rng)),
            t.num.testBit(c) || t.num.bitwiseTo(rr.ONE.shiftLeft(c), i, t.num),
            t.num.dAddOffset(31 - t.num.mod(r).byteValue(), 0),
            (n = 0),
            ++t.pqState)
          : t.pqState === 1
          ? t.num.bitLength() > l
            ? (t.pqState = 0)
            : t.num.isProbablePrime(YPe(t.num.bitLength()))
            ? ++t.pqState
            : t.num.dAddOffset(HPe[n++ % 8], 0)
          : t.pqState === 2
          ? (t.pqState = t.num.subtract(rr.ONE).gcd(t.e).compareTo(rr.ONE) === 0 ? 3 : 0)
          : t.pqState === 3 &&
            ((t.pqState = 0),
            t.p === null ? (t.p = t.num) : (t.q = t.num),
            t.p !== null && t.q !== null && ++t.state,
            (t.num = null))
      } else if (t.state === 1) t.p.compareTo(t.q) < 0 && ((t.num = t.p), (t.p = t.q), (t.q = t.num)), ++t.state
      else if (t.state === 2)
        (t.p1 = t.p.subtract(rr.ONE)), (t.q1 = t.q.subtract(rr.ONE)), (t.phi = t.p1.multiply(t.q1)), ++t.state
      else if (t.state === 3)
        t.phi.gcd(t.e).compareTo(rr.ONE) === 0 ? ++t.state : ((t.p = null), (t.q = null), (t.state = 0))
      else if (t.state === 4)
        (t.n = t.p.multiply(t.q)), t.n.bitLength() === t.bits ? ++t.state : ((t.q = null), (t.state = 0))
      else if (t.state === 5) {
        var u = t.e.modInverse(t.phi)
        t.keys = {
          privateKey: Dt.rsa.setPrivateKey(t.n, t.e, u, t.p, t.q, u.mod(t.p1), u.mod(t.q1), t.q.modInverse(t.p)),
          publicKey: Dt.rsa.setPublicKey(t.n, t.e),
        }
      }
      ;(s = +new Date()), (a += s - o), (o = s)
    }
    return t.keys !== null
  }
  Dt.rsa.generateKeyPair = function (t, e, r, n) {
    if (
      (arguments.length === 1
        ? typeof t == 'object'
          ? ((r = t), (t = void 0))
          : typeof t == 'function' && ((n = t), (t = void 0))
        : arguments.length === 2
        ? typeof t == 'number'
          ? typeof e == 'function'
            ? ((n = e), (e = void 0))
            : typeof e != 'number' && ((r = e), (e = void 0))
          : ((r = t), (n = e), (t = void 0), (e = void 0))
        : arguments.length === 3 &&
          (typeof e == 'number' ? typeof r == 'function' && ((n = r), (r = void 0)) : ((n = r), (r = e), (e = void 0))),
      (r = r || {}),
      t === void 0 && (t = r.bits || 2048),
      e === void 0 && (e = r.e || 65537),
      !lt.options.usePureJavaScript && !r.prng && t >= 256 && t <= 16384 && (e === 65537 || e === 3))
    ) {
      if (n) {
        if (QJ('generateKeyPair'))
          return Q8.generateKeyPair(
            'rsa',
            {
              modulusLength: t,
              publicExponent: e,
              publicKeyEncoding: { type: 'spki', format: 'pem' },
              privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
            },
            function (a, l, c) {
              if (a) return n(a)
              n(null, { privateKey: Dt.privateKeyFromPem(c), publicKey: Dt.publicKeyFromPem(l) })
            }
          )
        if (XJ('generateKey') && XJ('exportKey'))
          return Ba.globalScope.crypto.subtle
            .generateKey(
              { name: 'RSASSA-PKCS1-v1_5', modulusLength: t, publicExponent: ZJ(e), hash: { name: 'SHA-256' } },
              !0,
              ['sign', 'verify']
            )
            .then(function (a) {
              return Ba.globalScope.crypto.subtle.exportKey('pkcs8', a.privateKey)
            })
            .then(void 0, function (a) {
              n(a)
            })
            .then(function (a) {
              if (a) {
                var l = Dt.privateKeyFromAsn1(ue.fromDer(lt.util.createBuffer(a)))
                n(null, { privateKey: l, publicKey: Dt.setRsaPublicKey(l.n, l.e) })
              }
            })
        if (JJ('generateKey') && JJ('exportKey')) {
          var i = Ba.globalScope.msCrypto.subtle.generateKey(
            { name: 'RSASSA-PKCS1-v1_5', modulusLength: t, publicExponent: ZJ(e), hash: { name: 'SHA-256' } },
            !0,
            ['sign', 'verify']
          )
          ;(i.oncomplete = function (a) {
            var l = a.target.result,
              c = Ba.globalScope.msCrypto.subtle.exportKey('pkcs8', l.privateKey)
            ;(c.oncomplete = function (u) {
              var p = u.target.result,
                d = Dt.privateKeyFromAsn1(ue.fromDer(lt.util.createBuffer(p)))
              n(null, { privateKey: d, publicKey: Dt.setRsaPublicKey(d.n, d.e) })
            }),
              (c.onerror = function (u) {
                n(u)
              })
          }),
            (i.onerror = function (a) {
              n(a)
            })
          return
        }
      } else if (QJ('generateKeyPairSync')) {
        var o = Q8.generateKeyPairSync('rsa', {
          modulusLength: t,
          publicExponent: e,
          publicKeyEncoding: { type: 'spki', format: 'pem' },
          privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
        })
        return { privateKey: Dt.privateKeyFromPem(o.privateKey), publicKey: Dt.publicKeyFromPem(o.publicKey) }
      }
    }
    var s = Dt.rsa.createKeyPairGenerationState(t, e, r)
    if (!n) return Dt.rsa.stepKeyPairGenerationState(s, 0), s.keys
    KPe(s, r, n)
  }
  Dt.setRsaPublicKey = Dt.rsa.setPublicKey = function (t, e) {
    var r = { n: t, e }
    return (
      (r.encrypt = function (n, i, o) {
        if (
          (typeof i == 'string' ? (i = i.toUpperCase()) : i === void 0 && (i = 'RSAES-PKCS1-V1_5'),
          i === 'RSAES-PKCS1-V1_5')
        )
          i = {
            encode: function (a, l, c) {
              return tZ(a, l, 2).getBytes()
            },
          }
        else if (i === 'RSA-OAEP' || i === 'RSAES-OAEP')
          i = {
            encode: function (a, l) {
              return lt.pkcs1.encode_rsa_oaep(l, a, o)
            },
          }
        else if (['RAW', 'NONE', 'NULL', null].indexOf(i) !== -1)
          i = {
            encode: function (a) {
              return a
            },
          }
        else if (typeof i == 'string') throw new Error('Unsupported encryption scheme: "' + i + '".')
        var s = i.encode(n, r, !0)
        return Dt.rsa.encrypt(s, r, !0)
      }),
      (r.verify = function (n, i, o, s) {
        typeof o == 'string' ? (o = o.toUpperCase()) : o === void 0 && (o = 'RSASSA-PKCS1-V1_5'),
          s === void 0 && (s = { _parseAllDigestBytes: !0 }),
          '_parseAllDigestBytes' in s || (s._parseAllDigestBytes = !0),
          o === 'RSASSA-PKCS1-V1_5'
            ? (o = {
                verify: function (l, c) {
                  c = IA(c, r, !0)
                  var u = ue.fromDer(c, { parseAllBytes: s._parseAllDigestBytes }),
                    p = {},
                    d = []
                  if (!ue.validate(u, $Pe, p, d)) {
                    var f = new Error('ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.')
                    throw ((f.errors = d), f)
                  }
                  var m = ue.derToOid(p.algorithmIdentifier)
                  if (
                    !(
                      m === lt.oids.md2 ||
                      m === lt.oids.md5 ||
                      m === lt.oids.sha1 ||
                      m === lt.oids.sha224 ||
                      m === lt.oids.sha256 ||
                      m === lt.oids.sha384 ||
                      m === lt.oids.sha512 ||
                      m === lt.oids['sha512-224'] ||
                      m === lt.oids['sha512-256']
                    )
                  ) {
                    var f = new Error('Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.')
                    throw ((f.oid = m), f)
                  }
                  if ((m === lt.oids.md2 || m === lt.oids.md5) && !('parameters' in p))
                    throw new Error(
                      'ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.'
                    )
                  return l === p.digest
                },
              })
            : (o === 'NONE' || o === 'NULL' || o === null) &&
              (o = {
                verify: function (l, c) {
                  return (c = IA(c, r, !0)), l === c
                },
              })
        var a = Dt.rsa.decrypt(i, r, !0, !1)
        return o.verify(n, a, r.n.bitLength())
      }),
      r
    )
  }
  Dt.setRsaPrivateKey = Dt.rsa.setPrivateKey = function (t, e, r, n, i, o, s, a) {
    var l = { n: t, e, d: r, p: n, q: i, dP: o, dQ: s, qInv: a }
    return (
      (l.decrypt = function (c, u, p) {
        typeof u == 'string' ? (u = u.toUpperCase()) : u === void 0 && (u = 'RSAES-PKCS1-V1_5')
        var d = Dt.rsa.decrypt(c, l, !1, !1)
        if (u === 'RSAES-PKCS1-V1_5') u = { decode: IA }
        else if (u === 'RSA-OAEP' || u === 'RSAES-OAEP')
          u = {
            decode: function (f, m) {
              return lt.pkcs1.decode_rsa_oaep(m, f, p)
            },
          }
        else if (['RAW', 'NONE', 'NULL', null].indexOf(u) !== -1)
          u = {
            decode: function (f) {
              return f
            },
          }
        else throw new Error('Unsupported encryption scheme: "' + u + '".')
        return u.decode(d, l, !1)
      }),
      (l.sign = function (c, u) {
        var p = !1
        typeof u == 'string' && (u = u.toUpperCase()),
          u === void 0 || u === 'RSASSA-PKCS1-V1_5'
            ? ((u = { encode: WPe }), (p = 1))
            : (u === 'NONE' || u === 'NULL' || u === null) &&
              ((u = {
                encode: function () {
                  return c
                },
              }),
              (p = 1))
        var d = u.encode(c, l.n.bitLength())
        return Dt.rsa.encrypt(d, l, p)
      }),
      l
    )
  }
  Dt.wrapRsaPrivateKey = function (t) {
    return ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, ue.integerToDer(0).getBytes()),
      ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
        ue.create(ue.Class.UNIVERSAL, ue.Type.OID, !1, ue.oidToDer(Dt.oids.rsaEncryption).getBytes()),
        ue.create(ue.Class.UNIVERSAL, ue.Type.NULL, !1, ''),
      ]),
      ue.create(ue.Class.UNIVERSAL, ue.Type.OCTETSTRING, !1, ue.toDer(t).getBytes()),
    ])
  }
  Dt.privateKeyFromAsn1 = function (t) {
    var e = {},
      r = []
    if (
      (ue.validate(t, jPe, e, r) && (t = ue.fromDer(lt.util.createBuffer(e.privateKey))),
      (e = {}),
      (r = []),
      !ue.validate(t, GPe, e, r))
    ) {
      var n = new Error('Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.')
      throw ((n.errors = r), n)
    }
    var i, o, s, a, l, c, u, p
    return (
      (i = lt.util.createBuffer(e.privateKeyModulus).toHex()),
      (o = lt.util.createBuffer(e.privateKeyPublicExponent).toHex()),
      (s = lt.util.createBuffer(e.privateKeyPrivateExponent).toHex()),
      (a = lt.util.createBuffer(e.privateKeyPrime1).toHex()),
      (l = lt.util.createBuffer(e.privateKeyPrime2).toHex()),
      (c = lt.util.createBuffer(e.privateKeyExponent1).toHex()),
      (u = lt.util.createBuffer(e.privateKeyExponent2).toHex()),
      (p = lt.util.createBuffer(e.privateKeyCoefficient).toHex()),
      Dt.setRsaPrivateKey(
        new rr(i, 16),
        new rr(o, 16),
        new rr(s, 16),
        new rr(a, 16),
        new rr(l, 16),
        new rr(c, 16),
        new rr(u, 16),
        new rr(p, 16)
      )
    )
  }
  Dt.privateKeyToAsn1 = Dt.privateKeyToRSAPrivateKey = function (t) {
    return ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, ue.integerToDer(0).getBytes()),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.n)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.e)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.d)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.p)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.q)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.dP)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.dQ)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.qInv)),
    ])
  }
  Dt.publicKeyFromAsn1 = function (t) {
    var e = {},
      r = []
    if (ue.validate(t, zPe, e, r)) {
      var n = ue.derToOid(e.publicKeyOid)
      if (n !== Dt.oids.rsaEncryption) {
        var i = new Error('Cannot read public key. Unknown OID.')
        throw ((i.oid = n), i)
      }
      t = e.rsaPublicKey
    }
    if (((r = []), !ue.validate(t, VPe, e, r))) {
      var i = new Error('Cannot read public key. ASN.1 object does not contain an RSAPublicKey.')
      throw ((i.errors = r), i)
    }
    var o = lt.util.createBuffer(e.publicKeyModulus).toHex(),
      s = lt.util.createBuffer(e.publicKeyExponent).toHex()
    return Dt.setRsaPublicKey(new rr(o, 16), new rr(s, 16))
  }
  Dt.publicKeyToAsn1 = Dt.publicKeyToSubjectPublicKeyInfo = function (t) {
    return ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
      ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
        ue.create(ue.Class.UNIVERSAL, ue.Type.OID, !1, ue.oidToDer(Dt.oids.rsaEncryption).getBytes()),
        ue.create(ue.Class.UNIVERSAL, ue.Type.NULL, !1, ''),
      ]),
      ue.create(ue.Class.UNIVERSAL, ue.Type.BITSTRING, !1, [Dt.publicKeyToRSAPublicKey(t)]),
    ])
  }
  Dt.publicKeyToRSAPublicKey = function (t) {
    return ue.create(ue.Class.UNIVERSAL, ue.Type.SEQUENCE, !0, [
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.n)),
      ue.create(ue.Class.UNIVERSAL, ue.Type.INTEGER, !1, jl(t.e)),
    ])
  }
  function tZ(t, e, r) {
    var n = lt.util.createBuffer(),
      i = Math.ceil(e.n.bitLength() / 8)
    if (t.length > i - 11) {
      var o = new Error('Message is too long for PKCS#1 v1.5 padding.')
      throw ((o.length = t.length), (o.max = i - 11), o)
    }
    n.putByte(0), n.putByte(r)
    var s = i - 3 - t.length,
      a
    if (r === 0 || r === 1) {
      a = r === 0 ? 0 : 255
      for (var l = 0; l < s; ++l) n.putByte(a)
    } else
      for (; s > 0; ) {
        for (var c = 0, u = lt.random.getBytes(s), l = 0; l < s; ++l)
          (a = u.charCodeAt(l)), a === 0 ? ++c : n.putByte(a)
        s = c
      }
    return n.putByte(0), n.putBytes(t), n
  }
  function IA(t, e, r, n) {
    var i = Math.ceil(e.n.bitLength() / 8),
      o = lt.util.createBuffer(t),
      s = o.getByte(),
      a = o.getByte()
    if (s !== 0 || (r && a !== 0 && a !== 1) || (!r && a != 2) || (r && a === 0 && typeof n > 'u'))
      throw new Error('Encryption block is invalid.')
    var l = 0
    if (a === 0) {
      l = i - 3 - n
      for (var c = 0; c < l; ++c) if (o.getByte() !== 0) throw new Error('Encryption block is invalid.')
    } else if (a === 1)
      for (l = 0; o.length() > 1; ) {
        if (o.getByte() !== 255) {
          --o.read
          break
        }
        ++l
      }
    else if (a === 2)
      for (l = 0; o.length() > 1; ) {
        if (o.getByte() === 0) {
          --o.read
          break
        }
        ++l
      }
    var u = o.getByte()
    if (u !== 0 || l !== i - 3 - o.length()) throw new Error('Encryption block is invalid.')
    return o.getBytes()
  }
  function KPe(t, e, r) {
    typeof e == 'function' && ((r = e), (e = {})), (e = e || {})
    var n = {
      algorithm: {
        name: e.algorithm || 'PRIMEINC',
        options: { workers: e.workers || 2, workLoad: e.workLoad || 100, workerScript: e.workerScript },
      },
    }
    'prng' in e && (n.prng = e.prng), i()
    function i() {
      o(t.pBits, function (a, l) {
        if (a) return r(a)
        if (((t.p = l), t.q !== null)) return s(a, t.q)
        o(t.qBits, s)
      })
    }
    function o(a, l) {
      lt.prime.generateProbablePrime(a, n, l)
    }
    function s(a, l) {
      if (a) return r(a)
      if (((t.q = l), t.p.compareTo(t.q) < 0)) {
        var c = t.p
        ;(t.p = t.q), (t.q = c)
      }
      if (t.p.subtract(rr.ONE).gcd(t.e).compareTo(rr.ONE) !== 0) {
        ;(t.p = null), i()
        return
      }
      if (t.q.subtract(rr.ONE).gcd(t.e).compareTo(rr.ONE) !== 0) {
        ;(t.q = null), o(t.qBits, s)
        return
      }
      if (
        ((t.p1 = t.p.subtract(rr.ONE)),
        (t.q1 = t.q.subtract(rr.ONE)),
        (t.phi = t.p1.multiply(t.q1)),
        t.phi.gcd(t.e).compareTo(rr.ONE) !== 0)
      ) {
        ;(t.p = t.q = null), i()
        return
      }
      if (((t.n = t.p.multiply(t.q)), t.n.bitLength() !== t.bits)) {
        ;(t.q = null), o(t.qBits, s)
        return
      }
      var u = t.e.modInverse(t.phi)
      ;(t.keys = {
        privateKey: Dt.rsa.setPrivateKey(t.n, t.e, u, t.p, t.q, u.mod(t.p1), u.mod(t.q1), t.q.modInverse(t.p)),
        publicKey: Dt.rsa.setPublicKey(t.n, t.e),
      }),
        r(null, t.keys)
    }
  }
  function jl(t) {
    var e = t.toString(16)
    e[0] >= '8' && (e = '00' + e)
    var r = lt.util.hexToBytes(e)
    return r.length > 1 &&
      ((r.charCodeAt(0) === 0 && !(r.charCodeAt(1) & 128)) ||
        (r.charCodeAt(0) === 255 && (r.charCodeAt(1) & 128) === 128))
      ? r.substr(1)
      : r
  }
  function YPe(t) {
    return t <= 100
      ? 27
      : t <= 150
      ? 18
      : t <= 200
      ? 15
      : t <= 250
      ? 12
      : t <= 300
      ? 9
      : t <= 350
      ? 8
      : t <= 400
      ? 7
      : t <= 500
      ? 6
      : t <= 600
      ? 5
      : t <= 800
      ? 4
      : t <= 1250
      ? 3
      : 2
  }
  function QJ(t) {
    return lt.util.isNodejs && typeof Q8[t] == 'function'
  }
  function XJ(t) {
    return (
      typeof Ba.globalScope < 'u' &&
      typeof Ba.globalScope.crypto == 'object' &&
      typeof Ba.globalScope.crypto.subtle == 'object' &&
      typeof Ba.globalScope.crypto.subtle[t] == 'function'
    )
  }
  function JJ(t) {
    return (
      typeof Ba.globalScope < 'u' &&
      typeof Ba.globalScope.msCrypto == 'object' &&
      typeof Ba.globalScope.msCrypto.subtle == 'object' &&
      typeof Ba.globalScope.msCrypto.subtle[t] == 'function'
    )
  }
  function ZJ(t) {
    for (var e = lt.util.hexToBytes(t.toString(16)), r = new Uint8Array(e.length), n = 0; n < e.length; ++n)
      r[n] = e.charCodeAt(n)
    return r
  }
})
var X8 = handleExports((Zht, aZ) => {
  var Ke = Mt()
  Tf()
  Lc()
  Gb()
  Ll()
  Sf()
  bA()
  pg()
  Fa()
  j8()
  $b()
  cr()
  typeof nZ > 'u' && (nZ = Ke.jsbn.BigInteger)
  var nZ,
    _e = Ke.asn1,
    Ot = (Ke.pki = Ke.pki || {})
  aZ.exports = Ot.pbe = Ke.pbe = Ke.pbe || {}
  var mg = Ot.oids,
    QPe = {
      name: 'EncryptedPrivateKeyInfo',
      tagClass: _e.Class.UNIVERSAL,
      type: _e.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'AlgorithmIdentifier.algorithm',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.OID,
              constructed: !1,
              capture: 'encryptionOid',
            },
            {
              name: 'AlgorithmIdentifier.parameters',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: 'encryptionParams',
            },
          ],
        },
        {
          name: 'EncryptedPrivateKeyInfo.encryptedData',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.OCTETSTRING,
          constructed: !1,
          capture: 'encryptedData',
        },
      ],
    },
    XPe = {
      name: 'PBES2Algorithms',
      tagClass: _e.Class.UNIVERSAL,
      type: _e.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'PBES2Algorithms.keyDerivationFunc',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'PBES2Algorithms.keyDerivationFunc.oid',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.OID,
              constructed: !1,
              capture: 'kdfOid',
            },
            {
              name: 'PBES2Algorithms.params',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'PBES2Algorithms.params.salt',
                  tagClass: _e.Class.UNIVERSAL,
                  type: _e.Type.OCTETSTRING,
                  constructed: !1,
                  capture: 'kdfSalt',
                },
                {
                  name: 'PBES2Algorithms.params.iterationCount',
                  tagClass: _e.Class.UNIVERSAL,
                  type: _e.Type.INTEGER,
                  constructed: !1,
                  capture: 'kdfIterationCount',
                },
                {
                  name: 'PBES2Algorithms.params.keyLength',
                  tagClass: _e.Class.UNIVERSAL,
                  type: _e.Type.INTEGER,
                  constructed: !1,
                  optional: !0,
                  capture: 'keyLength',
                },
                {
                  name: 'PBES2Algorithms.params.prf',
                  tagClass: _e.Class.UNIVERSAL,
                  type: _e.Type.SEQUENCE,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'PBES2Algorithms.params.prf.algorithm',
                      tagClass: _e.Class.UNIVERSAL,
                      type: _e.Type.OID,
                      constructed: !1,
                      capture: 'prfOid',
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          name: 'PBES2Algorithms.encryptionScheme',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'PBES2Algorithms.encryptionScheme.oid',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.OID,
              constructed: !1,
              capture: 'encOid',
            },
            {
              name: 'PBES2Algorithms.encryptionScheme.iv',
              tagClass: _e.Class.UNIVERSAL,
              type: _e.Type.OCTETSTRING,
              constructed: !1,
              capture: 'encIv',
            },
          ],
        },
      ],
    },
    JPe = {
      name: 'pkcs-12PbeParams',
      tagClass: _e.Class.UNIVERSAL,
      type: _e.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'pkcs-12PbeParams.salt',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.OCTETSTRING,
          constructed: !1,
          capture: 'salt',
        },
        {
          name: 'pkcs-12PbeParams.iterations',
          tagClass: _e.Class.UNIVERSAL,
          type: _e.Type.INTEGER,
          constructed: !1,
          capture: 'iterations',
        },
      ],
    }
  Ot.encryptPrivateKeyInfo = function (t, e, r) {
    ;(r = r || {}),
      (r.saltSize = r.saltSize || 8),
      (r.count = r.count || 2048),
      (r.algorithm = r.algorithm || 'aes128'),
      (r.prfAlgorithm = r.prfAlgorithm || 'sha1')
    var n = Ke.random.getBytesSync(r.saltSize),
      i = r.count,
      o = _e.integerToDer(i),
      s,
      a,
      l
    if (r.algorithm.indexOf('aes') === 0 || r.algorithm === 'des') {
      var c, u, p
      switch (r.algorithm) {
        case 'aes128':
          ;(s = 16), (c = 16), (u = mg['aes128-CBC']), (p = Ke.aes.createEncryptionCipher)
          break
        case 'aes192':
          ;(s = 24), (c = 16), (u = mg['aes192-CBC']), (p = Ke.aes.createEncryptionCipher)
          break
        case 'aes256':
          ;(s = 32), (c = 16), (u = mg['aes256-CBC']), (p = Ke.aes.createEncryptionCipher)
          break
        case 'des':
          ;(s = 8), (c = 8), (u = mg.desCBC), (p = Ke.des.createEncryptionCipher)
          break
        default:
          var d = new Error('Cannot encrypt private key. Unknown encryption algorithm.')
          throw ((d.algorithm = r.algorithm), d)
      }
      var f = 'hmacWith' + r.prfAlgorithm.toUpperCase(),
        m = sZ(f),
        h = Ke.pkcs5.pbkdf2(e, n, i, s, m),
        g = Ke.random.getBytesSync(c),
        v = p(h)
      v.start(g), v.update(_e.toDer(t)), v.finish(), (l = v.output.getBytes())
      var _ = ZPe(n, o, s, f)
      a = _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
        _e.create(_e.Class.UNIVERSAL, _e.Type.OID, !1, _e.oidToDer(mg.pkcs5PBES2).getBytes()),
        _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
          _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
            _e.create(_e.Class.UNIVERSAL, _e.Type.OID, !1, _e.oidToDer(mg.pkcs5PBKDF2).getBytes()),
            _,
          ]),
          _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
            _e.create(_e.Class.UNIVERSAL, _e.Type.OID, !1, _e.oidToDer(u).getBytes()),
            _e.create(_e.Class.UNIVERSAL, _e.Type.OCTETSTRING, !1, g),
          ]),
        ]),
      ])
    } else if (r.algorithm === '3des') {
      s = 24
      var y = new Ke.util.ByteBuffer(n),
        h = Ot.pbe.generatePkcs12Key(e, y, 1, i, s),
        g = Ot.pbe.generatePkcs12Key(e, y, 2, i, s),
        v = Ke.des.createEncryptionCipher(h)
      v.start(g),
        v.update(_e.toDer(t)),
        v.finish(),
        (l = v.output.getBytes()),
        (a = _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
          _e.create(_e.Class.UNIVERSAL, _e.Type.OID, !1, _e.oidToDer(mg['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),
          _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
            _e.create(_e.Class.UNIVERSAL, _e.Type.OCTETSTRING, !1, n),
            _e.create(_e.Class.UNIVERSAL, _e.Type.INTEGER, !1, o.getBytes()),
          ]),
        ]))
    } else {
      var d = new Error('Cannot encrypt private key. Unknown encryption algorithm.')
      throw ((d.algorithm = r.algorithm), d)
    }
    var b = _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
      a,
      _e.create(_e.Class.UNIVERSAL, _e.Type.OCTETSTRING, !1, l),
    ])
    return b
  }
  Ot.decryptPrivateKeyInfo = function (t, e) {
    var r = null,
      n = {},
      i = []
    if (!_e.validate(t, QPe, n, i)) {
      var o = new Error('Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.')
      throw ((o.errors = i), o)
    }
    var s = _e.derToOid(n.encryptionOid),
      a = Ot.pbe.getCipher(s, n.encryptionParams, e),
      l = Ke.util.createBuffer(n.encryptedData)
    return a.update(l), a.finish() && (r = _e.fromDer(a.output)), r
  }
  Ot.encryptedPrivateKeyToPem = function (t, e) {
    var r = { type: 'ENCRYPTED PRIVATE KEY', body: _e.toDer(t).getBytes() }
    return Ke.pem.encode(r, { maxline: e })
  }
  Ot.encryptedPrivateKeyFromPem = function (t) {
    var e = Ke.pem.decode(t)[0]
    if (e.type !== 'ENCRYPTED PRIVATE KEY') {
      var r = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".')
      throw ((r.headerType = e.type), r)
    }
    if (e.procType && e.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert encrypted private key from PEM; PEM is encrypted.')
    return _e.fromDer(e.body)
  }
  Ot.encryptRsaPrivateKey = function (t, e, r) {
    if (((r = r || {}), !r.legacy)) {
      var n = Ot.wrapRsaPrivateKey(Ot.privateKeyToAsn1(t))
      return (n = Ot.encryptPrivateKeyInfo(n, e, r)), Ot.encryptedPrivateKeyToPem(n)
    }
    var i, o, s, a
    switch (r.algorithm) {
      case 'aes128':
        ;(i = 'AES-128-CBC'), (s = 16), (o = Ke.random.getBytesSync(16)), (a = Ke.aes.createEncryptionCipher)
        break
      case 'aes192':
        ;(i = 'AES-192-CBC'), (s = 24), (o = Ke.random.getBytesSync(16)), (a = Ke.aes.createEncryptionCipher)
        break
      case 'aes256':
        ;(i = 'AES-256-CBC'), (s = 32), (o = Ke.random.getBytesSync(16)), (a = Ke.aes.createEncryptionCipher)
        break
      case '3des':
        ;(i = 'DES-EDE3-CBC'), (s = 24), (o = Ke.random.getBytesSync(8)), (a = Ke.des.createEncryptionCipher)
        break
      case 'des':
        ;(i = 'DES-CBC'), (s = 8), (o = Ke.random.getBytesSync(8)), (a = Ke.des.createEncryptionCipher)
        break
      default:
        var l = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".')
        throw ((l.algorithm = r.algorithm), l)
    }
    var c = Ke.pbe.opensslDeriveBytes(e, o.substr(0, 8), s),
      u = a(c)
    u.start(o), u.update(_e.toDer(Ot.privateKeyToAsn1(t))), u.finish()
    var p = {
      type: 'RSA PRIVATE KEY',
      procType: { version: '4', type: 'ENCRYPTED' },
      dekInfo: { algorithm: i, parameters: Ke.util.bytesToHex(o).toUpperCase() },
      body: u.output.getBytes(),
    }
    return Ke.pem.encode(p)
  }
  Ot.decryptRsaPrivateKey = function (t, e) {
    var r = null,
      n = Ke.pem.decode(t)[0]
    if (n.type !== 'ENCRYPTED PRIVATE KEY' && n.type !== 'PRIVATE KEY' && n.type !== 'RSA PRIVATE KEY') {
      var i = new Error(
        'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".'
      )
      throw ((i.headerType = i), i)
    }
    if (n.procType && n.procType.type === 'ENCRYPTED') {
      var o, s
      switch (n.dekInfo.algorithm) {
        case 'DES-CBC':
          ;(o = 8), (s = Ke.des.createDecryptionCipher)
          break
        case 'DES-EDE3-CBC':
          ;(o = 24), (s = Ke.des.createDecryptionCipher)
          break
        case 'AES-128-CBC':
          ;(o = 16), (s = Ke.aes.createDecryptionCipher)
          break
        case 'AES-192-CBC':
          ;(o = 24), (s = Ke.aes.createDecryptionCipher)
          break
        case 'AES-256-CBC':
          ;(o = 32), (s = Ke.aes.createDecryptionCipher)
          break
        case 'RC2-40-CBC':
          ;(o = 5),
            (s = function (p) {
              return Ke.rc2.createDecryptionCipher(p, 40)
            })
          break
        case 'RC2-64-CBC':
          ;(o = 8),
            (s = function (p) {
              return Ke.rc2.createDecryptionCipher(p, 64)
            })
          break
        case 'RC2-128-CBC':
          ;(o = 16),
            (s = function (p) {
              return Ke.rc2.createDecryptionCipher(p, 128)
            })
          break
        default:
          var i = new Error(
            'Could not decrypt private key; unsupported encryption algorithm "' + n.dekInfo.algorithm + '".'
          )
          throw ((i.algorithm = n.dekInfo.algorithm), i)
      }
      var a = Ke.util.hexToBytes(n.dekInfo.parameters),
        l = Ke.pbe.opensslDeriveBytes(e, a.substr(0, 8), o),
        c = s(l)
      if ((c.start(a), c.update(Ke.util.createBuffer(n.body)), c.finish())) r = c.output.getBytes()
      else return r
    } else r = n.body
    return (
      n.type === 'ENCRYPTED PRIVATE KEY' ? (r = Ot.decryptPrivateKeyInfo(_e.fromDer(r), e)) : (r = _e.fromDer(r)),
      r !== null && (r = Ot.privateKeyFromAsn1(r)),
      r
    )
  }
  Ot.pbe.generatePkcs12Key = function (t, e, r, n, i, o) {
    var s, a
    if (typeof o > 'u' || o === null) {
      if (!('sha1' in Ke.md)) throw new Error('"sha1" hash algorithm unavailable.')
      o = Ke.md.sha1.create()
    }
    var l = o.digestLength,
      c = o.blockLength,
      u = new Ke.util.ByteBuffer(),
      p = new Ke.util.ByteBuffer()
    if (t != null) {
      for (a = 0; a < t.length; a++) p.putInt16(t.charCodeAt(a))
      p.putInt16(0)
    }
    var d = p.length(),
      f = e.length(),
      m = new Ke.util.ByteBuffer()
    m.fillWithByte(r, c)
    var h = c * Math.ceil(f / c),
      g = new Ke.util.ByteBuffer()
    for (a = 0; a < h; a++) g.putByte(e.at(a % f))
    var v = c * Math.ceil(d / c),
      _ = new Ke.util.ByteBuffer()
    for (a = 0; a < v; a++) _.putByte(p.at(a % d))
    var y = g
    y.putBuffer(_)
    for (var b = Math.ceil(i / l), x = 1; x <= b; x++) {
      var P = new Ke.util.ByteBuffer()
      P.putBytes(m.bytes()), P.putBytes(y.bytes())
      for (var U = 0; U < n; U++) o.start(), o.update(P.getBytes()), (P = o.digest())
      var H = new Ke.util.ByteBuffer()
      for (a = 0; a < c; a++) H.putByte(P.at(a % l))
      var j = Math.ceil(f / c) + Math.ceil(d / c),
        M = new Ke.util.ByteBuffer()
      for (s = 0; s < j; s++) {
        var F = new Ke.util.ByteBuffer(y.getBytes(c)),
          z = 511
        for (a = H.length() - 1; a >= 0; a--) (z = z >> 8), (z += H.at(a) + F.at(a)), F.setAt(a, z & 255)
        M.putBuffer(F)
      }
      ;(y = M), u.putBuffer(P)
    }
    return u.truncate(u.length() - i), u
  }
  Ot.pbe.getCipher = function (t, e, r) {
    switch (t) {
      case Ot.oids.pkcs5PBES2:
        return Ot.pbe.getCipherForPBES2(t, e, r)
      case Ot.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
      case Ot.oids['pbewithSHAAnd40BitRC2-CBC']:
        return Ot.pbe.getCipherForPKCS12PBE(t, e, r)
      default:
        var n = new Error('Cannot read encrypted PBE data block. Unsupported OID.')
        throw (
          ((n.oid = t),
          (n.supportedOids = ['pkcs5PBES2', 'pbeWithSHAAnd3-KeyTripleDES-CBC', 'pbewithSHAAnd40BitRC2-CBC']),
          n)
        )
    }
  }
  Ot.pbe.getCipherForPBES2 = function (t, e, r) {
    var n = {},
      i = []
    if (!_e.validate(e, XPe, n, i)) {
      var o = new Error(
        'Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.'
      )
      throw ((o.errors = i), o)
    }
    if (((t = _e.derToOid(n.kdfOid)), t !== Ot.oids.pkcs5PBKDF2)) {
      var o = new Error('Cannot read encrypted private key. Unsupported key derivation function OID.')
      throw ((o.oid = t), (o.supportedOids = ['pkcs5PBKDF2']), o)
    }
    if (
      ((t = _e.derToOid(n.encOid)),
      t !== Ot.oids['aes128-CBC'] &&
        t !== Ot.oids['aes192-CBC'] &&
        t !== Ot.oids['aes256-CBC'] &&
        t !== Ot.oids['des-EDE3-CBC'] &&
        t !== Ot.oids.desCBC)
    ) {
      var o = new Error('Cannot read encrypted private key. Unsupported encryption scheme OID.')
      throw ((o.oid = t), (o.supportedOids = ['aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC']), o)
    }
    var s = n.kdfSalt,
      a = Ke.util.createBuffer(n.kdfIterationCount)
    a = a.getInt(a.length() << 3)
    var l, c
    switch (Ot.oids[t]) {
      case 'aes128-CBC':
        ;(l = 16), (c = Ke.aes.createDecryptionCipher)
        break
      case 'aes192-CBC':
        ;(l = 24), (c = Ke.aes.createDecryptionCipher)
        break
      case 'aes256-CBC':
        ;(l = 32), (c = Ke.aes.createDecryptionCipher)
        break
      case 'des-EDE3-CBC':
        ;(l = 24), (c = Ke.des.createDecryptionCipher)
        break
      case 'desCBC':
        ;(l = 8), (c = Ke.des.createDecryptionCipher)
        break
    }
    var u = oZ(n.prfOid),
      p = Ke.pkcs5.pbkdf2(r, s, a, l, u),
      d = n.encIv,
      f = c(p)
    return f.start(d), f
  }
  Ot.pbe.getCipherForPKCS12PBE = function (t, e, r) {
    var n = {},
      i = []
    if (!_e.validate(e, JPe, n, i)) {
      var o = new Error(
        'Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.'
      )
      throw ((o.errors = i), o)
    }
    var s = Ke.util.createBuffer(n.salt),
      a = Ke.util.createBuffer(n.iterations)
    a = a.getInt(a.length() << 3)
    var l, c, u
    switch (t) {
      case Ot.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
        ;(l = 24), (c = 8), (u = Ke.des.startDecrypting)
        break
      case Ot.oids['pbewithSHAAnd40BitRC2-CBC']:
        ;(l = 5),
          (c = 8),
          (u = function (h, g) {
            var v = Ke.rc2.createDecryptionCipher(h, 40)
            return v.start(g, null), v
          })
        break
      default:
        var o = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.')
        throw ((o.oid = t), o)
    }
    var p = oZ(n.prfOid),
      d = Ot.pbe.generatePkcs12Key(r, s, 1, a, l, p)
    p.start()
    var f = Ot.pbe.generatePkcs12Key(r, s, 2, a, c, p)
    return u(d, f)
  }
  Ot.pbe.opensslDeriveBytes = function (t, e, r, n) {
    if (typeof n > 'u' || n === null) {
      if (!('md5' in Ke.md)) throw new Error('"md5" hash algorithm unavailable.')
      n = Ke.md.md5.create()
    }
    e === null && (e = '')
    for (var i = [iZ(n, t + e)], o = 16, s = 1; o < r; ++s, o += 16) i.push(iZ(n, i[s - 1] + t + e))
    return i.join('').substr(0, r)
  }
  function iZ(t, e) {
    return t.start().update(e).digest().getBytes()
  }
  function oZ(t) {
    var e
    if (!t) e = 'hmacWithSHA1'
    else if (((e = Ot.oids[_e.derToOid(t)]), !e)) {
      var r = new Error('Unsupported PRF OID.')
      throw (
        ((r.oid = t),
        (r.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512']),
        r)
      )
    }
    return sZ(e)
  }
  function sZ(t) {
    var e = Ke.md
    switch (t) {
      case 'hmacWithSHA224':
        e = Ke.md.sha512
      case 'hmacWithSHA1':
      case 'hmacWithSHA256':
      case 'hmacWithSHA384':
      case 'hmacWithSHA512':
        t = t.substr(8).toLowerCase()
        break
      default:
        var r = new Error('Unsupported PRF algorithm.')
        throw (
          ((r.algorithm = t),
          (r.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512']),
          r)
        )
    }
    if (!e || !(t in e)) throw new Error('Unknown hash algorithm: ' + t)
    return e[t].create()
  }
  function ZPe(t, e, r, n) {
    var i = _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
      _e.create(_e.Class.UNIVERSAL, _e.Type.OCTETSTRING, !1, t),
      _e.create(_e.Class.UNIVERSAL, _e.Type.INTEGER, !1, e.getBytes()),
    ])
    return (
      n !== 'hmacWithSHA1' &&
        i.value.push(
          _e.create(_e.Class.UNIVERSAL, _e.Type.INTEGER, !1, Ke.util.hexToBytes(r.toString(16))),
          _e.create(_e.Class.UNIVERSAL, _e.Type.SEQUENCE, !0, [
            _e.create(_e.Class.UNIVERSAL, _e.Type.OID, !1, _e.oidToDer(Ot.oids[n]).getBytes()),
            _e.create(_e.Class.UNIVERSAL, _e.Type.NULL, !1, ''),
          ])
        ),
      i
    )
  }
})
var J8 = handleExports((egt, uZ) => {
  var x_ = Mt()
  Lc()
  cr()
  var Ve = x_.asn1,
    b_ = (uZ.exports = x_.pkcs7asn1 = x_.pkcs7asn1 || {})
  x_.pkcs7 = x_.pkcs7 || {}
  x_.pkcs7.asn1 = b_
  var cZ = {
    name: 'ContentInfo',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'ContentInfo.ContentType',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.OID,
        constructed: !1,
        capture: 'contentType',
      },
      {
        name: 'ContentInfo.content',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        captureAsn1: 'content',
      },
    ],
  }
  b_.contentInfoValidator = cZ
  var lZ = {
    name: 'EncryptedContentInfo',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'EncryptedContentInfo.contentType',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.OID,
        constructed: !1,
        capture: 'contentType',
      },
      {
        name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.OID,
            constructed: !1,
            capture: 'encAlgorithm',
          },
          {
            name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
            tagClass: Ve.Class.UNIVERSAL,
            captureAsn1: 'encParameter',
          },
        ],
      },
      {
        name: 'EncryptedContentInfo.encryptedContent',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: 'encryptedContent',
        captureAsn1: 'encryptedContentAsn1',
      },
    ],
  }
  b_.envelopedDataValidator = {
    name: 'EnvelopedData',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'EnvelopedData.Version',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.INTEGER,
        constructed: !1,
        capture: 'version',
      },
      {
        name: 'EnvelopedData.RecipientInfos',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SET,
        constructed: !0,
        captureAsn1: 'recipientInfos',
      },
    ].concat(lZ),
  }
  b_.encryptedDataValidator = {
    name: 'EncryptedData',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'EncryptedData.Version',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.INTEGER,
        constructed: !1,
        capture: 'version',
      },
    ].concat(lZ),
  }
  var eNe = {
    name: 'SignerInfo',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      { name: 'SignerInfo.version', tagClass: Ve.Class.UNIVERSAL, type: Ve.Type.INTEGER, constructed: !1 },
      {
        name: 'SignerInfo.issuerAndSerialNumber',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'SignerInfo.issuerAndSerialNumber.issuer',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: 'issuer',
          },
          {
            name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.INTEGER,
            constructed: !1,
            capture: 'serial',
          },
        ],
      },
      {
        name: 'SignerInfo.digestAlgorithm',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'SignerInfo.digestAlgorithm.algorithm',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.OID,
            constructed: !1,
            capture: 'digestAlgorithm',
          },
          {
            name: 'SignerInfo.digestAlgorithm.parameter',
            tagClass: Ve.Class.UNIVERSAL,
            constructed: !1,
            captureAsn1: 'digestParameter',
            optional: !0,
          },
        ],
      },
      {
        name: 'SignerInfo.authenticatedAttributes',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        capture: 'authenticatedAttributes',
      },
      {
        name: 'SignerInfo.digestEncryptionAlgorithm',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        capture: 'signatureAlgorithm',
      },
      {
        name: 'SignerInfo.encryptedDigest',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.OCTETSTRING,
        constructed: !1,
        capture: 'signature',
      },
      {
        name: 'SignerInfo.unauthenticatedAttributes',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        optional: !0,
        capture: 'unauthenticatedAttributes',
      },
    ],
  }
  b_.signedDataValidator = {
    name: 'SignedData',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'SignedData.Version',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.INTEGER,
        constructed: !1,
        capture: 'version',
      },
      {
        name: 'SignedData.DigestAlgorithms',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SET,
        constructed: !0,
        captureAsn1: 'digestAlgorithms',
      },
      cZ,
      {
        name: 'SignedData.Certificates',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: !0,
        captureAsn1: 'certificates',
      },
      {
        name: 'SignedData.CertificateRevocationLists',
        tagClass: Ve.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: !0,
        captureAsn1: 'crls',
      },
      {
        name: 'SignedData.SignerInfos',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SET,
        capture: 'signerInfos',
        optional: !0,
        value: [eNe],
      },
    ],
  }
  b_.recipientInfoValidator = {
    name: 'RecipientInfo',
    tagClass: Ve.Class.UNIVERSAL,
    type: Ve.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'RecipientInfo.version',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.INTEGER,
        constructed: !1,
        capture: 'version',
      },
      {
        name: 'RecipientInfo.issuerAndSerial',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'RecipientInfo.issuerAndSerial.issuer',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: 'issuer',
          },
          {
            name: 'RecipientInfo.issuerAndSerial.serialNumber',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.INTEGER,
            constructed: !1,
            capture: 'serial',
          },
        ],
      },
      {
        name: 'RecipientInfo.keyEncryptionAlgorithm',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
            tagClass: Ve.Class.UNIVERSAL,
            type: Ve.Type.OID,
            constructed: !1,
            capture: 'encAlgorithm',
          },
          {
            name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
            tagClass: Ve.Class.UNIVERSAL,
            constructed: !1,
            captureAsn1: 'encParameter',
            optional: !0,
          },
        ],
      },
      {
        name: 'RecipientInfo.encryptedKey',
        tagClass: Ve.Class.UNIVERSAL,
        type: Ve.Type.OCTETSTRING,
        constructed: !1,
        capture: 'encKey',
      },
    ],
  }
})
var Z8 = handleExports((tgt, pZ) => {
  var hg = Mt()
  cr()
  hg.mgf = hg.mgf || {}
  var tNe = (pZ.exports = hg.mgf.mgf1 = hg.mgf1 = hg.mgf1 || {})
  tNe.create = function (t) {
    var e = {
      generate: function (r, n) {
        for (var i = new hg.util.ByteBuffer(), o = Math.ceil(n / t.digestLength), s = 0; s < o; s++) {
          var a = new hg.util.ByteBuffer()
          a.putInt32(s), t.start(), t.update(r + a.getBytes()), i.putBuffer(t.digest())
        }
        return i.truncate(i.length() - n), i.getBytes()
      },
    }
    return e
  }
})
var fZ = handleExports((rgt, dZ) => {
  var wA = Mt()
  Z8()
  dZ.exports = wA.mgf = wA.mgf || {}
  wA.mgf.mgf1 = wA.mgf1
})
var AA = handleExports((ngt, mZ) => {
  var gg = Mt()
  Fa()
  cr()
  var rNe = (mZ.exports = gg.pss = gg.pss || {})
  rNe.create = function (t) {
    arguments.length === 3 && (t = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] })
    var e = t.md,
      r = t.mgf,
      n = e.digestLength,
      i = t.salt || null
    typeof i == 'string' && (i = gg.util.createBuffer(i))
    var o
    if ('saltLength' in t) o = t.saltLength
    else if (i !== null) o = i.length()
    else throw new Error('Salt length not specified or specific salt not given.')
    if (i !== null && i.length() !== o) throw new Error('Given salt length does not match length of given salt.')
    var s = t.prng || gg.random,
      a = {}
    return (
      (a.encode = function (l, c) {
        var u,
          p = c - 1,
          d = Math.ceil(p / 8),
          f = l.digest().getBytes()
        if (d < n + o + 2) throw new Error('Message is too long to encrypt.')
        var m
        i === null ? (m = s.getBytesSync(o)) : (m = i.bytes())
        var h = new gg.util.ByteBuffer()
        h.fillWithByte(0, 8), h.putBytes(f), h.putBytes(m), e.start(), e.update(h.getBytes())
        var g = e.digest().getBytes(),
          v = new gg.util.ByteBuffer()
        v.fillWithByte(0, d - o - n - 2), v.putByte(1), v.putBytes(m)
        var _ = v.getBytes(),
          y = d - n - 1,
          b = r.generate(g, y),
          x = ''
        for (u = 0; u < y; u++) x += String.fromCharCode(_.charCodeAt(u) ^ b.charCodeAt(u))
        var P = (65280 >> (8 * d - p)) & 255
        return (x = String.fromCharCode(x.charCodeAt(0) & ~P) + x.substr(1)), x + g + String.fromCharCode(188)
      }),
      (a.verify = function (l, c, u) {
        var p,
          d = u - 1,
          f = Math.ceil(d / 8)
        if (((c = c.substr(-f)), f < n + o + 2))
          throw new Error('Inconsistent parameters to PSS signature verification.')
        if (c.charCodeAt(f - 1) !== 188) throw new Error('Encoded message does not end in 0xBC.')
        var m = f - n - 1,
          h = c.substr(0, m),
          g = c.substr(m, n),
          v = (65280 >> (8 * f - d)) & 255
        if (h.charCodeAt(0) & v) throw new Error('Bits beyond keysize not zero as expected.')
        var _ = r.generate(g, m),
          y = ''
        for (p = 0; p < m; p++) y += String.fromCharCode(h.charCodeAt(p) ^ _.charCodeAt(p))
        y = String.fromCharCode(y.charCodeAt(0) & ~v) + y.substr(1)
        var b = f - n - o - 2
        for (p = 0; p < b; p++) if (y.charCodeAt(p) !== 0) throw new Error('Leftmost octets not zero as expected')
        if (y.charCodeAt(b) !== 1) throw new Error('Inconsistent PSS signature, 0x01 marker not found')
        var x = y.substr(-o),
          P = new gg.util.ByteBuffer()
        P.fillWithByte(0, 8), P.putBytes(l), P.putBytes(x), e.start(), e.update(P.getBytes())
        var U = e.digest().getBytes()
        return g === U
      }),
      a
    )
  }
})
var PA = handleExports((igt, yZ) => {
  var ut = Mt()
  Tf()
  Lc()
  Gb()
  Ll()
  fZ()
  Sf()
  pg()
  AA()
  $b()
  cr()
  var w = ut.asn1,
    Fe = (yZ.exports = ut.pki = ut.pki || {}),
    nr = Fe.oids,
    kn = {}
  kn.CN = nr.commonName
  kn.commonName = 'CN'
  kn.C = nr.countryName
  kn.countryName = 'C'
  kn.L = nr.localityName
  kn.localityName = 'L'
  kn.ST = nr.stateOrProvinceName
  kn.stateOrProvinceName = 'ST'
  kn.O = nr.organizationName
  kn.organizationName = 'O'
  kn.OU = nr.organizationalUnitName
  kn.organizationalUnitName = 'OU'
  kn.E = nr.emailAddress
  kn.emailAddress = 'E'
  var gZ = ut.pki.rsa.publicKeyValidator,
    nNe = {
      name: 'Certificate',
      tagClass: w.Class.UNIVERSAL,
      type: w.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'Certificate.TBSCertificate',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'tbsCertificate',
          value: [
            {
              name: 'Certificate.TBSCertificate.version',
              tagClass: w.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: !0,
              optional: !0,
              value: [
                {
                  name: 'Certificate.TBSCertificate.version.integer',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.INTEGER,
                  constructed: !1,
                  capture: 'certVersion',
                },
              ],
            },
            {
              name: 'Certificate.TBSCertificate.serialNumber',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.INTEGER,
              constructed: !1,
              capture: 'certSerialNumber',
            },
            {
              name: 'Certificate.TBSCertificate.signature',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'Certificate.TBSCertificate.signature.algorithm',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.OID,
                  constructed: !1,
                  capture: 'certinfoSignatureOid',
                },
                {
                  name: 'Certificate.TBSCertificate.signature.parameters',
                  tagClass: w.Class.UNIVERSAL,
                  optional: !0,
                  captureAsn1: 'certinfoSignatureParams',
                },
              ],
            },
            {
              name: 'Certificate.TBSCertificate.issuer',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: 'certIssuer',
            },
            {
              name: 'Certificate.TBSCertificate.validity',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.UTCTIME,
                  constructed: !1,
                  optional: !0,
                  capture: 'certValidity1UTCTime',
                },
                {
                  name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.GENERALIZEDTIME,
                  constructed: !1,
                  optional: !0,
                  capture: 'certValidity2GeneralizedTime',
                },
                {
                  name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.UTCTIME,
                  constructed: !1,
                  optional: !0,
                  capture: 'certValidity3UTCTime',
                },
                {
                  name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.GENERALIZEDTIME,
                  constructed: !1,
                  optional: !0,
                  capture: 'certValidity4GeneralizedTime',
                },
              ],
            },
            {
              name: 'Certificate.TBSCertificate.subject',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: 'certSubject',
            },
            gZ,
            {
              name: 'Certificate.TBSCertificate.issuerUniqueID',
              tagClass: w.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: !0,
              optional: !0,
              value: [
                {
                  name: 'Certificate.TBSCertificate.issuerUniqueID.id',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.BITSTRING,
                  constructed: !1,
                  captureBitStringValue: 'certIssuerUniqueId',
                },
              ],
            },
            {
              name: 'Certificate.TBSCertificate.subjectUniqueID',
              tagClass: w.Class.CONTEXT_SPECIFIC,
              type: 2,
              constructed: !0,
              optional: !0,
              value: [
                {
                  name: 'Certificate.TBSCertificate.subjectUniqueID.id',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.BITSTRING,
                  constructed: !1,
                  captureBitStringValue: 'certSubjectUniqueId',
                },
              ],
            },
            {
              name: 'Certificate.TBSCertificate.extensions',
              tagClass: w.Class.CONTEXT_SPECIFIC,
              type: 3,
              constructed: !0,
              captureAsn1: 'certExtensions',
              optional: !0,
            },
          ],
        },
        {
          name: 'Certificate.signatureAlgorithm',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'Certificate.signatureAlgorithm.algorithm',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.OID,
              constructed: !1,
              capture: 'certSignatureOid',
            },
            {
              name: 'Certificate.TBSCertificate.signature.parameters',
              tagClass: w.Class.UNIVERSAL,
              optional: !0,
              captureAsn1: 'certSignatureParams',
            },
          ],
        },
        {
          name: 'Certificate.signatureValue',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.BITSTRING,
          constructed: !1,
          captureBitStringValue: 'certSignature',
        },
      ],
    },
    iNe = {
      name: 'rsapss',
      tagClass: w.Class.UNIVERSAL,
      type: w.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'rsapss.hashAlgorithm',
          tagClass: w.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          value: [
            {
              name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
              tagClass: w.Class.UNIVERSAL,
              type: w.Class.SEQUENCE,
              constructed: !0,
              optional: !0,
              value: [
                {
                  name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.OID,
                  constructed: !1,
                  capture: 'hashOid',
                },
              ],
            },
          ],
        },
        {
          name: 'rsapss.maskGenAlgorithm',
          tagClass: w.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          value: [
            {
              name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
              tagClass: w.Class.UNIVERSAL,
              type: w.Class.SEQUENCE,
              constructed: !0,
              optional: !0,
              value: [
                {
                  name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.OID,
                  constructed: !1,
                  capture: 'maskGenOid',
                },
                {
                  name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
                      tagClass: w.Class.UNIVERSAL,
                      type: w.Type.OID,
                      constructed: !1,
                      capture: 'maskGenHashOid',
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          name: 'rsapss.saltLength',
          tagClass: w.Class.CONTEXT_SPECIFIC,
          type: 2,
          optional: !0,
          value: [
            {
              name: 'rsapss.saltLength.saltLength',
              tagClass: w.Class.UNIVERSAL,
              type: w.Class.INTEGER,
              constructed: !1,
              capture: 'saltLength',
            },
          ],
        },
        {
          name: 'rsapss.trailerField',
          tagClass: w.Class.CONTEXT_SPECIFIC,
          type: 3,
          optional: !0,
          value: [
            {
              name: 'rsapss.trailer.trailer',
              tagClass: w.Class.UNIVERSAL,
              type: w.Class.INTEGER,
              constructed: !1,
              capture: 'trailer',
            },
          ],
        },
      ],
    },
    oNe = {
      name: 'CertificationRequestInfo',
      tagClass: w.Class.UNIVERSAL,
      type: w.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: 'certificationRequestInfo',
      value: [
        {
          name: 'CertificationRequestInfo.integer',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.INTEGER,
          constructed: !1,
          capture: 'certificationRequestInfoVersion',
        },
        {
          name: 'CertificationRequestInfo.subject',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'certificationRequestInfoSubject',
        },
        gZ,
        {
          name: 'CertificationRequestInfo.attributes',
          tagClass: w.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          capture: 'certificationRequestInfoAttributes',
          value: [
            {
              name: 'CertificationRequestInfo.attributes',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'CertificationRequestInfo.attributes.type',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.OID,
                  constructed: !1,
                },
                {
                  name: 'CertificationRequestInfo.attributes.value',
                  tagClass: w.Class.UNIVERSAL,
                  type: w.Type.SET,
                  constructed: !0,
                },
              ],
            },
          ],
        },
      ],
    },
    sNe = {
      name: 'CertificationRequest',
      tagClass: w.Class.UNIVERSAL,
      type: w.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: 'csr',
      value: [
        oNe,
        {
          name: 'CertificationRequest.signatureAlgorithm',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'CertificationRequest.signatureAlgorithm.algorithm',
              tagClass: w.Class.UNIVERSAL,
              type: w.Type.OID,
              constructed: !1,
              capture: 'csrSignatureOid',
            },
            {
              name: 'CertificationRequest.signatureAlgorithm.parameters',
              tagClass: w.Class.UNIVERSAL,
              optional: !0,
              captureAsn1: 'csrSignatureParams',
            },
          ],
        },
        {
          name: 'CertificationRequest.signature',
          tagClass: w.Class.UNIVERSAL,
          type: w.Type.BITSTRING,
          constructed: !1,
          captureBitStringValue: 'csrSignature',
        },
      ],
    }
  Fe.RDNAttributesAsArray = function (t, e) {
    for (var r = [], n, i, o, s = 0; s < t.value.length; ++s) {
      n = t.value[s]
      for (var a = 0; a < n.value.length; ++a)
        (o = {}),
          (i = n.value[a]),
          (o.type = w.derToOid(i.value[0].value)),
          (o.value = i.value[1].value),
          (o.valueTagClass = i.value[1].type),
          o.type in nr && ((o.name = nr[o.type]), o.name in kn && (o.shortName = kn[o.name])),
          e && (e.update(o.type), e.update(o.value)),
          r.push(o)
    }
    return r
  }
  Fe.CRIAttributesAsArray = function (t) {
    for (var e = [], r = 0; r < t.length; ++r)
      for (var n = t[r], i = w.derToOid(n.value[0].value), o = n.value[1].value, s = 0; s < o.length; ++s) {
        var a = {}
        if (
          ((a.type = i),
          (a.value = o[s].value),
          (a.valueTagClass = o[s].type),
          a.type in nr && ((a.name = nr[a.type]), a.name in kn && (a.shortName = kn[a.name])),
          a.type === nr.extensionRequest)
        ) {
          a.extensions = []
          for (var l = 0; l < a.value.length; ++l) a.extensions.push(Fe.certificateExtensionFromAsn1(a.value[l]))
        }
        e.push(a)
      }
    return e
  }
  function wf(t, e) {
    typeof e == 'string' && (e = { shortName: e })
    for (var r = null, n, i = 0; r === null && i < t.attributes.length; ++i)
      (n = t.attributes[i]),
        ((e.type && e.type === n.type) ||
          (e.name && e.name === n.name) ||
          (e.shortName && e.shortName === n.shortName)) &&
          (r = n)
    return r
  }
  var RA = function (t, e, r) {
      var n = {}
      if (t !== nr['RSASSA-PSS']) return n
      r &&
        (n = {
          hash: { algorithmOid: nr.sha1 },
          mgf: { algorithmOid: nr.mgf1, hash: { algorithmOid: nr.sha1 } },
          saltLength: 20,
        })
      var i = {},
        o = []
      if (!w.validate(e, iNe, i, o)) {
        var s = new Error('Cannot read RSASSA-PSS parameter block.')
        throw ((s.errors = o), s)
      }
      return (
        i.hashOid !== void 0 && ((n.hash = n.hash || {}), (n.hash.algorithmOid = w.derToOid(i.hashOid))),
        i.maskGenOid !== void 0 &&
          ((n.mgf = n.mgf || {}),
          (n.mgf.algorithmOid = w.derToOid(i.maskGenOid)),
          (n.mgf.hash = n.mgf.hash || {}),
          (n.mgf.hash.algorithmOid = w.derToOid(i.maskGenHashOid))),
        i.saltLength !== void 0 && (n.saltLength = i.saltLength.charCodeAt(0)),
        n
      )
    },
    DA = function (t) {
      switch (nr[t.signatureOid]) {
        case 'sha1WithRSAEncryption':
        case 'sha1WithRSASignature':
          return ut.md.sha1.create()
        case 'md5WithRSAEncryption':
          return ut.md.md5.create()
        case 'sha256WithRSAEncryption':
          return ut.md.sha256.create()
        case 'sha384WithRSAEncryption':
          return ut.md.sha384.create()
        case 'sha512WithRSAEncryption':
          return ut.md.sha512.create()
        case 'RSASSA-PSS':
          return ut.md.sha256.create()
        default:
          var e = new Error('Could not compute ' + t.type + ' digest. Unknown signature OID.')
          throw ((e.signatureOid = t.signatureOid), e)
      }
    },
    vZ = function (t) {
      var e = t.certificate,
        r
      switch (e.signatureOid) {
        case nr.sha1WithRSAEncryption:
        case nr.sha1WithRSASignature:
          break
        case nr['RSASSA-PSS']:
          var n, i
          if (((n = nr[e.signatureParameters.mgf.hash.algorithmOid]), n === void 0 || ut.md[n] === void 0)) {
            var o = new Error('Unsupported MGF hash function.')
            throw ((o.oid = e.signatureParameters.mgf.hash.algorithmOid), (o.name = n), o)
          }
          if (((i = nr[e.signatureParameters.mgf.algorithmOid]), i === void 0 || ut.mgf[i] === void 0)) {
            var o = new Error('Unsupported MGF function.')
            throw ((o.oid = e.signatureParameters.mgf.algorithmOid), (o.name = i), o)
          }
          if (
            ((i = ut.mgf[i].create(ut.md[n].create())),
            (n = nr[e.signatureParameters.hash.algorithmOid]),
            n === void 0 || ut.md[n] === void 0)
          ) {
            var o = new Error('Unsupported RSASSA-PSS hash function.')
            throw ((o.oid = e.signatureParameters.hash.algorithmOid), (o.name = n), o)
          }
          r = ut.pss.create(ut.md[n].create(), i, e.signatureParameters.saltLength)
          break
      }
      return e.publicKey.verify(t.md.digest().getBytes(), t.signature, r)
    }
  Fe.certificateFromPem = function (t, e, r) {
    var n = ut.pem.decode(t)[0]
    if (n.type !== 'CERTIFICATE' && n.type !== 'X509 CERTIFICATE' && n.type !== 'TRUSTED CERTIFICATE') {
      var i = new Error(
        'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
      )
      throw ((i.headerType = n.type), i)
    }
    if (n.procType && n.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert certificate from PEM; PEM is encrypted.')
    var o = w.fromDer(n.body, r)
    return Fe.certificateFromAsn1(o, e)
  }
  Fe.certificateToPem = function (t, e) {
    var r = { type: 'CERTIFICATE', body: w.toDer(Fe.certificateToAsn1(t)).getBytes() }
    return ut.pem.encode(r, { maxline: e })
  }
  Fe.publicKeyFromPem = function (t) {
    var e = ut.pem.decode(t)[0]
    if (e.type !== 'PUBLIC KEY' && e.type !== 'RSA PUBLIC KEY') {
      var r = new Error(
        'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".'
      )
      throw ((r.headerType = e.type), r)
    }
    if (e.procType && e.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert public key from PEM; PEM is encrypted.')
    var n = w.fromDer(e.body)
    return Fe.publicKeyFromAsn1(n)
  }
  Fe.publicKeyToPem = function (t, e) {
    var r = { type: 'PUBLIC KEY', body: w.toDer(Fe.publicKeyToAsn1(t)).getBytes() }
    return ut.pem.encode(r, { maxline: e })
  }
  Fe.publicKeyToRSAPublicKeyPem = function (t, e) {
    var r = { type: 'RSA PUBLIC KEY', body: w.toDer(Fe.publicKeyToRSAPublicKey(t)).getBytes() }
    return ut.pem.encode(r, { maxline: e })
  }
  Fe.getPublicKeyFingerprint = function (t, e) {
    e = e || {}
    var r = e.md || ut.md.sha1.create(),
      n = e.type || 'RSAPublicKey',
      i
    switch (n) {
      case 'RSAPublicKey':
        i = w.toDer(Fe.publicKeyToRSAPublicKey(t)).getBytes()
        break
      case 'SubjectPublicKeyInfo':
        i = w.toDer(Fe.publicKeyToAsn1(t)).getBytes()
        break
      default:
        throw new Error('Unknown fingerprint type "' + e.type + '".')
    }
    r.start(), r.update(i)
    var o = r.digest()
    if (e.encoding === 'hex') {
      var s = o.toHex()
      return e.delimiter ? s.match(/.{2}/g).join(e.delimiter) : s
    } else {
      if (e.encoding === 'binary') return o.getBytes()
      if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".')
    }
    return o
  }
  Fe.certificationRequestFromPem = function (t, e, r) {
    var n = ut.pem.decode(t)[0]
    if (n.type !== 'CERTIFICATE REQUEST') {
      var i = new Error(
        'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".'
      )
      throw ((i.headerType = n.type), i)
    }
    if (n.procType && n.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert certification request from PEM; PEM is encrypted.')
    var o = w.fromDer(n.body, r)
    return Fe.certificationRequestFromAsn1(o, e)
  }
  Fe.certificationRequestToPem = function (t, e) {
    var r = { type: 'CERTIFICATE REQUEST', body: w.toDer(Fe.certificationRequestToAsn1(t)).getBytes() }
    return ut.pem.encode(r, { maxline: e })
  }
  Fe.createCertificate = function () {
    var t = {}
    return (
      (t.version = 2),
      (t.serialNumber = '00'),
      (t.signatureOid = null),
      (t.signature = null),
      (t.siginfo = {}),
      (t.siginfo.algorithmOid = null),
      (t.validity = {}),
      (t.validity.notBefore = new Date()),
      (t.validity.notAfter = new Date()),
      (t.issuer = {}),
      (t.issuer.getField = function (e) {
        return wf(t.issuer, e)
      }),
      (t.issuer.addField = function (e) {
        qa([e]), t.issuer.attributes.push(e)
      }),
      (t.issuer.attributes = []),
      (t.issuer.hash = null),
      (t.subject = {}),
      (t.subject.getField = function (e) {
        return wf(t.subject, e)
      }),
      (t.subject.addField = function (e) {
        qa([e]), t.subject.attributes.push(e)
      }),
      (t.subject.attributes = []),
      (t.subject.hash = null),
      (t.extensions = []),
      (t.publicKey = null),
      (t.md = null),
      (t.setSubject = function (e, r) {
        qa(e),
          (t.subject.attributes = e),
          delete t.subject.uniqueId,
          r && (t.subject.uniqueId = r),
          (t.subject.hash = null)
      }),
      (t.setIssuer = function (e, r) {
        qa(e), (t.issuer.attributes = e), delete t.issuer.uniqueId, r && (t.issuer.uniqueId = r), (t.issuer.hash = null)
      }),
      (t.setExtensions = function (e) {
        for (var r = 0; r < e.length; ++r) _Z(e[r], { cert: t })
        t.extensions = e
      }),
      (t.getExtension = function (e) {
        typeof e == 'string' && (e = { name: e })
        for (var r = null, n, i = 0; r === null && i < t.extensions.length; ++i)
          (n = t.extensions[i]), ((e.id && n.id === e.id) || (e.name && n.name === e.name)) && (r = n)
        return r
      }),
      (t.sign = function (e, r) {
        t.md = r || ut.md.sha1.create()
        var n = nr[t.md.algorithm + 'WithRSAEncryption']
        if (!n) {
          var i = new Error('Could not compute certificate digest. Unknown message digest algorithm OID.')
          throw ((i.algorithm = t.md.algorithm), i)
        }
        ;(t.signatureOid = t.siginfo.algorithmOid = n), (t.tbsCertificate = Fe.getTBSCertificate(t))
        var o = w.toDer(t.tbsCertificate)
        t.md.update(o.getBytes()), (t.signature = e.sign(t.md))
      }),
      (t.verify = function (e) {
        var r = !1
        if (!t.issued(e)) {
          var n = e.issuer,
            i = t.subject,
            o = new Error(
              "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
            )
          throw ((o.expectedIssuer = i.attributes), (o.actualIssuer = n.attributes), o)
        }
        var s = e.md
        if (s === null) {
          s = DA({ signatureOid: e.signatureOid, type: 'certificate' })
          var a = e.tbsCertificate || Fe.getTBSCertificate(e),
            l = w.toDer(a)
          s.update(l.getBytes())
        }
        return s !== null && (r = vZ({ certificate: t, md: s, signature: e.signature })), r
      }),
      (t.isIssuer = function (e) {
        var r = !1,
          n = t.issuer,
          i = e.subject
        if (n.hash && i.hash) r = n.hash === i.hash
        else if (n.attributes.length === i.attributes.length) {
          r = !0
          for (var o, s, a = 0; r && a < n.attributes.length; ++a)
            (o = n.attributes[a]), (s = i.attributes[a]), (o.type !== s.type || o.value !== s.value) && (r = !1)
        }
        return r
      }),
      (t.issued = function (e) {
        return e.isIssuer(t)
      }),
      (t.generateSubjectKeyIdentifier = function () {
        return Fe.getPublicKeyFingerprint(t.publicKey, { type: 'RSAPublicKey' })
      }),
      (t.verifySubjectKeyIdentifier = function () {
        for (var e = nr.subjectKeyIdentifier, r = 0; r < t.extensions.length; ++r) {
          var n = t.extensions[r]
          if (n.id === e) {
            var i = t.generateSubjectKeyIdentifier().getBytes()
            return ut.util.hexToBytes(n.subjectKeyIdentifier) === i
          }
        }
        return !1
      }),
      t
    )
  }
  Fe.certificateFromAsn1 = function (t, e) {
    var r = {},
      n = []
    if (!w.validate(t, nNe, r, n)) {
      var i = new Error('Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.')
      throw ((i.errors = n), i)
    }
    var o = w.derToOid(r.publicKeyOid)
    if (o !== Fe.oids.rsaEncryption) throw new Error('Cannot read public key. OID is not RSA.')
    var s = Fe.createCertificate()
    s.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0
    var a = ut.util.createBuffer(r.certSerialNumber)
    ;(s.serialNumber = a.toHex()),
      (s.signatureOid = ut.asn1.derToOid(r.certSignatureOid)),
      (s.signatureParameters = RA(s.signatureOid, r.certSignatureParams, !0)),
      (s.siginfo.algorithmOid = ut.asn1.derToOid(r.certinfoSignatureOid)),
      (s.siginfo.parameters = RA(s.siginfo.algorithmOid, r.certinfoSignatureParams, !1)),
      (s.signature = r.certSignature)
    var l = []
    if (
      (r.certValidity1UTCTime !== void 0 && l.push(w.utcTimeToDate(r.certValidity1UTCTime)),
      r.certValidity2GeneralizedTime !== void 0 && l.push(w.generalizedTimeToDate(r.certValidity2GeneralizedTime)),
      r.certValidity3UTCTime !== void 0 && l.push(w.utcTimeToDate(r.certValidity3UTCTime)),
      r.certValidity4GeneralizedTime !== void 0 && l.push(w.generalizedTimeToDate(r.certValidity4GeneralizedTime)),
      l.length > 2)
    )
      throw new Error(
        'Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.'
      )
    if (l.length < 2)
      throw new Error(
        'Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.'
      )
    if (((s.validity.notBefore = l[0]), (s.validity.notAfter = l[1]), (s.tbsCertificate = r.tbsCertificate), e)) {
      s.md = DA({ signatureOid: s.signatureOid, type: 'certificate' })
      var c = w.toDer(s.tbsCertificate)
      s.md.update(c.getBytes())
    }
    var u = ut.md.sha1.create(),
      p = w.toDer(r.certIssuer)
    u.update(p.getBytes()),
      (s.issuer.getField = function (m) {
        return wf(s.issuer, m)
      }),
      (s.issuer.addField = function (m) {
        qa([m]), s.issuer.attributes.push(m)
      }),
      (s.issuer.attributes = Fe.RDNAttributesAsArray(r.certIssuer)),
      r.certIssuerUniqueId && (s.issuer.uniqueId = r.certIssuerUniqueId),
      (s.issuer.hash = u.digest().toHex())
    var d = ut.md.sha1.create(),
      f = w.toDer(r.certSubject)
    return (
      d.update(f.getBytes()),
      (s.subject.getField = function (m) {
        return wf(s.subject, m)
      }),
      (s.subject.addField = function (m) {
        qa([m]), s.subject.attributes.push(m)
      }),
      (s.subject.attributes = Fe.RDNAttributesAsArray(r.certSubject)),
      r.certSubjectUniqueId && (s.subject.uniqueId = r.certSubjectUniqueId),
      (s.subject.hash = d.digest().toHex()),
      r.certExtensions ? (s.extensions = Fe.certificateExtensionsFromAsn1(r.certExtensions)) : (s.extensions = []),
      (s.publicKey = Fe.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
      s
    )
  }
  Fe.certificateExtensionsFromAsn1 = function (t) {
    for (var e = [], r = 0; r < t.value.length; ++r)
      for (var n = t.value[r], i = 0; i < n.value.length; ++i) e.push(Fe.certificateExtensionFromAsn1(n.value[i]))
    return e
  }
  Fe.certificateExtensionFromAsn1 = function (t) {
    var e = {}
    if (
      ((e.id = w.derToOid(t.value[0].value)),
      (e.critical = !1),
      t.value[1].type === w.Type.BOOLEAN
        ? ((e.critical = t.value[1].value.charCodeAt(0) !== 0), (e.value = t.value[2].value))
        : (e.value = t.value[1].value),
      e.id in nr)
    ) {
      if (((e.name = nr[e.id]), e.name === 'keyUsage')) {
        var r = w.fromDer(e.value),
          n = 0,
          i = 0
        r.value.length > 1 && ((n = r.value.charCodeAt(1)), (i = r.value.length > 2 ? r.value.charCodeAt(2) : 0)),
          (e.digitalSignature = (n & 128) === 128),
          (e.nonRepudiation = (n & 64) === 64),
          (e.keyEncipherment = (n & 32) === 32),
          (e.dataEncipherment = (n & 16) === 16),
          (e.keyAgreement = (n & 8) === 8),
          (e.keyCertSign = (n & 4) === 4),
          (e.cRLSign = (n & 2) === 2),
          (e.encipherOnly = (n & 1) === 1),
          (e.decipherOnly = (i & 128) === 128)
      } else if (e.name === 'basicConstraints') {
        var r = w.fromDer(e.value)
        r.value.length > 0 && r.value[0].type === w.Type.BOOLEAN
          ? (e.cA = r.value[0].value.charCodeAt(0) !== 0)
          : (e.cA = !1)
        var o = null
        r.value.length > 0 && r.value[0].type === w.Type.INTEGER
          ? (o = r.value[0].value)
          : r.value.length > 1 && (o = r.value[1].value),
          o !== null && (e.pathLenConstraint = w.derToInteger(o))
      } else if (e.name === 'extKeyUsage')
        for (var r = w.fromDer(e.value), s = 0; s < r.value.length; ++s) {
          var a = w.derToOid(r.value[s].value)
          a in nr ? (e[nr[a]] = !0) : (e[a] = !0)
        }
      else if (e.name === 'nsCertType') {
        var r = w.fromDer(e.value),
          n = 0
        r.value.length > 1 && (n = r.value.charCodeAt(1)),
          (e.client = (n & 128) === 128),
          (e.server = (n & 64) === 64),
          (e.email = (n & 32) === 32),
          (e.objsign = (n & 16) === 16),
          (e.reserved = (n & 8) === 8),
          (e.sslCA = (n & 4) === 4),
          (e.emailCA = (n & 2) === 2),
          (e.objCA = (n & 1) === 1)
      } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {
        e.altNames = []
        for (var l, r = w.fromDer(e.value), c = 0; c < r.value.length; ++c) {
          l = r.value[c]
          var u = { type: l.type, value: l.value }
          switch ((e.altNames.push(u), l.type)) {
            case 1:
            case 2:
            case 6:
              break
            case 7:
              u.ip = ut.util.bytesToIP(l.value)
              break
            case 8:
              u.oid = w.derToOid(l.value)
              break
            default:
          }
        }
      } else if (e.name === 'subjectKeyIdentifier') {
        var r = w.fromDer(e.value)
        e.subjectKeyIdentifier = ut.util.bytesToHex(r.value)
      }
    }
    return e
  }
  Fe.certificationRequestFromAsn1 = function (t, e) {
    var r = {},
      n = []
    if (!w.validate(t, sNe, r, n)) {
      var i = new Error('Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.')
      throw ((i.errors = n), i)
    }
    var o = w.derToOid(r.publicKeyOid)
    if (o !== Fe.oids.rsaEncryption) throw new Error('Cannot read public key. OID is not RSA.')
    var s = Fe.createCertificationRequest()
    if (
      ((s.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0),
      (s.signatureOid = ut.asn1.derToOid(r.csrSignatureOid)),
      (s.signatureParameters = RA(s.signatureOid, r.csrSignatureParams, !0)),
      (s.siginfo.algorithmOid = ut.asn1.derToOid(r.csrSignatureOid)),
      (s.siginfo.parameters = RA(s.siginfo.algorithmOid, r.csrSignatureParams, !1)),
      (s.signature = r.csrSignature),
      (s.certificationRequestInfo = r.certificationRequestInfo),
      e)
    ) {
      s.md = DA({ signatureOid: s.signatureOid, type: 'certification request' })
      var a = w.toDer(s.certificationRequestInfo)
      s.md.update(a.getBytes())
    }
    var l = ut.md.sha1.create()
    return (
      (s.subject.getField = function (c) {
        return wf(s.subject, c)
      }),
      (s.subject.addField = function (c) {
        qa([c]), s.subject.attributes.push(c)
      }),
      (s.subject.attributes = Fe.RDNAttributesAsArray(r.certificationRequestInfoSubject, l)),
      (s.subject.hash = l.digest().toHex()),
      (s.publicKey = Fe.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
      (s.getAttribute = function (c) {
        return wf(s, c)
      }),
      (s.addAttribute = function (c) {
        qa([c]), s.attributes.push(c)
      }),
      (s.attributes = Fe.CRIAttributesAsArray(r.certificationRequestInfoAttributes || [])),
      s
    )
  }
  Fe.createCertificationRequest = function () {
    var t = {}
    return (
      (t.version = 0),
      (t.signatureOid = null),
      (t.signature = null),
      (t.siginfo = {}),
      (t.siginfo.algorithmOid = null),
      (t.subject = {}),
      (t.subject.getField = function (e) {
        return wf(t.subject, e)
      }),
      (t.subject.addField = function (e) {
        qa([e]), t.subject.attributes.push(e)
      }),
      (t.subject.attributes = []),
      (t.subject.hash = null),
      (t.publicKey = null),
      (t.attributes = []),
      (t.getAttribute = function (e) {
        return wf(t, e)
      }),
      (t.addAttribute = function (e) {
        qa([e]), t.attributes.push(e)
      }),
      (t.md = null),
      (t.setSubject = function (e) {
        qa(e), (t.subject.attributes = e), (t.subject.hash = null)
      }),
      (t.setAttributes = function (e) {
        qa(e), (t.attributes = e)
      }),
      (t.sign = function (e, r) {
        t.md = r || ut.md.sha1.create()
        var n = nr[t.md.algorithm + 'WithRSAEncryption']
        if (!n) {
          var i = new Error('Could not compute certification request digest. Unknown message digest algorithm OID.')
          throw ((i.algorithm = t.md.algorithm), i)
        }
        ;(t.signatureOid = t.siginfo.algorithmOid = n), (t.certificationRequestInfo = Fe.getCertificationRequestInfo(t))
        var o = w.toDer(t.certificationRequestInfo)
        t.md.update(o.getBytes()), (t.signature = e.sign(t.md))
      }),
      (t.verify = function () {
        var e = !1,
          r = t.md
        if (r === null) {
          r = DA({ signatureOid: t.signatureOid, type: 'certification request' })
          var n = t.certificationRequestInfo || Fe.getCertificationRequestInfo(t),
            i = w.toDer(n)
          r.update(i.getBytes())
        }
        return r !== null && (e = vZ({ certificate: t, md: r, signature: t.signature })), e
      }),
      t
    )
  }
  function E_(t) {
    for (
      var e = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, []), r, n, i = t.attributes, o = 0;
      o < i.length;
      ++o
    ) {
      r = i[o]
      var s = r.value,
        a = w.Type.PRINTABLESTRING
      'valueTagClass' in r && ((a = r.valueTagClass), a === w.Type.UTF8 && (s = ut.util.encodeUtf8(s))),
        (n = w.create(w.Class.UNIVERSAL, w.Type.SET, !0, [
          w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
            w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(r.type).getBytes()),
            w.create(w.Class.UNIVERSAL, a, !1, s),
          ]),
        ])),
        e.value.push(n)
    }
    return e
  }
  function qa(t) {
    for (var e, r = 0; r < t.length; ++r) {
      if (
        ((e = t[r]),
        typeof e.name > 'u' &&
          (e.type && e.type in Fe.oids
            ? (e.name = Fe.oids[e.type])
            : e.shortName && e.shortName in kn && (e.name = Fe.oids[kn[e.shortName]])),
        typeof e.type > 'u')
      )
        if (e.name && e.name in Fe.oids) e.type = Fe.oids[e.name]
        else {
          var n = new Error('Attribute type not specified.')
          throw ((n.attribute = e), n)
        }
      if (
        (typeof e.shortName > 'u' && e.name && e.name in kn && (e.shortName = kn[e.name]),
        e.type === nr.extensionRequest &&
          ((e.valueConstructed = !0), (e.valueTagClass = w.Type.SEQUENCE), !e.value && e.extensions))
      ) {
        e.value = []
        for (var i = 0; i < e.extensions.length; ++i) e.value.push(Fe.certificateExtensionToAsn1(_Z(e.extensions[i])))
      }
      if (typeof e.value > 'u') {
        var n = new Error('Attribute value not specified.')
        throw ((n.attribute = e), n)
      }
    }
  }
  function _Z(t, e) {
    if (((e = e || {}), typeof t.name > 'u' && t.id && t.id in Fe.oids && (t.name = Fe.oids[t.id]), typeof t.id > 'u'))
      if (t.name && t.name in Fe.oids) t.id = Fe.oids[t.name]
      else {
        var r = new Error('Extension ID not specified.')
        throw ((r.extension = t), r)
      }
    if (typeof t.value < 'u') return t
    if (t.name === 'keyUsage') {
      var n = 0,
        i = 0,
        o = 0
      t.digitalSignature && ((i |= 128), (n = 7)),
        t.nonRepudiation && ((i |= 64), (n = 6)),
        t.keyEncipherment && ((i |= 32), (n = 5)),
        t.dataEncipherment && ((i |= 16), (n = 4)),
        t.keyAgreement && ((i |= 8), (n = 3)),
        t.keyCertSign && ((i |= 4), (n = 2)),
        t.cRLSign && ((i |= 2), (n = 1)),
        t.encipherOnly && ((i |= 1), (n = 0)),
        t.decipherOnly && ((o |= 128), (n = 7))
      var s = String.fromCharCode(n)
      o !== 0 ? (s += String.fromCharCode(i) + String.fromCharCode(o)) : i !== 0 && (s += String.fromCharCode(i)),
        (t.value = w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, s))
    } else if (t.name === 'basicConstraints')
      (t.value = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])),
        t.cA && t.value.value.push(w.create(w.Class.UNIVERSAL, w.Type.BOOLEAN, !1, String.fromCharCode(255))),
        'pathLenConstraint' in t &&
          t.value.value.push(
            w.create(w.Class.UNIVERSAL, w.Type.INTEGER, !1, w.integerToDer(t.pathLenConstraint).getBytes())
          )
    else if (t.name === 'extKeyUsage') {
      t.value = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
      var a = t.value.value
      for (var l in t)
        t[l] === !0 &&
          (l in nr
            ? a.push(w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(nr[l]).getBytes()))
            : l.indexOf('.') !== -1 && a.push(w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(l).getBytes())))
    } else if (t.name === 'nsCertType') {
      var n = 0,
        i = 0
      t.client && ((i |= 128), (n = 7)),
        t.server && ((i |= 64), (n = 6)),
        t.email && ((i |= 32), (n = 5)),
        t.objsign && ((i |= 16), (n = 4)),
        t.reserved && ((i |= 8), (n = 3)),
        t.sslCA && ((i |= 4), (n = 2)),
        t.emailCA && ((i |= 2), (n = 1)),
        t.objCA && ((i |= 1), (n = 0))
      var s = String.fromCharCode(n)
      i !== 0 && (s += String.fromCharCode(i)), (t.value = w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, s))
    } else if (t.name === 'subjectAltName' || t.name === 'issuerAltName') {
      t.value = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
      for (var c, u = 0; u < t.altNames.length; ++u) {
        c = t.altNames[u]
        var s = c.value
        if (c.type === 7 && c.ip) {
          if (((s = ut.util.bytesFromIP(c.ip)), s === null)) {
            var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
            throw ((r.extension = t), r)
          }
        } else c.type === 8 && (c.oid ? (s = w.oidToDer(w.oidToDer(c.oid))) : (s = w.oidToDer(s)))
        t.value.value.push(w.create(w.Class.CONTEXT_SPECIFIC, c.type, !1, s))
      }
    } else if (t.name === 'nsComment' && e.cert) {
      if (!/^[\x00-\x7F]*$/.test(t.comment) || t.comment.length < 1 || t.comment.length > 128)
        throw new Error('Invalid "nsComment" content.')
      t.value = w.create(w.Class.UNIVERSAL, w.Type.IA5STRING, !1, t.comment)
    } else if (t.name === 'subjectKeyIdentifier' && e.cert) {
      var p = e.cert.generateSubjectKeyIdentifier()
      ;(t.subjectKeyIdentifier = p.toHex()),
        (t.value = w.create(w.Class.UNIVERSAL, w.Type.OCTETSTRING, !1, p.getBytes()))
    } else if (t.name === 'authorityKeyIdentifier' && e.cert) {
      t.value = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
      var a = t.value.value
      if (t.keyIdentifier) {
        var d = t.keyIdentifier === !0 ? e.cert.generateSubjectKeyIdentifier().getBytes() : t.keyIdentifier
        a.push(w.create(w.Class.CONTEXT_SPECIFIC, 0, !1, d))
      }
      if (t.authorityCertIssuer) {
        var f = [
          w.create(w.Class.CONTEXT_SPECIFIC, 4, !0, [
            E_(t.authorityCertIssuer === !0 ? e.cert.issuer : t.authorityCertIssuer),
          ]),
        ]
        a.push(w.create(w.Class.CONTEXT_SPECIFIC, 1, !0, f))
      }
      if (t.serialNumber) {
        var m = ut.util.hexToBytes(t.serialNumber === !0 ? e.cert.serialNumber : t.serialNumber)
        a.push(w.create(w.Class.CONTEXT_SPECIFIC, 2, !1, m))
      }
    } else if (t.name === 'cRLDistributionPoints') {
      t.value = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
      for (
        var a = t.value.value,
          h = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, []),
          g = w.create(w.Class.CONTEXT_SPECIFIC, 0, !0, []),
          c,
          u = 0;
        u < t.altNames.length;
        ++u
      ) {
        c = t.altNames[u]
        var s = c.value
        if (c.type === 7 && c.ip) {
          if (((s = ut.util.bytesFromIP(c.ip)), s === null)) {
            var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
            throw ((r.extension = t), r)
          }
        } else c.type === 8 && (c.oid ? (s = w.oidToDer(w.oidToDer(c.oid))) : (s = w.oidToDer(s)))
        g.value.push(w.create(w.Class.CONTEXT_SPECIFIC, c.type, !1, s))
      }
      h.value.push(w.create(w.Class.CONTEXT_SPECIFIC, 0, !0, [g])), a.push(h)
    }
    if (typeof t.value > 'u') {
      var r = new Error('Extension value not specified.')
      throw ((r.extension = t), r)
    }
    return t
  }
  function eM(t, e) {
    switch (t) {
      case nr['RSASSA-PSS']:
        var r = []
        return (
          e.hash.algorithmOid !== void 0 &&
            r.push(
              w.create(w.Class.CONTEXT_SPECIFIC, 0, !0, [
                w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
                  w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(e.hash.algorithmOid).getBytes()),
                  w.create(w.Class.UNIVERSAL, w.Type.NULL, !1, ''),
                ]),
              ])
            ),
          e.mgf.algorithmOid !== void 0 &&
            r.push(
              w.create(w.Class.CONTEXT_SPECIFIC, 1, !0, [
                w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
                  w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(e.mgf.algorithmOid).getBytes()),
                  w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
                    w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(e.mgf.hash.algorithmOid).getBytes()),
                    w.create(w.Class.UNIVERSAL, w.Type.NULL, !1, ''),
                  ]),
                ]),
              ])
            ),
          e.saltLength !== void 0 &&
            r.push(
              w.create(w.Class.CONTEXT_SPECIFIC, 2, !0, [
                w.create(w.Class.UNIVERSAL, w.Type.INTEGER, !1, w.integerToDer(e.saltLength).getBytes()),
              ])
            ),
          w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, r)
        )
      default:
        return w.create(w.Class.UNIVERSAL, w.Type.NULL, !1, '')
    }
  }
  function aNe(t) {
    var e = w.create(w.Class.CONTEXT_SPECIFIC, 0, !0, [])
    if (t.attributes.length === 0) return e
    for (var r = t.attributes, n = 0; n < r.length; ++n) {
      var i = r[n],
        o = i.value,
        s = w.Type.UTF8
      'valueTagClass' in i && (s = i.valueTagClass), s === w.Type.UTF8 && (o = ut.util.encodeUtf8(o))
      var a = !1
      'valueConstructed' in i && (a = i.valueConstructed)
      var l = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
        w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(i.type).getBytes()),
        w.create(w.Class.UNIVERSAL, w.Type.SET, !0, [w.create(w.Class.UNIVERSAL, s, a, o)]),
      ])
      e.value.push(l)
    }
    return e
  }
  var cNe = new Date('1950-01-01T00:00:00Z'),
    lNe = new Date('2050-01-01T00:00:00Z')
  function hZ(t) {
    return t >= cNe && t < lNe
      ? w.create(w.Class.UNIVERSAL, w.Type.UTCTIME, !1, w.dateToUtcTime(t))
      : w.create(w.Class.UNIVERSAL, w.Type.GENERALIZEDTIME, !1, w.dateToGeneralizedTime(t))
  }
  Fe.getTBSCertificate = function (t) {
    var e = hZ(t.validity.notBefore),
      r = hZ(t.validity.notAfter),
      n = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
        w.create(w.Class.CONTEXT_SPECIFIC, 0, !0, [
          w.create(w.Class.UNIVERSAL, w.Type.INTEGER, !1, w.integerToDer(t.version).getBytes()),
        ]),
        w.create(w.Class.UNIVERSAL, w.Type.INTEGER, !1, ut.util.hexToBytes(t.serialNumber)),
        w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
          w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(t.siginfo.algorithmOid).getBytes()),
          eM(t.siginfo.algorithmOid, t.siginfo.parameters),
        ]),
        E_(t.issuer),
        w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [e, r]),
        E_(t.subject),
        Fe.publicKeyToAsn1(t.publicKey),
      ])
    return (
      t.issuer.uniqueId &&
        n.value.push(
          w.create(w.Class.CONTEXT_SPECIFIC, 1, !0, [
            w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, String.fromCharCode(0) + t.issuer.uniqueId),
          ])
        ),
      t.subject.uniqueId &&
        n.value.push(
          w.create(w.Class.CONTEXT_SPECIFIC, 2, !0, [
            w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, String.fromCharCode(0) + t.subject.uniqueId),
          ])
        ),
      t.extensions.length > 0 && n.value.push(Fe.certificateExtensionsToAsn1(t.extensions)),
      n
    )
  }
  Fe.getCertificationRequestInfo = function (t) {
    var e = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
      w.create(w.Class.UNIVERSAL, w.Type.INTEGER, !1, w.integerToDer(t.version).getBytes()),
      E_(t.subject),
      Fe.publicKeyToAsn1(t.publicKey),
      aNe(t),
    ])
    return e
  }
  Fe.distinguishedNameToAsn1 = function (t) {
    return E_(t)
  }
  Fe.certificateToAsn1 = function (t) {
    var e = t.tbsCertificate || Fe.getTBSCertificate(t)
    return w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
      e,
      w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
        w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(t.signatureOid).getBytes()),
        eM(t.signatureOid, t.signatureParameters),
      ]),
      w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, String.fromCharCode(0) + t.signature),
    ])
  }
  Fe.certificateExtensionsToAsn1 = function (t) {
    var e = w.create(w.Class.CONTEXT_SPECIFIC, 3, !0, []),
      r = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
    e.value.push(r)
    for (var n = 0; n < t.length; ++n) r.value.push(Fe.certificateExtensionToAsn1(t[n]))
    return e
  }
  Fe.certificateExtensionToAsn1 = function (t) {
    var e = w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [])
    e.value.push(w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(t.id).getBytes())),
      t.critical && e.value.push(w.create(w.Class.UNIVERSAL, w.Type.BOOLEAN, !1, String.fromCharCode(255)))
    var r = t.value
    return (
      typeof t.value != 'string' && (r = w.toDer(r).getBytes()),
      e.value.push(w.create(w.Class.UNIVERSAL, w.Type.OCTETSTRING, !1, r)),
      e
    )
  }
  Fe.certificationRequestToAsn1 = function (t) {
    var e = t.certificationRequestInfo || Fe.getCertificationRequestInfo(t)
    return w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
      e,
      w.create(w.Class.UNIVERSAL, w.Type.SEQUENCE, !0, [
        w.create(w.Class.UNIVERSAL, w.Type.OID, !1, w.oidToDer(t.signatureOid).getBytes()),
        eM(t.signatureOid, t.signatureParameters),
      ]),
      w.create(w.Class.UNIVERSAL, w.Type.BITSTRING, !1, String.fromCharCode(0) + t.signature),
    ])
  }
  Fe.createCaStore = function (t) {
    var e = { certs: {} }
    ;(e.getIssuer = function (s) {
      var a = r(s.issuer)
      return a
    }),
      (e.addCertificate = function (s) {
        if ((typeof s == 'string' && (s = ut.pki.certificateFromPem(s)), n(s.subject), !e.hasCertificate(s)))
          if (s.subject.hash in e.certs) {
            var a = e.certs[s.subject.hash]
            ut.util.isArray(a) || (a = [a]), a.push(s), (e.certs[s.subject.hash] = a)
          } else e.certs[s.subject.hash] = s
      }),
      (e.hasCertificate = function (s) {
        typeof s == 'string' && (s = ut.pki.certificateFromPem(s))
        var a = r(s.subject)
        if (!a) return !1
        ut.util.isArray(a) || (a = [a])
        for (var l = w.toDer(Fe.certificateToAsn1(s)).getBytes(), c = 0; c < a.length; ++c) {
          var u = w.toDer(Fe.certificateToAsn1(a[c])).getBytes()
          if (l === u) return !0
        }
        return !1
      }),
      (e.listAllCertificates = function () {
        var s = []
        for (var a in e.certs)
          if (e.certs.hasOwnProperty(a)) {
            var l = e.certs[a]
            if (!ut.util.isArray(l)) s.push(l)
            else for (var c = 0; c < l.length; ++c) s.push(l[c])
          }
        return s
      }),
      (e.removeCertificate = function (s) {
        var a
        if ((typeof s == 'string' && (s = ut.pki.certificateFromPem(s)), n(s.subject), !e.hasCertificate(s)))
          return null
        var l = r(s.subject)
        if (!ut.util.isArray(l)) return (a = e.certs[s.subject.hash]), delete e.certs[s.subject.hash], a
        for (var c = w.toDer(Fe.certificateToAsn1(s)).getBytes(), u = 0; u < l.length; ++u) {
          var p = w.toDer(Fe.certificateToAsn1(l[u])).getBytes()
          c === p && ((a = l[u]), l.splice(u, 1))
        }
        return l.length === 0 && delete e.certs[s.subject.hash], a
      })
    function r(s) {
      return n(s), e.certs[s.hash] || null
    }
    function n(s) {
      if (!s.hash) {
        var a = ut.md.sha1.create()
        ;(s.attributes = Fe.RDNAttributesAsArray(E_(s), a)), (s.hash = a.digest().toHex())
      }
    }
    if (t)
      for (var i = 0; i < t.length; ++i) {
        var o = t[i]
        e.addCertificate(o)
      }
    return e
  }
  Fe.certificateError = {
    bad_certificate: 'forge.pki.BadCertificate',
    unsupported_certificate: 'forge.pki.UnsupportedCertificate',
    certificate_revoked: 'forge.pki.CertificateRevoked',
    certificate_expired: 'forge.pki.CertificateExpired',
    certificate_unknown: 'forge.pki.CertificateUnknown',
    unknown_ca: 'forge.pki.UnknownCertificateAuthority',
  }
  Fe.verifyCertificateChain = function (t, e, r) {
    typeof r == 'function' && (r = { verify: r }), (r = r || {}), (e = e.slice(0))
    var n = e.slice(0),
      i = r.validityCheckDate
    typeof i > 'u' && (i = new Date())
    var o = !0,
      s = null,
      a = 0
    do {
      var l = e.shift(),
        c = null,
        u = !1
      if (
        (i &&
          (i < l.validity.notBefore || i > l.validity.notAfter) &&
          (s = {
            message: 'Certificate is not valid yet or has expired.',
            error: Fe.certificateError.certificate_expired,
            notBefore: l.validity.notBefore,
            notAfter: l.validity.notAfter,
            now: i,
          }),
        s === null)
      ) {
        if (((c = e[0] || t.getIssuer(l)), c === null && l.isIssuer(l) && ((u = !0), (c = l)), c)) {
          var p = c
          ut.util.isArray(p) || (p = [p])
          for (var d = !1; !d && p.length > 0; ) {
            c = p.shift()
            try {
              d = c.verify(l)
            } catch {}
          }
          d || (s = { message: 'Certificate signature is invalid.', error: Fe.certificateError.bad_certificate })
        }
        s === null &&
          (!c || u) &&
          !t.hasCertificate(l) &&
          (s = { message: 'Certificate is not trusted.', error: Fe.certificateError.unknown_ca })
      }
      if (
        (s === null &&
          c &&
          !l.isIssuer(c) &&
          (s = { message: 'Certificate issuer is invalid.', error: Fe.certificateError.bad_certificate }),
        s === null)
      )
        for (var f = { keyUsage: !0, basicConstraints: !0 }, m = 0; s === null && m < l.extensions.length; ++m) {
          var h = l.extensions[m]
          h.critical &&
            !(h.name in f) &&
            (s = {
              message: 'Certificate has an unsupported critical extension.',
              error: Fe.certificateError.unsupported_certificate,
            })
        }
      if (s === null && (!o || (e.length === 0 && (!c || u)))) {
        var g = l.getExtension('basicConstraints'),
          v = l.getExtension('keyUsage')
        if (
          (v !== null &&
            (!v.keyCertSign || g === null) &&
            (s = {
              message:
                "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: Fe.certificateError.bad_certificate,
            }),
          s === null &&
            g !== null &&
            !g.cA &&
            (s = {
              message: 'Certificate basicConstraints indicates the certificate is not a CA.',
              error: Fe.certificateError.bad_certificate,
            }),
          s === null && v !== null && 'pathLenConstraint' in g)
        ) {
          var _ = a - 1
          _ > g.pathLenConstraint &&
            (s = {
              message: 'Certificate basicConstraints pathLenConstraint violated.',
              error: Fe.certificateError.bad_certificate,
            })
        }
      }
      var y = s === null ? !0 : s.error,
        b = r.verify ? r.verify(y, a, n) : y
      if (b === !0) s = null
      else
        throw (
          (y === !0 &&
            (s = { message: 'The application rejected the certificate.', error: Fe.certificateError.bad_certificate }),
          (b || b === 0) &&
            (typeof b == 'object' && !ut.util.isArray(b)
              ? (b.message && (s.message = b.message), b.error && (s.error = b.error))
              : typeof b == 'string' && (s.error = b)),
          s)
        )
      ;(o = !1), ++a
    } while (e.length > 0)
    return !0
  }
})
var rM = handleExports((ogt, bZ) => {
  var jr = Mt()
  Lc()
  h_()
  Sf()
  J8()
  X8()
  Fa()
  $b()
  y_()
  cr()
  PA()
  var $ = jr.asn1,
    Vt = jr.pki,
    Kb = (bZ.exports = jr.pkcs12 = jr.pkcs12 || {}),
    xZ = {
      name: 'ContentInfo',
      tagClass: $.Class.UNIVERSAL,
      type: $.Type.SEQUENCE,
      constructed: !0,
      value: [
        {
          name: 'ContentInfo.contentType',
          tagClass: $.Class.UNIVERSAL,
          type: $.Type.OID,
          constructed: !1,
          capture: 'contentType',
        },
        { name: 'ContentInfo.content', tagClass: $.Class.CONTEXT_SPECIFIC, constructed: !0, captureAsn1: 'content' },
      ],
    },
    uNe = {
      name: 'PFX',
      tagClass: $.Class.UNIVERSAL,
      type: $.Type.SEQUENCE,
      constructed: !0,
      value: [
        { name: 'PFX.version', tagClass: $.Class.UNIVERSAL, type: $.Type.INTEGER, constructed: !1, capture: 'version' },
        xZ,
        {
          name: 'PFX.macData',
          tagClass: $.Class.UNIVERSAL,
          type: $.Type.SEQUENCE,
          constructed: !0,
          optional: !0,
          captureAsn1: 'mac',
          value: [
            {
              name: 'PFX.macData.mac',
              tagClass: $.Class.UNIVERSAL,
              type: $.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'PFX.macData.mac.digestAlgorithm',
                  tagClass: $.Class.UNIVERSAL,
                  type: $.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'PFX.macData.mac.digestAlgorithm.algorithm',
                      tagClass: $.Class.UNIVERSAL,
                      type: $.Type.OID,
                      constructed: !1,
                      capture: 'macAlgorithm',
                    },
                    {
                      name: 'PFX.macData.mac.digestAlgorithm.parameters',
                      tagClass: $.Class.UNIVERSAL,
                      captureAsn1: 'macAlgorithmParameters',
                    },
                  ],
                },
                {
                  name: 'PFX.macData.mac.digest',
                  tagClass: $.Class.UNIVERSAL,
                  type: $.Type.OCTETSTRING,
                  constructed: !1,
                  capture: 'macDigest',
                },
              ],
            },
            {
              name: 'PFX.macData.macSalt',
              tagClass: $.Class.UNIVERSAL,
              type: $.Type.OCTETSTRING,
              constructed: !1,
              capture: 'macSalt',
            },
            {
              name: 'PFX.macData.iterations',
              tagClass: $.Class.UNIVERSAL,
              type: $.Type.INTEGER,
              constructed: !1,
              optional: !0,
              capture: 'macIterations',
            },
          ],
        },
      ],
    },
    pNe = {
      name: 'SafeBag',
      tagClass: $.Class.UNIVERSAL,
      type: $.Type.SEQUENCE,
      constructed: !0,
      value: [
        { name: 'SafeBag.bagId', tagClass: $.Class.UNIVERSAL, type: $.Type.OID, constructed: !1, capture: 'bagId' },
        { name: 'SafeBag.bagValue', tagClass: $.Class.CONTEXT_SPECIFIC, constructed: !0, captureAsn1: 'bagValue' },
        {
          name: 'SafeBag.bagAttributes',
          tagClass: $.Class.UNIVERSAL,
          type: $.Type.SET,
          constructed: !0,
          optional: !0,
          capture: 'bagAttributes',
        },
      ],
    },
    dNe = {
      name: 'Attribute',
      tagClass: $.Class.UNIVERSAL,
      type: $.Type.SEQUENCE,
      constructed: !0,
      value: [
        { name: 'Attribute.attrId', tagClass: $.Class.UNIVERSAL, type: $.Type.OID, constructed: !1, capture: 'oid' },
        {
          name: 'Attribute.attrValues',
          tagClass: $.Class.UNIVERSAL,
          type: $.Type.SET,
          constructed: !0,
          capture: 'values',
        },
      ],
    },
    fNe = {
      name: 'CertBag',
      tagClass: $.Class.UNIVERSAL,
      type: $.Type.SEQUENCE,
      constructed: !0,
      value: [
        { name: 'CertBag.certId', tagClass: $.Class.UNIVERSAL, type: $.Type.OID, constructed: !1, capture: 'certId' },
        {
          name: 'CertBag.certValue',
          tagClass: $.Class.CONTEXT_SPECIFIC,
          constructed: !0,
          value: [
            {
              name: 'CertBag.certValue[0]',
              tagClass: $.Class.UNIVERSAL,
              type: $.Class.OCTETSTRING,
              constructed: !1,
              capture: 'cert',
            },
          ],
        },
      ],
    }
  function Wb(t, e, r, n) {
    for (var i = [], o = 0; o < t.length; o++)
      for (var s = 0; s < t[o].safeBags.length; s++) {
        var a = t[o].safeBags[s]
        if (!(n !== void 0 && a.type !== n)) {
          if (e === null) {
            i.push(a)
            continue
          }
          a.attributes[e] !== void 0 && a.attributes[e].indexOf(r) >= 0 && i.push(a)
        }
      }
    return i
  }
  Kb.pkcs12FromAsn1 = function (t, e, r) {
    typeof e == 'string' ? ((r = e), (e = !0)) : e === void 0 && (e = !0)
    var n = {},
      i = []
    if (!$.validate(t, uNe, n, i)) {
      var o = new Error('Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.')
      throw ((o.errors = o), o)
    }
    var s = {
      version: n.version.charCodeAt(0),
      safeContents: [],
      getBags: function (g) {
        var v = {},
          _
        return (
          'localKeyId' in g ? (_ = g.localKeyId) : 'localKeyIdHex' in g && (_ = jr.util.hexToBytes(g.localKeyIdHex)),
          _ === void 0 &&
            !('friendlyName' in g) &&
            'bagType' in g &&
            (v[g.bagType] = Wb(s.safeContents, null, null, g.bagType)),
          _ !== void 0 && (v.localKeyId = Wb(s.safeContents, 'localKeyId', _, g.bagType)),
          'friendlyName' in g && (v.friendlyName = Wb(s.safeContents, 'friendlyName', g.friendlyName, g.bagType)),
          v
        )
      },
      getBagsByFriendlyName: function (g, v) {
        return Wb(s.safeContents, 'friendlyName', g, v)
      },
      getBagsByLocalKeyId: function (g, v) {
        return Wb(s.safeContents, 'localKeyId', g, v)
      },
    }
    if (n.version.charCodeAt(0) !== 3) {
      var o = new Error('PKCS#12 PFX of version other than 3 not supported.')
      throw ((o.version = n.version.charCodeAt(0)), o)
    }
    if ($.derToOid(n.contentType) !== Vt.oids.data) {
      var o = new Error('Only PKCS#12 PFX in password integrity mode supported.')
      throw ((o.oid = $.derToOid(n.contentType)), o)
    }
    var a = n.content.value[0]
    if (a.tagClass !== $.Class.UNIVERSAL || a.type !== $.Type.OCTETSTRING)
      throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.')
    if (((a = tM(a)), n.mac)) {
      var l = null,
        c = 0,
        u = $.derToOid(n.macAlgorithm)
      switch (u) {
        case Vt.oids.sha1:
          ;(l = jr.md.sha1.create()), (c = 20)
          break
        case Vt.oids.sha256:
          ;(l = jr.md.sha256.create()), (c = 32)
          break
        case Vt.oids.sha384:
          ;(l = jr.md.sha384.create()), (c = 48)
          break
        case Vt.oids.sha512:
          ;(l = jr.md.sha512.create()), (c = 64)
          break
        case Vt.oids.md5:
          ;(l = jr.md.md5.create()), (c = 16)
          break
      }
      if (l === null) throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + u)
      var p = new jr.util.ByteBuffer(n.macSalt),
        d = 'macIterations' in n ? parseInt(jr.util.bytesToHex(n.macIterations), 16) : 1,
        f = Kb.generateKey(r, p, 3, d, c, l),
        m = jr.hmac.create()
      m.start(l, f), m.update(a.value)
      var h = m.getMac()
      if (h.getBytes() !== n.macDigest) throw new Error('PKCS#12 MAC could not be verified. Invalid password?')
    }
    return mNe(s, a.value, e, r), s
  }
  function tM(t) {
    if (t.composed || t.constructed) {
      for (var e = jr.util.createBuffer(), r = 0; r < t.value.length; ++r) e.putBytes(t.value[r].value)
      ;(t.composed = t.constructed = !1), (t.value = e.getBytes())
    }
    return t
  }
  function mNe(t, e, r, n) {
    if (((e = $.fromDer(e, r)), e.tagClass !== $.Class.UNIVERSAL || e.type !== $.Type.SEQUENCE || e.constructed !== !0))
      throw new Error('PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo')
    for (var i = 0; i < e.value.length; i++) {
      var o = e.value[i],
        s = {},
        a = []
      if (!$.validate(o, xZ, s, a)) {
        var l = new Error('Cannot read ContentInfo.')
        throw ((l.errors = a), l)
      }
      var c = { encrypted: !1 },
        u = null,
        p = s.content.value[0]
      switch ($.derToOid(s.contentType)) {
        case Vt.oids.data:
          if (p.tagClass !== $.Class.UNIVERSAL || p.type !== $.Type.OCTETSTRING)
            throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.')
          u = tM(p).value
          break
        case Vt.oids.encryptedData:
          ;(u = hNe(p, n)), (c.encrypted = !0)
          break
        default:
          var l = new Error('Unsupported PKCS#12 contentType.')
          throw ((l.contentType = $.derToOid(s.contentType)), l)
      }
      ;(c.safeBags = gNe(u, r, n)), t.safeContents.push(c)
    }
  }
  function hNe(t, e) {
    var r = {},
      n = []
    if (!$.validate(t, jr.pkcs7.asn1.encryptedDataValidator, r, n)) {
      var i = new Error('Cannot read EncryptedContentInfo.')
      throw ((i.errors = n), i)
    }
    var o = $.derToOid(r.contentType)
    if (o !== Vt.oids.data) {
      var i = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.')
      throw ((i.oid = o), i)
    }
    o = $.derToOid(r.encAlgorithm)
    var s = Vt.pbe.getCipher(o, r.encParameter, e),
      a = tM(r.encryptedContentAsn1),
      l = jr.util.createBuffer(a.value)
    if ((s.update(l), !s.finish())) throw new Error('Failed to decrypt PKCS#12 SafeContents.')
    return s.output.getBytes()
  }
  function gNe(t, e, r) {
    if (!e && t.length === 0) return []
    if (((t = $.fromDer(t, e)), t.tagClass !== $.Class.UNIVERSAL || t.type !== $.Type.SEQUENCE || t.constructed !== !0))
      throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.')
    for (var n = [], i = 0; i < t.value.length; i++) {
      var o = t.value[i],
        s = {},
        a = []
      if (!$.validate(o, pNe, s, a)) {
        var l = new Error('Cannot read SafeBag.')
        throw ((l.errors = a), l)
      }
      var c = { type: $.derToOid(s.bagId), attributes: vNe(s.bagAttributes) }
      n.push(c)
      var u,
        p,
        d = s.bagValue.value[0]
      switch (c.type) {
        case Vt.oids.pkcs8ShroudedKeyBag:
          if (((d = Vt.decryptPrivateKeyInfo(d, r)), d === null))
            throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?')
        case Vt.oids.keyBag:
          try {
            c.key = Vt.privateKeyFromAsn1(d)
          } catch {
            ;(c.key = null), (c.asn1 = d)
          }
          continue
        case Vt.oids.certBag:
          ;(u = fNe),
            (p = function () {
              if ($.derToOid(s.certId) !== Vt.oids.x509Certificate) {
                var m = new Error('Unsupported certificate type, only X.509 supported.')
                throw ((m.oid = $.derToOid(s.certId)), m)
              }
              var h = $.fromDer(s.cert, e)
              try {
                c.cert = Vt.certificateFromAsn1(h, !0)
              } catch {
                ;(c.cert = null), (c.asn1 = h)
              }
            })
          break
        default:
          var l = new Error('Unsupported PKCS#12 SafeBag type.')
          throw ((l.oid = c.type), l)
      }
      if (u !== void 0 && !$.validate(d, u, s, a)) {
        var l = new Error('Cannot read PKCS#12 ' + u.name)
        throw ((l.errors = a), l)
      }
      p()
    }
    return n
  }
  function vNe(t) {
    var e = {}
    if (t !== void 0)
      for (var r = 0; r < t.length; ++r) {
        var n = {},
          i = []
        if (!$.validate(t[r], dNe, n, i)) {
          var o = new Error('Cannot read PKCS#12 BagAttribute.')
          throw ((o.errors = i), o)
        }
        var s = $.derToOid(n.oid)
        if (Vt.oids[s] !== void 0) {
          e[Vt.oids[s]] = []
          for (var a = 0; a < n.values.length; ++a) e[Vt.oids[s]].push(n.values[a].value)
        }
      }
    return e
  }
  Kb.toPkcs12Asn1 = function (t, e, r, n) {
    ;(n = n || {}),
      (n.saltSize = n.saltSize || 8),
      (n.count = n.count || 2048),
      (n.algorithm = n.algorithm || n.encAlgorithm || 'aes128'),
      'useMac' in n || (n.useMac = !0),
      'localKeyId' in n || (n.localKeyId = null),
      'generateLocalKeyId' in n || (n.generateLocalKeyId = !0)
    var i = n.localKeyId,
      o
    if (i !== null) i = jr.util.hexToBytes(i)
    else if (n.generateLocalKeyId)
      if (e) {
        var s = jr.util.isArray(e) ? e[0] : e
        typeof s == 'string' && (s = Vt.certificateFromPem(s))
        var a = jr.md.sha1.create()
        a.update($.toDer(Vt.certificateToAsn1(s)).getBytes()), (i = a.digest().getBytes())
      } else i = jr.random.getBytes(20)
    var l = []
    i !== null &&
      l.push(
        $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
          $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.localKeyId).getBytes()),
          $.create($.Class.UNIVERSAL, $.Type.SET, !0, [$.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, i)]),
        ])
      ),
      'friendlyName' in n &&
        l.push(
          $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.friendlyName).getBytes()),
            $.create($.Class.UNIVERSAL, $.Type.SET, !0, [
              $.create($.Class.UNIVERSAL, $.Type.BMPSTRING, !1, n.friendlyName),
            ]),
          ])
        ),
      l.length > 0 && (o = $.create($.Class.UNIVERSAL, $.Type.SET, !0, l))
    var c = [],
      u = []
    e !== null && (jr.util.isArray(e) ? (u = e) : (u = [e]))
    for (var p = [], d = 0; d < u.length; ++d) {
      ;(e = u[d]), typeof e == 'string' && (e = Vt.certificateFromPem(e))
      var f = d === 0 ? o : void 0,
        m = Vt.certificateToAsn1(e),
        h = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
          $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.certBag).getBytes()),
          $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [
            $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
              $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.x509Certificate).getBytes()),
              $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [
                $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, $.toDer(m).getBytes()),
              ]),
            ]),
          ]),
          f,
        ])
      p.push(h)
    }
    if (p.length > 0) {
      var g = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, p),
        v = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
          $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.data).getBytes()),
          $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, $.toDer(g).getBytes()),
          ]),
        ])
      c.push(v)
    }
    var _ = null
    if (t !== null) {
      var y = Vt.wrapRsaPrivateKey(Vt.privateKeyToAsn1(t))
      r === null
        ? (_ = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.keyBag).getBytes()),
            $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [y]),
            o,
          ]))
        : (_ = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.pkcs8ShroudedKeyBag).getBytes()),
            $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [Vt.encryptPrivateKeyInfo(y, r, n)]),
            o,
          ]))
      var b = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [_]),
        x = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
          $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.data).getBytes()),
          $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, $.toDer(b).getBytes()),
          ]),
        ])
      c.push(x)
    }
    var P = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, c),
      U
    if (n.useMac) {
      var a = jr.md.sha1.create(),
        H = new jr.util.ByteBuffer(jr.random.getBytes(n.saltSize)),
        j = n.count,
        t = Kb.generateKey(r, H, 3, j, 20),
        M = jr.hmac.create()
      M.start(a, t), M.update($.toDer(P).getBytes())
      var F = M.getMac()
      U = $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
        $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
          $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
            $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.sha1).getBytes()),
            $.create($.Class.UNIVERSAL, $.Type.NULL, !1, ''),
          ]),
          $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, F.getBytes()),
        ]),
        $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, H.getBytes()),
        $.create($.Class.UNIVERSAL, $.Type.INTEGER, !1, $.integerToDer(j).getBytes()),
      ])
    }
    return $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
      $.create($.Class.UNIVERSAL, $.Type.INTEGER, !1, $.integerToDer(3).getBytes()),
      $.create($.Class.UNIVERSAL, $.Type.SEQUENCE, !0, [
        $.create($.Class.UNIVERSAL, $.Type.OID, !1, $.oidToDer(Vt.oids.data).getBytes()),
        $.create($.Class.CONTEXT_SPECIFIC, 0, !0, [
          $.create($.Class.UNIVERSAL, $.Type.OCTETSTRING, !1, $.toDer(P).getBytes()),
        ]),
      ]),
      U,
    ])
  }
  Kb.generateKey = jr.pbe.generatePkcs12Key
})
var iM = handleExports((sgt, EZ) => {
  var Af = Mt()
  Lc()
  Sf()
  X8()
  pg()
  bA()
  rM()
  AA()
  $b()
  cr()
  PA()
  var nM = Af.asn1,
    T_ = (EZ.exports = Af.pki = Af.pki || {})
  T_.pemToDer = function (t) {
    var e = Af.pem.decode(t)[0]
    if (e.procType && e.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert PEM to DER; PEM is encrypted.')
    return Af.util.createBuffer(e.body)
  }
  T_.privateKeyFromPem = function (t) {
    var e = Af.pem.decode(t)[0]
    if (e.type !== 'PRIVATE KEY' && e.type !== 'RSA PRIVATE KEY') {
      var r = new Error(
        'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".'
      )
      throw ((r.headerType = e.type), r)
    }
    if (e.procType && e.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert private key from PEM; PEM is encrypted.')
    var n = nM.fromDer(e.body)
    return T_.privateKeyFromAsn1(n)
  }
  T_.privateKeyToPem = function (t, e) {
    var r = { type: 'RSA PRIVATE KEY', body: nM.toDer(T_.privateKeyToAsn1(t)).getBytes() }
    return Af.pem.encode(r, { maxline: e })
  }
  T_.privateKeyInfoToPem = function (t, e) {
    var r = { type: 'PRIVATE KEY', body: nM.toDer(t).getBytes() }
    return Af.pem.encode(r, { maxline: e })
  }
})
var uM = handleExports((agt, DZ) => {
  var Ce = Mt()
  Lc()
  h_()
  vA()
  pg()
  iM()
  Fa()
  y_()
  cr()
  var LA = function (t, e, r, n) {
      var i = Ce.util.createBuffer(),
        o = t.length >> 1,
        s = o + (t.length & 1),
        a = t.substr(0, s),
        l = t.substr(o, s),
        c = Ce.util.createBuffer(),
        u = Ce.hmac.create()
      r = e + r
      var p = Math.ceil(n / 16),
        d = Math.ceil(n / 20)
      u.start('MD5', a)
      var f = Ce.util.createBuffer()
      c.putBytes(r)
      for (var m = 0; m < p; ++m)
        u.start(null, null),
          u.update(c.getBytes()),
          c.putBuffer(u.digest()),
          u.start(null, null),
          u.update(c.bytes() + r),
          f.putBuffer(u.digest())
      u.start('SHA1', l)
      var h = Ce.util.createBuffer()
      c.clear(), c.putBytes(r)
      for (var m = 0; m < d; ++m)
        u.start(null, null),
          u.update(c.getBytes()),
          c.putBuffer(u.digest()),
          u.start(null, null),
          u.update(c.bytes() + r),
          h.putBuffer(u.digest())
      return i.putBytes(Ce.util.xorBytes(f.getBytes(), h.getBytes(), n)), i
    },
    _Ne = function (t, e, r) {
      var n = Ce.hmac.create()
      n.start('SHA1', t)
      var i = Ce.util.createBuffer()
      return (
        i.putInt32(e[0]),
        i.putInt32(e[1]),
        i.putByte(r.type),
        i.putByte(r.version.major),
        i.putByte(r.version.minor),
        i.putInt16(r.length),
        i.putBytes(r.fragment.bytes()),
        n.update(i.getBytes()),
        n.digest().getBytes()
      )
    },
    yNe = function (t, e, r) {
      var n = !1
      try {
        var i = t.deflate(e.fragment.getBytes())
        ;(e.fragment = Ce.util.createBuffer(i)), (e.length = i.length), (n = !0)
      } catch {}
      return n
    },
    xNe = function (t, e, r) {
      var n = !1
      try {
        var i = t.inflate(e.fragment.getBytes())
        ;(e.fragment = Ce.util.createBuffer(i)), (e.length = i.length), (n = !0)
      } catch {}
      return n
    },
    la = function (t, e) {
      var r = 0
      switch (e) {
        case 1:
          r = t.getByte()
          break
        case 2:
          r = t.getInt16()
          break
        case 3:
          r = t.getInt24()
          break
        case 4:
          r = t.getInt32()
          break
      }
      return Ce.util.createBuffer(t.getBytes(r))
    },
    Ha = function (t, e, r) {
      t.putInt(r.length(), e << 3), t.putBuffer(r)
    },
    D = {}
  D.Versions = { TLS_1_0: { major: 3, minor: 1 }, TLS_1_1: { major: 3, minor: 2 }, TLS_1_2: { major: 3, minor: 3 } }
  D.SupportedVersions = [D.Versions.TLS_1_1, D.Versions.TLS_1_0]
  D.Version = D.SupportedVersions[0]
  D.MaxFragment = 16384 - 1024
  D.ConnectionEnd = { server: 0, client: 1 }
  D.PRFAlgorithm = { tls_prf_sha256: 0 }
  D.BulkCipherAlgorithm = { none: null, rc4: 0, des3: 1, aes: 2 }
  D.CipherType = { stream: 0, block: 1, aead: 2 }
  D.MACAlgorithm = { none: null, hmac_md5: 0, hmac_sha1: 1, hmac_sha256: 2, hmac_sha384: 3, hmac_sha512: 4 }
  D.CompressionMethod = { none: 0, deflate: 1 }
  D.ContentType = { change_cipher_spec: 20, alert: 21, handshake: 22, application_data: 23, heartbeat: 24 }
  D.HandshakeType = {
    hello_request: 0,
    client_hello: 1,
    server_hello: 2,
    certificate: 11,
    server_key_exchange: 12,
    certificate_request: 13,
    server_hello_done: 14,
    certificate_verify: 15,
    client_key_exchange: 16,
    finished: 20,
  }
  D.Alert = {}
  D.Alert.Level = { warning: 1, fatal: 2 }
  D.Alert.Description = {
    close_notify: 0,
    unexpected_message: 10,
    bad_record_mac: 20,
    decryption_failed: 21,
    record_overflow: 22,
    decompression_failure: 30,
    handshake_failure: 40,
    bad_certificate: 42,
    unsupported_certificate: 43,
    certificate_revoked: 44,
    certificate_expired: 45,
    certificate_unknown: 46,
    illegal_parameter: 47,
    unknown_ca: 48,
    access_denied: 49,
    decode_error: 50,
    decrypt_error: 51,
    export_restriction: 60,
    protocol_version: 70,
    insufficient_security: 71,
    internal_error: 80,
    user_canceled: 90,
    no_renegotiation: 100,
  }
  D.HeartbeatMessageType = { heartbeat_request: 1, heartbeat_response: 2 }
  D.CipherSuites = {}
  D.getCipherSuite = function (t) {
    var e = null
    for (var r in D.CipherSuites) {
      var n = D.CipherSuites[r]
      if (n.id[0] === t.charCodeAt(0) && n.id[1] === t.charCodeAt(1)) {
        e = n
        break
      }
    }
    return e
  }
  D.handleUnexpected = function (t, e) {
    var r = !t.open && t.entity === D.ConnectionEnd.client
    r ||
      t.error(t, {
        message: 'Unexpected message. Received TLS record out of order.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.unexpected_message },
      })
  }
  D.handleHelloRequest = function (t, e, r) {
    !t.handshaking &&
      t.handshakes > 0 &&
      (D.queue(
        t,
        D.createAlert(t, { level: D.Alert.Level.warning, description: D.Alert.Description.no_renegotiation })
      ),
      D.flush(t)),
      t.process()
  }
  D.parseHelloMessage = function (t, e, r) {
    var n = null,
      i = t.entity === D.ConnectionEnd.client
    if (r < 38)
      t.error(t, {
        message: i
          ? 'Invalid ServerHello message. Message too short.'
          : 'Invalid ClientHello message. Message too short.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
      })
    else {
      var o = e.fragment,
        s = o.length()
      if (
        ((n = {
          version: { major: o.getByte(), minor: o.getByte() },
          random: Ce.util.createBuffer(o.getBytes(32)),
          session_id: la(o, 1),
          extensions: [],
        }),
        i
          ? ((n.cipher_suite = o.getBytes(2)), (n.compression_method = o.getByte()))
          : ((n.cipher_suites = la(o, 2)), (n.compression_methods = la(o, 1))),
        (s = r - (s - o.length())),
        s > 0)
      ) {
        for (var a = la(o, 2); a.length() > 0; ) n.extensions.push({ type: [a.getByte(), a.getByte()], data: la(a, 2) })
        if (!i)
          for (var l = 0; l < n.extensions.length; ++l) {
            var c = n.extensions[l]
            if (c.type[0] === 0 && c.type[1] === 0)
              for (var u = la(c.data, 2); u.length() > 0; ) {
                var p = u.getByte()
                if (p !== 0) break
                t.session.extensions.server_name.serverNameList.push(la(u, 2).getBytes())
              }
          }
      }
      if (
        t.session.version &&
        (n.version.major !== t.session.version.major || n.version.minor !== t.session.version.minor)
      )
        return t.error(t, {
          message: 'TLS version change is disallowed during renegotiation.',
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.protocol_version },
        })
      if (i) t.session.cipherSuite = D.getCipherSuite(n.cipher_suite)
      else
        for (
          var d = Ce.util.createBuffer(n.cipher_suites.bytes());
          d.length() > 0 && ((t.session.cipherSuite = D.getCipherSuite(d.getBytes(2))), t.session.cipherSuite === null);

        );
      if (t.session.cipherSuite === null)
        return t.error(t, {
          message: 'No cipher suites in common.',
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.handshake_failure },
          cipherSuite: Ce.util.bytesToHex(n.cipher_suite),
        })
      i
        ? (t.session.compressionMethod = n.compression_method)
        : (t.session.compressionMethod = D.CompressionMethod.none)
    }
    return n
  }
  D.createSecurityParameters = function (t, e) {
    var r = t.entity === D.ConnectionEnd.client,
      n = e.random.bytes(),
      i = r ? t.session.sp.client_random : n,
      o = r ? n : D.createRandom().getBytes()
    t.session.sp = {
      entity: t.entity,
      prf_algorithm: D.PRFAlgorithm.tls_prf_sha256,
      bulk_cipher_algorithm: null,
      cipher_type: null,
      enc_key_length: null,
      block_length: null,
      fixed_iv_length: null,
      record_iv_length: null,
      mac_algorithm: null,
      mac_length: null,
      mac_key_length: null,
      compression_algorithm: t.session.compressionMethod,
      pre_master_secret: null,
      master_secret: null,
      client_random: i,
      server_random: o,
    }
  }
  D.handleServerHello = function (t, e, r) {
    var n = D.parseHelloMessage(t, e, r)
    if (!t.fail) {
      if (n.version.minor <= t.version.minor) t.version.minor = n.version.minor
      else
        return t.error(t, {
          message: 'Incompatible TLS version.',
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.protocol_version },
        })
      t.session.version = t.version
      var i = n.session_id.bytes()
      i.length > 0 && i === t.session.id
        ? ((t.expect = CZ), (t.session.resuming = !0), (t.session.sp.server_random = n.random.bytes()))
        : ((t.expect = ENe), (t.session.resuming = !1), D.createSecurityParameters(t, n)),
        (t.session.id = i),
        t.process()
    }
  }
  D.handleClientHello = function (t, e, r) {
    var n = D.parseHelloMessage(t, e, r)
    if (!t.fail) {
      var i = n.session_id.bytes(),
        o = null
      if (
        (t.sessionCache &&
          ((o = t.sessionCache.getSession(i)),
          o === null
            ? (i = '')
            : (o.version.major !== n.version.major || o.version.minor > n.version.minor) && ((o = null), (i = ''))),
        i.length === 0 && (i = Ce.random.getBytes(32)),
        (t.session.id = i),
        (t.session.clientHelloVersion = n.version),
        (t.session.sp = {}),
        o)
      )
        (t.version = t.session.version = o.version), (t.session.sp = o.sp)
      else {
        for (
          var s, a = 1;
          a < D.SupportedVersions.length && ((s = D.SupportedVersions[a]), !(s.minor <= n.version.minor));
          ++a
        );
        ;(t.version = { major: s.major, minor: s.minor }), (t.session.version = t.version)
      }
      o !== null
        ? ((t.expect = cM), (t.session.resuming = !0), (t.session.sp.client_random = n.random.bytes()))
        : ((t.expect = t.verifyClient !== !1 ? RNe : aM), (t.session.resuming = !1), D.createSecurityParameters(t, n)),
        (t.open = !0),
        D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createServerHello(t) })),
        t.session.resuming
          ? (D.queue(
              t,
              D.createRecord(t, { type: D.ContentType.change_cipher_spec, data: D.createChangeCipherSpec() })
            ),
            (t.state.pending = D.createConnectionState(t)),
            (t.state.current.write = t.state.pending.write),
            D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createFinished(t) })))
          : (D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createCertificate(t) })),
            t.fail ||
              (D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createServerKeyExchange(t) })),
              t.verifyClient !== !1 &&
                D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createCertificateRequest(t) })),
              D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createServerHelloDone(t) })))),
        D.flush(t),
        t.process()
    }
  }
  D.handleCertificate = function (t, e, r) {
    if (r < 3)
      return t.error(t, {
        message: 'Invalid Certificate message. Message too short.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
      })
    var n = e.fragment,
      i = { certificate_list: la(n, 3) },
      o,
      s,
      a = []
    try {
      for (; i.certificate_list.length() > 0; )
        (o = la(i.certificate_list, 3)), (s = Ce.asn1.fromDer(o)), (o = Ce.pki.certificateFromAsn1(s, !0)), a.push(o)
    } catch (c) {
      return t.error(t, {
        message: 'Could not parse certificate list.',
        cause: c,
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.bad_certificate },
      })
    }
    var l = t.entity === D.ConnectionEnd.client
    ;(l || t.verifyClient === !0) && a.length === 0
      ? t.error(t, {
          message: l ? 'No server certificate provided.' : 'No client certificate provided.',
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
        })
      : a.length === 0
      ? (t.expect = l ? TZ : aM)
      : (l ? (t.session.serverCertificate = a[0]) : (t.session.clientCertificate = a[0]),
        D.verifyCertificateChain(t, a) && (t.expect = l ? TZ : aM)),
      t.process()
  }
  D.handleServerKeyExchange = function (t, e, r) {
    if (r > 0)
      return t.error(t, {
        message: 'Invalid key parameters. Only RSA is supported.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.unsupported_certificate },
      })
    ;(t.expect = TNe), t.process()
  }
  D.handleClientKeyExchange = function (t, e, r) {
    if (r < 48)
      return t.error(t, {
        message: 'Invalid key parameters. Only RSA is supported.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.unsupported_certificate },
      })
    var n = e.fragment,
      i = { enc_pre_master_secret: la(n, 2).getBytes() },
      o = null
    if (t.getPrivateKey)
      try {
        ;(o = t.getPrivateKey(t, t.session.serverCertificate)), (o = Ce.pki.privateKeyFromPem(o))
      } catch (l) {
        t.error(t, {
          message: 'Could not get private key.',
          cause: l,
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
        })
      }
    if (o === null)
      return t.error(t, {
        message: 'No private key set.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
      })
    try {
      var s = t.session.sp
      s.pre_master_secret = o.decrypt(i.enc_pre_master_secret)
      var a = t.session.clientHelloVersion
      if (a.major !== s.pre_master_secret.charCodeAt(0) || a.minor !== s.pre_master_secret.charCodeAt(1))
        throw new Error('TLS version rollback attack detected.')
    } catch {
      s.pre_master_secret = Ce.random.getBytes(48)
    }
    ;(t.expect = cM), t.session.clientCertificate !== null && (t.expect = DNe), t.process()
  }
  D.handleCertificateRequest = function (t, e, r) {
    if (r < 3)
      return t.error(t, {
        message: 'Invalid CertificateRequest. Message too short.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
      })
    var n = e.fragment,
      i = { certificate_types: la(n, 1), certificate_authorities: la(n, 2) }
    ;(t.session.certificateRequest = i), (t.expect = SNe), t.process()
  }
  D.handleCertificateVerify = function (t, e, r) {
    if (r < 2)
      return t.error(t, {
        message: 'Invalid CertificateVerify. Message too short.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
      })
    var n = e.fragment
    n.read -= 4
    var i = n.bytes()
    n.read += 4
    var o = { signature: la(n, 2).getBytes() },
      s = Ce.util.createBuffer()
    s.putBuffer(t.session.md5.digest()), s.putBuffer(t.session.sha1.digest()), (s = s.getBytes())
    try {
      var a = t.session.clientCertificate
      if (!a.publicKey.verify(s, o.signature, 'NONE')) throw new Error('CertificateVerify signature does not match.')
      t.session.md5.update(i), t.session.sha1.update(i)
    } catch {
      return t.error(t, {
        message: 'Bad signature in CertificateVerify.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.handshake_failure },
      })
    }
    ;(t.expect = cM), t.process()
  }
  D.handleServerHelloDone = function (t, e, r) {
    if (r > 0)
      return t.error(t, {
        message: 'Invalid ServerHelloDone message. Invalid length.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.record_overflow },
      })
    if (t.serverCertificate === null) {
      var n = {
          message: 'No server certificate provided. Not enough security.',
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.insufficient_security },
        },
        i = 0,
        o = t.verify(t, n.alert.description, i, [])
      if (o !== !0)
        return (
          (o || o === 0) &&
            (typeof o == 'object' && !Ce.util.isArray(o)
              ? (o.message && (n.message = o.message), o.alert && (n.alert.description = o.alert))
              : typeof o == 'number' && (n.alert.description = o)),
          t.error(t, n)
        )
    }
    t.session.certificateRequest !== null &&
      ((e = D.createRecord(t, { type: D.ContentType.handshake, data: D.createCertificate(t) })), D.queue(t, e)),
      (e = D.createRecord(t, { type: D.ContentType.handshake, data: D.createClientKeyExchange(t) })),
      D.queue(t, e),
      (t.expect = wNe)
    var s = function (a, l) {
      a.session.certificateRequest !== null &&
        a.session.clientCertificate !== null &&
        D.queue(a, D.createRecord(a, { type: D.ContentType.handshake, data: D.createCertificateVerify(a, l) })),
        D.queue(a, D.createRecord(a, { type: D.ContentType.change_cipher_spec, data: D.createChangeCipherSpec() })),
        (a.state.pending = D.createConnectionState(a)),
        (a.state.current.write = a.state.pending.write),
        D.queue(a, D.createRecord(a, { type: D.ContentType.handshake, data: D.createFinished(a) })),
        (a.expect = CZ),
        D.flush(a),
        a.process()
    }
    if (t.session.certificateRequest === null || t.session.clientCertificate === null) return s(t, null)
    D.getClientSignature(t, s)
  }
  D.handleChangeCipherSpec = function (t, e) {
    if (e.fragment.getByte() !== 1)
      return t.error(t, {
        message: 'Invalid ChangeCipherSpec message received.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.illegal_parameter },
      })
    var r = t.entity === D.ConnectionEnd.client
    ;((t.session.resuming && r) || (!t.session.resuming && !r)) && (t.state.pending = D.createConnectionState(t)),
      (t.state.current.read = t.state.pending.read),
      ((!t.session.resuming && r) || (t.session.resuming && !r)) && (t.state.pending = null),
      (t.expect = r ? CNe : PNe),
      t.process()
  }
  D.handleFinished = function (t, e, r) {
    var n = e.fragment
    n.read -= 4
    var i = n.bytes()
    n.read += 4
    var o = e.fragment.getBytes()
    ;(n = Ce.util.createBuffer()), n.putBuffer(t.session.md5.digest()), n.putBuffer(t.session.sha1.digest())
    var s = t.entity === D.ConnectionEnd.client,
      a = s ? 'server finished' : 'client finished',
      l = t.session.sp,
      c = 12,
      u = LA
    if (((n = u(l.master_secret, a, n.getBytes(), c)), n.getBytes() !== o))
      return t.error(t, {
        message: 'Invalid verify_data in Finished message.',
        send: !0,
        alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.decrypt_error },
      })
    t.session.md5.update(i),
      t.session.sha1.update(i),
      ((t.session.resuming && s) || (!t.session.resuming && !s)) &&
        (D.queue(t, D.createRecord(t, { type: D.ContentType.change_cipher_spec, data: D.createChangeCipherSpec() })),
        (t.state.current.write = t.state.pending.write),
        (t.state.pending = null),
        D.queue(t, D.createRecord(t, { type: D.ContentType.handshake, data: D.createFinished(t) }))),
      (t.expect = s ? INe : NNe),
      (t.handshaking = !1),
      ++t.handshakes,
      (t.peerCertificate = s ? t.session.serverCertificate : t.session.clientCertificate),
      D.flush(t),
      (t.isConnected = !0),
      t.connected(t),
      t.process()
  }
  D.handleAlert = function (t, e) {
    var r = e.fragment,
      n = { level: r.getByte(), description: r.getByte() },
      i
    switch (n.description) {
      case D.Alert.Description.close_notify:
        i = 'Connection closed.'
        break
      case D.Alert.Description.unexpected_message:
        i = 'Unexpected message.'
        break
      case D.Alert.Description.bad_record_mac:
        i = 'Bad record MAC.'
        break
      case D.Alert.Description.decryption_failed:
        i = 'Decryption failed.'
        break
      case D.Alert.Description.record_overflow:
        i = 'Record overflow.'
        break
      case D.Alert.Description.decompression_failure:
        i = 'Decompression failed.'
        break
      case D.Alert.Description.handshake_failure:
        i = 'Handshake failure.'
        break
      case D.Alert.Description.bad_certificate:
        i = 'Bad certificate.'
        break
      case D.Alert.Description.unsupported_certificate:
        i = 'Unsupported certificate.'
        break
      case D.Alert.Description.certificate_revoked:
        i = 'Certificate revoked.'
        break
      case D.Alert.Description.certificate_expired:
        i = 'Certificate expired.'
        break
      case D.Alert.Description.certificate_unknown:
        i = 'Certificate unknown.'
        break
      case D.Alert.Description.illegal_parameter:
        i = 'Illegal parameter.'
        break
      case D.Alert.Description.unknown_ca:
        i = 'Unknown certificate authority.'
        break
      case D.Alert.Description.access_denied:
        i = 'Access denied.'
        break
      case D.Alert.Description.decode_error:
        i = 'Decode error.'
        break
      case D.Alert.Description.decrypt_error:
        i = 'Decrypt error.'
        break
      case D.Alert.Description.export_restriction:
        i = 'Export restriction.'
        break
      case D.Alert.Description.protocol_version:
        i = 'Unsupported protocol version.'
        break
      case D.Alert.Description.insufficient_security:
        i = 'Insufficient security.'
        break
      case D.Alert.Description.internal_error:
        i = 'Internal error.'
        break
      case D.Alert.Description.user_canceled:
        i = 'User canceled.'
        break
      case D.Alert.Description.no_renegotiation:
        i = 'Renegotiation not supported.'
        break
      default:
        i = 'Unknown error.'
        break
    }
    if (n.description === D.Alert.Description.close_notify) return t.close()
    t.error(t, { message: i, send: !1, origin: t.entity === D.ConnectionEnd.client ? 'server' : 'client', alert: n }),
      t.process()
  }
  D.handleHandshake = function (t, e) {
    var r = e.fragment,
      n = r.getByte(),
      i = r.getInt24()
    if (i > r.length()) return (t.fragmented = e), (e.fragment = Ce.util.createBuffer()), (r.read -= 4), t.process()
    ;(t.fragmented = null), (r.read -= 4)
    var o = r.bytes(i + 4)
    ;(r.read += 4),
      n in OA[t.entity][t.expect]
        ? (t.entity === D.ConnectionEnd.server &&
            !t.open &&
            !t.fail &&
            ((t.handshaking = !0),
            (t.session = {
              version: null,
              extensions: { server_name: { serverNameList: [] } },
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              clientCertificate: null,
              md5: Ce.md.md5.create(),
              sha1: Ce.md.sha1.create(),
            })),
          n !== D.HandshakeType.hello_request &&
            n !== D.HandshakeType.certificate_verify &&
            n !== D.HandshakeType.finished &&
            (t.session.md5.update(o), t.session.sha1.update(o)),
          OA[t.entity][t.expect][n](t, e, i))
        : D.handleUnexpected(t, e)
  }
  D.handleApplicationData = function (t, e) {
    t.data.putBuffer(e.fragment), t.dataReady(t), t.process()
  }
  D.handleHeartbeat = function (t, e) {
    var r = e.fragment,
      n = r.getByte(),
      i = r.getInt16(),
      o = r.getBytes(i)
    if (n === D.HeartbeatMessageType.heartbeat_request) {
      if (t.handshaking || i > o.length) return t.process()
      D.queue(
        t,
        D.createRecord(t, {
          type: D.ContentType.heartbeat,
          data: D.createHeartbeat(D.HeartbeatMessageType.heartbeat_response, o),
        })
      ),
        D.flush(t)
    } else if (n === D.HeartbeatMessageType.heartbeat_response) {
      if (o !== t.expectedHeartbeatPayload) return t.process()
      t.heartbeatReceived && t.heartbeatReceived(t, Ce.util.createBuffer(o))
    }
    t.process()
  }
  var bNe = 0,
    ENe = 1,
    TZ = 2,
    TNe = 3,
    SNe = 4,
    CZ = 5,
    CNe = 6,
    INe = 7,
    wNe = 8,
    ANe = 0,
    RNe = 1,
    aM = 2,
    DNe = 3,
    cM = 4,
    PNe = 5,
    NNe = 6,
    R = D.handleUnexpected,
    IZ = D.handleChangeCipherSpec,
    ro = D.handleAlert,
    Ko = D.handleHandshake,
    wZ = D.handleApplicationData,
    no = D.handleHeartbeat,
    lM = []
  lM[D.ConnectionEnd.client] = [
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [IZ, ro, R, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, wZ, no],
    [R, ro, Ko, R, no],
  ]
  lM[D.ConnectionEnd.server] = [
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, R, no],
    [IZ, ro, R, R, no],
    [R, ro, Ko, R, no],
    [R, ro, Ko, wZ, no],
    [R, ro, Ko, R, no],
  ]
  var Rf = D.handleHelloRequest,
    kNe = D.handleServerHello,
    AZ = D.handleCertificate,
    SZ = D.handleServerKeyExchange,
    oM = D.handleCertificateRequest,
    NA = D.handleServerHelloDone,
    RZ = D.handleFinished,
    OA = []
  OA[D.ConnectionEnd.client] = [
    [R, R, kNe, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, AZ, SZ, oM, NA, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, SZ, oM, NA, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, oM, NA, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, R, NA, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, RZ],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [Rf, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
  ]
  var ONe = D.handleClientHello,
    LNe = D.handleClientKeyExchange,
    MNe = D.handleCertificateVerify
  OA[D.ConnectionEnd.server] = [
    [R, ONe, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, AZ, R, R, R, R, R, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, LNe, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, MNe, R, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, RZ],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
    [R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R, R],
  ]
  D.generateKeys = function (t, e) {
    var r = LA,
      n = e.client_random + e.server_random
    t.session.resuming ||
      ((e.master_secret = r(e.pre_master_secret, 'master secret', n, 48).bytes()), (e.pre_master_secret = null)),
      (n = e.server_random + e.client_random)
    var i = 2 * e.mac_key_length + 2 * e.enc_key_length,
      o = t.version.major === D.Versions.TLS_1_0.major && t.version.minor === D.Versions.TLS_1_0.minor
    o && (i += 2 * e.fixed_iv_length)
    var s = r(e.master_secret, 'key expansion', n, i),
      a = {
        client_write_MAC_key: s.getBytes(e.mac_key_length),
        server_write_MAC_key: s.getBytes(e.mac_key_length),
        client_write_key: s.getBytes(e.enc_key_length),
        server_write_key: s.getBytes(e.enc_key_length),
      }
    return (
      o && ((a.client_write_IV = s.getBytes(e.fixed_iv_length)), (a.server_write_IV = s.getBytes(e.fixed_iv_length))), a
    )
  }
  D.createConnectionState = function (t) {
    var e = t.entity === D.ConnectionEnd.client,
      r = function () {
        var o = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function (s) {
            return !0
          },
          compressionState: null,
          compressFunction: function (s) {
            return !0
          },
          updateSequenceNumber: function () {
            o.sequenceNumber[1] === 4294967295
              ? ((o.sequenceNumber[1] = 0), ++o.sequenceNumber[0])
              : ++o.sequenceNumber[1]
          },
        }
        return o
      },
      n = { read: r(), write: r() }
    if (
      ((n.read.update = function (o, s) {
        return (
          n.read.cipherFunction(s, n.read)
            ? n.read.compressFunction(o, s, n.read) ||
              o.error(o, {
                message: 'Could not decompress record.',
                send: !0,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.decompression_failure },
              })
            : o.error(o, {
                message: 'Could not decrypt record or bad MAC.',
                send: !0,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.bad_record_mac },
              }),
          !o.fail
        )
      }),
      (n.write.update = function (o, s) {
        return (
          n.write.compressFunction(o, s, n.write)
            ? n.write.cipherFunction(s, n.write) ||
              o.error(o, {
                message: 'Could not encrypt record.',
                send: !1,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
              })
            : o.error(o, {
                message: 'Could not compress record.',
                send: !1,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
              }),
          !o.fail
        )
      }),
      t.session)
    ) {
      var i = t.session.sp
      switch (
        (t.session.cipherSuite.initSecurityParameters(i),
        (i.keys = D.generateKeys(t, i)),
        (n.read.macKey = e ? i.keys.server_write_MAC_key : i.keys.client_write_MAC_key),
        (n.write.macKey = e ? i.keys.client_write_MAC_key : i.keys.server_write_MAC_key),
        t.session.cipherSuite.initConnectionState(n, t, i),
        i.compression_algorithm)
      ) {
        case D.CompressionMethod.none:
          break
        case D.CompressionMethod.deflate:
          ;(n.read.compressFunction = xNe), (n.write.compressFunction = yNe)
          break
        default:
          throw new Error('Unsupported compression algorithm.')
      }
    }
    return n
  }
  D.createRandom = function () {
    var t = new Date(),
      e = +t + t.getTimezoneOffset() * 6e4,
      r = Ce.util.createBuffer()
    return r.putInt32(e), r.putBytes(Ce.random.getBytes(28)), r
  }
  D.createRecord = function (t, e) {
    if (!e.data) return null
    var r = {
      type: e.type,
      version: { major: t.version.major, minor: t.version.minor },
      length: e.data.length(),
      fragment: e.data,
    }
    return r
  }
  D.createAlert = function (t, e) {
    var r = Ce.util.createBuffer()
    return r.putByte(e.level), r.putByte(e.description), D.createRecord(t, { type: D.ContentType.alert, data: r })
  }
  D.createClientHello = function (t) {
    t.session.clientHelloVersion = { major: t.version.major, minor: t.version.minor }
    for (var e = Ce.util.createBuffer(), r = 0; r < t.cipherSuites.length; ++r) {
      var n = t.cipherSuites[r]
      e.putByte(n.id[0]), e.putByte(n.id[1])
    }
    var i = e.length(),
      o = Ce.util.createBuffer()
    o.putByte(D.CompressionMethod.none)
    var s = o.length(),
      a = Ce.util.createBuffer()
    if (t.virtualHost) {
      var l = Ce.util.createBuffer()
      l.putByte(0), l.putByte(0)
      var c = Ce.util.createBuffer()
      c.putByte(0), Ha(c, 2, Ce.util.createBuffer(t.virtualHost))
      var u = Ce.util.createBuffer()
      Ha(u, 2, c), Ha(l, 2, u), a.putBuffer(l)
    }
    var p = a.length()
    p > 0 && (p += 2)
    var d = t.session.id,
      f = d.length + 1 + 2 + 4 + 28 + 2 + i + 1 + s + p,
      m = Ce.util.createBuffer()
    return (
      m.putByte(D.HandshakeType.client_hello),
      m.putInt24(f),
      m.putByte(t.version.major),
      m.putByte(t.version.minor),
      m.putBytes(t.session.sp.client_random),
      Ha(m, 1, Ce.util.createBuffer(d)),
      Ha(m, 2, e),
      Ha(m, 1, o),
      p > 0 && Ha(m, 2, a),
      m
    )
  }
  D.createServerHello = function (t) {
    var e = t.session.id,
      r = e.length + 1 + 2 + 4 + 28 + 2 + 1,
      n = Ce.util.createBuffer()
    return (
      n.putByte(D.HandshakeType.server_hello),
      n.putInt24(r),
      n.putByte(t.version.major),
      n.putByte(t.version.minor),
      n.putBytes(t.session.sp.server_random),
      Ha(n, 1, Ce.util.createBuffer(e)),
      n.putByte(t.session.cipherSuite.id[0]),
      n.putByte(t.session.cipherSuite.id[1]),
      n.putByte(t.session.compressionMethod),
      n
    )
  }
  D.createCertificate = function (t) {
    var e = t.entity === D.ConnectionEnd.client,
      r = null
    if (t.getCertificate) {
      var n
      e ? (n = t.session.certificateRequest) : (n = t.session.extensions.server_name.serverNameList),
        (r = t.getCertificate(t, n))
    }
    var i = Ce.util.createBuffer()
    if (r !== null)
      try {
        Ce.util.isArray(r) || (r = [r])
        for (var o = null, s = 0; s < r.length; ++s) {
          var a = Ce.pem.decode(r[s])[0]
          if (a.type !== 'CERTIFICATE' && a.type !== 'X509 CERTIFICATE' && a.type !== 'TRUSTED CERTIFICATE') {
            var l = new Error(
              'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
            )
            throw ((l.headerType = a.type), l)
          }
          if (a.procType && a.procType.type === 'ENCRYPTED')
            throw new Error('Could not convert certificate from PEM; PEM is encrypted.')
          var c = Ce.util.createBuffer(a.body)
          o === null && (o = Ce.asn1.fromDer(c.bytes(), !1))
          var u = Ce.util.createBuffer()
          Ha(u, 3, c), i.putBuffer(u)
        }
        ;(r = Ce.pki.certificateFromAsn1(o)), e ? (t.session.clientCertificate = r) : (t.session.serverCertificate = r)
      } catch (f) {
        return t.error(t, {
          message: 'Could not send certificate list.',
          cause: f,
          send: !0,
          alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.bad_certificate },
        })
      }
    var p = 3 + i.length(),
      d = Ce.util.createBuffer()
    return d.putByte(D.HandshakeType.certificate), d.putInt24(p), Ha(d, 3, i), d
  }
  D.createClientKeyExchange = function (t) {
    var e = Ce.util.createBuffer()
    e.putByte(t.session.clientHelloVersion.major),
      e.putByte(t.session.clientHelloVersion.minor),
      e.putBytes(Ce.random.getBytes(46))
    var r = t.session.sp
    r.pre_master_secret = e.getBytes()
    var n = t.session.serverCertificate.publicKey
    e = n.encrypt(r.pre_master_secret)
    var i = e.length + 2,
      o = Ce.util.createBuffer()
    return o.putByte(D.HandshakeType.client_key_exchange), o.putInt24(i), o.putInt16(e.length), o.putBytes(e), o
  }
  D.createServerKeyExchange = function (t) {
    var e = 0,
      r = Ce.util.createBuffer()
    return e > 0 && (r.putByte(D.HandshakeType.server_key_exchange), r.putInt24(e)), r
  }
  D.getClientSignature = function (t, e) {
    var r = Ce.util.createBuffer()
    r.putBuffer(t.session.md5.digest()),
      r.putBuffer(t.session.sha1.digest()),
      (r = r.getBytes()),
      (t.getSignature =
        t.getSignature ||
        function (n, i, o) {
          var s = null
          if (n.getPrivateKey)
            try {
              ;(s = n.getPrivateKey(n, n.session.clientCertificate)), (s = Ce.pki.privateKeyFromPem(s))
            } catch (a) {
              n.error(n, {
                message: 'Could not get private key.',
                cause: a,
                send: !0,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
              })
            }
          s === null
            ? n.error(n, {
                message: 'No private key set.',
                send: !0,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.internal_error },
              })
            : (i = s.sign(i, null)),
            o(n, i)
        }),
      t.getSignature(t, r, e)
  }
  D.createCertificateVerify = function (t, e) {
    var r = e.length + 2,
      n = Ce.util.createBuffer()
    return n.putByte(D.HandshakeType.certificate_verify), n.putInt24(r), n.putInt16(e.length), n.putBytes(e), n
  }
  D.createCertificateRequest = function (t) {
    var e = Ce.util.createBuffer()
    e.putByte(1)
    var r = Ce.util.createBuffer()
    for (var n in t.caStore.certs) {
      var i = t.caStore.certs[n],
        o = Ce.pki.distinguishedNameToAsn1(i.subject),
        s = Ce.asn1.toDer(o)
      r.putInt16(s.length()), r.putBuffer(s)
    }
    var a = 1 + e.length() + 2 + r.length(),
      l = Ce.util.createBuffer()
    return l.putByte(D.HandshakeType.certificate_request), l.putInt24(a), Ha(l, 1, e), Ha(l, 2, r), l
  }
  D.createServerHelloDone = function (t) {
    var e = Ce.util.createBuffer()
    return e.putByte(D.HandshakeType.server_hello_done), e.putInt24(0), e
  }
  D.createChangeCipherSpec = function () {
    var t = Ce.util.createBuffer()
    return t.putByte(1), t
  }
  D.createFinished = function (t) {
    var e = Ce.util.createBuffer()
    e.putBuffer(t.session.md5.digest()), e.putBuffer(t.session.sha1.digest())
    var r = t.entity === D.ConnectionEnd.client,
      n = t.session.sp,
      i = 12,
      o = LA,
      s = r ? 'client finished' : 'server finished'
    e = o(n.master_secret, s, e.getBytes(), i)
    var a = Ce.util.createBuffer()
    return a.putByte(D.HandshakeType.finished), a.putInt24(e.length()), a.putBuffer(e), a
  }
  D.createHeartbeat = function (t, e, r) {
    typeof r > 'u' && (r = e.length)
    var n = Ce.util.createBuffer()
    n.putByte(t), n.putInt16(r), n.putBytes(e)
    var i = n.length(),
      o = Math.max(16, i - r - 3)
    return n.putBytes(Ce.random.getBytes(o)), n
  }
  D.queue = function (t, e) {
    if (
      e &&
      !(
        e.fragment.length() === 0 &&
        (e.type === D.ContentType.handshake ||
          e.type === D.ContentType.alert ||
          e.type === D.ContentType.change_cipher_spec)
      )
    ) {
      if (e.type === D.ContentType.handshake) {
        var r = e.fragment.bytes()
        t.session.md5.update(r), t.session.sha1.update(r), (r = null)
      }
      var n
      if (e.fragment.length() <= D.MaxFragment) n = [e]
      else {
        n = []
        for (var i = e.fragment.bytes(); i.length > D.MaxFragment; )
          n.push(D.createRecord(t, { type: e.type, data: Ce.util.createBuffer(i.slice(0, D.MaxFragment)) })),
            (i = i.slice(D.MaxFragment))
        i.length > 0 && n.push(D.createRecord(t, { type: e.type, data: Ce.util.createBuffer(i) }))
      }
      for (var o = 0; o < n.length && !t.fail; ++o) {
        var s = n[o],
          a = t.state.current.write
        a.update(t, s) && t.records.push(s)
      }
    }
  }
  D.flush = function (t) {
    for (var e = 0; e < t.records.length; ++e) {
      var r = t.records[e]
      t.tlsData.putByte(r.type),
        t.tlsData.putByte(r.version.major),
        t.tlsData.putByte(r.version.minor),
        t.tlsData.putInt16(r.fragment.length()),
        t.tlsData.putBuffer(t.records[e].fragment)
    }
    return (t.records = []), t.tlsDataReady(t)
  }
  var sM = function (t) {
      switch (t) {
        case !0:
          return !0
        case Ce.pki.certificateError.bad_certificate:
          return D.Alert.Description.bad_certificate
        case Ce.pki.certificateError.unsupported_certificate:
          return D.Alert.Description.unsupported_certificate
        case Ce.pki.certificateError.certificate_revoked:
          return D.Alert.Description.certificate_revoked
        case Ce.pki.certificateError.certificate_expired:
          return D.Alert.Description.certificate_expired
        case Ce.pki.certificateError.certificate_unknown:
          return D.Alert.Description.certificate_unknown
        case Ce.pki.certificateError.unknown_ca:
          return D.Alert.Description.unknown_ca
        default:
          return D.Alert.Description.bad_certificate
      }
    },
    FNe = function (t) {
      switch (t) {
        case !0:
          return !0
        case D.Alert.Description.bad_certificate:
          return Ce.pki.certificateError.bad_certificate
        case D.Alert.Description.unsupported_certificate:
          return Ce.pki.certificateError.unsupported_certificate
        case D.Alert.Description.certificate_revoked:
          return Ce.pki.certificateError.certificate_revoked
        case D.Alert.Description.certificate_expired:
          return Ce.pki.certificateError.certificate_expired
        case D.Alert.Description.certificate_unknown:
          return Ce.pki.certificateError.certificate_unknown
        case D.Alert.Description.unknown_ca:
          return Ce.pki.certificateError.unknown_ca
        default:
          return Ce.pki.certificateError.bad_certificate
      }
    }
  D.verifyCertificateChain = function (t, e) {
    try {
      var r = {}
      for (var n in t.verifyOptions) r[n] = t.verifyOptions[n]
      ;(r.verify = function (o, s, a) {
        var l = sM(o),
          c = t.verify(t, o, s, a)
        if (c !== !0) {
          if (typeof c == 'object' && !Ce.util.isArray(c)) {
            var u = new Error('The application rejected the certificate.')
            throw (
              ((u.send = !0),
              (u.alert = { level: D.Alert.Level.fatal, description: D.Alert.Description.bad_certificate }),
              c.message && (u.message = c.message),
              c.alert && (u.alert.description = c.alert),
              u)
            )
          }
          c !== o && (c = FNe(c))
        }
        return c
      }),
        Ce.pki.verifyCertificateChain(t.caStore, e, r)
    } catch (o) {
      var i = o
      ;(typeof i != 'object' || Ce.util.isArray(i)) &&
        (i = { send: !0, alert: { level: D.Alert.Level.fatal, description: sM(o) } }),
        'send' in i || (i.send = !0),
        'alert' in i || (i.alert = { level: D.Alert.Level.fatal, description: sM(i.error) }),
        t.error(t, i)
    }
    return !t.fail
  }
  D.createSessionCache = function (t, e) {
    var r = null
    if (t && t.getSession && t.setSession && t.order) r = t
    else {
      ;(r = {}), (r.cache = t || {}), (r.capacity = Math.max(e || 100, 1)), (r.order = [])
      for (var n in t) r.order.length <= e ? r.order.push(n) : delete t[n]
      ;(r.getSession = function (i) {
        var o = null,
          s = null
        if ((i ? (s = Ce.util.bytesToHex(i)) : r.order.length > 0 && (s = r.order[0]), s !== null && s in r.cache)) {
          ;(o = r.cache[s]), delete r.cache[s]
          for (var a in r.order)
            if (r.order[a] === s) {
              r.order.splice(a, 1)
              break
            }
        }
        return o
      }),
        (r.setSession = function (i, o) {
          if (r.order.length === r.capacity) {
            var s = r.order.shift()
            delete r.cache[s]
          }
          var s = Ce.util.bytesToHex(i)
          r.order.push(s), (r.cache[s] = o)
        })
    }
    return r
  }
  D.createConnection = function (t) {
    var e = null
    t.caStore
      ? Ce.util.isArray(t.caStore)
        ? (e = Ce.pki.createCaStore(t.caStore))
        : (e = t.caStore)
      : (e = Ce.pki.createCaStore())
    var r = t.cipherSuites || null
    if (r === null) {
      r = []
      for (var n in D.CipherSuites) r.push(D.CipherSuites[n])
    }
    var i = t.server ? D.ConnectionEnd.server : D.ConnectionEnd.client,
      o = t.sessionCache ? D.createSessionCache(t.sessionCache) : null,
      s = {
        version: { major: D.Version.major, minor: D.Version.minor },
        entity: i,
        sessionId: t.sessionId,
        caStore: e,
        sessionCache: o,
        cipherSuites: r,
        connected: t.connected,
        virtualHost: t.virtualHost || null,
        verifyClient: t.verifyClient || !1,
        verify:
          t.verify ||
          function (u, p, d, f) {
            return p
          },
        verifyOptions: t.verifyOptions || {},
        getCertificate: t.getCertificate || null,
        getPrivateKey: t.getPrivateKey || null,
        getSignature: t.getSignature || null,
        input: Ce.util.createBuffer(),
        tlsData: Ce.util.createBuffer(),
        data: Ce.util.createBuffer(),
        tlsDataReady: t.tlsDataReady,
        dataReady: t.dataReady,
        heartbeatReceived: t.heartbeatReceived,
        closed: t.closed,
        error: function (u, p) {
          ;(p.origin = p.origin || (u.entity === D.ConnectionEnd.client ? 'client' : 'server')),
            p.send && (D.queue(u, D.createAlert(u, p.alert)), D.flush(u))
          var d = p.fatal !== !1
          d && (u.fail = !0), t.error(u, p), d && u.close(!1)
        },
        deflate: t.deflate || null,
        inflate: t.inflate || null,
      }
    ;(s.reset = function (u) {
      ;(s.version = { major: D.Version.major, minor: D.Version.minor }),
        (s.record = null),
        (s.session = null),
        (s.peerCertificate = null),
        (s.state = { pending: null, current: null }),
        (s.expect = s.entity === D.ConnectionEnd.client ? bNe : ANe),
        (s.fragmented = null),
        (s.records = []),
        (s.open = !1),
        (s.handshakes = 0),
        (s.handshaking = !1),
        (s.isConnected = !1),
        (s.fail = !(u || typeof u > 'u')),
        s.input.clear(),
        s.tlsData.clear(),
        s.data.clear(),
        (s.state.current = D.createConnectionState(s))
    }),
      s.reset()
    var a = function (u, p) {
        var d = p.type - D.ContentType.change_cipher_spec,
          f = lM[u.entity][u.expect]
        d in f ? f[d](u, p) : D.handleUnexpected(u, p)
      },
      l = function (u) {
        var p = 0,
          d = u.input,
          f = d.length()
        if (f < 5) p = 5 - f
        else {
          u.record = {
            type: d.getByte(),
            version: { major: d.getByte(), minor: d.getByte() },
            length: d.getInt16(),
            fragment: Ce.util.createBuffer(),
            ready: !1,
          }
          var m = u.record.version.major === u.version.major
          m && u.session && u.session.version && (m = u.record.version.minor === u.version.minor),
            m ||
              u.error(u, {
                message: 'Incompatible TLS version.',
                send: !0,
                alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.protocol_version },
              })
        }
        return p
      },
      c = function (u) {
        var p = 0,
          d = u.input,
          f = d.length()
        if (f < u.record.length) p = u.record.length - f
        else {
          u.record.fragment.putBytes(d.getBytes(u.record.length)), d.compact()
          var m = u.state.current.read
          m.update(u, u.record) &&
            (u.fragmented !== null &&
              (u.fragmented.type === u.record.type
                ? (u.fragmented.fragment.putBuffer(u.record.fragment), (u.record = u.fragmented))
                : u.error(u, {
                    message: 'Invalid fragmented record.',
                    send: !0,
                    alert: { level: D.Alert.Level.fatal, description: D.Alert.Description.unexpected_message },
                  })),
            (u.record.ready = !0))
        }
        return p
      }
    return (
      (s.handshake = function (u) {
        if (s.entity !== D.ConnectionEnd.client)
          s.error(s, { message: 'Cannot initiate handshake as a server.', fatal: !1 })
        else if (s.handshaking) s.error(s, { message: 'Handshake already in progress.', fatal: !1 })
        else {
          s.fail && !s.open && s.handshakes === 0 && (s.fail = !1), (s.handshaking = !0), (u = u || '')
          var p = null
          u.length > 0 && (s.sessionCache && (p = s.sessionCache.getSession(u)), p === null && (u = '')),
            u.length === 0 && s.sessionCache && ((p = s.sessionCache.getSession()), p !== null && (u = p.id)),
            (s.session = {
              id: u,
              version: null,
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              certificateRequest: null,
              clientCertificate: null,
              sp: {},
              md5: Ce.md.md5.create(),
              sha1: Ce.md.sha1.create(),
            }),
            p && ((s.version = p.version), (s.session.sp = p.sp)),
            (s.session.sp.client_random = D.createRandom().getBytes()),
            (s.open = !0),
            D.queue(s, D.createRecord(s, { type: D.ContentType.handshake, data: D.createClientHello(s) })),
            D.flush(s)
        }
      }),
      (s.process = function (u) {
        var p = 0
        return (
          u && s.input.putBytes(u),
          s.fail ||
            (s.record !== null && s.record.ready && s.record.fragment.isEmpty() && (s.record = null),
            s.record === null && (p = l(s)),
            !s.fail && s.record !== null && !s.record.ready && (p = c(s)),
            !s.fail && s.record !== null && s.record.ready && a(s, s.record)),
          p
        )
      }),
      (s.prepare = function (u) {
        return (
          D.queue(s, D.createRecord(s, { type: D.ContentType.application_data, data: Ce.util.createBuffer(u) })),
          D.flush(s)
        )
      }),
      (s.prepareHeartbeatRequest = function (u, p) {
        return (
          u instanceof Ce.util.ByteBuffer && (u = u.bytes()),
          typeof p > 'u' && (p = u.length),
          (s.expectedHeartbeatPayload = u),
          D.queue(
            s,
            D.createRecord(s, {
              type: D.ContentType.heartbeat,
              data: D.createHeartbeat(D.HeartbeatMessageType.heartbeat_request, u, p),
            })
          ),
          D.flush(s)
        )
      }),
      (s.close = function (u) {
        if (!s.fail && s.sessionCache && s.session) {
          var p = { id: s.session.id, version: s.session.version, sp: s.session.sp }
          ;(p.sp.keys = null), s.sessionCache.setSession(p.id, p)
        }
        s.open &&
          ((s.open = !1),
          s.input.clear(),
          (s.isConnected || s.handshaking) &&
            ((s.isConnected = s.handshaking = !1),
            D.queue(
              s,
              D.createAlert(s, { level: D.Alert.Level.warning, description: D.Alert.Description.close_notify })
            ),
            D.flush(s)),
          s.closed(s)),
          s.reset(u)
      }),
      s
    )
  }
  DZ.exports = Ce.tls = Ce.tls || {}
  for (kA in D) typeof D[kA] != 'function' && (Ce.tls[kA] = D[kA])
  var kA
  Ce.tls.prf_tls1 = LA
  Ce.tls.hmac_sha1 = _Ne
  Ce.tls.createSessionCache = D.createSessionCache
  Ce.tls.createConnection = D.createConnection
})
var kZ = handleExports((cgt, NZ) => {
  var Df = Mt()
  Tf()
  uM()
  var ja = (NZ.exports = Df.tls)
  ja.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
    id: [0, 47],
    name: 'TLS_RSA_WITH_AES_128_CBC_SHA',
    initSecurityParameters: function (t) {
      ;(t.bulk_cipher_algorithm = ja.BulkCipherAlgorithm.aes),
        (t.cipher_type = ja.CipherType.block),
        (t.enc_key_length = 16),
        (t.block_length = 16),
        (t.fixed_iv_length = 16),
        (t.record_iv_length = 16),
        (t.mac_algorithm = ja.MACAlgorithm.hmac_sha1),
        (t.mac_length = 20),
        (t.mac_key_length = 20)
    },
    initConnectionState: PZ,
  }
  ja.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
    id: [0, 53],
    name: 'TLS_RSA_WITH_AES_256_CBC_SHA',
    initSecurityParameters: function (t) {
      ;(t.bulk_cipher_algorithm = ja.BulkCipherAlgorithm.aes),
        (t.cipher_type = ja.CipherType.block),
        (t.enc_key_length = 32),
        (t.block_length = 16),
        (t.fixed_iv_length = 16),
        (t.record_iv_length = 16),
        (t.mac_algorithm = ja.MACAlgorithm.hmac_sha1),
        (t.mac_length = 20),
        (t.mac_key_length = 20)
    },
    initConnectionState: PZ,
  }
  function PZ(t, e, r) {
    var n = e.entity === Df.tls.ConnectionEnd.client
    ;(t.read.cipherState = {
      init: !1,
      cipher: Df.cipher.createDecipher('AES-CBC', n ? r.keys.server_write_key : r.keys.client_write_key),
      iv: n ? r.keys.server_write_IV : r.keys.client_write_IV,
    }),
      (t.write.cipherState = {
        init: !1,
        cipher: Df.cipher.createCipher('AES-CBC', n ? r.keys.client_write_key : r.keys.server_write_key),
        iv: n ? r.keys.client_write_IV : r.keys.server_write_IV,
      }),
      (t.read.cipherFunction = HNe),
      (t.write.cipherFunction = UNe),
      (t.read.macLength = t.write.macLength = r.mac_length),
      (t.read.macFunction = t.write.macFunction = ja.hmac_sha1)
  }
  function UNe(t, e) {
    var r = !1,
      n = e.macFunction(e.macKey, e.sequenceNumber, t)
    t.fragment.putBytes(n), e.updateSequenceNumber()
    var i
    t.version.minor === ja.Versions.TLS_1_0.minor
      ? (i = e.cipherState.init ? null : e.cipherState.iv)
      : (i = Df.random.getBytesSync(16)),
      (e.cipherState.init = !0)
    var o = e.cipherState.cipher
    return (
      o.start({ iv: i }),
      t.version.minor >= ja.Versions.TLS_1_1.minor && o.output.putBytes(i),
      o.update(t.fragment),
      o.finish(BNe) && ((t.fragment = o.output), (t.length = t.fragment.length()), (r = !0)),
      r
    )
  }
  function BNe(t, e, r) {
    if (!r) {
      var n = t - (e.length() % t)
      e.fillWithByte(n - 1, n)
    }
    return !0
  }
  function qNe(t, e, r) {
    var n = !0
    if (r) {
      for (var i = e.length(), o = e.last(), s = i - 1 - o; s < i - 1; ++s) n = n && e.at(s) == o
      n && e.truncate(o + 1)
    }
    return n
  }
  function HNe(t, e) {
    var r = !1,
      n
    t.version.minor === ja.Versions.TLS_1_0.minor
      ? (n = e.cipherState.init ? null : e.cipherState.iv)
      : (n = t.fragment.getBytes(16)),
      (e.cipherState.init = !0)
    var i = e.cipherState.cipher
    i.start({ iv: n }), i.update(t.fragment), (r = i.finish(qNe))
    var o = e.macLength,
      s = Df.random.getBytesSync(o),
      a = i.output.length()
    a >= o ? ((t.fragment = i.output.getBytes(a - o)), (s = i.output.getBytes(o))) : (t.fragment = i.output.getBytes()),
      (t.fragment = Df.util.createBuffer(t.fragment)),
      (t.length = t.fragment.length())
    var l = e.macFunction(e.macKey, e.sequenceNumber, t)
    return e.updateSequenceNumber(), (r = jNe(e.macKey, s, l) && r), r
  }
  function jNe(t, e, r) {
    var n = Df.hmac.create()
    return (
      n.start('SHA1', t),
      n.update(e),
      (e = n.digest().getBytes()),
      n.start(null, null),
      n.update(r),
      (r = n.digest().getBytes()),
      e === r
    )
  }
})
var fM = handleExports((lgt, FZ) => {
  var nn = Mt()
  Ll()
  cr()
  var Yb = (FZ.exports = nn.sha512 = nn.sha512 || {})
  nn.md.sha512 = nn.md.algorithms.sha512 = Yb
  var LZ = (nn.sha384 = nn.sha512.sha384 = nn.sha512.sha384 || {})
  LZ.create = function () {
    return Yb.create('SHA-384')
  }
  nn.md.sha384 = nn.md.algorithms.sha384 = LZ
  nn.sha512.sha256 = nn.sha512.sha256 || {
    create: function () {
      return Yb.create('SHA-512/256')
    },
  }
  nn.md['sha512/256'] = nn.md.algorithms['sha512/256'] = nn.sha512.sha256
  nn.sha512.sha224 = nn.sha512.sha224 || {
    create: function () {
      return Yb.create('SHA-512/224')
    },
  }
  nn.md['sha512/224'] = nn.md.algorithms['sha512/224'] = nn.sha512.sha224
  Yb.create = function (t) {
    if ((MZ || GNe(), typeof t > 'u' && (t = 'SHA-512'), !(t in vg))) throw new Error('Invalid SHA-512 algorithm: ' + t)
    for (var e = vg[t], r = null, n = nn.util.createBuffer(), i = new Array(80), o = 0; o < 80; ++o) i[o] = new Array(2)
    var s = 64
    switch (t) {
      case 'SHA-384':
        s = 48
        break
      case 'SHA-512/256':
        s = 32
        break
      case 'SHA-512/224':
        s = 28
        break
    }
    var a = {
      algorithm: t.replace('-', '').toLowerCase(),
      blockLength: 128,
      digestLength: s,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16,
    }
    return (
      (a.start = function () {
        ;(a.messageLength = 0), (a.fullMessageLength = a.messageLength128 = [])
        for (var l = a.messageLengthSize / 4, c = 0; c < l; ++c) a.fullMessageLength.push(0)
        ;(n = nn.util.createBuffer()), (r = new Array(e.length))
        for (var c = 0; c < e.length; ++c) r[c] = e[c].slice(0)
        return a
      }),
      a.start(),
      (a.update = function (l, c) {
        c === 'utf8' && (l = nn.util.encodeUtf8(l))
        var u = l.length
        ;(a.messageLength += u), (u = [(u / 4294967296) >>> 0, u >>> 0])
        for (var p = a.fullMessageLength.length - 1; p >= 0; --p)
          (a.fullMessageLength[p] += u[1]),
            (u[1] = u[0] + ((a.fullMessageLength[p] / 4294967296) >>> 0)),
            (a.fullMessageLength[p] = a.fullMessageLength[p] >>> 0),
            (u[0] = (u[1] / 4294967296) >>> 0)
        return n.putBytes(l), OZ(r, i, n), (n.read > 2048 || n.length() === 0) && n.compact(), a
      }),
      (a.digest = function () {
        var l = nn.util.createBuffer()
        l.putBytes(n.bytes())
        var c = a.fullMessageLength[a.fullMessageLength.length - 1] + a.messageLengthSize,
          u = c & (a.blockLength - 1)
        l.putBytes(pM.substr(0, a.blockLength - u))
        for (var p, d, f = a.fullMessageLength[0] * 8, m = 0; m < a.fullMessageLength.length - 1; ++m)
          (p = a.fullMessageLength[m + 1] * 8),
            (d = (p / 4294967296) >>> 0),
            (f += d),
            l.putInt32(f >>> 0),
            (f = p >>> 0)
        l.putInt32(f)
        for (var h = new Array(r.length), m = 0; m < r.length; ++m) h[m] = r[m].slice(0)
        OZ(h, i, l)
        var g = nn.util.createBuffer(),
          v
        t === 'SHA-512' ? (v = h.length) : t === 'SHA-384' ? (v = h.length - 2) : (v = h.length - 4)
        for (var m = 0; m < v; ++m) g.putInt32(h[m][0]), (m !== v - 1 || t !== 'SHA-512/224') && g.putInt32(h[m][1])
        return g
      }),
      a
    )
  }
  var pM = null,
    MZ = !1,
    dM = null,
    vg = null
  function GNe() {
    ;(pM = String.fromCharCode(128)),
      (pM += nn.util.fillString(String.fromCharCode(0), 128)),
      (dM = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591],
      ]),
      (vg = {}),
      (vg['SHA-512'] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209],
      ]),
      (vg['SHA-384'] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428],
      ]),
      (vg['SHA-512/256'] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882],
      ]),
      (vg['SHA-512/224'] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561],
      ]),
      (MZ = !0)
  }
  function OZ(t, e, r) {
    for (
      var n,
        i,
        o,
        s,
        a,
        l,
        c,
        u,
        p,
        d,
        f,
        m,
        h,
        g,
        v,
        _,
        y,
        b,
        x,
        P,
        U,
        H,
        j,
        M,
        F,
        z,
        q,
        L,
        S,
        T,
        A,
        X,
        fe,
        ce,
        oe,
        ae = r.length();
      ae >= 128;

    ) {
      for (S = 0; S < 16; ++S) (e[S][0] = r.getInt32() >>> 0), (e[S][1] = r.getInt32() >>> 0)
      for (; S < 80; ++S)
        (X = e[S - 2]),
          (T = X[0]),
          (A = X[1]),
          (n = (((T >>> 19) | (A << 13)) ^ ((A >>> 29) | (T << 3)) ^ (T >>> 6)) >>> 0),
          (i = (((T << 13) | (A >>> 19)) ^ ((A << 3) | (T >>> 29)) ^ ((T << 26) | (A >>> 6))) >>> 0),
          (ce = e[S - 15]),
          (T = ce[0]),
          (A = ce[1]),
          (o = (((T >>> 1) | (A << 31)) ^ ((T >>> 8) | (A << 24)) ^ (T >>> 7)) >>> 0),
          (s = (((T << 31) | (A >>> 1)) ^ ((T << 24) | (A >>> 8)) ^ ((T << 25) | (A >>> 7))) >>> 0),
          (fe = e[S - 7]),
          (oe = e[S - 16]),
          (A = i + fe[1] + s + oe[1]),
          (e[S][0] = (n + fe[0] + o + oe[0] + ((A / 4294967296) >>> 0)) >>> 0),
          (e[S][1] = A >>> 0)
      for (
        h = t[0][0],
          g = t[0][1],
          v = t[1][0],
          _ = t[1][1],
          y = t[2][0],
          b = t[2][1],
          x = t[3][0],
          P = t[3][1],
          U = t[4][0],
          H = t[4][1],
          j = t[5][0],
          M = t[5][1],
          F = t[6][0],
          z = t[6][1],
          q = t[7][0],
          L = t[7][1],
          S = 0;
        S < 80;
        ++S
      )
        (c = (((U >>> 14) | (H << 18)) ^ ((U >>> 18) | (H << 14)) ^ ((H >>> 9) | (U << 23))) >>> 0),
          (u = (((U << 18) | (H >>> 14)) ^ ((U << 14) | (H >>> 18)) ^ ((H << 23) | (U >>> 9))) >>> 0),
          (p = (F ^ (U & (j ^ F))) >>> 0),
          (d = (z ^ (H & (M ^ z))) >>> 0),
          (a = (((h >>> 28) | (g << 4)) ^ ((g >>> 2) | (h << 30)) ^ ((g >>> 7) | (h << 25))) >>> 0),
          (l = (((h << 4) | (g >>> 28)) ^ ((g << 30) | (h >>> 2)) ^ ((g << 25) | (h >>> 7))) >>> 0),
          (f = ((h & v) | (y & (h ^ v))) >>> 0),
          (m = ((g & _) | (b & (g ^ _))) >>> 0),
          (A = L + u + d + dM[S][1] + e[S][1]),
          (n = (q + c + p + dM[S][0] + e[S][0] + ((A / 4294967296) >>> 0)) >>> 0),
          (i = A >>> 0),
          (A = l + m),
          (o = (a + f + ((A / 4294967296) >>> 0)) >>> 0),
          (s = A >>> 0),
          (q = F),
          (L = z),
          (F = j),
          (z = M),
          (j = U),
          (M = H),
          (A = P + i),
          (U = (x + n + ((A / 4294967296) >>> 0)) >>> 0),
          (H = A >>> 0),
          (x = y),
          (P = b),
          (y = v),
          (b = _),
          (v = h),
          (_ = g),
          (A = i + s),
          (h = (n + o + ((A / 4294967296) >>> 0)) >>> 0),
          (g = A >>> 0)
      ;(A = t[0][1] + g),
        (t[0][0] = (t[0][0] + h + ((A / 4294967296) >>> 0)) >>> 0),
        (t[0][1] = A >>> 0),
        (A = t[1][1] + _),
        (t[1][0] = (t[1][0] + v + ((A / 4294967296) >>> 0)) >>> 0),
        (t[1][1] = A >>> 0),
        (A = t[2][1] + b),
        (t[2][0] = (t[2][0] + y + ((A / 4294967296) >>> 0)) >>> 0),
        (t[2][1] = A >>> 0),
        (A = t[3][1] + P),
        (t[3][0] = (t[3][0] + x + ((A / 4294967296) >>> 0)) >>> 0),
        (t[3][1] = A >>> 0),
        (A = t[4][1] + H),
        (t[4][0] = (t[4][0] + U + ((A / 4294967296) >>> 0)) >>> 0),
        (t[4][1] = A >>> 0),
        (A = t[5][1] + M),
        (t[5][0] = (t[5][0] + j + ((A / 4294967296) >>> 0)) >>> 0),
        (t[5][1] = A >>> 0),
        (A = t[6][1] + z),
        (t[6][0] = (t[6][0] + F + ((A / 4294967296) >>> 0)) >>> 0),
        (t[6][1] = A >>> 0),
        (A = t[7][1] + L),
        (t[7][0] = (t[7][0] + q + ((A / 4294967296) >>> 0)) >>> 0),
        (t[7][1] = A >>> 0),
        (ae -= 128)
    }
  }
})
var UZ = handleExports(mM => {
  var VNe = Mt()
  Lc()
  var Ui = VNe.asn1
  mM.privateKeyValidator = {
    name: 'PrivateKeyInfo',
    tagClass: Ui.Class.UNIVERSAL,
    type: Ui.Type.SEQUENCE,
    constructed: !0,
    value: [
      {
        name: 'PrivateKeyInfo.version',
        tagClass: Ui.Class.UNIVERSAL,
        type: Ui.Type.INTEGER,
        constructed: !1,
        capture: 'privateKeyVersion',
      },
      {
        name: 'PrivateKeyInfo.privateKeyAlgorithm',
        tagClass: Ui.Class.UNIVERSAL,
        type: Ui.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'AlgorithmIdentifier.algorithm',
            tagClass: Ui.Class.UNIVERSAL,
            type: Ui.Type.OID,
            constructed: !1,
            capture: 'privateKeyOid',
          },
        ],
      },
      {
        name: 'PrivateKeyInfo',
        tagClass: Ui.Class.UNIVERSAL,
        type: Ui.Type.OCTETSTRING,
        constructed: !1,
        capture: 'privateKey',
      },
    ],
  }
  mM.publicKeyValidator = {
    name: 'SubjectPublicKeyInfo',
    tagClass: Ui.Class.UNIVERSAL,
    type: Ui.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: 'subjectPublicKeyInfo',
    value: [
      {
        name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
        tagClass: Ui.Class.UNIVERSAL,
        type: Ui.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'AlgorithmIdentifier.algorithm',
            tagClass: Ui.Class.UNIVERSAL,
            type: Ui.Type.OID,
            constructed: !1,
            capture: 'publicKeyOid',
          },
        ],
      },
      {
        tagClass: Ui.Class.UNIVERSAL,
        type: Ui.Type.BITSTRING,
        constructed: !1,
        composed: !0,
        captureBitStringValue: 'ed25519PublicKey',
      },
    ],
  }
})
var XZ = handleExports((pgt, QZ) => {
  var io = Mt()
  zb()
  Fa()
  fM()
  cr()
  var VZ = UZ(),
    zNe = VZ.publicKeyValidator,
    $Ne = VZ.privateKeyValidator
  typeof BZ > 'u' && (BZ = io.jsbn.BigInteger)
  var BZ,
    vM = io.util.ByteBuffer,
    Ts = typeof Buffer > 'u' ? Uint8Array : Buffer
  io.pki = io.pki || {}
  QZ.exports = io.pki.ed25519 = io.ed25519 = io.ed25519 || {}
  var zt = io.ed25519
  zt.constants = {}
  zt.constants.PUBLIC_KEY_BYTE_LENGTH = 32
  zt.constants.PRIVATE_KEY_BYTE_LENGTH = 64
  zt.constants.SEED_BYTE_LENGTH = 32
  zt.constants.SIGN_BYTE_LENGTH = 64
  zt.constants.HASH_BYTE_LENGTH = 64
  zt.generateKeyPair = function (t) {
    t = t || {}
    var e = t.seed
    if (e === void 0) e = io.random.getBytesSync(zt.constants.SEED_BYTE_LENGTH)
    else if (typeof e == 'string') {
      if (e.length !== zt.constants.SEED_BYTE_LENGTH)
        throw new TypeError('"seed" must be ' + zt.constants.SEED_BYTE_LENGTH + ' bytes in length.')
    } else if (!(e instanceof Uint8Array))
      throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.')
    e = vp({ message: e, encoding: 'binary' })
    for (
      var r = new Ts(zt.constants.PUBLIC_KEY_BYTE_LENGTH), n = new Ts(zt.constants.PRIVATE_KEY_BYTE_LENGTH), i = 0;
      i < 32;
      ++i
    )
      n[i] = e[i]
    return QNe(r, n), { publicKey: r, privateKey: n }
  }
  zt.privateKeyFromAsn1 = function (t) {
    var e = {},
      r = [],
      n = io.asn1.validate(t, $Ne, e, r)
    if (!n) {
      var i = new Error('Invalid Key.')
      throw ((i.errors = r), i)
    }
    var o = io.asn1.derToOid(e.privateKeyOid),
      s = io.oids.EdDSA25519
    if (o !== s) throw new Error('Invalid OID "' + o + '"; OID must be "' + s + '".')
    var a = e.privateKey,
      l = vp({ message: io.asn1.fromDer(a).value, encoding: 'binary' })
    return { privateKeyBytes: l }
  }
  zt.publicKeyFromAsn1 = function (t) {
    var e = {},
      r = [],
      n = io.asn1.validate(t, zNe, e, r)
    if (!n) {
      var i = new Error('Invalid Key.')
      throw ((i.errors = r), i)
    }
    var o = io.asn1.derToOid(e.publicKeyOid),
      s = io.oids.EdDSA25519
    if (o !== s) throw new Error('Invalid OID "' + o + '"; OID must be "' + s + '".')
    var a = e.ed25519PublicKey
    if (a.length !== zt.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error('Key length is invalid.')
    return vp({ message: a, encoding: 'binary' })
  }
  zt.publicKeyFromPrivateKey = function (t) {
    t = t || {}
    var e = vp({ message: t.privateKey, encoding: 'binary' })
    if (e.length !== zt.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError('"options.privateKey" must have a byte length of ' + zt.constants.PRIVATE_KEY_BYTE_LENGTH)
    for (var r = new Ts(zt.constants.PUBLIC_KEY_BYTE_LENGTH), n = 0; n < r.length; ++n) r[n] = e[32 + n]
    return r
  }
  zt.sign = function (t) {
    t = t || {}
    var e = vp(t),
      r = vp({ message: t.privateKey, encoding: 'binary' })
    if (r.length === zt.constants.SEED_BYTE_LENGTH) {
      var n = zt.generateKeyPair({ seed: r })
      r = n.privateKey
    } else if (r.length !== zt.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.privateKey" must have a byte length of ' +
          zt.constants.SEED_BYTE_LENGTH +
          ' or ' +
          zt.constants.PRIVATE_KEY_BYTE_LENGTH
      )
    var i = new Ts(zt.constants.SIGN_BYTE_LENGTH + e.length)
    XNe(i, e, e.length, r)
    for (var o = new Ts(zt.constants.SIGN_BYTE_LENGTH), s = 0; s < o.length; ++s) o[s] = i[s]
    return o
  }
  zt.verify = function (t) {
    t = t || {}
    var e = vp(t)
    if (t.signature === void 0)
      throw new TypeError(
        '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
      )
    var r = vp({ message: t.signature, encoding: 'binary' })
    if (r.length !== zt.constants.SIGN_BYTE_LENGTH)
      throw new TypeError('"options.signature" must have a byte length of ' + zt.constants.SIGN_BYTE_LENGTH)
    var n = vp({ message: t.publicKey, encoding: 'binary' })
    if (n.length !== zt.constants.PUBLIC_KEY_BYTE_LENGTH)
      throw new TypeError('"options.publicKey" must have a byte length of ' + zt.constants.PUBLIC_KEY_BYTE_LENGTH)
    var i = new Ts(zt.constants.SIGN_BYTE_LENGTH + e.length),
      o = new Ts(zt.constants.SIGN_BYTE_LENGTH + e.length),
      s
    for (s = 0; s < zt.constants.SIGN_BYTE_LENGTH; ++s) i[s] = r[s]
    for (s = 0; s < e.length; ++s) i[s + zt.constants.SIGN_BYTE_LENGTH] = e[s]
    return JNe(o, i, i.length, n) >= 0
  }
  function vp(t) {
    var e = t.message
    if (e instanceof Uint8Array || e instanceof Ts) return e
    var r = t.encoding
    if (e === void 0)
      if (t.md) (e = t.md.digest().getBytes()), (r = 'binary')
      else throw new TypeError('"options.message" or "options.md" not specified.')
    if (typeof e == 'string' && !r) throw new TypeError('"options.encoding" must be "binary" or "utf8".')
    if (typeof e == 'string') {
      if (typeof Buffer < 'u') return Buffer.from(e, r)
      e = new vM(e, r)
    } else if (!(e instanceof vM))
      throw new TypeError(
        '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
      )
    for (var n = new Ts(e.length()), i = 0; i < n.length; ++i) n[i] = e.at(i)
    return n
  }
  var _M = ht(),
    MA = ht([1]),
    WNe = ht([
      30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995,
    ]),
    KNe = ht([
      61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222,
    ]),
    qZ = ht([
      54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553,
    ]),
    HZ = ht([
      26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
    ]),
    hM = new Float64Array([
      237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 16,
    ]),
    YNe = ht([
      41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139,
    ])
  function Qb(t, e) {
    var r = io.md.sha512.create(),
      n = new vM(t)
    r.update(n.getBytes(e), 'binary')
    var i = r.digest().getBytes()
    if (typeof Buffer < 'u') return Buffer.from(i, 'binary')
    for (var o = new Ts(zt.constants.HASH_BYTE_LENGTH), s = 0; s < 64; ++s) o[s] = i.charCodeAt(s)
    return o
  }
  function QNe(t, e) {
    var r = [ht(), ht(), ht(), ht()],
      n,
      i = Qb(e, 32)
    for (i[0] &= 248, i[31] &= 127, i[31] |= 64, EM(r, i), bM(t, r), n = 0; n < 32; ++n) e[n + 32] = t[n]
    return 0
  }
  function XNe(t, e, r, n) {
    var i,
      o,
      s = new Float64Array(64),
      a = [ht(), ht(), ht(), ht()],
      l = Qb(n, 32)
    ;(l[0] &= 248), (l[31] &= 127), (l[31] |= 64)
    var c = r + 64
    for (i = 0; i < r; ++i) t[64 + i] = e[i]
    for (i = 0; i < 32; ++i) t[32 + i] = l[32 + i]
    var u = Qb(t.subarray(32), r + 32)
    for (yM(u), EM(a, u), bM(t, a), i = 32; i < 64; ++i) t[i] = n[i]
    var p = Qb(t, r + 64)
    for (yM(p), i = 32; i < 64; ++i) s[i] = 0
    for (i = 0; i < 32; ++i) s[i] = u[i]
    for (i = 0; i < 32; ++i) for (o = 0; o < 32; o++) s[i + o] += p[i] * l[o]
    return zZ(t.subarray(32), s), c
  }
  function JNe(t, e, r, n) {
    var i,
      o,
      s = new Ts(32),
      a = [ht(), ht(), ht(), ht()],
      l = [ht(), ht(), ht(), ht()]
    if (((o = -1), r < 64 || ZNe(l, n))) return -1
    for (i = 0; i < r; ++i) t[i] = e[i]
    for (i = 0; i < 32; ++i) t[i + 32] = n[i]
    var c = Qb(t, r)
    if ((yM(c), KZ(a, l, c), EM(l, e.subarray(32)), xM(a, l), bM(s, a), (r -= 64), $Z(e, 0, s, 0))) {
      for (i = 0; i < r; ++i) t[i] = 0
      return -1
    }
    for (i = 0; i < r; ++i) t[i] = e[i + 64]
    return (o = r), o
  }
  function zZ(t, e) {
    var r, n, i, o
    for (n = 63; n >= 32; --n) {
      for (r = 0, i = n - 32, o = n - 12; i < o; ++i)
        (e[i] += r - 16 * e[n] * hM[i - (n - 32)]), (r = (e[i] + 128) >> 8), (e[i] -= r * 256)
      ;(e[i] += r), (e[n] = 0)
    }
    for (r = 0, i = 0; i < 32; ++i) (e[i] += r - (e[31] >> 4) * hM[i]), (r = e[i] >> 8), (e[i] &= 255)
    for (i = 0; i < 32; ++i) e[i] -= r * hM[i]
    for (n = 0; n < 32; ++n) (e[n + 1] += e[n] >> 8), (t[n] = e[n] & 255)
  }
  function yM(t) {
    for (var e = new Float64Array(64), r = 0; r < 64; ++r) (e[r] = t[r]), (t[r] = 0)
    zZ(t, e)
  }
  function xM(t, e) {
    var r = ht(),
      n = ht(),
      i = ht(),
      o = ht(),
      s = ht(),
      a = ht(),
      l = ht(),
      c = ht(),
      u = ht()
    C_(r, t[1], t[0]),
      C_(u, e[1], e[0]),
      Fr(r, r, u),
      S_(n, t[0], t[1]),
      S_(u, e[0], e[1]),
      Fr(n, n, u),
      Fr(i, t[3], e[3]),
      Fr(i, i, KNe),
      Fr(o, t[2], e[2]),
      S_(o, o, o),
      C_(s, n, r),
      C_(a, o, i),
      S_(l, o, i),
      S_(c, n, r),
      Fr(t[0], s, a),
      Fr(t[1], c, l),
      Fr(t[2], l, a),
      Fr(t[3], s, c)
  }
  function jZ(t, e, r) {
    for (var n = 0; n < 4; ++n) YZ(t[n], e[n], r)
  }
  function bM(t, e) {
    var r = ht(),
      n = ht(),
      i = ht()
    nke(i, e[2]), Fr(r, e[0], i), Fr(n, e[1], i), FA(t, n), (t[31] ^= WZ(r) << 7)
  }
  function FA(t, e) {
    var r,
      n,
      i,
      o = ht(),
      s = ht()
    for (r = 0; r < 16; ++r) s[r] = e[r]
    for (gM(s), gM(s), gM(s), n = 0; n < 2; ++n) {
      for (o[0] = s[0] - 65517, r = 1; r < 15; ++r) (o[r] = s[r] - 65535 - ((o[r - 1] >> 16) & 1)), (o[r - 1] &= 65535)
      ;(o[15] = s[15] - 32767 - ((o[14] >> 16) & 1)), (i = (o[15] >> 16) & 1), (o[14] &= 65535), YZ(s, o, 1 - i)
    }
    for (r = 0; r < 16; r++) (t[2 * r] = s[r] & 255), (t[2 * r + 1] = s[r] >> 8)
  }
  function ZNe(t, e) {
    var r = ht(),
      n = ht(),
      i = ht(),
      o = ht(),
      s = ht(),
      a = ht(),
      l = ht()
    return (
      Pf(t[2], MA),
      eke(t[1], e),
      _g(i, t[1]),
      Fr(o, i, WNe),
      C_(i, i, t[2]),
      S_(o, t[2], o),
      _g(s, o),
      _g(a, s),
      Fr(l, a, s),
      Fr(r, l, i),
      Fr(r, r, o),
      tke(r, r),
      Fr(r, r, i),
      Fr(r, r, o),
      Fr(r, r, o),
      Fr(t[0], r, o),
      _g(n, t[0]),
      Fr(n, n, o),
      GZ(n, i) && Fr(t[0], t[0], YNe),
      _g(n, t[0]),
      Fr(n, n, o),
      GZ(n, i) ? -1 : (WZ(t[0]) === e[31] >> 7 && C_(t[0], _M, t[0]), Fr(t[3], t[0], t[1]), 0)
    )
  }
  function eke(t, e) {
    var r
    for (r = 0; r < 16; ++r) t[r] = e[2 * r] + (e[2 * r + 1] << 8)
    t[15] &= 32767
  }
  function tke(t, e) {
    var r = ht(),
      n
    for (n = 0; n < 16; ++n) r[n] = e[n]
    for (n = 250; n >= 0; --n) _g(r, r), n !== 1 && Fr(r, r, e)
    for (n = 0; n < 16; ++n) t[n] = r[n]
  }
  function GZ(t, e) {
    var r = new Ts(32),
      n = new Ts(32)
    return FA(r, t), FA(n, e), $Z(r, 0, n, 0)
  }
  function $Z(t, e, r, n) {
    return rke(t, e, r, n, 32)
  }
  function rke(t, e, r, n, i) {
    var o,
      s = 0
    for (o = 0; o < i; ++o) s |= t[e + o] ^ r[n + o]
    return (1 & ((s - 1) >>> 8)) - 1
  }
  function WZ(t) {
    var e = new Ts(32)
    return FA(e, t), e[0] & 1
  }
  function KZ(t, e, r) {
    var n, i
    for (Pf(t[0], _M), Pf(t[1], MA), Pf(t[2], MA), Pf(t[3], _M), i = 255; i >= 0; --i)
      (n = (r[(i / 8) | 0] >> (i & 7)) & 1), jZ(t, e, n), xM(e, t), xM(t, t), jZ(t, e, n)
  }
  function EM(t, e) {
    var r = [ht(), ht(), ht(), ht()]
    Pf(r[0], qZ), Pf(r[1], HZ), Pf(r[2], MA), Fr(r[3], qZ, HZ), KZ(t, r, e)
  }
  function Pf(t, e) {
    var r
    for (r = 0; r < 16; r++) t[r] = e[r] | 0
  }
  function nke(t, e) {
    var r = ht(),
      n
    for (n = 0; n < 16; ++n) r[n] = e[n]
    for (n = 253; n >= 0; --n) _g(r, r), n !== 2 && n !== 4 && Fr(r, r, e)
    for (n = 0; n < 16; ++n) t[n] = r[n]
  }
  function gM(t) {
    var e,
      r,
      n = 1
    for (e = 0; e < 16; ++e) (r = t[e] + n + 65535), (n = Math.floor(r / 65536)), (t[e] = r - n * 65536)
    t[0] += n - 1 + 37 * (n - 1)
  }
  function YZ(t, e, r) {
    for (var n, i = ~(r - 1), o = 0; o < 16; ++o) (n = i & (t[o] ^ e[o])), (t[o] ^= n), (e[o] ^= n)
  }
  function ht(t) {
    var e,
      r = new Float64Array(16)
    if (t) for (e = 0; e < t.length; ++e) r[e] = t[e]
    return r
  }
  function S_(t, e, r) {
    for (var n = 0; n < 16; ++n) t[n] = e[n] + r[n]
  }
  function C_(t, e, r) {
    for (var n = 0; n < 16; ++n) t[n] = e[n] - r[n]
  }
  function _g(t, e) {
    Fr(t, e, e)
  }
  function Fr(t, e, r) {
    var n,
      i,
      o = 0,
      s = 0,
      a = 0,
      l = 0,
      c = 0,
      u = 0,
      p = 0,
      d = 0,
      f = 0,
      m = 0,
      h = 0,
      g = 0,
      v = 0,
      _ = 0,
      y = 0,
      b = 0,
      x = 0,
      P = 0,
      U = 0,
      H = 0,
      j = 0,
      M = 0,
      F = 0,
      z = 0,
      q = 0,
      L = 0,
      S = 0,
      T = 0,
      A = 0,
      X = 0,
      fe = 0,
      ce = r[0],
      oe = r[1],
      ae = r[2],
      je = r[3],
      Ye = r[4],
      Ze = r[5],
      ke = r[6],
      st = r[7],
      tt = r[8],
      ve = r[9],
      W = r[10],
      ne = r[11],
      ye = r[12],
      Te = r[13],
      Ne = r[14],
      qe = r[15]
    ;(n = e[0]),
      (o += n * ce),
      (s += n * oe),
      (a += n * ae),
      (l += n * je),
      (c += n * Ye),
      (u += n * Ze),
      (p += n * ke),
      (d += n * st),
      (f += n * tt),
      (m += n * ve),
      (h += n * W),
      (g += n * ne),
      (v += n * ye),
      (_ += n * Te),
      (y += n * Ne),
      (b += n * qe),
      (n = e[1]),
      (s += n * ce),
      (a += n * oe),
      (l += n * ae),
      (c += n * je),
      (u += n * Ye),
      (p += n * Ze),
      (d += n * ke),
      (f += n * st),
      (m += n * tt),
      (h += n * ve),
      (g += n * W),
      (v += n * ne),
      (_ += n * ye),
      (y += n * Te),
      (b += n * Ne),
      (x += n * qe),
      (n = e[2]),
      (a += n * ce),
      (l += n * oe),
      (c += n * ae),
      (u += n * je),
      (p += n * Ye),
      (d += n * Ze),
      (f += n * ke),
      (m += n * st),
      (h += n * tt),
      (g += n * ve),
      (v += n * W),
      (_ += n * ne),
      (y += n * ye),
      (b += n * Te),
      (x += n * Ne),
      (P += n * qe),
      (n = e[3]),
      (l += n * ce),
      (c += n * oe),
      (u += n * ae),
      (p += n * je),
      (d += n * Ye),
      (f += n * Ze),
      (m += n * ke),
      (h += n * st),
      (g += n * tt),
      (v += n * ve),
      (_ += n * W),
      (y += n * ne),
      (b += n * ye),
      (x += n * Te),
      (P += n * Ne),
      (U += n * qe),
      (n = e[4]),
      (c += n * ce),
      (u += n * oe),
      (p += n * ae),
      (d += n * je),
      (f += n * Ye),
      (m += n * Ze),
      (h += n * ke),
      (g += n * st),
      (v += n * tt),
      (_ += n * ve),
      (y += n * W),
      (b += n * ne),
      (x += n * ye),
      (P += n * Te),
      (U += n * Ne),
      (H += n * qe),
      (n = e[5]),
      (u += n * ce),
      (p += n * oe),
      (d += n * ae),
      (f += n * je),
      (m += n * Ye),
      (h += n * Ze),
      (g += n * ke),
      (v += n * st),
      (_ += n * tt),
      (y += n * ve),
      (b += n * W),
      (x += n * ne),
      (P += n * ye),
      (U += n * Te),
      (H += n * Ne),
      (j += n * qe),
      (n = e[6]),
      (p += n * ce),
      (d += n * oe),
      (f += n * ae),
      (m += n * je),
      (h += n * Ye),
      (g += n * Ze),
      (v += n * ke),
      (_ += n * st),
      (y += n * tt),
      (b += n * ve),
      (x += n * W),
      (P += n * ne),
      (U += n * ye),
      (H += n * Te),
      (j += n * Ne),
      (M += n * qe),
      (n = e[7]),
      (d += n * ce),
      (f += n * oe),
      (m += n * ae),
      (h += n * je),
      (g += n * Ye),
      (v += n * Ze),
      (_ += n * ke),
      (y += n * st),
      (b += n * tt),
      (x += n * ve),
      (P += n * W),
      (U += n * ne),
      (H += n * ye),
      (j += n * Te),
      (M += n * Ne),
      (F += n * qe),
      (n = e[8]),
      (f += n * ce),
      (m += n * oe),
      (h += n * ae),
      (g += n * je),
      (v += n * Ye),
      (_ += n * Ze),
      (y += n * ke),
      (b += n * st),
      (x += n * tt),
      (P += n * ve),
      (U += n * W),
      (H += n * ne),
      (j += n * ye),
      (M += n * Te),
      (F += n * Ne),
      (z += n * qe),
      (n = e[9]),
      (m += n * ce),
      (h += n * oe),
      (g += n * ae),
      (v += n * je),
      (_ += n * Ye),
      (y += n * Ze),
      (b += n * ke),
      (x += n * st),
      (P += n * tt),
      (U += n * ve),
      (H += n * W),
      (j += n * ne),
      (M += n * ye),
      (F += n * Te),
      (z += n * Ne),
      (q += n * qe),
      (n = e[10]),
      (h += n * ce),
      (g += n * oe),
      (v += n * ae),
      (_ += n * je),
      (y += n * Ye),
      (b += n * Ze),
      (x += n * ke),
      (P += n * st),
      (U += n * tt),
      (H += n * ve),
      (j += n * W),
      (M += n * ne),
      (F += n * ye),
      (z += n * Te),
      (q += n * Ne),
      (L += n * qe),
      (n = e[11]),
      (g += n * ce),
      (v += n * oe),
      (_ += n * ae),
      (y += n * je),
      (b += n * Ye),
      (x += n * Ze),
      (P += n * ke),
      (U += n * st),
      (H += n * tt),
      (j += n * ve),
      (M += n * W),
      (F += n * ne),
      (z += n * ye),
      (q += n * Te),
      (L += n * Ne),
      (S += n * qe),
      (n = e[12]),
      (v += n * ce),
      (_ += n * oe),
      (y += n * ae),
      (b += n * je),
      (x += n * Ye),
      (P += n * Ze),
      (U += n * ke),
      (H += n * st),
      (j += n * tt),
      (M += n * ve),
      (F += n * W),
      (z += n * ne),
      (q += n * ye),
      (L += n * Te),
      (S += n * Ne),
      (T += n * qe),
      (n = e[13]),
      (_ += n * ce),
      (y += n * oe),
      (b += n * ae),
      (x += n * je),
      (P += n * Ye),
      (U += n * Ze),
      (H += n * ke),
      (j += n * st),
      (M += n * tt),
      (F += n * ve),
      (z += n * W),
      (q += n * ne),
      (L += n * ye),
      (S += n * Te),
      (T += n * Ne),
      (A += n * qe),
      (n = e[14]),
      (y += n * ce),
      (b += n * oe),
      (x += n * ae),
      (P += n * je),
      (U += n * Ye),
      (H += n * Ze),
      (j += n * ke),
      (M += n * st),
      (F += n * tt),
      (z += n * ve),
      (q += n * W),
      (L += n * ne),
      (S += n * ye),
      (T += n * Te),
      (A += n * Ne),
      (X += n * qe),
      (n = e[15]),
      (b += n * ce),
      (x += n * oe),
      (P += n * ae),
      (U += n * je),
      (H += n * Ye),
      (j += n * Ze),
      (M += n * ke),
      (F += n * st),
      (z += n * tt),
      (q += n * ve),
      (L += n * W),
      (S += n * ne),
      (T += n * ye),
      (A += n * Te),
      (X += n * Ne),
      (fe += n * qe),
      (o += 38 * x),
      (s += 38 * P),
      (a += 38 * U),
      (l += 38 * H),
      (c += 38 * j),
      (u += 38 * M),
      (p += 38 * F),
      (d += 38 * z),
      (f += 38 * q),
      (m += 38 * L),
      (h += 38 * S),
      (g += 38 * T),
      (v += 38 * A),
      (_ += 38 * X),
      (y += 38 * fe),
      (i = 1),
      (n = o + i + 65535),
      (i = Math.floor(n / 65536)),
      (o = n - i * 65536),
      (n = s + i + 65535),
      (i = Math.floor(n / 65536)),
      (s = n - i * 65536),
      (n = a + i + 65535),
      (i = Math.floor(n / 65536)),
      (a = n - i * 65536),
      (n = l + i + 65535),
      (i = Math.floor(n / 65536)),
      (l = n - i * 65536),
      (n = c + i + 65535),
      (i = Math.floor(n / 65536)),
      (c = n - i * 65536),
      (n = u + i + 65535),
      (i = Math.floor(n / 65536)),
      (u = n - i * 65536),
      (n = p + i + 65535),
      (i = Math.floor(n / 65536)),
      (p = n - i * 65536),
      (n = d + i + 65535),
      (i = Math.floor(n / 65536)),
      (d = n - i * 65536),
      (n = f + i + 65535),
      (i = Math.floor(n / 65536)),
      (f = n - i * 65536),
      (n = m + i + 65535),
      (i = Math.floor(n / 65536)),
      (m = n - i * 65536),
      (n = h + i + 65535),
      (i = Math.floor(n / 65536)),
      (h = n - i * 65536),
      (n = g + i + 65535),
      (i = Math.floor(n / 65536)),
      (g = n - i * 65536),
      (n = v + i + 65535),
      (i = Math.floor(n / 65536)),
      (v = n - i * 65536),
      (n = _ + i + 65535),
      (i = Math.floor(n / 65536)),
      (_ = n - i * 65536),
      (n = y + i + 65535),
      (i = Math.floor(n / 65536)),
      (y = n - i * 65536),
      (n = b + i + 65535),
      (i = Math.floor(n / 65536)),
      (b = n - i * 65536),
      (o += i - 1 + 37 * (i - 1)),
      (i = 1),
      (n = o + i + 65535),
      (i = Math.floor(n / 65536)),
      (o = n - i * 65536),
      (n = s + i + 65535),
      (i = Math.floor(n / 65536)),
      (s = n - i * 65536),
      (n = a + i + 65535),
      (i = Math.floor(n / 65536)),
      (a = n - i * 65536),
      (n = l + i + 65535),
      (i = Math.floor(n / 65536)),
      (l = n - i * 65536),
      (n = c + i + 65535),
      (i = Math.floor(n / 65536)),
      (c = n - i * 65536),
      (n = u + i + 65535),
      (i = Math.floor(n / 65536)),
      (u = n - i * 65536),
      (n = p + i + 65535),
      (i = Math.floor(n / 65536)),
      (p = n - i * 65536),
      (n = d + i + 65535),
      (i = Math.floor(n / 65536)),
      (d = n - i * 65536),
      (n = f + i + 65535),
      (i = Math.floor(n / 65536)),
      (f = n - i * 65536),
      (n = m + i + 65535),
      (i = Math.floor(n / 65536)),
      (m = n - i * 65536),
      (n = h + i + 65535),
      (i = Math.floor(n / 65536)),
      (h = n - i * 65536),
      (n = g + i + 65535),
      (i = Math.floor(n / 65536)),
      (g = n - i * 65536),
      (n = v + i + 65535),
      (i = Math.floor(n / 65536)),
      (v = n - i * 65536),
      (n = _ + i + 65535),
      (i = Math.floor(n / 65536)),
      (_ = n - i * 65536),
      (n = y + i + 65535),
      (i = Math.floor(n / 65536)),
      (y = n - i * 65536),
      (n = b + i + 65535),
      (i = Math.floor(n / 65536)),
      (b = n - i * 65536),
      (o += i - 1 + 37 * (i - 1)),
      (t[0] = o),
      (t[1] = s),
      (t[2] = a),
      (t[3] = l),
      (t[4] = c),
      (t[5] = u),
      (t[6] = p),
      (t[7] = d),
      (t[8] = f),
      (t[9] = m),
      (t[10] = h),
      (t[11] = g),
      (t[12] = v),
      (t[13] = _),
      (t[14] = y),
      (t[15] = b)
  }
})
var tee = handleExports((dgt, eee) => {
  var ua = Mt()
  cr()
  Fa()
  zb()
  eee.exports = ua.kem = ua.kem || {}
  var JZ = ua.jsbn.BigInteger
  ua.kem.rsa = {}
  ua.kem.rsa.create = function (t, e) {
    e = e || {}
    var r = e.prng || ua.random,
      n = {}
    return (
      (n.encrypt = function (i, o) {
        var s = Math.ceil(i.n.bitLength() / 8),
          a
        do a = new JZ(ua.util.bytesToHex(r.getBytesSync(s)), 16).mod(i.n)
        while (a.compareTo(JZ.ONE) <= 0)
        a = ua.util.hexToBytes(a.toString(16))
        var l = s - a.length
        l > 0 && (a = ua.util.fillString(String.fromCharCode(0), l) + a)
        var c = i.encrypt(a, 'NONE'),
          u = t.generate(a, o)
        return { encapsulation: c, key: u }
      }),
      (n.decrypt = function (i, o, s) {
        var a = i.decrypt(o, 'NONE')
        return t.generate(a, s)
      }),
      n
    )
  }
  ua.kem.kdf1 = function (t, e) {
    ZZ(this, t, 0, e || t.digestLength)
  }
  ua.kem.kdf2 = function (t, e) {
    ZZ(this, t, 1, e || t.digestLength)
  }
  function ZZ(t, e, r, n) {
    t.generate = function (i, o) {
      for (
        var s = new ua.util.ByteBuffer(), a = Math.ceil(o / n) + r, l = new ua.util.ByteBuffer(), c = r;
        c < a;
        ++c
      ) {
        l.putInt32(c), e.start(), e.update(i + l.getBytes())
        var u = e.digest()
        s.putBytes(u.getBytes(n))
      }
      return s.truncate(s.length() - o), s.getBytes()
    }
  }
})
var oee = handleExports((fgt, iee) => {
  var Kt = Mt()
  cr()
  iee.exports = Kt.log = Kt.log || {}
  Kt.log.levels = ['none', 'error', 'warning', 'info', 'debug', 'verbose', 'max']
  var UA = {},
    CM = [],
    Jb = null
  Kt.log.LEVEL_LOCKED = 2
  Kt.log.NO_LEVEL_CHECK = 4
  Kt.log.INTERPOLATE = 8
  for (Gl = 0; Gl < Kt.log.levels.length; ++Gl)
    (TM = Kt.log.levels[Gl]), (UA[TM] = { index: Gl, name: TM.toUpperCase() })
  var TM, Gl
  Kt.log.logMessage = function (t) {
    for (var e = UA[t.level].index, r = 0; r < CM.length; ++r) {
      var n = CM[r]
      if (n.flags & Kt.log.NO_LEVEL_CHECK) n.f(t)
      else {
        var i = UA[n.level].index
        e <= i && n.f(n, t)
      }
    }
  }
  Kt.log.prepareStandard = function (t) {
    'standard' in t || (t.standard = UA[t.level].name + ' [' + t.category + '] ' + t.message)
  }
  Kt.log.prepareFull = function (t) {
    if (!('full' in t)) {
      var e = [t.message]
      ;(e = e.concat([])), (t.full = Kt.util.format.apply(this, e))
    }
  }
  Kt.log.prepareStandardFull = function (t) {
    'standardFull' in t || (Kt.log.prepareStandard(t), (t.standardFull = t.standard))
  }
  for (SM = ['error', 'warning', 'info', 'debug', 'verbose'], Gl = 0; Gl < SM.length; ++Gl)
    (function (e) {
      Kt.log[e] = function (r, n) {
        var i = Array.prototype.slice.call(arguments).slice(2),
          o = { timestamp: new Date(), level: e, category: r, message: n, arguments: i }
        Kt.log.logMessage(o)
      }
    })(SM[Gl])
  var SM, Gl
  Kt.log.makeLogger = function (t) {
    var e = { flags: 0, f: t }
    return Kt.log.setLevel(e, 'none'), e
  }
  Kt.log.setLevel = function (t, e) {
    var r = !1
    if (t && !(t.flags & Kt.log.LEVEL_LOCKED))
      for (var n = 0; n < Kt.log.levels.length; ++n) {
        var i = Kt.log.levels[n]
        if (e == i) {
          ;(t.level = e), (r = !0)
          break
        }
      }
    return r
  }
  Kt.log.lock = function (t, e) {
    typeof e > 'u' || e ? (t.flags |= Kt.log.LEVEL_LOCKED) : (t.flags &= ~Kt.log.LEVEL_LOCKED)
  }
  Kt.log.addLogger = function (t) {
    CM.push(t)
  }
  typeof console < 'u' && 'log' in console
    ? (console.error && console.warn && console.info && console.debug
        ? ((ree = {
            error: console.error,
            warning: console.warn,
            info: console.info,
            debug: console.debug,
            verbose: console.debug,
          }),
          (Zb = function (t, e) {
            Kt.log.prepareStandard(e)
            var r = ree[e.level],
              n = [e.standard]
            ;(n = n.concat(e.arguments.slice())), r.apply(console, n)
          }),
          (I_ = Kt.log.makeLogger(Zb)))
        : ((Zb = function (e, r) {
            Kt.log.prepareStandardFull(r), console.log(r.standardFull)
          }),
          (I_ = Kt.log.makeLogger(Zb))),
      Kt.log.setLevel(I_, 'debug'),
      Kt.log.addLogger(I_),
      (Jb = I_))
    : (console = { log: function () {} })
  var I_, ree, Zb
  Jb !== null &&
    typeof window < 'u' &&
    window.location &&
    ((Xb = new URL(window.location.href).searchParams),
    Xb.has('console.level') && Kt.log.setLevel(Jb, Xb.get('console.level').slice(-1)[0]),
    Xb.has('console.lock') && ((nee = Xb.get('console.lock').slice(-1)[0]), nee == 'true' && Kt.log.lock(Jb)))
  var Xb, nee
  Kt.log.consoleLogger = Jb
})
var aee = handleExports((mgt, see) => {
  see.exports = Ll()
  vA()
  y_()
  U8()
  fM()
})
var uee = handleExports((hgt, lee) => {
  var Be = Mt()
  Tf()
  Lc()
  Gb()
  Sf()
  pg()
  J8()
  Fa()
  cr()
  PA()
  var J = Be.asn1,
    Yo = (lee.exports = Be.pkcs7 = Be.pkcs7 || {})
  Yo.messageFromPem = function (t) {
    var e = Be.pem.decode(t)[0]
    if (e.type !== 'PKCS7') {
      var r = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".')
      throw ((r.headerType = e.type), r)
    }
    if (e.procType && e.procType.type === 'ENCRYPTED')
      throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.')
    var n = J.fromDer(e.body)
    return Yo.messageFromAsn1(n)
  }
  Yo.messageToPem = function (t, e) {
    var r = { type: 'PKCS7', body: J.toDer(t.toAsn1()).getBytes() }
    return Be.pem.encode(r, { maxline: e })
  }
  Yo.messageFromAsn1 = function (t) {
    var e = {},
      r = []
    if (!J.validate(t, Yo.asn1.contentInfoValidator, e, r)) {
      var n = new Error('Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.')
      throw ((n.errors = r), n)
    }
    var i = J.derToOid(e.contentType),
      o
    switch (i) {
      case Be.pki.oids.envelopedData:
        o = Yo.createEnvelopedData()
        break
      case Be.pki.oids.encryptedData:
        o = Yo.createEncryptedData()
        break
      case Be.pki.oids.signedData:
        o = Yo.createSignedData()
        break
      default:
        throw new Error('Cannot read PKCS#7 message. ContentType with OID ' + i + ' is not (yet) supported.')
    }
    return o.fromAsn1(e.content.value[0]), o
  }
  Yo.createSignedData = function () {
    var t = null
    return (
      (t = {
        type: Be.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function (n) {
          if (
            (wM(t, n, Yo.asn1.signedDataValidator),
            (t.certificates = []),
            (t.crls = []),
            (t.digestAlgorithmIdentifiers = []),
            (t.contentInfo = null),
            (t.signerInfos = []),
            t.rawCapture.certificates)
          )
            for (var i = t.rawCapture.certificates.value, o = 0; o < i.length; ++o)
              t.certificates.push(Be.pki.certificateFromAsn1(i[o]))
        },
        toAsn1: function () {
          t.contentInfo || t.sign()
          for (var n = [], i = 0; i < t.certificates.length; ++i) n.push(Be.pki.certificateToAsn1(t.certificates[i]))
          var o = [],
            s = J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, [
              J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
                J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, J.integerToDer(t.version).getBytes()),
                J.create(J.Class.UNIVERSAL, J.Type.SET, !0, t.digestAlgorithmIdentifiers),
                t.contentInfo,
              ]),
            ])
          return (
            n.length > 0 && s.value[0].value.push(J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, n)),
            o.length > 0 && s.value[0].value.push(J.create(J.Class.CONTEXT_SPECIFIC, 1, !0, o)),
            s.value[0].value.push(J.create(J.Class.UNIVERSAL, J.Type.SET, !0, t.signerInfos)),
            J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
              J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.type).getBytes()),
              s,
            ])
          )
        },
        addSigner: function (n) {
          var i = n.issuer,
            o = n.serialNumber
          if (n.certificate) {
            var s = n.certificate
            typeof s == 'string' && (s = Be.pki.certificateFromPem(s)), (i = s.issuer.attributes), (o = s.serialNumber)
          }
          var a = n.key
          if (!a) throw new Error('Could not add PKCS#7 signer; no private key specified.')
          typeof a == 'string' && (a = Be.pki.privateKeyFromPem(a))
          var l = n.digestAlgorithm || Be.pki.oids.sha1
          switch (l) {
            case Be.pki.oids.sha1:
            case Be.pki.oids.sha256:
            case Be.pki.oids.sha384:
            case Be.pki.oids.sha512:
            case Be.pki.oids.md5:
              break
            default:
              throw new Error('Could not add PKCS#7 signer; unknown message digest algorithm: ' + l)
          }
          var c = n.authenticatedAttributes || []
          if (c.length > 0) {
            for (var u = !1, p = !1, d = 0; d < c.length; ++d) {
              var f = c[d]
              if (!u && f.type === Be.pki.oids.contentType) {
                if (((u = !0), p)) break
                continue
              }
              if (!p && f.type === Be.pki.oids.messageDigest) {
                if (((p = !0), u)) break
                continue
              }
            }
            if (!u || !p)
              throw new Error(
                'Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.'
              )
          }
          t.signers.push({
            key: a,
            version: 1,
            issuer: i,
            serialNumber: o,
            digestAlgorithm: l,
            signatureAlgorithm: Be.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes: c,
            unauthenticatedAttributes: [],
          })
        },
        sign: function (n) {
          if (
            ((n = n || {}),
            (typeof t.content != 'object' || t.contentInfo === null) &&
              ((t.contentInfo = J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
                J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(Be.pki.oids.data).getBytes()),
              ])),
              'content' in t))
          ) {
            var i
            t.content instanceof Be.util.ByteBuffer
              ? (i = t.content.bytes())
              : typeof t.content == 'string' && (i = Be.util.encodeUtf8(t.content)),
              n.detached
                ? (t.detachedContent = J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, i))
                : t.contentInfo.value.push(
                    J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, [J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, i)])
                  )
          }
          if (t.signers.length !== 0) {
            var o = e()
            r(o)
          }
        },
        verify: function () {
          throw new Error('PKCS#7 signature verification not yet implemented.')
        },
        addCertificate: function (n) {
          typeof n == 'string' && (n = Be.pki.certificateFromPem(n)), t.certificates.push(n)
        },
        addCertificateRevokationList: function (n) {
          throw new Error('PKCS#7 CRL support not yet implemented.')
        },
      }),
      t
    )
    function e() {
      for (var n = {}, i = 0; i < t.signers.length; ++i) {
        var o = t.signers[i],
          s = o.digestAlgorithm
        s in n || (n[s] = Be.md[Be.pki.oids[s]].create()),
          o.authenticatedAttributes.length === 0 ? (o.md = n[s]) : (o.md = Be.md[Be.pki.oids[s]].create())
      }
      t.digestAlgorithmIdentifiers = []
      for (var s in n)
        t.digestAlgorithmIdentifiers.push(
          J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
            J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(s).getBytes()),
            J.create(J.Class.UNIVERSAL, J.Type.NULL, !1, ''),
          ])
        )
      return n
    }
    function r(n) {
      var i
      if ((t.detachedContent ? (i = t.detachedContent) : ((i = t.contentInfo.value[1]), (i = i.value[0])), !i))
        throw new Error('Could not sign PKCS#7 message; there is no content to sign.')
      var o = J.derToOid(t.contentInfo.value[0].value),
        s = J.toDer(i)
      s.getByte(), J.getBerValueLength(s), (s = s.getBytes())
      for (var a in n) n[a].start().update(s)
      for (var l = new Date(), c = 0; c < t.signers.length; ++c) {
        var u = t.signers[c]
        if (u.authenticatedAttributes.length === 0) {
          if (o !== Be.pki.oids.data)
            throw new Error(
              'Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.'
            )
        } else {
          u.authenticatedAttributesAsn1 = J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, [])
          for (
            var p = J.create(J.Class.UNIVERSAL, J.Type.SET, !0, []), d = 0;
            d < u.authenticatedAttributes.length;
            ++d
          ) {
            var f = u.authenticatedAttributes[d]
            f.type === Be.pki.oids.messageDigest
              ? (f.value = n[u.digestAlgorithm].digest())
              : f.type === Be.pki.oids.signingTime && (f.value || (f.value = l)),
              p.value.push(IM(f)),
              u.authenticatedAttributesAsn1.value.push(IM(f))
          }
          ;(s = J.toDer(p).getBytes()), u.md.start().update(s)
        }
        u.signature = u.key.sign(u.md, 'RSASSA-PKCS1-V1_5')
      }
      t.signerInfos = lke(t.signers)
    }
  }
  Yo.createEncryptedData = function () {
    var t = null
    return (
      (t = {
        type: Be.pki.oids.encryptedData,
        version: 0,
        encryptedContent: { algorithm: Be.pki.oids['aes256-CBC'] },
        fromAsn1: function (e) {
          wM(t, e, Yo.asn1.encryptedDataValidator)
        },
        decrypt: function (e) {
          e !== void 0 && (t.encryptedContent.key = e), cee(t)
        },
      }),
      t
    )
  }
  Yo.createEnvelopedData = function () {
    var t = null
    return (
      (t = {
        type: Be.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: { algorithm: Be.pki.oids['aes256-CBC'] },
        fromAsn1: function (e) {
          var r = wM(t, e, Yo.asn1.envelopedDataValidator)
          t.recipients = ske(r.recipientInfos.value)
        },
        toAsn1: function () {
          return J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
            J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.type).getBytes()),
            J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, [
              J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
                J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, J.integerToDer(t.version).getBytes()),
                J.create(J.Class.UNIVERSAL, J.Type.SET, !0, ake(t.recipients)),
                J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, uke(t.encryptedContent)),
              ]),
            ]),
          ])
        },
        findRecipient: function (e) {
          for (var r = e.issuer.attributes, n = 0; n < t.recipients.length; ++n) {
            var i = t.recipients[n],
              o = i.issuer
            if (i.serialNumber === e.serialNumber && o.length === r.length) {
              for (var s = !0, a = 0; a < r.length; ++a)
                if (o[a].type !== r[a].type || o[a].value !== r[a].value) {
                  s = !1
                  break
                }
              if (s) return i
            }
          }
          return null
        },
        decrypt: function (e, r) {
          if (t.encryptedContent.key === void 0 && e !== void 0 && r !== void 0)
            switch (e.encryptedContent.algorithm) {
              case Be.pki.oids.rsaEncryption:
              case Be.pki.oids.desCBC:
                var n = r.decrypt(e.encryptedContent.content)
                t.encryptedContent.key = Be.util.createBuffer(n)
                break
              default:
                throw new Error('Unsupported asymmetric cipher, OID ' + e.encryptedContent.algorithm)
            }
          cee(t)
        },
        addRecipient: function (e) {
          t.recipients.push({
            version: 0,
            issuer: e.issuer.attributes,
            serialNumber: e.serialNumber,
            encryptedContent: { algorithm: Be.pki.oids.rsaEncryption, key: e.publicKey },
          })
        },
        encrypt: function (e, r) {
          if (t.encryptedContent.content === void 0) {
            ;(r = r || t.encryptedContent.algorithm), (e = e || t.encryptedContent.key)
            var n, i, o
            switch (r) {
              case Be.pki.oids['aes128-CBC']:
                ;(n = 16), (i = 16), (o = Be.aes.createEncryptionCipher)
                break
              case Be.pki.oids['aes192-CBC']:
                ;(n = 24), (i = 16), (o = Be.aes.createEncryptionCipher)
                break
              case Be.pki.oids['aes256-CBC']:
                ;(n = 32), (i = 16), (o = Be.aes.createEncryptionCipher)
                break
              case Be.pki.oids['des-EDE3-CBC']:
                ;(n = 24), (i = 8), (o = Be.des.createEncryptionCipher)
                break
              default:
                throw new Error('Unsupported symmetric cipher, OID ' + r)
            }
            if (e === void 0) e = Be.util.createBuffer(Be.random.getBytes(n))
            else if (e.length() != n)
              throw new Error('Symmetric key has wrong length; got ' + e.length() + ' bytes, expected ' + n + '.')
            ;(t.encryptedContent.algorithm = r),
              (t.encryptedContent.key = e),
              (t.encryptedContent.parameter = Be.util.createBuffer(Be.random.getBytes(i)))
            var s = o(e)
            if ((s.start(t.encryptedContent.parameter.copy()), s.update(t.content), !s.finish()))
              throw new Error('Symmetric encryption failed.')
            t.encryptedContent.content = s.output
          }
          for (var a = 0; a < t.recipients.length; ++a) {
            var l = t.recipients[a]
            if (l.encryptedContent.content === void 0)
              switch (l.encryptedContent.algorithm) {
                case Be.pki.oids.rsaEncryption:
                  l.encryptedContent.content = l.encryptedContent.key.encrypt(t.encryptedContent.key.data)
                  break
                default:
                  throw new Error('Unsupported asymmetric cipher, OID ' + l.encryptedContent.algorithm)
              }
          }
        },
      }),
      t
    )
  }
  function ike(t) {
    var e = {},
      r = []
    if (!J.validate(t, Yo.asn1.recipientInfoValidator, e, r)) {
      var n = new Error('Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.')
      throw ((n.errors = r), n)
    }
    return {
      version: e.version.charCodeAt(0),
      issuer: Be.pki.RDNAttributesAsArray(e.issuer),
      serialNumber: Be.util.createBuffer(e.serial).toHex(),
      encryptedContent: {
        algorithm: J.derToOid(e.encAlgorithm),
        parameter: e.encParameter ? e.encParameter.value : void 0,
        content: e.encKey,
      },
    }
  }
  function oke(t) {
    return J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
      J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, J.integerToDer(t.version).getBytes()),
      J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
        Be.pki.distinguishedNameToAsn1({ attributes: t.issuer }),
        J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, Be.util.hexToBytes(t.serialNumber)),
      ]),
      J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
        J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.encryptedContent.algorithm).getBytes()),
        J.create(J.Class.UNIVERSAL, J.Type.NULL, !1, ''),
      ]),
      J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, t.encryptedContent.content),
    ])
  }
  function ske(t) {
    for (var e = [], r = 0; r < t.length; ++r) e.push(ike(t[r]))
    return e
  }
  function ake(t) {
    for (var e = [], r = 0; r < t.length; ++r) e.push(oke(t[r]))
    return e
  }
  function cke(t) {
    var e = J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
      J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, J.integerToDer(t.version).getBytes()),
      J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
        Be.pki.distinguishedNameToAsn1({ attributes: t.issuer }),
        J.create(J.Class.UNIVERSAL, J.Type.INTEGER, !1, Be.util.hexToBytes(t.serialNumber)),
      ]),
      J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
        J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.digestAlgorithm).getBytes()),
        J.create(J.Class.UNIVERSAL, J.Type.NULL, !1, ''),
      ]),
    ])
    if (
      (t.authenticatedAttributesAsn1 && e.value.push(t.authenticatedAttributesAsn1),
      e.value.push(
        J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
          J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.signatureAlgorithm).getBytes()),
          J.create(J.Class.UNIVERSAL, J.Type.NULL, !1, ''),
        ])
      ),
      e.value.push(J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, t.signature)),
      t.unauthenticatedAttributes.length > 0)
    ) {
      for (var r = J.create(J.Class.CONTEXT_SPECIFIC, 1, !0, []), n = 0; n < t.unauthenticatedAttributes.length; ++n) {
        var i = t.unauthenticatedAttributes[n]
        r.values.push(IM(i))
      }
      e.value.push(r)
    }
    return e
  }
  function lke(t) {
    for (var e = [], r = 0; r < t.length; ++r) e.push(cke(t[r]))
    return e
  }
  function IM(t) {
    var e
    if (t.type === Be.pki.oids.contentType)
      e = J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.value).getBytes())
    else if (t.type === Be.pki.oids.messageDigest)
      e = J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, t.value.bytes())
    else if (t.type === Be.pki.oids.signingTime) {
      var r = new Date('1950-01-01T00:00:00Z'),
        n = new Date('2050-01-01T00:00:00Z'),
        i = t.value
      if (typeof i == 'string') {
        var o = Date.parse(i)
        isNaN(o) ? (i.length === 13 ? (i = J.utcTimeToDate(i)) : (i = J.generalizedTimeToDate(i))) : (i = new Date(o))
      }
      i >= r && i < n
        ? (e = J.create(J.Class.UNIVERSAL, J.Type.UTCTIME, !1, J.dateToUtcTime(i)))
        : (e = J.create(J.Class.UNIVERSAL, J.Type.GENERALIZEDTIME, !1, J.dateToGeneralizedTime(i)))
    }
    return J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
      J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.type).getBytes()),
      J.create(J.Class.UNIVERSAL, J.Type.SET, !0, [e]),
    ])
  }
  function uke(t) {
    return [
      J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(Be.pki.oids.data).getBytes()),
      J.create(J.Class.UNIVERSAL, J.Type.SEQUENCE, !0, [
        J.create(J.Class.UNIVERSAL, J.Type.OID, !1, J.oidToDer(t.algorithm).getBytes()),
        t.parameter ? J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, t.parameter.getBytes()) : void 0,
      ]),
      J.create(J.Class.CONTEXT_SPECIFIC, 0, !0, [
        J.create(J.Class.UNIVERSAL, J.Type.OCTETSTRING, !1, t.content.getBytes()),
      ]),
    ]
  }
  function wM(t, e, r) {
    var n = {},
      i = []
    if (!J.validate(e, r, n, i)) {
      var o = new Error('Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.')
      throw ((o.errors = o), o)
    }
    var s = J.derToOid(n.contentType)
    if (s !== Be.pki.oids.data) throw new Error('Unsupported PKCS#7 message. Only wrapped ContentType Data supported.')
    if (n.encryptedContent) {
      var a = ''
      if (Be.util.isArray(n.encryptedContent))
        for (var l = 0; l < n.encryptedContent.length; ++l) {
          if (n.encryptedContent[l].type !== J.Type.OCTETSTRING)
            throw new Error(
              'Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.'
            )
          a += n.encryptedContent[l].value
        }
      else a = n.encryptedContent
      t.encryptedContent = {
        algorithm: J.derToOid(n.encAlgorithm),
        parameter: Be.util.createBuffer(n.encParameter.value),
        content: Be.util.createBuffer(a),
      }
    }
    if (n.content) {
      var a = ''
      if (Be.util.isArray(n.content))
        for (var l = 0; l < n.content.length; ++l) {
          if (n.content[l].type !== J.Type.OCTETSTRING)
            throw new Error('Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.')
          a += n.content[l].value
        }
      else a = n.content
      t.content = Be.util.createBuffer(a)
    }
    return (t.version = n.version.charCodeAt(0)), (t.rawCapture = n), n
  }
  function cee(t) {
    if (t.encryptedContent.key === void 0) throw new Error('Symmetric key not available.')
    if (t.content === void 0) {
      var e
      switch (t.encryptedContent.algorithm) {
        case Be.pki.oids['aes128-CBC']:
        case Be.pki.oids['aes192-CBC']:
        case Be.pki.oids['aes256-CBC']:
          e = Be.aes.createDecryptionCipher(t.encryptedContent.key)
          break
        case Be.pki.oids.desCBC:
        case Be.pki.oids['des-EDE3-CBC']:
          e = Be.des.createDecryptionCipher(t.encryptedContent.key)
          break
        default:
          throw new Error('Unsupported symmetric cipher, OID ' + t.encryptedContent.algorithm)
      }
      if ((e.start(t.encryptedContent.parameter), e.update(t.encryptedContent.content), !e.finish()))
        throw new Error('Symmetric decryption failed.')
      t.content = e.output
    }
  }
})
var dee = handleExports((ggt, pee) => {
  var ii = Mt()
  Tf()
  h_()
  vA()
  y_()
  cr()
  var qA = (pee.exports = ii.ssh = ii.ssh || {})
  qA.privateKeyToPutty = function (t, e, r) {
    ;(r = r || ''), (e = e || '')
    var n = 'ssh-rsa',
      i = e === '' ? 'none' : 'aes256-cbc',
      o =
        'PuTTY-User-Key-File-2: ' +
        n +
        `\r
`
    ;(o +=
      'Encryption: ' +
      i +
      `\r
`),
      (o +=
        'Comment: ' +
        r +
        `\r
`)
    var s = ii.util.createBuffer()
    w_(s, n), Vl(s, t.e), Vl(s, t.n)
    var a = ii.util.encode64(s.bytes(), 64),
      l = Math.floor(a.length / 66) + 1
    ;(o +=
      'Public-Lines: ' +
      l +
      `\r
`),
      (o += a)
    var c = ii.util.createBuffer()
    Vl(c, t.d), Vl(c, t.p), Vl(c, t.q), Vl(c, t.qInv)
    var u
    if (!e) u = ii.util.encode64(c.bytes(), 64)
    else {
      var p = c.length() + 16 - 1
      p -= p % 16
      var d = BA(c.bytes())
      d.truncate(d.length() - p + c.length()), c.putBuffer(d)
      var f = ii.util.createBuffer()
      f.putBuffer(BA('\0\0\0\0', e)), f.putBuffer(BA('\0\0\0', e))
      var m = ii.aes.createEncryptionCipher(f.truncate(8), 'CBC')
      m.start(ii.util.createBuffer().fillWithByte(0, 16)), m.update(c.copy()), m.finish()
      var h = m.output
      h.truncate(16), (u = ii.util.encode64(h.bytes(), 64))
    }
    ;(l = Math.floor(u.length / 66) + 1),
      (o +=
        `\r
Private-Lines: ` +
        l +
        `\r
`),
      (o += u)
    var g = BA('putty-private-key-file-mac-key', e),
      v = ii.util.createBuffer()
    w_(v, n), w_(v, i), w_(v, r), v.putInt32(s.length()), v.putBuffer(s), v.putInt32(c.length()), v.putBuffer(c)
    var _ = ii.hmac.create()
    return (
      _.start('sha1', g),
      _.update(v.bytes()),
      (o +=
        `\r
Private-MAC: ` +
        _.digest().toHex() +
        `\r
`),
      o
    )
  }
  qA.publicKeyToOpenSSH = function (t, e) {
    var r = 'ssh-rsa'
    e = e || ''
    var n = ii.util.createBuffer()
    return w_(n, r), Vl(n, t.e), Vl(n, t.n), r + ' ' + ii.util.encode64(n.bytes()) + ' ' + e
  }
  qA.privateKeyToOpenSSH = function (t, e) {
    return e ? ii.pki.encryptRsaPrivateKey(t, e, { legacy: !0, algorithm: 'aes128' }) : ii.pki.privateKeyToPem(t)
  }
  qA.getPublicKeyFingerprint = function (t, e) {
    e = e || {}
    var r = e.md || ii.md.md5.create(),
      n = 'ssh-rsa',
      i = ii.util.createBuffer()
    w_(i, n), Vl(i, t.e), Vl(i, t.n), r.start(), r.update(i.getBytes())
    var o = r.digest()
    if (e.encoding === 'hex') {
      var s = o.toHex()
      return e.delimiter ? s.match(/.{2}/g).join(e.delimiter) : s
    } else {
      if (e.encoding === 'binary') return o.getBytes()
      if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".')
    }
    return o
  }
  function Vl(t, e) {
    var r = e.toString(16)
    r[0] >= '8' && (r = '00' + r)
    var n = ii.util.hexToBytes(r)
    t.putInt32(n.length), t.putBytes(n)
  }
  function w_(t, e) {
    t.putInt32(e.length), t.putString(e)
  }
  function BA() {
    for (var t = ii.md.sha1.create(), e = arguments.length, r = 0; r < e; ++r) t.update(arguments[r])
    return t.digest()
  }
})
var mee = handleExports((vgt, fee) => {
  fee.exports = Mt()
  Tf()
  kZ()
  Lc()
  uA()
  Gb()
  XZ()
  h_()
  tee()
  oee()
  aee()
  Z8()
  bA()
  pg()
  W8()
  rM()
  uee()
  iM()
  Y8()
  B8()
  AA()
  Fa()
  j8()
  dee()
  uM()
  cr()
})
var hee = handleExports((_gt, pke) => {
  pke.exports = {
    name: '@roamhq/mac-ca',
    version: '1.0.7',
    description: 'Get Mac OS Root certificates',
    main: 'index.js',
    repository: { type: 'git', url: 'https://github.com/WonderInventions/mac-ca.git' },
    scripts: { test: 'echo "Error: no test specified" && exit 1', lint: 'eslint .' },
    license: 'BSD-3-Clause',
    dependencies: { 'node-forge': '^1.3.1' },
    devDependencies: { eslint: '^8.22.0' },
  }
})
var _ee = handleExports((ygt, AM) => {
  var jA = mee(),
    gee = hee(),
    HA = (AM.exports.validFormats = { der: 0, pem: 1, txt: 2, asn1: 3 })
  function vee(t) {
    let e = jA.pki.pemToDer(t),
      r = jA.asn1,
      n = r.fromDer(e.data.toString('binary')).value[0].value,
      i = n[0],
      o = i.tagClass === r.Class.CONTEXT_SPECIFIC && i.type === 0 && i.constructed,
      s = n.slice(o)
    return { serial: s[0], issuer: s[2], valid: s[3], subject: s[4] }
  }
  function dke(t) {
    let e = vee(t),
      r = new Date(),
      n = e.subject.value.map(s => s.value[0].value[1].value).join('/'),
      i = e.valid.value.map(s => s.value).join(' - '),
      o = r.toTimeString().replace(/\s*\(.*\)\s*/, '')
    return [`Subject	${n}`, `Valid	${i}`, `Saved	${r.toLocaleDateString()} ${o} by ${gee.name}@${gee.version}`, String(t)]
      .join(`
`)
  }
  AM.exports.transform = function (t) {
    return function (e) {
      try {
        switch (t) {
          case HA.der:
            return jA.pki.pemToDer(e)
          case HA.pem:
            return e
          case HA.txt:
            return dke(e)
          case HA.asn1:
            return vee(e)
          default:
            return jA.pki.certificateFromPem(e)
        }
      } catch {
        return
      }
    }
  }
})
var macCa = handleExports((xgt, A_) => {
  var https = require('https'),
    DM = _ee()
  if (process.platform !== 'darwin') (A_.exports.all = () => []), (A_.exports.each = () => {})
  else {
    let a = function (c, u, p) {
      return p.indexOf(c) === u
    }
    fke = a
    let t = require('child_process'),
      e = /(?=-----BEGIN\sCERTIFICATE-----)/g,
      r = '/System/Library/Keychains/SystemRootCertificates.keychain',
      n = ['find-certificate', '-a', '-p'],
      i = t.spawnSync('/usr/bin/security', n).stdout.toString().split(e),
      o = t.spawnSync('/usr/bin/security', n.concat(r)).stdout.toString().split(e)
    https.globalAgent.options.ca = https.globalAgent.options.ca || []
    let s = https.globalAgent.options.ca,
      l = i.concat(o)
    l.filter(a).forEach(c => s.push(c)),
      (A_.exports.der2 = DM.validFormats),
      (A_.exports.all = function (c) {
        return l.map(DM.transform(c)).filter(u => u)
      }),
      (A_.exports.each = function (c, u) {
        return (
          typeof c == 'function' && ((u = c), (c = void 0)),
          l
            .map(DM.transform(c))
            .filter(p => p)
            .forEach(u)
        )
      })
  }
  var fke
})
var Hee = handleExports((Mvt, qee) => {
  function Nee(t) {
    return Array.isArray(t) ? t : [t]
  }
  var Mee = '',
    kee = ' ',
    QM = '\\',
    Cke = /^\s+$/,
    Ike = /(?:[^\\]|^)\\$/,
    wke = /^\\!/,
    Ake = /^\\#/,
    Rke = /\r?\n/g,
    Dke = /^\.*\/|^\.+$/,
    XM = '/',
    Fee = 'node-ignore'
  typeof Symbol < 'u' && (Fee = Symbol.for('node-ignore'))
  var Oee = Fee,
    Pke = (t, e, r) => Object.defineProperty(t, e, { value: r }),
    Nke = /([0-z])-([0-z])/g,
    Uee = () => !1,
    kke = t => t.replace(Nke, (e, r, n) => (r.charCodeAt(0) <= n.charCodeAt(0) ? e : Mee)),
    Oke = t => {
      let { length: e } = t
      return t.slice(0, e - (e % 2))
    },
    Lke = [
      [/\\?\s+$/, t => (t.indexOf('\\') === 0 ? kee : Mee)],
      [/\\\s/g, () => kee],
      [/[\\$.|*+(){^]/g, t => `\\${t}`],
      [/(?!\\)\?/g, () => '[^/]'],
      [/^\//, () => '^'],
      [/\//g, () => '\\/'],
      [/^\^*\\\*\\\*\\\//, () => '^(?:.*\\/)?'],
      [
        /^(?=[^^])/,
        function () {
          return /\/(?!$)/.test(this) ? '^' : '(?:^|\\/)'
        },
      ],
      [/\\\/\\\*\\\*(?=\\\/|$)/g, (t, e, r) => (e + 6 < r.length ? '(?:\\/[^\\/]+)*' : '\\/.+')],
      [
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        (t, e, r) => {
          let n = r.replace(/\\\*/g, '[^\\/]*')
          return e + n
        },
      ],
      [/\\\\\\(?=[$.|*+(){^])/g, () => QM],
      [/\\\\/g, () => QM],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (t, e, r, n, i) =>
          e === QM ? `\\[${r}${Oke(n)}${i}` : i === ']' && n.length % 2 === 0 ? `[${kke(r)}${n}]` : '[]',
      ],
      [/(?:[^*])$/, t => (/\/$/.test(t) ? `${t}$` : `${t}(?=$|\\/$)`)],
      [/(\^|\\\/)?\\\*$/, (t, e) => `${e ? `${e}[^/]+` : '[^/]*'}(?=$|\\/$)`],
    ],
    Lee = Object.create(null),
    Mke = (t, e) => {
      let r = Lee[t]
      return (
        r || ((r = Lke.reduce((n, i) => n.replace(i[0], i[1].bind(t)), t)), (Lee[t] = r)),
        e ? new RegExp(r, 'i') : new RegExp(r)
      )
    },
    e6 = t => typeof t == 'string',
    Fke = t => t && e6(t) && !Cke.test(t) && !Ike.test(t) && t.indexOf('#') !== 0,
    Uke = t => t.split(Rke),
    JM = class {
      constructor(e, r, n, i) {
        ;(this.origin = e), (this.pattern = r), (this.negative = n), (this.regex = i)
      }
    },
    Bke = (t, e) => {
      let r = t,
        n = !1
      t.indexOf('!') === 0 && ((n = !0), (t = t.substr(1))), (t = t.replace(wke, '!').replace(Ake, '#'))
      let i = Mke(t, e)
      return new JM(r, t, n, i)
    },
    qke = (t, e) => {
      throw new e(t)
    },
    yp = (t, e, r) =>
      e6(t)
        ? t
          ? yp.isNotRelative(t)
            ? r(`path should be a \`path.relative()\`d string, but got "${e}"`, RangeError)
            : !0
          : r('path must not be empty', TypeError)
        : r(`path must be a string, but got \`${e}\``, TypeError),
    Bee = t => Dke.test(t)
  yp.isNotRelative = Bee
  yp.convert = t => t
  var ZM = class {
      constructor({ ignorecase: e = !0, ignoreCase: r = e, allowRelativePaths: n = !1 } = {}) {
        Pke(this, Oee, !0),
          (this._rules = []),
          (this._ignoreCase = r),
          (this._allowRelativePaths = n),
          this._initCache()
      }
      _initCache() {
        ;(this._ignoreCache = Object.create(null)), (this._testCache = Object.create(null))
      }
      _addPattern(e) {
        if (e && e[Oee]) {
          ;(this._rules = this._rules.concat(e._rules)), (this._added = !0)
          return
        }
        if (Fke(e)) {
          let r = Bke(e, this._ignoreCase)
          ;(this._added = !0), this._rules.push(r)
        }
      }
      add(e) {
        return (
          (this._added = !1),
          Nee(e6(e) ? Uke(e) : e).forEach(this._addPattern, this),
          this._added && this._initCache(),
          this
        )
      }
      addPattern(e) {
        return this.add(e)
      }
      _testOne(e, r) {
        let n = !1,
          i = !1
        return (
          this._rules.forEach(o => {
            let { negative: s } = o
            if ((i === s && n !== i) || (s && !n && !i && !r)) return
            o.regex.test(e) && ((n = !s), (i = s))
          }),
          { ignored: n, unignored: i }
        )
      }
      _test(e, r, n, i) {
        let o = e && yp.convert(e)
        return yp(o, e, this._allowRelativePaths ? Uee : qke), this._t(o, r, n, i)
      }
      _t(e, r, n, i) {
        if (e in r) return r[e]
        if ((i || (i = e.split(XM)), i.pop(), !i.length)) return (r[e] = this._testOne(e, n))
        let o = this._t(i.join(XM) + XM, r, n, i)
        return (r[e] = o.ignored ? o : this._testOne(e, n))
      }
      ignores(e) {
        return this._test(e, this._ignoreCache, !1).ignored
      }
      createFilter() {
        return e => !this.ignores(e)
      }
      filter(e) {
        return Nee(e).filter(this.createFilter())
      }
      test(e) {
        return this._test(e, this._testCache, !0)
      }
    },
    ZA = t => new ZM(t),
    Hke = t => yp(t && yp.convert(t), t, Uee)
  ZA.isPathValid = Hke
  ZA.default = ZA
  qee.exports = ZA
  if (typeof process < 'u' && ((process.env && process.env.IGNORE_TEST_WIN32) || process.platform === 'win32')) {
    let t = r => (/^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, '/'))
    yp.convert = t
    let e = /^[a-z]:\//i
    yp.isNotRelative = r => e.test(r) || Bee(r)
  }
})
var o6 = handleExports($t => {
  'use strict'
  var n6 =
      ($t && $t.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    i6 =
      ($t && $t.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }
  Object.defineProperty($t, '__esModule', { value: !0 })
  $t.getShallowFileSize =
    $t.getShallowDirectorySizeSync =
    $t.getShallowDirectorySize =
    $t.confirmDirExists =
    $t.unlinkAsync =
    $t.readdirAsync =
    $t.readFileAsync =
    $t.writeFileAsync =
    $t.appendFileAsync =
    $t.accessAsync =
    $t.mkdirAsync =
    $t.lstatAsync =
    $t.statAsync =
      void 0
  var Bc = require('fs'),
    Wee = require('path'),
    bp = require('util')
  $t.statAsync = bp.promisify(Bc.stat)
  $t.lstatAsync = bp.promisify(Bc.lstat)
  $t.mkdirAsync = bp.promisify(Bc.mkdir)
  $t.accessAsync = bp.promisify(Bc.access)
  $t.appendFileAsync = bp.promisify(Bc.appendFile)
  $t.writeFileAsync = bp.promisify(Bc.writeFile)
  $t.readFileAsync = bp.promisify(Bc.readFile)
  $t.readdirAsync = bp.promisify(Bc.readdir)
  $t.unlinkAsync = bp.promisify(Bc.unlink)
  var Gke = function (t) {
    return n6(void 0, void 0, void 0, function () {
      var e, r, n
      return i6(this, function (i) {
        switch (i.label) {
          case 0:
            return i.trys.push([0, 2, , 7]), [4, $t.lstatAsync(t)]
          case 1:
            if (((e = i.sent()), !e.isDirectory())) throw new Error('Path existed but was not a directory')
            return [3, 7]
          case 2:
            if (((r = i.sent()), !(r && r.code === 'ENOENT'))) return [3, 6]
            i.label = 3
          case 3:
            return i.trys.push([3, 5, , 6]), [4, $t.mkdirAsync(t)]
          case 4:
            return i.sent(), [3, 6]
          case 5:
            if (((n = i.sent()), n && n.code !== 'EEXIST')) throw n
            return [3, 6]
          case 6:
            return [3, 7]
          case 7:
            return [2]
        }
      })
    })
  }
  $t.confirmDirExists = Gke
  var Vke = function (t) {
    return n6(void 0, void 0, void 0, function () {
      var e, r, n, i, o, s
      return i6(this, function (a) {
        switch (a.label) {
          case 0:
            return [4, $t.readdirAsync(t)]
          case 1:
            ;(e = a.sent()), (r = 0), (n = 0), (i = e), (a.label = 2)
          case 2:
            return n < i.length ? ((o = i[n]), [4, $t.statAsync(Wee.join(t, o))]) : [3, 5]
          case 3:
            ;(s = a.sent()), s.isFile() && (r += s.size), (a.label = 4)
          case 4:
            return n++, [3, 2]
          case 5:
            return [2, r]
        }
      })
    })
  }
  $t.getShallowDirectorySize = Vke
  var zke = function (t) {
    for (var e = Bc.readdirSync(t), r = 0, n = 0; n < e.length; n++) r += Bc.statSync(Wee.join(t, e[n])).size
    return r
  }
  $t.getShallowDirectorySizeSync = zke
  var $ke = function (t) {
    return n6(void 0, void 0, void 0, function () {
      var e
      return i6(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, $t.statAsync(t)]
          case 1:
            return (e = r.sent()), e.isFile() ? [2, e.size] : [2]
        }
      })
    })
  }
  $t.getShallowFileSize = $ke
})
var Qee = handleExports((Tg, Yee) => {
  'use strict'
  var s6 =
      (Tg && Tg.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    a6 =
      (Tg && Tg.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    Kee =
      (Tg && Tg.__spreadArrays) ||
      function () {
        for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length
        for (var n = Array(t), i = 0, e = 0; e < r; e++)
          for (var o = arguments[e], s = 0, a = o.length; s < a; s++, i++) n[i] = o[s]
        return n
      },
    Wke = require('fs'),
    Kke = require('os'),
    Eg = require('path'),
    zl = o6(),
    Yke = (function () {
      function t() {
        var e = this
        ;(this.TAG = 'Logger'),
          (this._cleanupTimeOut = 60 * 30 * 1e3),
          (this._tempDir = ''),
          (this._logFileName = ''),
          (this._fileFullPath = ''),
          (this._backUpNameFormat = ''),
          (this._logToFile = !1),
          (this._logToConsole = !0)
        var r = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION
        r == 'file+console' && (this._logToFile = !0),
          r == 'file' && ((this._logToFile = !0), (this._logToConsole = !1)),
          (this.maxSizeBytes = 5e4),
          (this.maxHistory = 1),
          (this._logFileName = 'applicationinsights.log')
        var n = process.env.APPLICATIONINSIGHTS_LOGDIR
        n
          ? Eg.isAbsolute(n)
            ? (this._tempDir = n)
            : (this._tempDir = Eg.join(process.cwd(), n))
          : (this._tempDir = Eg.join(Kke.tmpdir(), 'appInsights-node')),
          (this._fileFullPath = Eg.join(this._tempDir, this._logFileName)),
          (this._backUpNameFormat = '.' + this._logFileName),
          this._logToFile &&
            (t._fileCleanupTimer ||
              ((t._fileCleanupTimer = setInterval(function () {
                e._fileCleanupTask()
              }, this._cleanupTimeOut)),
              t._fileCleanupTimer.unref()))
      }
      return (
        (t.prototype.info = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          var i = e ? Kee([e], r) : r
          this._logToFile && this._storeToDisk(i), this._logToConsole && console.info.apply(console, i)
        }),
        (t.prototype.warning = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          var i = e ? Kee([e], r) : r
          this._logToFile && this._storeToDisk(i), this._logToConsole && console.warn.apply(console, i)
        }),
        (t.getInstance = function () {
          return t._instance || (t._instance = new t()), t._instance
        }),
        (t.prototype._storeToDisk = function (e) {
          return s6(this, void 0, void 0, function () {
            var r, n, i, o, s, a
            return a6(this, function (l) {
              switch (l.label) {
                case 0:
                  ;(r =
                    e +
                    `\r
`),
                    (l.label = 1)
                case 1:
                  return l.trys.push([1, 3, , 4]), [4, zl.confirmDirExists(this._tempDir)]
                case 2:
                  return l.sent(), [3, 4]
                case 3:
                  return (
                    (n = l.sent()),
                    console.log(this.TAG, 'Failed to create directory for log file: ' + (n && n.message)),
                    [2]
                  )
                case 4:
                  return l.trys.push([4, 6, , 11]), [4, zl.accessAsync(this._fileFullPath, Wke.constants.F_OK)]
                case 5:
                  return l.sent(), [3, 11]
                case 6:
                  ;(i = l.sent()), (l.label = 7)
                case 7:
                  return l.trys.push([7, 9, , 10]), [4, zl.appendFileAsync(this._fileFullPath, r)]
                case 8:
                  return l.sent(), [2]
                case 9:
                  return (o = l.sent()), console.log(this.TAG, 'Failed to put log into file: ' + (i && i.message)), [2]
                case 10:
                  return [3, 11]
                case 11:
                  return l.trys.push([11, 17, , 18]), [4, zl.getShallowFileSize(this._fileFullPath)]
                case 12:
                  return (s = l.sent()), s > this.maxSizeBytes ? [4, this._createBackupFile(r)] : [3, 14]
                case 13:
                  return l.sent(), [3, 16]
                case 14:
                  return [4, zl.appendFileAsync(this._fileFullPath, r)]
                case 15:
                  l.sent(), (l.label = 16)
                case 16:
                  return [3, 18]
                case 17:
                  return (
                    (a = l.sent()), console.log(this.TAG, 'Failed to create backup file: ' + (a && a.message)), [3, 18]
                  )
                case 18:
                  return [2]
              }
            })
          })
        }),
        (t.prototype._createBackupFile = function (e) {
          return s6(this, void 0, void 0, function () {
            var r, n, i
            return a6(this, function (o) {
              switch (o.label) {
                case 0:
                  return o.trys.push([0, 3, 4, 5]), [4, zl.readFileAsync(this._fileFullPath)]
                case 1:
                  return (
                    (r = o.sent()),
                    (n = Eg.join(this._tempDir, new Date().getTime() + '.' + this._logFileName)),
                    [4, zl.writeFileAsync(n, r)]
                  )
                case 2:
                  return o.sent(), [3, 5]
                case 3:
                  return (i = o.sent()), console.log('Failed to generate backup log file', i), [3, 5]
                case 4:
                  return zl.writeFileAsync(this._fileFullPath, e), [7]
                case 5:
                  return [2]
              }
            })
          })
        }),
        (t.prototype._fileCleanupTask = function () {
          return s6(this, void 0, void 0, function () {
            var e,
              r,
              n,
              i,
              o,
              s = this
            return a6(this, function (a) {
              switch (a.label) {
                case 0:
                  return a.trys.push([0, 6, , 7]), [4, zl.readdirAsync(this._tempDir)]
                case 1:
                  ;(e = a.sent()),
                    (e = e.filter(function (l) {
                      return Eg.basename(l).indexOf(s._backUpNameFormat) > -1
                    })),
                    e.sort(function (l, c) {
                      var u = new Date(parseInt(l.split(s._backUpNameFormat)[0])),
                        p = new Date(parseInt(c.split(s._backUpNameFormat)[0]))
                      if (u < p) return -1
                      if (u >= p) return 1
                    }),
                    (r = e.length),
                    (n = 0),
                    (a.label = 2)
                case 2:
                  return n < r - this.maxHistory ? ((i = Eg.join(this._tempDir, e[n])), [4, zl.unlinkAsync(i)]) : [3, 5]
                case 3:
                  a.sent(), (a.label = 4)
                case 4:
                  return n++, [3, 2]
                case 5:
                  return [3, 7]
                case 6:
                  return (
                    (o = a.sent()), console.log(this.TAG, 'Failed to cleanup log files: ' + (o && o.message)), [3, 7]
                  )
                case 7:
                  return [2]
              }
            })
          })
        }),
        (t._fileCleanupTimer = null),
        t
      )
    })()
  Yee.exports = Yke
})
var on = handleExports((_0t, Jee) => {
  'use strict'
  var Xee = Qee(),
    Qke = 'APPLICATION_INSIGHTS_ENABLE_DEBUG_LOGS',
    Xke = 'APPLICATION_INSIGHTS_DISABLE_WARNING_LOGS',
    Jke = (function () {
      function t() {}
      return (
        (t.info = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          this.enableDebug && Xee.getInstance().info(this.TAG + e, r)
        }),
        (t.warn = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          this.disableWarnings || Xee.getInstance().warning(this.TAG + e, r)
        }),
        (t.enableDebug = !!process.env[Qke]),
        (t.disableWarnings = !!process.env[Xke]),
        (t.TAG = 'ApplicationInsights:'),
        t
      )
    })()
  Jee.exports = Jke
})
var d2 = handleExports(p2 => {
  'use strict'
  Object.defineProperty(p2, '__esModule', { value: !0 })
  p2.JsonConfig = void 0
  var Zke = require('fs'),
    u2 = require('path'),
    c6 = on(),
    e4e = 'APPLICATIONINSIGHTS_CONFIGURATION_FILE',
    t4e = 'APPLICATIONINSIGHTS_CONNECTION_STRING',
    Zee = 'APPSETTING_',
    ete = 'APPINSIGHTS_INSTRUMENTATIONKEY',
    tte = 'APPINSIGHTS_INSTRUMENTATION_KEY',
    r4e = 'APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC',
    n4e = 'APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS',
    i4e = 'http_proxy',
    o4e = 'https_proxy',
    s4e = 'APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL',
    a4e = 'APPLICATION_INSIGHTS_NO_STATSBEAT',
    c4e = 'APPLICATION_INSIGHTS_NO_HTTP_AGENT_KEEP_ALIVE',
    l4e = 'APPLICATION_INSIGHTS_NO_PATCH_MODULES',
    u4e = 'APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_ENABLED',
    p4e = 'APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_CONNECTION_STRING',
    d4e = 'APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_SOURCE',
    f4e = 'APPLICATIONINSIGHTS_WEB_SNIPPET_ENABLED',
    m4e = 'APPLICATIONINSIGHTS_WEB_SNIPPET_CONNECTION_STRING',
    h4e = (function () {
      function t() {
        ;(this.connectionString = process.env[t4e]),
          (this.instrumentationKey =
            process.env[ete] || process.env[Zee + ete] || process.env[tte] || process.env[Zee + tte]),
          !this.connectionString &&
            this.instrumentationKey &&
            c6.warn(
              'APPINSIGHTS_INSTRUMENTATIONKEY is in path of deprecation, please use APPLICATIONINSIGHTS_CONNECTION_STRING env variable to setup the SDK.'
            ),
          (this.disableAllExtendedMetrics = !!process.env[n4e]),
          (this.extendedMetricDisablers = process.env[r4e]),
          (this.proxyHttpUrl = process.env[i4e]),
          (this.proxyHttpsUrl = process.env[o4e]),
          (this.noDiagnosticChannel = !!process.env[s4e]),
          (this.disableStatsbeat = !!process.env[a4e]),
          (this.noHttpAgentKeepAlive = !!process.env[c4e]),
          (this.noPatchModules = process.env[l4e] || ''),
          (this.enableWebInstrumentation = !!process.env[u4e] || !!process.env[f4e]),
          (this.webInstrumentationSrc = process.env[d4e] || ''),
          (this.webInstrumentationConnectionString = process.env[p4e] || process.env[m4e] || ''),
          (this.enableAutoWebSnippetInjection = this.enableWebInstrumentation),
          (this.webSnippetConnectionString = this.webInstrumentationConnectionString),
          this._loadJsonFile()
      }
      return (
        (t.getInstance = function () {
          return t._instance || (t._instance = new t()), t._instance
        }),
        (t.prototype._loadJsonFile = function () {
          var e = '',
            r = '{}'
          if (r) e = r
          else {
            var n = 'applicationinsights.json',
              i = u2.join(__dirname, '../../'),
              o = u2.join(i, n),
              s = process.env[e4e]
            s && (u2.isAbsolute(s) ? (o = s) : (o = u2.join(i, s)))
            try {
              e = Zke.readFileSync(o, 'utf8')
            } catch (l) {
              c6.warn('Failed to read JSON config file: ', l)
            }
          }
          try {
            var a = JSON.parse(e)
            a.disableStatsbeat != null && (this.disableStatsbeat = a.disableStatsbeat),
              a.disableAllExtendedMetrics != null && (this.disableAllExtendedMetrics = a.disableStatsbeat),
              a.noDiagnosticChannel != null && (this.noDiagnosticChannel = a.noDiagnosticChannel),
              a.noHttpAgentKeepAlive != null && (this.noHttpAgentKeepAlive = a.noHttpAgentKeepAlive),
              a.connectionString != null && (this.connectionString = a.connectionString),
              a.extendedMetricDisablers != null && (this.extendedMetricDisablers = a.extendedMetricDisablers),
              a.noDiagnosticChannel != null && (this.noDiagnosticChannel = a.noDiagnosticChannel),
              a.proxyHttpUrl != null && (this.proxyHttpUrl = a.proxyHttpUrl),
              a.proxyHttpsUrl != null && (this.proxyHttpsUrl = a.proxyHttpsUrl),
              a.proxyHttpsUrl != null && (this.proxyHttpsUrl = a.proxyHttpsUrl),
              a.noPatchModules != null && (this.noPatchModules = a.noPatchModules),
              a.enableAutoWebSnippetInjection != null &&
                ((this.enableWebInstrumentation = a.enableAutoWebSnippetInjection),
                (this.enableAutoWebSnippetInjection = this.enableWebInstrumentation)),
              a.enableWebInstrumentation != null &&
                ((this.enableWebInstrumentation = a.enableWebInstrumentation),
                (this.enableAutoWebSnippetInjection = this.enableWebInstrumentation)),
              a.webSnippetConnectionString != null &&
                ((this.webInstrumentationConnectionString = a.webSnippetConnectionString),
                (this.webSnippetConnectionString = this.webInstrumentationConnectionString)),
              a.webInstrumentationConnectionString != null &&
                ((this.webInstrumentationConnectionString = a.webInstrumentationConnectionString),
                (this.webSnippetConnectionString = this.webInstrumentationConnectionString)),
              a.webInstrumentationConfig != null && (this.webInstrumentationConfig = a.webInstrumentationConfig),
              a.webInstrumentationSrc != null && (this.webInstrumentationSrc = a.webInstrumentationSrc),
              a.enableLoggerErrorToTrace != null && (this.enableLoggerErrorToTrace = a.enableLoggerErrorToTrace),
              (this.endpointUrl = a.endpointUrl),
              (this.maxBatchSize = a.maxBatchSize),
              (this.maxBatchIntervalMs = a.maxBatchIntervalMs),
              (this.disableAppInsights = a.disableAppInsights),
              (this.samplingPercentage = a.samplingPercentage),
              (this.correlationIdRetryIntervalMs = a.correlationIdRetryIntervalMs),
              (this.correlationHeaderExcludedDomains = a.correlationHeaderExcludedDomains),
              (this.ignoreLegacyHeaders = a.ignoreLegacyHeaders),
              (this.distributedTracingMode = a.distributedTracingMode),
              (this.enableAutoCollectExternalLoggers = a.enableAutoCollectExternalLoggers),
              (this.enableAutoCollectConsole = a.enableAutoCollectConsole),
              (this.enableLoggerErrorToTrace = a.enableLoggerErrorToTrace),
              (this.enableAutoCollectExceptions = a.enableAutoCollectExceptions),
              (this.enableAutoCollectPerformance = a.enableAutoCollectPerformance),
              (this.enableAutoCollectExtendedMetrics = a.enableAutoCollectExtendedMetrics),
              (this.enableAutoCollectPreAggregatedMetrics = a.enableAutoCollectPreAggregatedMetrics),
              (this.enableAutoCollectHeartbeat = a.enableAutoCollectHeartbeat),
              (this.enableAutoCollectRequests = a.enableAutoCollectRequests),
              (this.enableAutoCollectDependencies = a.enableAutoCollectDependencies),
              (this.enableAutoDependencyCorrelation = a.enableAutoDependencyCorrelation),
              (this.enableAutoCollectIncomingRequestAzureFunctions = a.enableAutoCollectIncomingRequestAzureFunctions),
              (this.enableUseAsyncHooks = a.enableUseAsyncHooks),
              (this.enableUseDiskRetryCaching = a.enableUseDiskRetryCaching),
              (this.enableResendInterval = a.enableResendInterval),
              (this.enableMaxBytesOnDisk = a.enableMaxBytesOnDisk),
              (this.enableInternalDebugLogging = a.enableInternalDebugLogging),
              (this.enableInternalWarningLogging = a.enableInternalWarningLogging),
              (this.enableSendLiveMetrics = a.enableSendLiveMetrics),
              (this.quickPulseHost = a.quickPulseHost)
          } catch (l) {
            c6.warn('Invalid JSON config file: ', l)
          }
        }),
        t
      )
    })()
  p2.JsonConfig = h4e
})
var nE = handleExports((x0t, rte) => {
  var g4e = '2.0.0',
    v4e = Number.MAX_SAFE_INTEGER || 9007199254740991,
    _4e = 16,
    y4e = 256 - 6,
    x4e = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease']
  rte.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: _4e,
    MAX_SAFE_BUILD_LENGTH: y4e,
    MAX_SAFE_INTEGER: v4e,
    RELEASE_TYPES: x4e,
    SEMVER_SPEC_VERSION: g4e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  }
})
var iE = handleExports((b0t, nte) => {
  var b4e =
    typeof process == 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...t) => console.error('SEMVER', ...t)
      : () => {}
  nte.exports = b4e
})
var N_ = handleExports((Ep, ite) => {
  var { MAX_SAFE_COMPONENT_LENGTH: l6, MAX_SAFE_BUILD_LENGTH: E4e, MAX_LENGTH: T4e } = nE(),
    S4e = iE()
  Ep = ite.exports = {}
  var C4e = (Ep.re = []),
    I4e = (Ep.safeRe = []),
    nt = (Ep.src = []),
    it = (Ep.t = {}),
    w4e = 0,
    u6 = '[a-zA-Z0-9-]',
    A4e = [
      ['\\s', 1],
      ['\\d', T4e],
      [u6, E4e],
    ],
    R4e = t => {
      for (let [e, r] of A4e) t = t.split(`${e}*`).join(`${e}{0,${r}}`).split(`${e}+`).join(`${e}{1,${r}}`)
      return t
    },
    Ft = (t, e, r) => {
      let n = R4e(e),
        i = w4e++
      S4e(t, i, e),
        (it[t] = i),
        (nt[i] = e),
        (C4e[i] = new RegExp(e, r ? 'g' : void 0)),
        (I4e[i] = new RegExp(n, r ? 'g' : void 0))
    }
  Ft('NUMERICIDENTIFIER', '0|[1-9]\\d*')
  Ft('NUMERICIDENTIFIERLOOSE', '\\d+')
  Ft('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${u6}*`)
  Ft('MAINVERSION', `(${nt[it.NUMERICIDENTIFIER]})\\.(${nt[it.NUMERICIDENTIFIER]})\\.(${nt[it.NUMERICIDENTIFIER]})`)
  Ft(
    'MAINVERSIONLOOSE',
    `(${nt[it.NUMERICIDENTIFIERLOOSE]})\\.(${nt[it.NUMERICIDENTIFIERLOOSE]})\\.(${nt[it.NUMERICIDENTIFIERLOOSE]})`
  )
  Ft('PRERELEASEIDENTIFIER', `(?:${nt[it.NUMERICIDENTIFIER]}|${nt[it.NONNUMERICIDENTIFIER]})`)
  Ft('PRERELEASEIDENTIFIERLOOSE', `(?:${nt[it.NUMERICIDENTIFIERLOOSE]}|${nt[it.NONNUMERICIDENTIFIER]})`)
  Ft('PRERELEASE', `(?:-(${nt[it.PRERELEASEIDENTIFIER]}(?:\\.${nt[it.PRERELEASEIDENTIFIER]})*))`)
  Ft('PRERELEASELOOSE', `(?:-?(${nt[it.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${nt[it.PRERELEASEIDENTIFIERLOOSE]})*))`)
  Ft('BUILDIDENTIFIER', `${u6}+`)
  Ft('BUILD', `(?:\\+(${nt[it.BUILDIDENTIFIER]}(?:\\.${nt[it.BUILDIDENTIFIER]})*))`)
  Ft('FULLPLAIN', `v?${nt[it.MAINVERSION]}${nt[it.PRERELEASE]}?${nt[it.BUILD]}?`)
  Ft('FULL', `^${nt[it.FULLPLAIN]}$`)
  Ft('LOOSEPLAIN', `[v=\\s]*${nt[it.MAINVERSIONLOOSE]}${nt[it.PRERELEASELOOSE]}?${nt[it.BUILD]}?`)
  Ft('LOOSE', `^${nt[it.LOOSEPLAIN]}$`)
  Ft('GTLT', '((?:<|>)?=?)')
  Ft('XRANGEIDENTIFIERLOOSE', `${nt[it.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
  Ft('XRANGEIDENTIFIER', `${nt[it.NUMERICIDENTIFIER]}|x|X|\\*`)
  Ft(
    'XRANGEPLAIN',
    `[v=\\s]*(${nt[it.XRANGEIDENTIFIER]})(?:\\.(${nt[it.XRANGEIDENTIFIER]})(?:\\.(${nt[it.XRANGEIDENTIFIER]})(?:${
      nt[it.PRERELEASE]
    })?${nt[it.BUILD]}?)?)?`
  )
  Ft(
    'XRANGEPLAINLOOSE',
    `[v=\\s]*(${nt[it.XRANGEIDENTIFIERLOOSE]})(?:\\.(${nt[it.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
      nt[it.XRANGEIDENTIFIERLOOSE]
    })(?:${nt[it.PRERELEASELOOSE]})?${nt[it.BUILD]}?)?)?`
  )
  Ft('XRANGE', `^${nt[it.GTLT]}\\s*${nt[it.XRANGEPLAIN]}$`)
  Ft('XRANGELOOSE', `^${nt[it.GTLT]}\\s*${nt[it.XRANGEPLAINLOOSE]}$`)
  Ft('COERCE', `(^|[^\\d])(\\d{1,${l6}})(?:\\.(\\d{1,${l6}}))?(?:\\.(\\d{1,${l6}}))?(?:$|[^\\d])`)
  Ft('COERCERTL', nt[it.COERCE], !0)
  Ft('LONETILDE', '(?:~>?)')
  Ft('TILDETRIM', `(\\s*)${nt[it.LONETILDE]}\\s+`, !0)
  Ep.tildeTrimReplace = '$1~'
  Ft('TILDE', `^${nt[it.LONETILDE]}${nt[it.XRANGEPLAIN]}$`)
  Ft('TILDELOOSE', `^${nt[it.LONETILDE]}${nt[it.XRANGEPLAINLOOSE]}$`)
  Ft('LONECARET', '(?:\\^)')
  Ft('CARETTRIM', `(\\s*)${nt[it.LONECARET]}\\s+`, !0)
  Ep.caretTrimReplace = '$1^'
  Ft('CARET', `^${nt[it.LONECARET]}${nt[it.XRANGEPLAIN]}$`)
  Ft('CARETLOOSE', `^${nt[it.LONECARET]}${nt[it.XRANGEPLAINLOOSE]}$`)
  Ft('COMPARATORLOOSE', `^${nt[it.GTLT]}\\s*(${nt[it.LOOSEPLAIN]})$|^$`)
  Ft('COMPARATOR', `^${nt[it.GTLT]}\\s*(${nt[it.FULLPLAIN]})$|^$`)
  Ft('COMPARATORTRIM', `(\\s*)${nt[it.GTLT]}\\s*(${nt[it.LOOSEPLAIN]}|${nt[it.XRANGEPLAIN]})`, !0)
  Ep.comparatorTrimReplace = '$1$2$3'
  Ft('HYPHENRANGE', `^\\s*(${nt[it.XRANGEPLAIN]})\\s+-\\s+(${nt[it.XRANGEPLAIN]})\\s*$`)
  Ft('HYPHENRANGELOOSE', `^\\s*(${nt[it.XRANGEPLAINLOOSE]})\\s+-\\s+(${nt[it.XRANGEPLAINLOOSE]})\\s*$`)
  Ft('STAR', '(<|>)?=?\\s*\\*')
  Ft('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
  Ft('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
})
var f2 = handleExports((E0t, ote) => {
  var D4e = Object.freeze({ loose: !0 }),
    P4e = Object.freeze({}),
    N4e = t => (t ? (typeof t != 'object' ? D4e : t) : P4e)
  ote.exports = N4e
})
var p6 = handleExports((T0t, cte) => {
  var ste = /^[0-9]+$/,
    ate = (t, e) => {
      let r = ste.test(t),
        n = ste.test(e)
      return r && n && ((t = +t), (e = +e)), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1
    },
    k4e = (t, e) => ate(e, t)
  cte.exports = { compareIdentifiers: ate, rcompareIdentifiers: k4e }
})
var Co = handleExports((S0t, dte) => {
  var m2 = iE(),
    { MAX_LENGTH: lte, MAX_SAFE_INTEGER: h2 } = nE(),
    { safeRe: ute, t: pte } = N_(),
    O4e = f2(),
    { compareIdentifiers: k_ } = p6(),
    d6 = class t {
      constructor(e, r) {
        if (((r = O4e(r)), e instanceof t)) {
          if (e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease) return e
          e = e.version
        } else if (typeof e != 'string')
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`)
        if (e.length > lte) throw new TypeError(`version is longer than ${lte} characters`)
        m2('SemVer', e, r),
          (this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease)
        let n = e.trim().match(r.loose ? ute[pte.LOOSE] : ute[pte.FULL])
        if (!n) throw new TypeError(`Invalid Version: ${e}`)
        if (
          ((this.raw = e),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > h2 || this.major < 0)
        )
          throw new TypeError('Invalid major version')
        if (this.minor > h2 || this.minor < 0) throw new TypeError('Invalid minor version')
        if (this.patch > h2 || this.patch < 0) throw new TypeError('Invalid patch version')
        n[4]
          ? (this.prerelease = n[4].split('.').map(i => {
              if (/^[0-9]+$/.test(i)) {
                let o = +i
                if (o >= 0 && o < h2) return o
              }
              return i
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split('.') : []),
          this.format()
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length && (this.version += `-${this.prerelease.join('.')}`),
          this.version
        )
      }
      toString() {
        return this.version
      }
      compare(e) {
        if ((m2('SemVer.compare', this.version, this.options, e), !(e instanceof t))) {
          if (typeof e == 'string' && e === this.version) return 0
          e = new t(e, this.options)
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e)
      }
      compareMain(e) {
        return (
          e instanceof t || (e = new t(e, this.options)),
          k_(this.major, e.major) || k_(this.minor, e.minor) || k_(this.patch, e.patch)
        )
      }
      comparePre(e) {
        if ((e instanceof t || (e = new t(e, this.options)), this.prerelease.length && !e.prerelease.length)) return -1
        if (!this.prerelease.length && e.prerelease.length) return 1
        if (!this.prerelease.length && !e.prerelease.length) return 0
        let r = 0
        do {
          let n = this.prerelease[r],
            i = e.prerelease[r]
          if ((m2('prerelease compare', r, n, i), n === void 0 && i === void 0)) return 0
          if (i === void 0) return 1
          if (n === void 0) return -1
          if (n === i) continue
          return k_(n, i)
        } while (++r)
      }
      compareBuild(e) {
        e instanceof t || (e = new t(e, this.options))
        let r = 0
        do {
          let n = this.build[r],
            i = e.build[r]
          if ((m2('prerelease compare', r, n, i), n === void 0 && i === void 0)) return 0
          if (i === void 0) return 1
          if (n === void 0) return -1
          if (n === i) continue
          return k_(n, i)
        } while (++r)
      }
      inc(e, r, n) {
        switch (e) {
          case 'premajor':
            ;(this.prerelease.length = 0), (this.patch = 0), (this.minor = 0), this.major++, this.inc('pre', r, n)
            break
          case 'preminor':
            ;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', r, n)
            break
          case 'prepatch':
            ;(this.prerelease.length = 0), this.inc('patch', r, n), this.inc('pre', r, n)
            break
          case 'prerelease':
            this.prerelease.length === 0 && this.inc('patch', r, n), this.inc('pre', r, n)
            break
          case 'major':
            ;(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = [])
            break
          case 'minor':
            ;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = [])
            break
          case 'patch':
            this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
            break
          case 'pre': {
            let i = Number(n) ? 1 : 0
            if (!r && n === !1) throw new Error('invalid increment argument: identifier is empty')
            if (this.prerelease.length === 0) this.prerelease = [i]
            else {
              let o = this.prerelease.length
              for (; --o >= 0; ) typeof this.prerelease[o] == 'number' && (this.prerelease[o]++, (o = -2))
              if (o === -1) {
                if (r === this.prerelease.join('.') && n === !1)
                  throw new Error('invalid increment argument: identifier already exists')
                this.prerelease.push(i)
              }
            }
            if (r) {
              let o = [r, i]
              n === !1 && (o = [r]),
                k_(this.prerelease[0], r) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = o)
                  : (this.prerelease = o)
            }
            break
          }
          default:
            throw new Error(`invalid increment argument: ${e}`)
        }
        return (this.raw = this.format()), this.build.length && (this.raw += `+${this.build.join('.')}`), this
      }
    }
  dte.exports = d6
})
var Sg = handleExports((C0t, mte) => {
  var fte = Co(),
    L4e = (t, e, r = !1) => {
      if (t instanceof fte) return t
      try {
        return new fte(t, e)
      } catch (n) {
        if (!r) return null
        throw n
      }
    }
  mte.exports = L4e
})
var gte = handleExports((I0t, hte) => {
  var M4e = Sg(),
    F4e = (t, e) => {
      let r = M4e(t, e)
      return r ? r.version : null
    }
  hte.exports = F4e
})
var _te = handleExports((w0t, vte) => {
  var U4e = Sg(),
    B4e = (t, e) => {
      let r = U4e(t.trim().replace(/^[=v]+/, ''), e)
      return r ? r.version : null
    }
  vte.exports = B4e
})
var bte = handleExports((A0t, xte) => {
  var yte = Co(),
    q4e = (t, e, r, n, i) => {
      typeof r == 'string' && ((i = n), (n = r), (r = void 0))
      try {
        return new yte(t instanceof yte ? t.version : t, r).inc(e, n, i).version
      } catch {
        return null
      }
    }
  xte.exports = q4e
})
var Ste = handleExports((R0t, Tte) => {
  var Ete = Sg(),
    H4e = (t, e) => {
      let r = Ete(t, null, !0),
        n = Ete(e, null, !0),
        i = r.compare(n)
      if (i === 0) return null
      let o = i > 0,
        s = o ? r : n,
        a = o ? n : r,
        l = !!s.prerelease.length
      if (!!a.prerelease.length && !l)
        return !a.patch && !a.minor ? 'major' : s.patch ? 'patch' : s.minor ? 'minor' : 'major'
      let u = l ? 'pre' : ''
      return r.major !== n.major
        ? u + 'major'
        : r.minor !== n.minor
        ? u + 'minor'
        : r.patch !== n.patch
        ? u + 'patch'
        : 'prerelease'
    }
  Tte.exports = H4e
})
var Ite = handleExports((D0t, Cte) => {
  var j4e = Co(),
    G4e = (t, e) => new j4e(t, e).major
  Cte.exports = G4e
})
var Ate = handleExports((P0t, wte) => {
  var V4e = Co(),
    z4e = (t, e) => new V4e(t, e).minor
  wte.exports = z4e
})
var Dte = handleExports((N0t, Rte) => {
  var $4e = Co(),
    W4e = (t, e) => new $4e(t, e).patch
  Rte.exports = W4e
})
var Nte = handleExports((k0t, Pte) => {
  var K4e = Sg(),
    Y4e = (t, e) => {
      let r = K4e(t, e)
      return r && r.prerelease.length ? r.prerelease : null
    }
  Pte.exports = Y4e
})
var Ga = handleExports((O0t, Ote) => {
  var kte = Co(),
    Q4e = (t, e, r) => new kte(t, r).compare(new kte(e, r))
  Ote.exports = Q4e
})
var Mte = handleExports((L0t, Lte) => {
  var X4e = Ga(),
    J4e = (t, e, r) => X4e(e, t, r)
  Lte.exports = J4e
})
var Ute = handleExports((M0t, Fte) => {
  var Z4e = Ga(),
    eOe = (t, e) => Z4e(t, e, !0)
  Fte.exports = eOe
})
var g2 = handleExports((F0t, qte) => {
  var Bte = Co(),
    tOe = (t, e, r) => {
      let n = new Bte(t, r),
        i = new Bte(e, r)
      return n.compare(i) || n.compareBuild(i)
    }
  qte.exports = tOe
})
var jte = handleExports((U0t, Hte) => {
  var rOe = g2(),
    nOe = (t, e) => t.sort((r, n) => rOe(r, n, e))
  Hte.exports = nOe
})
var Vte = handleExports((B0t, Gte) => {
  var iOe = g2(),
    oOe = (t, e) => t.sort((r, n) => iOe(n, r, e))
  Gte.exports = oOe
})
var oE = handleExports((q0t, zte) => {
  var sOe = Ga(),
    aOe = (t, e, r) => sOe(t, e, r) > 0
  zte.exports = aOe
})
var v2 = handleExports((H0t, $te) => {
  var cOe = Ga(),
    lOe = (t, e, r) => cOe(t, e, r) < 0
  $te.exports = lOe
})
var f6 = handleExports((j0t, Wte) => {
  var uOe = Ga(),
    pOe = (t, e, r) => uOe(t, e, r) === 0
  Wte.exports = pOe
})
var m6 = handleExports((G0t, Kte) => {
  var dOe = Ga(),
    fOe = (t, e, r) => dOe(t, e, r) !== 0
  Kte.exports = fOe
})
var _2 = handleExports((V0t, Yte) => {
  var mOe = Ga(),
    hOe = (t, e, r) => mOe(t, e, r) >= 0
  Yte.exports = hOe
})
var y2 = handleExports((z0t, Qte) => {
  var gOe = Ga(),
    vOe = (t, e, r) => gOe(t, e, r) <= 0
  Qte.exports = vOe
})
var h6 = handleExports(($0t, Xte) => {
  var _Oe = f6(),
    yOe = m6(),
    xOe = oE(),
    bOe = _2(),
    EOe = v2(),
    TOe = y2(),
    SOe = (t, e, r, n) => {
      switch (e) {
        case '===':
          return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t === r
        case '!==':
          return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t !== r
        case '':
        case '=':
        case '==':
          return _Oe(t, r, n)
        case '!=':
          return yOe(t, r, n)
        case '>':
          return xOe(t, r, n)
        case '>=':
          return bOe(t, r, n)
        case '<':
          return EOe(t, r, n)
        case '<=':
          return TOe(t, r, n)
        default:
          throw new TypeError(`Invalid operator: ${e}`)
      }
    }
  Xte.exports = SOe
})
var Zte = handleExports((W0t, Jte) => {
  var COe = Co(),
    IOe = Sg(),
    { safeRe: x2, t: b2 } = N_(),
    wOe = (t, e) => {
      if (t instanceof COe) return t
      if ((typeof t == 'number' && (t = String(t)), typeof t != 'string')) return null
      e = e || {}
      let r = null
      if (!e.rtl) r = t.match(x2[b2.COERCE])
      else {
        let n
        for (; (n = x2[b2.COERCERTL].exec(t)) && (!r || r.index + r[0].length !== t.length); )
          (!r || n.index + n[0].length !== r.index + r[0].length) && (r = n),
            (x2[b2.COERCERTL].lastIndex = n.index + n[1].length + n[2].length)
        x2[b2.COERCERTL].lastIndex = -1
      }
      return r === null ? null : IOe(`${r[2]}.${r[3] || '0'}.${r[4] || '0'}`, e)
    }
  Jte.exports = wOe
})
var tre = handleExports((K0t, ere) => {
  'use strict'
  ere.exports = function (t) {
    t.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next) yield e.value
    }
  }
})
var nre = handleExports((Y0t, rre) => {
  'use strict'
  rre.exports = mr
  mr.Node = Cg
  mr.create = mr
  function mr(t) {
    var e = this
    if (
      (e instanceof mr || (e = new mr()),
      (e.tail = null),
      (e.head = null),
      (e.length = 0),
      t && typeof t.forEach == 'function')
    )
      t.forEach(function (i) {
        e.push(i)
      })
    else if (arguments.length > 0) for (var r = 0, n = arguments.length; r < n; r++) e.push(arguments[r])
    return e
  }
  mr.prototype.removeNode = function (t) {
    if (t.list !== this) throw new Error('removing node which does not belong to this list')
    var e = t.next,
      r = t.prev
    return (
      e && (e.prev = r),
      r && (r.next = e),
      t === this.head && (this.head = e),
      t === this.tail && (this.tail = r),
      t.list.length--,
      (t.next = null),
      (t.prev = null),
      (t.list = null),
      e
    )
  }
  mr.prototype.unshiftNode = function (t) {
    if (t !== this.head) {
      t.list && t.list.removeNode(t)
      var e = this.head
      ;(t.list = this), (t.next = e), e && (e.prev = t), (this.head = t), this.tail || (this.tail = t), this.length++
    }
  }
  mr.prototype.pushNode = function (t) {
    if (t !== this.tail) {
      t.list && t.list.removeNode(t)
      var e = this.tail
      ;(t.list = this), (t.prev = e), e && (e.next = t), (this.tail = t), this.head || (this.head = t), this.length++
    }
  }
  mr.prototype.push = function () {
    for (var t = 0, e = arguments.length; t < e; t++) ROe(this, arguments[t])
    return this.length
  }
  mr.prototype.unshift = function () {
    for (var t = 0, e = arguments.length; t < e; t++) DOe(this, arguments[t])
    return this.length
  }
  mr.prototype.pop = function () {
    if (this.tail) {
      var t = this.tail.value
      return (this.tail = this.tail.prev), this.tail ? (this.tail.next = null) : (this.head = null), this.length--, t
    }
  }
  mr.prototype.shift = function () {
    if (this.head) {
      var t = this.head.value
      return (this.head = this.head.next), this.head ? (this.head.prev = null) : (this.tail = null), this.length--, t
    }
  }
  mr.prototype.forEach = function (t, e) {
    e = e || this
    for (var r = this.head, n = 0; r !== null; n++) t.call(e, r.value, n, this), (r = r.next)
  }
  mr.prototype.forEachReverse = function (t, e) {
    e = e || this
    for (var r = this.tail, n = this.length - 1; r !== null; n--) t.call(e, r.value, n, this), (r = r.prev)
  }
  mr.prototype.get = function (t) {
    for (var e = 0, r = this.head; r !== null && e < t; e++) r = r.next
    if (e === t && r !== null) return r.value
  }
  mr.prototype.getReverse = function (t) {
    for (var e = 0, r = this.tail; r !== null && e < t; e++) r = r.prev
    if (e === t && r !== null) return r.value
  }
  mr.prototype.map = function (t, e) {
    e = e || this
    for (var r = new mr(), n = this.head; n !== null; ) r.push(t.call(e, n.value, this)), (n = n.next)
    return r
  }
  mr.prototype.mapReverse = function (t, e) {
    e = e || this
    for (var r = new mr(), n = this.tail; n !== null; ) r.push(t.call(e, n.value, this)), (n = n.prev)
    return r
  }
  mr.prototype.reduce = function (t, e) {
    var r,
      n = this.head
    if (arguments.length > 1) r = e
    else if (this.head) (n = this.head.next), (r = this.head.value)
    else throw new TypeError('Reduce of empty list with no initial value')
    for (var i = 0; n !== null; i++) (r = t(r, n.value, i)), (n = n.next)
    return r
  }
  mr.prototype.reduceReverse = function (t, e) {
    var r,
      n = this.tail
    if (arguments.length > 1) r = e
    else if (this.tail) (n = this.tail.prev), (r = this.tail.value)
    else throw new TypeError('Reduce of empty list with no initial value')
    for (var i = this.length - 1; n !== null; i--) (r = t(r, n.value, i)), (n = n.prev)
    return r
  }
  mr.prototype.toArray = function () {
    for (var t = new Array(this.length), e = 0, r = this.head; r !== null; e++) (t[e] = r.value), (r = r.next)
    return t
  }
  mr.prototype.toArrayReverse = function () {
    for (var t = new Array(this.length), e = 0, r = this.tail; r !== null; e++) (t[e] = r.value), (r = r.prev)
    return t
  }
  mr.prototype.slice = function (t, e) {
    ;(e = e || this.length), e < 0 && (e += this.length), (t = t || 0), t < 0 && (t += this.length)
    var r = new mr()
    if (e < t || e < 0) return r
    t < 0 && (t = 0), e > this.length && (e = this.length)
    for (var n = 0, i = this.head; i !== null && n < t; n++) i = i.next
    for (; i !== null && n < e; n++, i = i.next) r.push(i.value)
    return r
  }
  mr.prototype.sliceReverse = function (t, e) {
    ;(e = e || this.length), e < 0 && (e += this.length), (t = t || 0), t < 0 && (t += this.length)
    var r = new mr()
    if (e < t || e < 0) return r
    t < 0 && (t = 0), e > this.length && (e = this.length)
    for (var n = this.length, i = this.tail; i !== null && n > e; n--) i = i.prev
    for (; i !== null && n > t; n--, i = i.prev) r.push(i.value)
    return r
  }
  mr.prototype.splice = function (t, e, ...r) {
    t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t)
    for (var n = 0, i = this.head; i !== null && n < t; n++) i = i.next
    for (var o = [], n = 0; i && n < e; n++) o.push(i.value), (i = this.removeNode(i))
    i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev)
    for (var n = 0; n < r.length; n++) i = AOe(this, i, r[n])
    return o
  }
  mr.prototype.reverse = function () {
    for (var t = this.head, e = this.tail, r = t; r !== null; r = r.prev) {
      var n = r.prev
      ;(r.prev = r.next), (r.next = n)
    }
    return (this.head = e), (this.tail = t), this
  }
  function AOe(t, e, r) {
    var n = e === t.head ? new Cg(r, null, e, t) : new Cg(r, e, e.next, t)
    return n.next === null && (t.tail = n), n.prev === null && (t.head = n), t.length++, n
  }
  function ROe(t, e) {
    ;(t.tail = new Cg(e, t.tail, null, t)), t.head || (t.head = t.tail), t.length++
  }
  function DOe(t, e) {
    ;(t.head = new Cg(e, null, t.head, t)), t.tail || (t.tail = t.head), t.length++
  }
  function Cg(t, e, r, n) {
    if (!(this instanceof Cg)) return new Cg(t, e, r, n)
    ;(this.list = n),
      (this.value = t),
      e ? ((e.next = this), (this.prev = e)) : (this.prev = null),
      r ? ((r.prev = this), (this.next = r)) : (this.next = null)
  }
  try {
    tre()(mr)
  } catch {}
})
var cre = handleExports((Q0t, are) => {
  'use strict'
  var POe = nre(),
    Ig = Symbol('max'),
    Sp = Symbol('length'),
    O_ = Symbol('lengthCalculator'),
    aE = Symbol('allowStale'),
    wg = Symbol('maxAge'),
    Tp = Symbol('dispose'),
    ire = Symbol('noDisposeOnSet'),
    Bi = Symbol('lruList'),
    qc = Symbol('cache'),
    sre = Symbol('updateAgeOnGet'),
    g6 = () => 1,
    _6 = class {
      constructor(e) {
        if ((typeof e == 'number' && (e = { max: e }), e || (e = {}), e.max && (typeof e.max != 'number' || e.max < 0)))
          throw new TypeError('max must be a non-negative number')
        let r = (this[Ig] = e.max || 1 / 0),
          n = e.length || g6
        if (
          ((this[O_] = typeof n != 'function' ? g6 : n),
          (this[aE] = e.stale || !1),
          e.maxAge && typeof e.maxAge != 'number')
        )
          throw new TypeError('maxAge must be a number')
        ;(this[wg] = e.maxAge || 0),
          (this[Tp] = e.dispose),
          (this[ire] = e.noDisposeOnSet || !1),
          (this[sre] = e.updateAgeOnGet || !1),
          this.reset()
      }
      set max(e) {
        if (typeof e != 'number' || e < 0) throw new TypeError('max must be a non-negative number')
        ;(this[Ig] = e || 1 / 0), sE(this)
      }
      get max() {
        return this[Ig]
      }
      set allowStale(e) {
        this[aE] = !!e
      }
      get allowStale() {
        return this[aE]
      }
      set maxAge(e) {
        if (typeof e != 'number') throw new TypeError('maxAge must be a non-negative number')
        ;(this[wg] = e), sE(this)
      }
      get maxAge() {
        return this[wg]
      }
      set lengthCalculator(e) {
        typeof e != 'function' && (e = g6),
          e !== this[O_] &&
            ((this[O_] = e),
            (this[Sp] = 0),
            this[Bi].forEach(r => {
              ;(r.length = this[O_](r.value, r.key)), (this[Sp] += r.length)
            })),
          sE(this)
      }
      get lengthCalculator() {
        return this[O_]
      }
      get length() {
        return this[Sp]
      }
      get itemCount() {
        return this[Bi].length
      }
      rforEach(e, r) {
        r = r || this
        for (let n = this[Bi].tail; n !== null; ) {
          let i = n.prev
          ore(this, e, n, r), (n = i)
        }
      }
      forEach(e, r) {
        r = r || this
        for (let n = this[Bi].head; n !== null; ) {
          let i = n.next
          ore(this, e, n, r), (n = i)
        }
      }
      keys() {
        return this[Bi].toArray().map(e => e.key)
      }
      values() {
        return this[Bi].toArray().map(e => e.value)
      }
      reset() {
        this[Tp] && this[Bi] && this[Bi].length && this[Bi].forEach(e => this[Tp](e.key, e.value)),
          (this[qc] = new Map()),
          (this[Bi] = new POe()),
          (this[Sp] = 0)
      }
      dump() {
        return this[Bi].map(e => (E2(this, e) ? !1 : { k: e.key, v: e.value, e: e.now + (e.maxAge || 0) }))
          .toArray()
          .filter(e => e)
      }
      dumpLru() {
        return this[Bi]
      }
      set(e, r, n) {
        if (((n = n || this[wg]), n && typeof n != 'number')) throw new TypeError('maxAge must be a number')
        let i = n ? Date.now() : 0,
          o = this[O_](r, e)
        if (this[qc].has(e)) {
          if (o > this[Ig]) return L_(this, this[qc].get(e)), !1
          let l = this[qc].get(e).value
          return (
            this[Tp] && (this[ire] || this[Tp](e, l.value)),
            (l.now = i),
            (l.maxAge = n),
            (l.value = r),
            (this[Sp] += o - l.length),
            (l.length = o),
            this.get(e),
            sE(this),
            !0
          )
        }
        let s = new y6(e, r, o, i, n)
        return s.length > this[Ig]
          ? (this[Tp] && this[Tp](e, r), !1)
          : ((this[Sp] += s.length), this[Bi].unshift(s), this[qc].set(e, this[Bi].head), sE(this), !0)
      }
      has(e) {
        if (!this[qc].has(e)) return !1
        let r = this[qc].get(e).value
        return !E2(this, r)
      }
      get(e) {
        return v6(this, e, !0)
      }
      peek(e) {
        return v6(this, e, !1)
      }
      pop() {
        let e = this[Bi].tail
        return e ? (L_(this, e), e.value) : null
      }
      del(e) {
        L_(this, this[qc].get(e))
      }
      load(e) {
        this.reset()
        let r = Date.now()
        for (let n = e.length - 1; n >= 0; n--) {
          let i = e[n],
            o = i.e || 0
          if (o === 0) this.set(i.k, i.v)
          else {
            let s = o - r
            s > 0 && this.set(i.k, i.v, s)
          }
        }
      }
      prune() {
        this[qc].forEach((e, r) => v6(this, r, !1))
      }
    },
    v6 = (t, e, r) => {
      let n = t[qc].get(e)
      if (n) {
        let i = n.value
        if (E2(t, i)) {
          if ((L_(t, n), !t[aE])) return
        } else r && (t[sre] && (n.value.now = Date.now()), t[Bi].unshiftNode(n))
        return i.value
      }
    },
    E2 = (t, e) => {
      if (!e || (!e.maxAge && !t[wg])) return !1
      let r = Date.now() - e.now
      return e.maxAge ? r > e.maxAge : t[wg] && r > t[wg]
    },
    sE = t => {
      if (t[Sp] > t[Ig])
        for (let e = t[Bi].tail; t[Sp] > t[Ig] && e !== null; ) {
          let r = e.prev
          L_(t, e), (e = r)
        }
    },
    L_ = (t, e) => {
      if (e) {
        let r = e.value
        t[Tp] && t[Tp](r.key, r.value), (t[Sp] -= r.length), t[qc].delete(r.key), t[Bi].removeNode(e)
      }
    },
    y6 = class {
      constructor(e, r, n, i, o) {
        ;(this.key = e), (this.value = r), (this.length = n), (this.now = i), (this.maxAge = o || 0)
      }
    },
    ore = (t, e, r, n) => {
      let i = r.value
      E2(t, i) && (L_(t, r), t[aE] || (i = void 0)), i && e.call(n, i.value, i.key, t)
    }
  are.exports = _6
})
var Va = handleExports((X0t, dre) => {
  var x6 = class t {
    constructor(e, r) {
      if (((r = kOe(r)), e instanceof t))
        return e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease ? e : new t(e.raw, r)
      if (e instanceof b6) return (this.raw = e.value), (this.set = [[e]]), this.format(), this
      if (
        ((this.options = r),
        (this.loose = !!r.loose),
        (this.includePrerelease = !!r.includePrerelease),
        (this.raw = e.trim().split(/\s+/).join(' ')),
        (this.set = this.raw
          .split('||')
          .map(n => this.parseRange(n.trim()))
          .filter(n => n.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
      if (this.set.length > 1) {
        let n = this.set[0]
        if (((this.set = this.set.filter(i => !ure(i[0]))), this.set.length === 0)) this.set = [n]
        else if (this.set.length > 1) {
          for (let i of this.set)
            if (i.length === 1 && qOe(i[0])) {
              this.set = [i]
              break
            }
        }
      }
      this.format()
    }
    format() {
      return (
        (this.range = this.set
          .map(e => e.join(' ').trim())
          .join('||')
          .trim()),
        this.range
      )
    }
    toString() {
      return this.range
    }
    parseRange(e) {
      let n = ((this.options.includePrerelease && UOe) | (this.options.loose && BOe)) + ':' + e,
        i = lre.get(n)
      if (i) return i
      let o = this.options.loose,
        s = o ? Ss[Xo.HYPHENRANGELOOSE] : Ss[Xo.HYPHENRANGE]
      ;(e = e.replace(s, QOe(this.options.includePrerelease))),
        sn('hyphen replace', e),
        (e = e.replace(Ss[Xo.COMPARATORTRIM], LOe)),
        sn('comparator trim', e),
        (e = e.replace(Ss[Xo.TILDETRIM], MOe)),
        sn('tilde trim', e),
        (e = e.replace(Ss[Xo.CARETTRIM], FOe)),
        sn('caret trim', e)
      let a = e
        .split(' ')
        .map(p => HOe(p, this.options))
        .join(' ')
        .split(/\s+/)
        .map(p => YOe(p, this.options))
      o && (a = a.filter(p => (sn('loose invalid filter', p, this.options), !!p.match(Ss[Xo.COMPARATORLOOSE])))),
        sn('range list', a)
      let l = new Map(),
        c = a.map(p => new b6(p, this.options))
      for (let p of c) {
        if (ure(p)) return [p]
        l.set(p.value, p)
      }
      l.size > 1 && l.has('') && l.delete('')
      let u = [...l.values()]
      return lre.set(n, u), u
    }
    intersects(e, r) {
      if (!(e instanceof t)) throw new TypeError('a Range is required')
      return this.set.some(
        n => pre(n, r) && e.set.some(i => pre(i, r) && n.every(o => i.every(s => o.intersects(s, r))))
      )
    }
    test(e) {
      if (!e) return !1
      if (typeof e == 'string')
        try {
          e = new OOe(e, this.options)
        } catch {
          return !1
        }
      for (let r = 0; r < this.set.length; r++) if (XOe(this.set[r], e, this.options)) return !0
      return !1
    }
  }
  dre.exports = x6
  var NOe = cre(),
    lre = new NOe({ max: 1e3 }),
    kOe = f2(),
    b6 = cE(),
    sn = iE(),
    OOe = Co(),
    { safeRe: Ss, t: Xo, comparatorTrimReplace: LOe, tildeTrimReplace: MOe, caretTrimReplace: FOe } = N_(),
    { FLAG_INCLUDE_PRERELEASE: UOe, FLAG_LOOSE: BOe } = nE(),
    ure = t => t.value === '<0.0.0-0',
    qOe = t => t.value === '',
    pre = (t, e) => {
      let r = !0,
        n = t.slice(),
        i = n.pop()
      for (; r && n.length; ) (r = n.every(o => i.intersects(o, e))), (i = n.pop())
      return r
    },
    HOe = (t, e) => (
      sn('comp', t, e),
      (t = VOe(t, e)),
      sn('caret', t),
      (t = jOe(t, e)),
      sn('tildes', t),
      (t = $Oe(t, e)),
      sn('xrange', t),
      (t = KOe(t, e)),
      sn('stars', t),
      t
    ),
    Jo = t => !t || t.toLowerCase() === 'x' || t === '*',
    jOe = (t, e) =>
      t
        .trim()
        .split(/\s+/)
        .map(r => GOe(r, e))
        .join(' '),
    GOe = (t, e) => {
      let r = e.loose ? Ss[Xo.TILDELOOSE] : Ss[Xo.TILDE]
      return t.replace(r, (n, i, o, s, a) => {
        sn('tilde', t, n, i, o, s, a)
        let l
        return (
          Jo(i)
            ? (l = '')
            : Jo(o)
            ? (l = `>=${i}.0.0 <${+i + 1}.0.0-0`)
            : Jo(s)
            ? (l = `>=${i}.${o}.0 <${i}.${+o + 1}.0-0`)
            : a
            ? (sn('replaceTilde pr', a), (l = `>=${i}.${o}.${s}-${a} <${i}.${+o + 1}.0-0`))
            : (l = `>=${i}.${o}.${s} <${i}.${+o + 1}.0-0`),
          sn('tilde return', l),
          l
        )
      })
    },
    VOe = (t, e) =>
      t
        .trim()
        .split(/\s+/)
        .map(r => zOe(r, e))
        .join(' '),
    zOe = (t, e) => {
      sn('caret', t, e)
      let r = e.loose ? Ss[Xo.CARETLOOSE] : Ss[Xo.CARET],
        n = e.includePrerelease ? '-0' : ''
      return t.replace(r, (i, o, s, a, l) => {
        sn('caret', t, i, o, s, a, l)
        let c
        return (
          Jo(o)
            ? (c = '')
            : Jo(s)
            ? (c = `>=${o}.0.0${n} <${+o + 1}.0.0-0`)
            : Jo(a)
            ? o === '0'
              ? (c = `>=${o}.${s}.0${n} <${o}.${+s + 1}.0-0`)
              : (c = `>=${o}.${s}.0${n} <${+o + 1}.0.0-0`)
            : l
            ? (sn('replaceCaret pr', l),
              o === '0'
                ? s === '0'
                  ? (c = `>=${o}.${s}.${a}-${l} <${o}.${s}.${+a + 1}-0`)
                  : (c = `>=${o}.${s}.${a}-${l} <${o}.${+s + 1}.0-0`)
                : (c = `>=${o}.${s}.${a}-${l} <${+o + 1}.0.0-0`))
            : (sn('no pr'),
              o === '0'
                ? s === '0'
                  ? (c = `>=${o}.${s}.${a}${n} <${o}.${s}.${+a + 1}-0`)
                  : (c = `>=${o}.${s}.${a}${n} <${o}.${+s + 1}.0-0`)
                : (c = `>=${o}.${s}.${a} <${+o + 1}.0.0-0`)),
          sn('caret return', c),
          c
        )
      })
    },
    $Oe = (t, e) => (
      sn('replaceXRanges', t, e),
      t
        .split(/\s+/)
        .map(r => WOe(r, e))
        .join(' ')
    ),
    WOe = (t, e) => {
      t = t.trim()
      let r = e.loose ? Ss[Xo.XRANGELOOSE] : Ss[Xo.XRANGE]
      return t.replace(r, (n, i, o, s, a, l) => {
        sn('xRange', t, n, i, o, s, a, l)
        let c = Jo(o),
          u = c || Jo(s),
          p = u || Jo(a),
          d = p
        return (
          i === '=' && d && (i = ''),
          (l = e.includePrerelease ? '-0' : ''),
          c
            ? i === '>' || i === '<'
              ? (n = '<0.0.0-0')
              : (n = '*')
            : i && d
            ? (u && (s = 0),
              (a = 0),
              i === '>'
                ? ((i = '>='), u ? ((o = +o + 1), (s = 0), (a = 0)) : ((s = +s + 1), (a = 0)))
                : i === '<=' && ((i = '<'), u ? (o = +o + 1) : (s = +s + 1)),
              i === '<' && (l = '-0'),
              (n = `${i + o}.${s}.${a}${l}`))
            : u
            ? (n = `>=${o}.0.0${l} <${+o + 1}.0.0-0`)
            : p && (n = `>=${o}.${s}.0${l} <${o}.${+s + 1}.0-0`),
          sn('xRange return', n),
          n
        )
      })
    },
    KOe = (t, e) => (sn('replaceStars', t, e), t.trim().replace(Ss[Xo.STAR], '')),
    YOe = (t, e) => (sn('replaceGTE0', t, e), t.trim().replace(Ss[e.includePrerelease ? Xo.GTE0PRE : Xo.GTE0], '')),
    QOe = t => (e, r, n, i, o, s, a, l, c, u, p, d, f) =>
      Jo(n)
        ? (r = '')
        : Jo(i)
        ? (r = `>=${n}.0.0${t ? '-0' : ''}`)
        : Jo(o)
        ? (r = `>=${n}.${i}.0${t ? '-0' : ''}`)
        : s
        ? (r = `>=${r}`)
        : (r = `>=${r}${t ? '-0' : ''}`),
      Jo(c)
        ? (l = '')
        : Jo(u)
        ? (l = `<${+c + 1}.0.0-0`)
        : Jo(p)
        ? (l = `<${c}.${+u + 1}.0-0`)
        : d
        ? (l = `<=${c}.${u}.${p}-${d}`)
        : t
        ? (l = `<${c}.${u}.${+p + 1}-0`)
        : (l = `<=${l}`),
      `${r} ${l}`.trim(),
    XOe = (t, e, r) => {
      for (let n = 0; n < t.length; n++) if (!t[n].test(e)) return !1
      if (e.prerelease.length && !r.includePrerelease) {
        for (let n = 0; n < t.length; n++)
          if ((sn(t[n].semver), t[n].semver !== b6.ANY && t[n].semver.prerelease.length > 0)) {
            let i = t[n].semver
            if (i.major === e.major && i.minor === e.minor && i.patch === e.patch) return !0
          }
        return !1
      }
      return !0
    }
})
var cE = handleExports((J0t, _re) => {
  var lE = Symbol('SemVer ANY'),
    S6 = class t {
      static get ANY() {
        return lE
      }
      constructor(e, r) {
        if (((r = fre(r)), e instanceof t)) {
          if (e.loose === !!r.loose) return e
          e = e.value
        }
        ;(e = e.trim().split(/\s+/).join(' ')),
          T6('comparator', e, r),
          (this.options = r),
          (this.loose = !!r.loose),
          this.parse(e),
          this.semver === lE ? (this.value = '') : (this.value = this.operator + this.semver.version),
          T6('comp', this)
      }
      parse(e) {
        let r = this.options.loose ? mre[hre.COMPARATORLOOSE] : mre[hre.COMPARATOR],
          n = e.match(r)
        if (!n) throw new TypeError(`Invalid comparator: ${e}`)
        ;(this.operator = n[1] !== void 0 ? n[1] : ''),
          this.operator === '=' && (this.operator = ''),
          n[2] ? (this.semver = new gre(n[2], this.options.loose)) : (this.semver = lE)
      }
      toString() {
        return this.value
      }
      test(e) {
        if ((T6('Comparator.test', e, this.options.loose), this.semver === lE || e === lE)) return !0
        if (typeof e == 'string')
          try {
            e = new gre(e, this.options)
          } catch {
            return !1
          }
        return E6(e, this.operator, this.semver, this.options)
      }
      intersects(e, r) {
        if (!(e instanceof t)) throw new TypeError('a Comparator is required')
        return this.operator === ''
          ? this.value === ''
            ? !0
            : new vre(e.value, r).test(this.value)
          : e.operator === ''
          ? e.value === ''
            ? !0
            : new vre(this.value, r).test(e.semver)
          : ((r = fre(r)),
            (r.includePrerelease && (this.value === '<0.0.0-0' || e.value === '<0.0.0-0')) ||
            (!r.includePrerelease && (this.value.startsWith('<0.0.0') || e.value.startsWith('<0.0.0')))
              ? !1
              : !!(
                  (this.operator.startsWith('>') && e.operator.startsWith('>')) ||
                  (this.operator.startsWith('<') && e.operator.startsWith('<')) ||
                  (this.semver.version === e.semver.version &&
                    this.operator.includes('=') &&
                    e.operator.includes('=')) ||
                  (E6(this.semver, '<', e.semver, r) && this.operator.startsWith('>') && e.operator.startsWith('<')) ||
                  (E6(this.semver, '>', e.semver, r) && this.operator.startsWith('<') && e.operator.startsWith('>'))
                ))
      }
    }
  _re.exports = S6
  var fre = f2(),
    { safeRe: mre, t: hre } = N_(),
    E6 = h6(),
    T6 = iE(),
    gre = Co(),
    vre = Va()
})
var uE = handleExports((Z0t, yre) => {
  var JOe = Va(),
    ZOe = (t, e, r) => {
      try {
        e = new JOe(e, r)
      } catch {
        return !1
      }
      return e.test(t)
    }
  yre.exports = ZOe
})
var bre = handleExports((e_t, xre) => {
  var eLe = Va(),
    tLe = (t, e) =>
      new eLe(t, e).set.map(r =>
        r
          .map(n => n.value)
          .join(' ')
          .trim()
          .split(' ')
      )
  xre.exports = tLe
})
var Tre = handleExports((t_t, Ere) => {
  var rLe = Co(),
    nLe = Va(),
    iLe = (t, e, r) => {
      let n = null,
        i = null,
        o = null
      try {
        o = new nLe(e, r)
      } catch {
        return null
      }
      return (
        t.forEach(s => {
          o.test(s) && (!n || i.compare(s) === -1) && ((n = s), (i = new rLe(n, r)))
        }),
        n
      )
    }
  Ere.exports = iLe
})
var Cre = handleExports((r_t, Sre) => {
  var oLe = Co(),
    sLe = Va(),
    aLe = (t, e, r) => {
      let n = null,
        i = null,
        o = null
      try {
        o = new sLe(e, r)
      } catch {
        return null
      }
      return (
        t.forEach(s => {
          o.test(s) && (!n || i.compare(s) === 1) && ((n = s), (i = new oLe(n, r)))
        }),
        n
      )
    }
  Sre.exports = aLe
})
var Are = handleExports((n_t, wre) => {
  var C6 = Co(),
    cLe = Va(),
    Ire = oE(),
    lLe = (t, e) => {
      t = new cLe(t, e)
      let r = new C6('0.0.0')
      if (t.test(r) || ((r = new C6('0.0.0-0')), t.test(r))) return r
      r = null
      for (let n = 0; n < t.set.length; ++n) {
        let i = t.set[n],
          o = null
        i.forEach(s => {
          let a = new C6(s.semver.version)
          switch (s.operator) {
            case '>':
              a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), (a.raw = a.format())
            case '':
            case '>=':
              ;(!o || Ire(a, o)) && (o = a)
              break
            case '<':
            case '<=':
              break
            default:
              throw new Error(`Unexpected operation: ${s.operator}`)
          }
        }),
          o && (!r || Ire(r, o)) && (r = o)
      }
      return r && t.test(r) ? r : null
    }
  wre.exports = lLe
})
var Dre = handleExports((i_t, Rre) => {
  var uLe = Va(),
    pLe = (t, e) => {
      try {
        return new uLe(t, e).range || '*'
      } catch {
        return null
      }
    }
  Rre.exports = pLe
})
var T2 = handleExports((o_t, Ore) => {
  var dLe = Co(),
    kre = cE(),
    { ANY: fLe } = kre,
    mLe = Va(),
    hLe = uE(),
    Pre = oE(),
    Nre = v2(),
    gLe = y2(),
    vLe = _2(),
    _Le = (t, e, r, n) => {
      ;(t = new dLe(t, n)), (e = new mLe(e, n))
      let i, o, s, a, l
      switch (r) {
        case '>':
          ;(i = Pre), (o = gLe), (s = Nre), (a = '>'), (l = '>=')
          break
        case '<':
          ;(i = Nre), (o = vLe), (s = Pre), (a = '<'), (l = '<=')
          break
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"')
      }
      if (hLe(t, e, n)) return !1
      for (let c = 0; c < e.set.length; ++c) {
        let u = e.set[c],
          p = null,
          d = null
        if (
          (u.forEach(f => {
            f.semver === fLe && (f = new kre('>=0.0.0')),
              (p = p || f),
              (d = d || f),
              i(f.semver, p.semver, n) ? (p = f) : s(f.semver, d.semver, n) && (d = f)
          }),
          p.operator === a || p.operator === l || ((!d.operator || d.operator === a) && o(t, d.semver)))
        )
          return !1
        if (d.operator === l && s(t, d.semver)) return !1
      }
      return !0
    }
  Ore.exports = _Le
})
var Mre = handleExports((s_t, Lre) => {
  var yLe = T2(),
    xLe = (t, e, r) => yLe(t, e, '>', r)
  Lre.exports = xLe
})
var Ure = handleExports((a_t, Fre) => {
  var bLe = T2(),
    ELe = (t, e, r) => bLe(t, e, '<', r)
  Fre.exports = ELe
})
var Hre = handleExports((c_t, qre) => {
  var Bre = Va(),
    TLe = (t, e, r) => ((t = new Bre(t, r)), (e = new Bre(e, r)), t.intersects(e, r))
  qre.exports = TLe
})
var Gre = handleExports((l_t, jre) => {
  var SLe = uE(),
    CLe = Ga()
  jre.exports = (t, e, r) => {
    let n = [],
      i = null,
      o = null,
      s = t.sort((u, p) => CLe(u, p, r))
    for (let u of s) SLe(u, e, r) ? ((o = u), i || (i = u)) : (o && n.push([i, o]), (o = null), (i = null))
    i && n.push([i, null])
    let a = []
    for (let [u, p] of n)
      u === p
        ? a.push(u)
        : !p && u === s[0]
        ? a.push('*')
        : p
        ? u === s[0]
          ? a.push(`<=${p}`)
          : a.push(`${u} - ${p}`)
        : a.push(`>=${u}`)
    let l = a.join(' || '),
      c = typeof e.raw == 'string' ? e.raw : String(e)
    return l.length < c.length ? l : e
  }
})
var Yre = handleExports((u_t, Kre) => {
  var Vre = Va(),
    w6 = cE(),
    { ANY: I6 } = w6,
    pE = uE(),
    A6 = Ga(),
    ILe = (t, e, r = {}) => {
      if (t === e) return !0
      ;(t = new Vre(t, r)), (e = new Vre(e, r))
      let n = !1
      e: for (let i of t.set) {
        for (let o of e.set) {
          let s = ALe(i, o, r)
          if (((n = n || s !== null), s)) continue e
        }
        if (n) return !1
      }
      return !0
    },
    wLe = [new w6('>=0.0.0-0')],
    zre = [new w6('>=0.0.0')],
    ALe = (t, e, r) => {
      if (t === e) return !0
      if (t.length === 1 && t[0].semver === I6) {
        if (e.length === 1 && e[0].semver === I6) return !0
        r.includePrerelease ? (t = wLe) : (t = zre)
      }
      if (e.length === 1 && e[0].semver === I6) {
        if (r.includePrerelease) return !0
        e = zre
      }
      let n = new Set(),
        i,
        o
      for (let f of t)
        f.operator === '>' || f.operator === '>='
          ? (i = $re(i, f, r))
          : f.operator === '<' || f.operator === '<='
          ? (o = Wre(o, f, r))
          : n.add(f.semver)
      if (n.size > 1) return null
      let s
      if (i && o) {
        if (((s = A6(i.semver, o.semver, r)), s > 0)) return null
        if (s === 0 && (i.operator !== '>=' || o.operator !== '<=')) return null
      }
      for (let f of n) {
        if ((i && !pE(f, String(i), r)) || (o && !pE(f, String(o), r))) return null
        for (let m of e) if (!pE(f, String(m), r)) return !1
        return !0
      }
      let a,
        l,
        c,
        u,
        p = o && !r.includePrerelease && o.semver.prerelease.length ? o.semver : !1,
        d = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1
      p && p.prerelease.length === 1 && o.operator === '<' && p.prerelease[0] === 0 && (p = !1)
      for (let f of e) {
        if (
          ((u = u || f.operator === '>' || f.operator === '>='),
          (c = c || f.operator === '<' || f.operator === '<='),
          i)
        ) {
          if (
            (d &&
              f.semver.prerelease &&
              f.semver.prerelease.length &&
              f.semver.major === d.major &&
              f.semver.minor === d.minor &&
              f.semver.patch === d.patch &&
              (d = !1),
            f.operator === '>' || f.operator === '>=')
          ) {
            if (((a = $re(i, f, r)), a === f && a !== i)) return !1
          } else if (i.operator === '>=' && !pE(i.semver, String(f), r)) return !1
        }
        if (o) {
          if (
            (p &&
              f.semver.prerelease &&
              f.semver.prerelease.length &&
              f.semver.major === p.major &&
              f.semver.minor === p.minor &&
              f.semver.patch === p.patch &&
              (p = !1),
            f.operator === '<' || f.operator === '<=')
          ) {
            if (((l = Wre(o, f, r)), l === f && l !== o)) return !1
          } else if (o.operator === '<=' && !pE(o.semver, String(f), r)) return !1
        }
        if (!f.operator && (o || i) && s !== 0) return !1
      }
      return !((i && c && !o && s !== 0) || (o && u && !i && s !== 0) || d || p)
    },
    $re = (t, e, r) => {
      if (!t) return e
      let n = A6(t.semver, e.semver, r)
      return n > 0 ? t : n < 0 || (e.operator === '>' && t.operator === '>=') ? e : t
    },
    Wre = (t, e, r) => {
      if (!t) return e
      let n = A6(t.semver, e.semver, r)
      return n < 0 ? t : n > 0 || (e.operator === '<' && t.operator === '<=') ? e : t
    }
  Kre.exports = ILe
})
var Zre = handleExports((p_t, Jre) => {
  var R6 = N_(),
    Qre = nE(),
    RLe = Co(),
    Xre = p6(),
    DLe = Sg(),
    PLe = gte(),
    NLe = _te(),
    kLe = bte(),
    OLe = Ste(),
    LLe = Ite(),
    MLe = Ate(),
    FLe = Dte(),
    ULe = Nte(),
    BLe = Ga(),
    qLe = Mte(),
    HLe = Ute(),
    jLe = g2(),
    GLe = jte(),
    VLe = Vte(),
    zLe = oE(),
    $Le = v2(),
    WLe = f6(),
    KLe = m6(),
    YLe = _2(),
    QLe = y2(),
    XLe = h6(),
    JLe = Zte(),
    ZLe = cE(),
    e5e = Va(),
    t5e = uE(),
    r5e = bre(),
    n5e = Tre(),
    i5e = Cre(),
    o5e = Are(),
    s5e = Dre(),
    a5e = T2(),
    c5e = Mre(),
    l5e = Ure(),
    u5e = Hre(),
    p5e = Gre(),
    d5e = Yre()
  Jre.exports = {
    parse: DLe,
    valid: PLe,
    clean: NLe,
    inc: kLe,
    diff: OLe,
    major: LLe,
    minor: MLe,
    patch: FLe,
    prerelease: ULe,
    compare: BLe,
    rcompare: qLe,
    compareLoose: HLe,
    compareBuild: jLe,
    sort: GLe,
    rsort: VLe,
    gt: zLe,
    lt: $Le,
    eq: WLe,
    neq: KLe,
    gte: YLe,
    lte: QLe,
    cmp: XLe,
    coerce: JLe,
    Comparator: ZLe,
    Range: e5e,
    satisfies: t5e,
    toComparators: r5e,
    maxSatisfying: n5e,
    minSatisfying: i5e,
    minVersion: o5e,
    validRange: s5e,
    outside: a5e,
    gtr: c5e,
    ltr: l5e,
    intersects: u5e,
    simplifyRange: p5e,
    subset: d5e,
    SemVer: RLe,
    re: R6.re,
    src: R6.src,
    tokens: R6.t,
    SEMVER_SPEC_VERSION: Qre.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: Qre.RELEASE_TYPES,
    compareIdentifiers: Xre.compareIdentifiers,
    rcompareIdentifiers: Xre.rcompareIdentifiers,
  }
})
var D6 = handleExports(S2 => {
  'use strict'
  Object.defineProperty(S2, '__esModule', { value: !0 })
  S2.makePatchingRequire = void 0
  var f5e = require('path'),
    m5e = Zre(),
    ene = On(),
    rne = require('module'),
    h5e = Object.keys(process.binding('natives')),
    tne = rne.prototype.require
  function g5e(t) {
    var e = {}
    return function (n) {
      var i = tne.apply(this, arguments)
      if (t[n]) {
        var o = rne._resolveFilename(n, this)
        if (e.hasOwnProperty(o)) return e[o]
        var s = void 0
        if (h5e.indexOf(n) < 0)
          try {
            s = tne.call(this, f5e.join(n, 'package.json')).version
          } catch {
            return i
          }
        else s = process.version.substring(1)
        var a = s.indexOf('-')
        a >= 0 && (s = s.substring(0, a))
        for (var l = i, c = 0, u = t[n]; c < u.length; c++) {
          var p = u[c]
          if (m5e.satisfies(s, p.versionSpecifier) && ((l = p.patch(l, o)), ene.channel)) {
            var d = p.publisherName || n
            ene.channel.addPatchedModule(d, s)
          }
        }
        return (e[o] = l)
      }
      return i
    }
  }
  S2.makePatchingRequire = g5e
})
var nne = handleExports((f_t, v5e) => {
  v5e.exports = {
    name: 'diagnostic-channel',
    version: '1.1.1',
    main: './dist/src/channel.js',
    types: './dist/src/channel.d.ts',
    scripts: {
      build: 'tsc',
      lint: 'eslint ./ --fix',
      clean: 'rimraf ./dist',
      test: 'mocha ./dist/tests/**/*.js',
      debug: 'mocha --inspect-brk ./dist/tests/**/*.js',
    },
    homepage: 'https://github.com/Microsoft/node-diagnostic-channel',
    bugs: { url: 'https://github.com/Microsoft/node-diagnostic-channel/issues' },
    repository: { type: 'git', url: 'https://github.com/Microsoft/node-diagnostic-channel.git' },
    description: 'Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers',
    dependencies: { semver: '^7.5.3' },
    devDependencies: {
      '@types/mocha': '^2.2.40',
      '@types/node': '~8.0.0',
      mocha: '^3.2.0',
      rimraf: '^2.6.1',
      sinon: '1.17.6',
      typescript: '4.1.2',
    },
    files: ['dist/src/**/*.d.ts', 'dist/src/**/*.js', 'LICENSE', 'README.md', 'package.json'],
    license: 'MIT',
  }
})
var On = handleExports(za => {
  'use strict'
  Object.defineProperty(za, '__esModule', { value: !0 })
  za.channel = za.ContextPreservingEventEmitter = za.trueFilter = za.makePatchingRequire = void 0
  var _5e = D6(),
    y5e = D6()
  Object.defineProperty(za, 'makePatchingRequire', {
    enumerable: !0,
    get: function () {
      return y5e.makePatchingRequire
    },
  })
  var x5e = function (t) {
    return !0
  }
  za.trueFilter = x5e
  var one = (function () {
    function t() {
      ;(this.version = nne().version),
        (this.subscribers = {}),
        (this.contextPreservationFunction = function (e) {
          return e
        }),
        (this.knownPatches = {}),
        (this.modulesPatched = []),
        (this.currentlyPublishing = !1)
    }
    return (
      (t.prototype.shouldPublish = function (e) {
        var r = this.subscribers[e]
        return r
          ? r.some(function (n) {
              var i = n.filter
              return !i || i(!1)
            })
          : !1
      }),
      (t.prototype.publish = function (e, r) {
        if (!this.currentlyPublishing) {
          var n = this.subscribers[e]
          if (n) {
            var i = { timestamp: Date.now(), data: r }
            ;(this.currentlyPublishing = !0),
              n.forEach(function (o) {
                var s = o.listener,
                  a = o.filter
                try {
                  a && a(!0) && s(i)
                } catch {}
              }),
              (this.currentlyPublishing = !1)
          }
        }
      }),
      (t.prototype.subscribe = function (e, r, n, i) {
        n === void 0 && (n = za.trueFilter),
          this.subscribers[e] || (this.subscribers[e] = []),
          this.subscribers[e].push({ listener: r, filter: n, patchCallback: i })
        var o = this.checkIfModuleIsAlreadyPatched(e)
        o && i && i(o.name, o.version)
      }),
      (t.prototype.unsubscribe = function (e, r, n) {
        n === void 0 && (n = za.trueFilter)
        var i = this.subscribers[e]
        if (i) {
          for (var o = 0; o < i.length; ++o) if (i[o].listener === r && i[o].filter === n) return i.splice(o, 1), !0
        }
        return !1
      }),
      (t.prototype.reset = function () {
        var e = this
        ;(this.subscribers = {}),
          (this.contextPreservationFunction = function (r) {
            return r
          }),
          Object.getOwnPropertyNames(this.knownPatches).forEach(function (r) {
            return delete e.knownPatches[r]
          })
      }),
      (t.prototype.bindToContext = function (e) {
        return this.contextPreservationFunction(e)
      }),
      (t.prototype.addContextPreservation = function (e) {
        var r = this.contextPreservationFunction
        this.contextPreservationFunction = function (n) {
          return e(r(n))
        }
      }),
      (t.prototype.registerMonkeyPatch = function (e, r) {
        this.knownPatches[e] || (this.knownPatches[e] = []), this.knownPatches[e].push(r)
      }),
      (t.prototype.getPatchesObject = function () {
        return this.knownPatches
      }),
      (t.prototype.addPatchedModule = function (e, r) {
        for (var n = 0, i = this.modulesPatched; n < i.length; n++) {
          var o = i[n]
          if (o.name === e) return
        }
        this.modulesPatched.push({ name: e, version: r })
        var s = this.subscribers[e]
        s &&
          s.forEach(function (a) {
            a.patchCallback && a.patchCallback(e, r)
          })
      }),
      (t.prototype.checkIfModuleIsAlreadyPatched = function (e) {
        for (var r = 0, n = this.modulesPatched; r < n.length; r++) {
          var i = n[r]
          if (i.name === e) return i
        }
        return null
      }),
      t
    )
  })()
  za.ContextPreservingEventEmitter = one
  global.diagnosticsSource ||
    ((global.diagnosticsSource = new one()),
    (ine = require('module')),
    (ine.prototype.require = _5e.makePatchingRequire(global.diagnosticsSource.getPatchesObject())))
  var ine
  za.channel = global.diagnosticsSource
})
var sne,
  ane = createGetter(() => {
    sne = typeof globalThis == 'object' ? globalThis : global
  })
var cne = createGetter(() => {
  ane()
})
var lne = createGetter(() => {
  cne()
})
var Cp,
  P6 = createGetter(() => {
    Cp = '1.6.0'
  })
function b5e(t) {
  var e = new Set([t]),
    r = new Set(),
    n = t.match(une)
  if (!n)
    return function () {
      return !1
    }
  var i = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] }
  if (i.prerelease != null)
    return function (l) {
      return l === t
    }
  function o(a) {
    return r.add(a), !1
  }
  function s(a) {
    return e.add(a), !0
  }
  return function (l) {
    if (e.has(l)) return !0
    if (r.has(l)) return !1
    var c = l.match(une)
    if (!c) return o(l)
    var u = { major: +c[1], minor: +c[2], patch: +c[3], prerelease: c[4] }
    return u.prerelease != null || i.major !== u.major
      ? o(l)
      : i.major === 0
      ? i.minor === u.minor && i.patch <= u.patch
        ? s(l)
        : o(l)
      : i.minor <= u.minor
      ? s(l)
      : o(l)
  }
}
var une,
  pne,
  dne = createGetter(() => {
    P6()
    une = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/
    pne = b5e(Cp)
  })
function $l(t, e, r, n) {
  var i
  n === void 0 && (n = !1)
  var o = (fE[dE] = (i = fE[dE]) !== null && i !== void 0 ? i : { version: Cp })
  if (!n && o[t]) {
    var s = new Error('@opentelemetry/api: Attempted duplicate registration of API: ' + t)
    return r.error(s.stack || s.message), !1
  }
  if (o.version !== Cp) {
    var s = new Error(
      '@opentelemetry/api: Registration of version v' +
        o.version +
        ' for ' +
        t +
        ' does not match previously registered API v' +
        Cp
    )
    return r.error(s.stack || s.message), !1
  }
  return (o[t] = e), r.debug('@opentelemetry/api: Registered a global for ' + t + ' v' + Cp + '.'), !0
}
function pa(t) {
  var e,
    r,
    n = (e = fE[dE]) === null || e === void 0 ? void 0 : e.version
  if (!(!n || !pne(n))) return (r = fE[dE]) === null || r === void 0 ? void 0 : r[t]
}
function Wl(t, e) {
  e.debug('@opentelemetry/api: Unregistering a global for ' + t + ' v' + Cp + '.')
  var r = fE[dE]
  r && delete r[t]
}
var E5e,
  dE,
  fE,
  Ag = createGetter(() => {
    lne()
    P6()
    dne()
    ;(E5e = Cp.split('.')[0]), (dE = Symbol.for('opentelemetry.js.api.' + E5e)), (fE = sne)
  })
function mE(t, e, r) {
  var n = pa('diag')
  if (n) return r.unshift(e), n[t].apply(n, S5e([], T5e(r), !1))
}
var T5e,
  S5e,
  fne,
  mne = createGetter(() => {
    Ag()
    ;(T5e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (S5e = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (fne = (function () {
        function t(e) {
          this._namespace = e.namespace || 'DiagComponentLogger'
        }
        return (
          (t.prototype.debug = function () {
            for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
            return mE('debug', this._namespace, e)
          }),
          (t.prototype.error = function () {
            for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
            return mE('error', this._namespace, e)
          }),
          (t.prototype.info = function () {
            for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
            return mE('info', this._namespace, e)
          }),
          (t.prototype.warn = function () {
            for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
            return mE('warn', this._namespace, e)
          }),
          (t.prototype.verbose = function () {
            for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
            return mE('verbose', this._namespace, e)
          }),
          t
        )
      })())
  })
var Gr,
  C2 = createGetter(() => {
    ;(function (t) {
      ;(t[(t.NONE = 0)] = 'NONE'),
        (t[(t.ERROR = 30)] = 'ERROR'),
        (t[(t.WARN = 50)] = 'WARN'),
        (t[(t.INFO = 60)] = 'INFO'),
        (t[(t.DEBUG = 70)] = 'DEBUG'),
        (t[(t.VERBOSE = 80)] = 'VERBOSE'),
        (t[(t.ALL = 9999)] = 'ALL')
    })(Gr || (Gr = {}))
  })
function hne(t, e) {
  t < Gr.NONE ? (t = Gr.NONE) : t > Gr.ALL && (t = Gr.ALL), (e = e || {})
  function r(n, i) {
    var o = e[n]
    return typeof o == 'function' && t >= i ? o.bind(e) : function () {}
  }
  return {
    error: r('error', Gr.ERROR),
    warn: r('warn', Gr.WARN),
    info: r('info', Gr.INFO),
    debug: r('debug', Gr.DEBUG),
    verbose: r('verbose', Gr.VERBOSE),
  }
}
var gne = createGetter(() => {
  C2()
})
var C5e,
  I5e,
  w5e,
  Io,
  Rg = createGetter(() => {
    mne()
    gne()
    C2()
    Ag()
    ;(C5e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (I5e = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (w5e = 'diag'),
      (Io = (function () {
        function t() {
          function e(i) {
            return function () {
              for (var o = [], s = 0; s < arguments.length; s++) o[s] = arguments[s]
              var a = pa('diag')
              if (a) return a[i].apply(a, I5e([], C5e(o), !1))
            }
          }
          var r = this,
            n = function (i, o) {
              var s, a, l
              if ((o === void 0 && (o = { logLevel: Gr.INFO }), i === r)) {
                var c = new Error(
                  'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                )
                return r.error((s = c.stack) !== null && s !== void 0 ? s : c.message), !1
              }
              typeof o == 'number' && (o = { logLevel: o })
              var u = pa('diag'),
                p = hne((a = o.logLevel) !== null && a !== void 0 ? a : Gr.INFO, i)
              if (u && !o.suppressOverrideMessage) {
                var d = (l = new Error().stack) !== null && l !== void 0 ? l : '<failed to generate stacktrace>'
                u.warn('Current logger will be overwritten from ' + d),
                  p.warn('Current logger will overwrite one already registered from ' + d)
              }
              return $l('diag', p, r, !0)
            }
          ;(r.setLogger = n),
            (r.disable = function () {
              Wl(w5e, r)
            }),
            (r.createComponentLogger = function (i) {
              return new fne(i)
            }),
            (r.verbose = e('verbose')),
            (r.debug = e('debug')),
            (r.info = e('info')),
            (r.warn = e('warn')),
            (r.error = e('error'))
        }
        return (
          (t.instance = function () {
            return this._instance || (this._instance = new t()), this._instance
          }),
          t
        )
      })())
  })
var A5e,
  R5e,
  vne,
  _ne = createGetter(() => {
    ;(A5e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (R5e = function (t) {
        var e = typeof Symbol == 'function' && Symbol.iterator,
          r = e && t[e],
          n = 0
        if (r) return r.call(t)
        if (t && typeof t.length == 'number')
          return {
            next: function () {
              return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
            },
          }
        throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
      }),
      (vne = (function () {
        function t(e) {
          this._entries = e ? new Map(e) : new Map()
        }
        return (
          (t.prototype.getEntry = function (e) {
            var r = this._entries.get(e)
            if (r) return Object.assign({}, r)
          }),
          (t.prototype.getAllEntries = function () {
            return Array.from(this._entries.entries()).map(function (e) {
              var r = A5e(e, 2),
                n = r[0],
                i = r[1]
              return [n, i]
            })
          }),
          (t.prototype.setEntry = function (e, r) {
            var n = new t(this._entries)
            return n._entries.set(e, r), n
          }),
          (t.prototype.removeEntry = function (e) {
            var r = new t(this._entries)
            return r._entries.delete(e), r
          }),
          (t.prototype.removeEntries = function () {
            for (var e, r, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i]
            var o = new t(this._entries)
            try {
              for (var s = R5e(n), a = s.next(); !a.done; a = s.next()) {
                var l = a.value
                o._entries.delete(l)
              }
            } catch (c) {
              e = { error: c }
            } finally {
              try {
                a && !a.done && (r = s.return) && r.call(s)
              } finally {
                if (e) throw e.error
              }
            }
            return o
          }),
          (t.prototype.clear = function () {
            return new t()
          }),
          t
        )
      })())
  })
var yne,
  xne = createGetter(() => {
    yne = Symbol('BaggageEntryMetadata')
  })
function bne(t) {
  return t === void 0 && (t = {}), new vne(new Map(Object.entries(t)))
}
function I2(t) {
  return (
    typeof t != 'string' && (D5e.error('Cannot create baggage metadata from unknown type: ' + typeof t), (t = '')),
    {
      __TYPE__: yne,
      toString: function () {
        return t
      },
    }
  )
}
var D5e,
  N6 = createGetter(() => {
    Rg()
    _ne()
    xne()
    D5e = Io.instance()
  })
function Kl(t) {
  return Symbol.for(t)
}
var P5e,
  w2,
  hE = createGetter(() => {
    ;(P5e = (function () {
      function t(e) {
        var r = this
        ;(r._currentContext = e ? new Map(e) : new Map()),
          (r.getValue = function (n) {
            return r._currentContext.get(n)
          }),
          (r.setValue = function (n, i) {
            var o = new t(r._currentContext)
            return o._currentContext.set(n, i), o
          }),
          (r.deleteValue = function (n) {
            var i = new t(r._currentContext)
            return i._currentContext.delete(n), i
          })
      }
      return t
    })()),
      (w2 = new P5e())
  })
var k6,
  Ene,
  Tne = createGetter(() => {
    ;(k6 = [
      { n: 'error', c: 'error' },
      { n: 'warn', c: 'warn' },
      { n: 'info', c: 'info' },
      { n: 'debug', c: 'debug' },
      { n: 'verbose', c: 'trace' },
    ]),
      (Ene = (function () {
        function t() {
          function e(n) {
            return function () {
              for (var i = [], o = 0; o < arguments.length; o++) i[o] = arguments[o]
              if (console) {
                var s = console[n]
                if ((typeof s != 'function' && (s = console.log), typeof s == 'function')) return s.apply(console, i)
              }
            }
          }
          for (var r = 0; r < k6.length; r++) this[k6[r].n] = e(k6[r].c)
        }
        return t
      })())
  })
function Sne() {
  return M6
}
var M_,
  N5e,
  O6,
  k5e,
  O5e,
  L5e,
  L6,
  M5e,
  F5e,
  U5e,
  M6,
  B5e,
  q5e,
  H5e,
  j5e,
  G5e,
  V5e,
  F6 = createGetter(() => {
    ;(M_ = (function () {
      var t = function (e, r) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i
              }) ||
            function (n, i) {
              for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
            }),
          t(e, r)
        )
      }
      return function (e, r) {
        if (typeof r != 'function' && r !== null)
          throw new TypeError('Class extends value ' + String(r) + ' is not a constructor or null')
        t(e, r)
        function n() {
          this.constructor = e
        }
        e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
      }
    })()),
      (N5e = (function () {
        function t() {}
        return (
          (t.prototype.createHistogram = function (e, r) {
            return q5e
          }),
          (t.prototype.createCounter = function (e, r) {
            return B5e
          }),
          (t.prototype.createUpDownCounter = function (e, r) {
            return H5e
          }),
          (t.prototype.createObservableGauge = function (e, r) {
            return G5e
          }),
          (t.prototype.createObservableCounter = function (e, r) {
            return j5e
          }),
          (t.prototype.createObservableUpDownCounter = function (e, r) {
            return V5e
          }),
          (t.prototype.addBatchObservableCallback = function (e, r) {}),
          (t.prototype.removeBatchObservableCallback = function (e) {}),
          t
        )
      })()),
      (O6 = (function () {
        function t() {}
        return t
      })()),
      (k5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return (e.prototype.add = function (r, n) {}), e
      })(O6)),
      (O5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return (e.prototype.add = function (r, n) {}), e
      })(O6)),
      (L5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return (e.prototype.record = function (r, n) {}), e
      })(O6)),
      (L6 = (function () {
        function t() {}
        return (t.prototype.addCallback = function (e) {}), (t.prototype.removeCallback = function (e) {}), t
      })()),
      (M5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return e
      })(L6)),
      (F5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return e
      })(L6)),
      (U5e = (function (t) {
        M_(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return e
      })(L6)),
      (M6 = new N5e()),
      (B5e = new k5e()),
      (q5e = new L5e()),
      (H5e = new O5e()),
      (j5e = new M5e()),
      (G5e = new F5e()),
      (V5e = new U5e())
  })
var A2,
  Cne = createGetter(() => {
    ;(function (t) {
      ;(t[(t.INT = 0)] = 'INT'), (t[(t.DOUBLE = 1)] = 'DOUBLE')
    })(A2 || (A2 = {}))
  })
var R2,
  D2,
  U6 = createGetter(() => {
    ;(R2 = {
      get: function (t, e) {
        if (t != null) return t[e]
      },
      keys: function (t) {
        return t == null ? [] : Object.keys(t)
      },
    }),
      (D2 = {
        set: function (t, e, r) {
          t != null && (t[e] = r)
        },
      })
  })
var z5e,
  $5e,
  Ine,
  wne = createGetter(() => {
    hE()
    ;(z5e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      ($5e = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (Ine = (function () {
        function t() {}
        return (
          (t.prototype.active = function () {
            return w2
          }),
          (t.prototype.with = function (e, r, n) {
            for (var i = [], o = 3; o < arguments.length; o++) i[o - 3] = arguments[o]
            return r.call.apply(r, $5e([n], z5e(i), !1))
          }),
          (t.prototype.bind = function (e, r) {
            return r
          }),
          (t.prototype.enable = function () {
            return this
          }),
          (t.prototype.disable = function () {
            return this
          }),
          t
        )
      })())
  })
var W5e,
  K5e,
  B6,
  Y5e,
  Lf,
  gE = createGetter(() => {
    wne()
    Ag()
    Rg()
    ;(W5e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (K5e = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (B6 = 'context'),
      (Y5e = new Ine()),
      (Lf = (function () {
        function t() {}
        return (
          (t.getInstance = function () {
            return this._instance || (this._instance = new t()), this._instance
          }),
          (t.prototype.setGlobalContextManager = function (e) {
            return $l(B6, e, Io.instance())
          }),
          (t.prototype.active = function () {
            return this._getContextManager().active()
          }),
          (t.prototype.with = function (e, r, n) {
            for (var i, o = [], s = 3; s < arguments.length; s++) o[s - 3] = arguments[s]
            return (i = this._getContextManager()).with.apply(i, K5e([e, r, n], W5e(o), !1))
          }),
          (t.prototype.bind = function (e, r) {
            return this._getContextManager().bind(e, r)
          }),
          (t.prototype._getContextManager = function () {
            return pa(B6) || Y5e
          }),
          (t.prototype.disable = function () {
            this._getContextManager().disable(), Wl(B6, Io.instance())
          }),
          t
        )
      })())
  })
var Vn,
  q6 = createGetter(() => {
    ;(function (t) {
      ;(t[(t.NONE = 0)] = 'NONE'), (t[(t.SAMPLED = 1)] = 'SAMPLED')
    })(Vn || (Vn = {}))
  })
var vE,
  _E,
  F_,
  P2 = createGetter(() => {
    q6()
    ;(vE = '0000000000000000'),
      (_E = '00000000000000000000000000000000'),
      (F_ = { traceId: _E, spanId: vE, traceFlags: Vn.NONE })
  })
var Mf,
  N2 = createGetter(() => {
    P2()
    Mf = (function () {
      function t(e) {
        e === void 0 && (e = F_), (this._spanContext = e)
      }
      return (
        (t.prototype.spanContext = function () {
          return this._spanContext
        }),
        (t.prototype.setAttribute = function (e, r) {
          return this
        }),
        (t.prototype.setAttributes = function (e) {
          return this
        }),
        (t.prototype.addEvent = function (e, r) {
          return this
        }),
        (t.prototype.setStatus = function (e) {
          return this
        }),
        (t.prototype.updateName = function (e) {
          return this
        }),
        (t.prototype.end = function (e) {}),
        (t.prototype.isRecording = function () {
          return !1
        }),
        (t.prototype.recordException = function (e, r) {}),
        t
      )
    })()
  })
function k2(t) {
  return t.getValue(H6) || void 0
}
function Ane() {
  return k2(Lf.getInstance().active())
}
function yE(t, e) {
  return t.setValue(H6, e)
}
function Rne(t) {
  return t.deleteValue(H6)
}
function Dne(t, e) {
  return yE(t, new Mf(e))
}
function O2(t) {
  var e
  return (e = k2(t)) === null || e === void 0 ? void 0 : e.spanContext()
}
var H6,
  j6 = createGetter(() => {
    hE()
    N2()
    gE()
    H6 = Kl('OpenTelemetry Context Key SPAN')
  })
function Dg(t) {
  return Q5e.test(t) && t !== _E
}
function G6(t) {
  return X5e.test(t) && t !== vE
}
function $a(t) {
  return Dg(t.traceId) && G6(t.spanId)
}
function Pne(t) {
  return new Mf(t)
}
var Q5e,
  X5e,
  L2 = createGetter(() => {
    P2()
    N2()
    ;(Q5e = /^([0-9a-f]{32})$/i), (X5e = /^[0-9a-f]{16}$/i)
  })
function J5e(t) {
  return (
    typeof t == 'object' &&
    typeof t.spanId == 'string' &&
    typeof t.traceId == 'string' &&
    typeof t.traceFlags == 'number'
  )
}
var V6,
  M2,
  z6 = createGetter(() => {
    gE()
    j6()
    N2()
    L2()
    ;(V6 = Lf.getInstance()),
      (M2 = (function () {
        function t() {}
        return (
          (t.prototype.startSpan = function (e, r, n) {
            n === void 0 && (n = V6.active())
            var i = !!r?.root
            if (i) return new Mf()
            var o = n && O2(n)
            return J5e(o) && $a(o) ? new Mf(o) : new Mf()
          }),
          (t.prototype.startActiveSpan = function (e, r, n, i) {
            var o, s, a
            if (!(arguments.length < 2)) {
              arguments.length === 2
                ? (a = r)
                : arguments.length === 3
                ? ((o = r), (a = n))
                : ((o = r), (s = n), (a = i))
              var l = s ?? V6.active(),
                c = this.startSpan(e, o, l),
                u = yE(l, c)
              return V6.with(u, a, void 0, c)
            }
          }),
          t
        )
      })())
  })
var Z5e,
  F2,
  $6 = createGetter(() => {
    z6()
    ;(Z5e = new M2()),
      (F2 = (function () {
        function t(e, r, n, i) {
          ;(this._provider = e), (this.name = r), (this.version = n), (this.options = i)
        }
        return (
          (t.prototype.startSpan = function (e, r, n) {
            return this._getTracer().startSpan(e, r, n)
          }),
          (t.prototype.startActiveSpan = function (e, r, n, i) {
            var o = this._getTracer()
            return Reflect.apply(o.startActiveSpan, o, arguments)
          }),
          (t.prototype._getTracer = function () {
            if (this._delegate) return this._delegate
            var e = this._provider.getDelegateTracer(this.name, this.version, this.options)
            return e ? ((this._delegate = e), this._delegate) : Z5e
          }),
          t
        )
      })())
  })
var Nne,
  kne = createGetter(() => {
    z6()
    Nne = (function () {
      function t() {}
      return (
        (t.prototype.getTracer = function (e, r, n) {
          return new M2()
        }),
        t
      )
    })()
  })
var e3e,
  xE,
  W6 = createGetter(() => {
    $6()
    kne()
    ;(e3e = new Nne()),
      (xE = (function () {
        function t() {}
        return (
          (t.prototype.getTracer = function (e, r, n) {
            var i
            return (i = this.getDelegateTracer(e, r, n)) !== null && i !== void 0 ? i : new F2(this, e, r, n)
          }),
          (t.prototype.getDelegate = function () {
            var e
            return (e = this._delegate) !== null && e !== void 0 ? e : e3e
          }),
          (t.prototype.setDelegate = function (e) {
            this._delegate = e
          }),
          (t.prototype.getDelegateTracer = function (e, r, n) {
            var i
            return (i = this._delegate) === null || i === void 0 ? void 0 : i.getTracer(e, r, n)
          }),
          t
        )
      })())
  })
var Cs,
  One = createGetter(() => {
    ;(function (t) {
      ;(t[(t.NOT_RECORD = 0)] = 'NOT_RECORD'),
        (t[(t.RECORD = 1)] = 'RECORD'),
        (t[(t.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED')
    })(Cs || (Cs = {}))
  })
var U_,
  Lne = createGetter(() => {
    ;(function (t) {
      ;(t[(t.INTERNAL = 0)] = 'INTERNAL'),
        (t[(t.SERVER = 1)] = 'SERVER'),
        (t[(t.CLIENT = 2)] = 'CLIENT'),
        (t[(t.PRODUCER = 3)] = 'PRODUCER'),
        (t[(t.CONSUMER = 4)] = 'CONSUMER')
    })(U_ || (U_ = {}))
  })
var B_,
  Mne = createGetter(() => {
    ;(function (t) {
      ;(t[(t.UNSET = 0)] = 'UNSET'), (t[(t.OK = 1)] = 'OK'), (t[(t.ERROR = 2)] = 'ERROR')
    })(B_ || (B_ = {}))
  })
function Fne(t) {
  return n3e.test(t)
}
function Une(t) {
  return i3e.test(t) && !o3e.test(t)
}
var K6,
  t3e,
  r3e,
  n3e,
  i3e,
  o3e,
  Bne = createGetter(() => {
    ;(K6 = '[_0-9a-z-*/]'),
      (t3e = '[a-z]' + K6 + '{0,255}'),
      (r3e = '[a-z0-9]' + K6 + '{0,240}@[a-z]' + K6 + '{0,13}'),
      (n3e = new RegExp('^(?:' + t3e + '|' + r3e + ')$')),
      (i3e = /^[ -~]{0,255}[!-~]$/),
      (o3e = /,|=/)
  })
var qne,
  s3e,
  Hne,
  jne,
  Gne,
  Vne = createGetter(() => {
    Bne()
    ;(qne = 32),
      (s3e = 512),
      (Hne = ','),
      (jne = '='),
      (Gne = (function () {
        function t(e) {
          ;(this._internalState = new Map()), e && this._parse(e)
        }
        return (
          (t.prototype.set = function (e, r) {
            var n = this._clone()
            return n._internalState.has(e) && n._internalState.delete(e), n._internalState.set(e, r), n
          }),
          (t.prototype.unset = function (e) {
            var r = this._clone()
            return r._internalState.delete(e), r
          }),
          (t.prototype.get = function (e) {
            return this._internalState.get(e)
          }),
          (t.prototype.serialize = function () {
            var e = this
            return this._keys()
              .reduce(function (r, n) {
                return r.push(n + jne + e.get(n)), r
              }, [])
              .join(Hne)
          }),
          (t.prototype._parse = function (e) {
            e.length > s3e ||
              ((this._internalState = e
                .split(Hne)
                .reverse()
                .reduce(function (r, n) {
                  var i = n.trim(),
                    o = i.indexOf(jne)
                  if (o !== -1) {
                    var s = i.slice(0, o),
                      a = i.slice(o + 1, n.length)
                    Fne(s) && Une(a) && r.set(s, a)
                  }
                  return r
                }, new Map())),
              this._internalState.size > qne &&
                (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, qne))))
          }),
          (t.prototype._keys = function () {
            return Array.from(this._internalState.keys()).reverse()
          }),
          (t.prototype._clone = function () {
            var e = new t()
            return (e._internalState = new Map(this._internalState)), e
          }),
          t
        )
      })())
  })
function zne(t) {
  return new Gne(t)
}
var $ne = createGetter(() => {
  Vne()
})
var Zo,
  Wne = createGetter(() => {
    gE()
    Zo = Lf.getInstance()
  })
var at,
  Kne = createGetter(() => {
    Rg()
    at = Io.instance()
  })
var a3e,
  Yne,
  Qne = createGetter(() => {
    F6()
    ;(a3e = (function () {
      function t() {}
      return (
        (t.prototype.getMeter = function (e, r, n) {
          return M6
        }),
        t
      )
    })()),
      (Yne = new a3e())
  })
var Y6,
  Xne,
  Jne = createGetter(() => {
    Qne()
    Ag()
    Rg()
    ;(Y6 = 'metrics'),
      (Xne = (function () {
        function t() {}
        return (
          (t.getInstance = function () {
            return this._instance || (this._instance = new t()), this._instance
          }),
          (t.prototype.setGlobalMeterProvider = function (e) {
            return $l(Y6, e, Io.instance())
          }),
          (t.prototype.getMeterProvider = function () {
            return pa(Y6) || Yne
          }),
          (t.prototype.getMeter = function (e, r, n) {
            return this.getMeterProvider().getMeter(e, r, n)
          }),
          (t.prototype.disable = function () {
            Wl(Y6, Io.instance())
          }),
          t
        )
      })())
  })
var Q6,
  Zne = createGetter(() => {
    Jne()
    Q6 = Xne.getInstance()
  })
var eie,
  tie = createGetter(() => {
    eie = (function () {
      function t() {}
      return (
        (t.prototype.inject = function (e, r) {}),
        (t.prototype.extract = function (e, r) {
          return e
        }),
        (t.prototype.fields = function () {
          return []
        }),
        t
      )
    })()
  })
function J6(t) {
  return t.getValue(X6) || void 0
}
function rie() {
  return J6(Lf.getInstance().active())
}
function nie(t, e) {
  return t.setValue(X6, e)
}
function iie(t) {
  return t.deleteValue(X6)
}
var X6,
  oie = createGetter(() => {
    gE()
    hE()
    X6 = Kl('OpenTelemetry Baggage Key')
  })
var Z6,
  c3e,
  sie,
  aie = createGetter(() => {
    Ag()
    tie()
    U6()
    oie()
    N6()
    Rg()
    ;(Z6 = 'propagation'),
      (c3e = new eie()),
      (sie = (function () {
        function t() {
          ;(this.createBaggage = bne),
            (this.getBaggage = J6),
            (this.getActiveBaggage = rie),
            (this.setBaggage = nie),
            (this.deleteBaggage = iie)
        }
        return (
          (t.getInstance = function () {
            return this._instance || (this._instance = new t()), this._instance
          }),
          (t.prototype.setGlobalPropagator = function (e) {
            return $l(Z6, e, Io.instance())
          }),
          (t.prototype.inject = function (e, r, n) {
            return n === void 0 && (n = D2), this._getGlobalPropagator().inject(e, r, n)
          }),
          (t.prototype.extract = function (e, r, n) {
            return n === void 0 && (n = R2), this._getGlobalPropagator().extract(e, r, n)
          }),
          (t.prototype.fields = function () {
            return this._getGlobalPropagator().fields()
          }),
          (t.prototype.disable = function () {
            Wl(Z6, Io.instance())
          }),
          (t.prototype._getGlobalPropagator = function () {
            return pa(Z6) || c3e
          }),
          t
        )
      })())
  })
var Ip,
  cie = createGetter(() => {
    aie()
    Ip = sie.getInstance()
  })
var eF,
  lie,
  uie = createGetter(() => {
    Ag()
    W6()
    L2()
    j6()
    Rg()
    ;(eF = 'trace'),
      (lie = (function () {
        function t() {
          ;(this._proxyTracerProvider = new xE()),
            (this.wrapSpanContext = Pne),
            (this.isSpanContextValid = $a),
            (this.deleteSpan = Rne),
            (this.getSpan = k2),
            (this.getActiveSpan = Ane),
            (this.getSpanContext = O2),
            (this.setSpan = yE),
            (this.setSpanContext = Dne)
        }
        return (
          (t.getInstance = function () {
            return this._instance || (this._instance = new t()), this._instance
          }),
          (t.prototype.setGlobalTracerProvider = function (e) {
            var r = $l(eF, this._proxyTracerProvider, Io.instance())
            return r && this._proxyTracerProvider.setDelegate(e), r
          }),
          (t.prototype.getTracerProvider = function () {
            return pa(eF) || this._proxyTracerProvider
          }),
          (t.prototype.getTracer = function (e, r) {
            return this.getTracerProvider().getTracer(e, r)
          }),
          (t.prototype.disable = function () {
            Wl(eF, Io.instance()), (this._proxyTracerProvider = new xE())
          }),
          t
        )
      })())
  })
var xi,
  pie = createGetter(() => {
    uie()
    xi = lie.getInstance()
  })
var q_ = {}
defineProperties(q_, {
  DiagConsoleLogger: () => Ene,
  DiagLogLevel: () => Gr,
  INVALID_SPANID: () => vE,
  INVALID_SPAN_CONTEXT: () => F_,
  INVALID_TRACEID: () => _E,
  ProxyTracer: () => F2,
  ProxyTracerProvider: () => xE,
  ROOT_CONTEXT: () => w2,
  SamplingDecision: () => Cs,
  SpanKind: () => U_,
  SpanStatusCode: () => B_,
  TraceFlags: () => Vn,
  ValueType: () => A2,
  baggageEntryMetadataFromString: () => I2,
  context: () => Zo,
  createContextKey: () => Kl,
  createNoopMeter: () => Sne,
  createTraceState: () => zne,
  default: () => l3e,
  defaultTextMapGetter: () => R2,
  defaultTextMapSetter: () => D2,
  diag: () => at,
  isSpanContextValid: () => $a,
  isValidSpanId: () => G6,
  isValidTraceId: () => Dg,
  metrics: () => Q6,
  propagation: () => Ip,
  trace: () => xi,
})
var l3e,
  Yt = createGetter(() => {
    N6()
    hE()
    Tne()
    C2()
    F6()
    Cne()
    U6()
    $6()
    W6()
    One()
    Lne()
    Mne()
    q6()
    $ne()
    L2()
    P2()
    Wne()
    Kne()
    Zne()
    cie()
    pie()
    l3e = { context: Zo, diag: at, metrics: Q6, propagation: Ip, trace: xi }
  })
function bE(t) {
  return t.setValue(tF, !0)
}
function u3e(t) {
  return t.deleteValue(tF)
}
function Pg(t) {
  return t.getValue(tF) === !0
}
var tF,
  EE = createGetter(() => {
    Yt()
    tF = Kl('OpenTelemetry SDK Context Key SUPPRESS_TRACING')
  })
var die,
  U2,
  H_,
  B2,
  fie,
  mie,
  hie,
  rF = createGetter(() => {
    ;(die = '='), (U2 = ';'), (H_ = ','), (B2 = 'baggage'), (fie = 180), (mie = 4096), (hie = 8192)
  })
var oF = {}
defineProperties(oF, {
  getKeyPairs: () => iF,
  parseKeyPairsIntoRecord: () => d3e,
  parsePairKeyValue: () => q2,
  serializeKeyPairs: () => nF,
})
function nF(t) {
  return t.reduce(function (e, r) {
    var n = '' + e + (e !== '' ? H_ : '') + r
    return n.length > hie ? e : n
  }, '')
}
function iF(t) {
  return t.getAllEntries().map(function (e) {
    var r = p3e(e, 2),
      n = r[0],
      i = r[1],
      o = encodeURIComponent(n) + '=' + encodeURIComponent(i.value)
    return i.metadata !== void 0 && (o += U2 + i.metadata.toString()), o
  })
}
function q2(t) {
  var e = t.split(U2)
  if (!(e.length <= 0)) {
    var r = e.shift()
    if (r) {
      var n = r.indexOf(die)
      if (!(n <= 0)) {
        var i = decodeURIComponent(r.substring(0, n).trim()),
          o = decodeURIComponent(r.substring(n + 1).trim()),
          s
        return e.length > 0 && (s = I2(e.join(U2))), { key: i, value: o, metadata: s }
      }
    }
  }
}
function d3e(t) {
  return typeof t != 'string' || t.length === 0
    ? {}
    : t
        .split(H_)
        .map(function (e) {
          return q2(e)
        })
        .filter(function (e) {
          return e !== void 0 && e.value.length > 0
        })
        .reduce(function (e, r) {
          return (e[r.key] = r.value), e
        }, {})
}
var p3e,
  sF = createGetter(() => {
    Yt()
    rF()
    p3e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }
  })
var aF,
  gie = createGetter(() => {
    Yt()
    EE()
    rF()
    sF()
    aF = (function () {
      function t() {}
      return (
        (t.prototype.inject = function (e, r, n) {
          var i = Ip.getBaggage(e)
          if (!(!i || Pg(e))) {
            var o = iF(i)
                .filter(function (a) {
                  return a.length <= mie
                })
                .slice(0, fie),
              s = nF(o)
            s.length > 0 && n.set(r, B2, s)
          }
        }),
        (t.prototype.extract = function (e, r, n) {
          var i = n.get(r, B2),
            o = Array.isArray(i) ? i.join(H_) : i
          if (!o) return e
          var s = {}
          if (o.length === 0) return e
          var a = o.split(H_)
          return (
            a.forEach(function (l) {
              var c = q2(l)
              if (c) {
                var u = { value: c.value }
                c.metadata && (u.metadata = c.metadata), (s[c.key] = u)
              }
            }),
            Object.entries(s).length === 0 ? e : Ip.setBaggage(e, Ip.createBaggage(s))
          )
        }),
        (t.prototype.fields = function () {
          return [B2]
        }),
        t
      )
    })()
  })
var f3e,
  vie = createGetter(() => {
    f3e = (function () {
      function t(e, r) {
        ;(this._monotonicClock = r), (this._epochMillis = e.now()), (this._performanceMillis = r.now())
      }
      return (
        (t.prototype.now = function () {
          var e = this._monotonicClock.now() - this._performanceMillis
          return this._epochMillis + e
        }),
        t
      )
    })()
  })
function Ng(t) {
  var e,
    r,
    n = {}
  if (typeof t != 'object' || t == null) return n
  try {
    for (var i = _ie(Object.entries(t)), o = i.next(); !o.done; o = i.next()) {
      var s = m3e(o.value, 2),
        a = s[0],
        l = s[1]
      if (!yie(a)) {
        at.warn('Invalid attribute key: ' + a)
        continue
      }
      if (!H2(l)) {
        at.warn('Invalid attribute value set for key: ' + a)
        continue
      }
      Array.isArray(l) ? (n[a] = l.slice()) : (n[a] = l)
    }
  } catch (c) {
    e = { error: c }
  } finally {
    try {
      o && !o.done && (r = i.return) && r.call(i)
    } finally {
      if (e) throw e.error
    }
  }
  return n
}
function yie(t) {
  return typeof t == 'string' && t.length > 0
}
function H2(t) {
  return t == null ? !0 : Array.isArray(t) ? h3e(t) : xie(t)
}
function h3e(t) {
  var e, r, n
  try {
    for (var i = _ie(t), o = i.next(); !o.done; o = i.next()) {
      var s = o.value
      if (s != null) {
        if (!n) {
          if (xie(s)) {
            n = typeof s
            continue
          }
          return !1
        }
        if (typeof s !== n) return !1
      }
    }
  } catch (a) {
    e = { error: a }
  } finally {
    try {
      o && !o.done && (r = i.return) && r.call(i)
    } finally {
      if (e) throw e.error
    }
  }
  return !0
}
function xie(t) {
  switch (typeof t) {
    case 'number':
    case 'boolean':
    case 'string':
      return !0
  }
  return !1
}
var _ie,
  m3e,
  bie = createGetter(() => {
    Yt()
    ;(_ie = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      (m3e = function (t, e) {
        var r = typeof Symbol == 'function' && t[Symbol.iterator]
        if (!r) return t
        var n = r.call(t),
          i,
          o = [],
          s
        try {
          for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
        } catch (a) {
          s = { error: a }
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n)
          } finally {
            if (s) throw s.error
          }
        }
        return o
      })
  })
function cF() {
  return function (t) {
    at.error(g3e(t))
  }
}
function g3e(t) {
  return typeof t == 'string' ? t : JSON.stringify(v3e(t))
}
function v3e(t) {
  for (var e = {}, r = t; r !== null; )
    Object.getOwnPropertyNames(r).forEach(function (n) {
      if (!e[n]) {
        var i = r[n]
        i && (e[n] = String(i))
      }
    }),
      (r = Object.getPrototypeOf(r))
  return e
}
var lF = createGetter(() => {
  Yt()
})
function _3e(t) {
  Eie = t
}
function Is(t) {
  try {
    Eie(t)
  } catch {}
}
var Eie,
  uF = createGetter(() => {
    lF()
    Eie = cF()
  })
var da,
  pF = createGetter(() => {
    ;(function (t) {
      ;(t.AlwaysOff = 'always_off'),
        (t.AlwaysOn = 'always_on'),
        (t.ParentBasedAlwaysOff = 'parentbased_always_off'),
        (t.ParentBasedAlwaysOn = 'parentbased_always_on'),
        (t.ParentBasedTraceIdRatio = 'parentbased_traceidratio'),
        (t.TraceIdRatio = 'traceidratio')
    })(da || (da = {}))
  })
var Tie,
  Sie = createGetter(() => {
    Tie =
      typeof globalThis == 'object'
        ? globalThis
        : typeof self == 'object'
        ? self
        : typeof window == 'object'
        ? window
        : typeof global == 'object'
        ? global
        : {}
  })
function b3e(t) {
  return x3e.indexOf(t) > -1
}
function T3e(t) {
  return E3e.indexOf(t) > -1
}
function C3e(t) {
  return S3e.indexOf(t) > -1
}
function I3e(t, e, r) {
  if (!(typeof r[t] > 'u')) {
    var n = String(r[t])
    e[t] = n.toLowerCase() === 'true'
  }
}
function w3e(t, e, r, n, i) {
  if ((n === void 0 && (n = -1 / 0), i === void 0 && (i = 1 / 0), typeof r[t] < 'u')) {
    var o = Number(r[t])
    isNaN(o) || (o < n ? (e[t] = n) : o > i ? (e[t] = i) : (e[t] = o))
  }
}
function A3e(t, e, r, n) {
  n === void 0 && (n = y3e)
  var i = r[t]
  typeof i == 'string' &&
    (e[t] = i.split(n).map(function (o) {
      return o.trim()
    }))
}
function D3e(t, e, r) {
  var n = r[t]
  if (typeof n == 'string') {
    var i = R3e[n.toUpperCase()]
    i != null && (e[t] = i)
  }
}
function TE(t) {
  var e = {}
  for (var r in j2) {
    var n = r
    switch (n) {
      case 'OTEL_LOG_LEVEL':
        D3e(n, e, t)
        break
      default:
        if (b3e(n)) I3e(n, e, t)
        else if (T3e(n)) w3e(n, e, t)
        else if (C3e(n)) A3e(n, e, t)
        else {
          var i = t[n]
          typeof i < 'u' && i !== null && (e[n] = String(i))
        }
    }
  }
  return e
}
function dF() {
  return typeof process < 'u' && process && process.env ? TE(process.env) : TE(Tie)
}
var y3e,
  x3e,
  E3e,
  S3e,
  j_,
  G_,
  Cie,
  Iie,
  j2,
  R3e,
  fF = createGetter(() => {
    Yt()
    pF()
    Sie()
    ;(y3e = ','), (x3e = ['OTEL_SDK_DISABLED'])
    E3e = [
      'OTEL_BSP_EXPORT_TIMEOUT',
      'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
      'OTEL_BSP_MAX_QUEUE_SIZE',
      'OTEL_BSP_SCHEDULE_DELAY',
      'OTEL_BLRP_EXPORT_TIMEOUT',
      'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
      'OTEL_BLRP_MAX_QUEUE_SIZE',
      'OTEL_BLRP_SCHEDULE_DELAY',
      'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
      'OTEL_ATTRIBUTE_COUNT_LIMIT',
      'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
      'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
      'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
      'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
      'OTEL_SPAN_EVENT_COUNT_LIMIT',
      'OTEL_SPAN_LINK_COUNT_LIMIT',
      'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
      'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
      'OTEL_EXPORTER_OTLP_TIMEOUT',
      'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
      'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
      'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
      'OTEL_EXPORTER_JAEGER_AGENT_PORT',
    ]
    S3e = ['OTEL_NO_PATCH_MODULES', 'OTEL_PROPAGATORS']
    ;(j_ = 1 / 0),
      (G_ = 128),
      (Cie = 128),
      (Iie = 128),
      (j2 = {
        OTEL_SDK_DISABLED: !1,
        CONTAINER_NAME: '',
        ECS_CONTAINER_METADATA_URI_V4: '',
        ECS_CONTAINER_METADATA_URI: '',
        HOSTNAME: '',
        KUBERNETES_SERVICE_HOST: '',
        NAMESPACE: '',
        OTEL_BSP_EXPORT_TIMEOUT: 3e4,
        OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
        OTEL_BSP_MAX_QUEUE_SIZE: 2048,
        OTEL_BSP_SCHEDULE_DELAY: 5e3,
        OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
        OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
        OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
        OTEL_BLRP_SCHEDULE_DELAY: 5e3,
        OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
        OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
        OTEL_EXPORTER_JAEGER_ENDPOINT: '',
        OTEL_EXPORTER_JAEGER_PASSWORD: '',
        OTEL_EXPORTER_JAEGER_USER: '',
        OTEL_EXPORTER_OTLP_ENDPOINT: '',
        OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
        OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
        OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
        OTEL_EXPORTER_OTLP_HEADERS: '',
        OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
        OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
        OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
        OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
        OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
        OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
        OTEL_LOG_LEVEL: Gr.INFO,
        OTEL_NO_PATCH_MODULES: [],
        OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
        OTEL_RESOURCE_ATTRIBUTES: '',
        OTEL_SERVICE_NAME: '',
        OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: j_,
        OTEL_ATTRIBUTE_COUNT_LIMIT: G_,
        OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: j_,
        OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: G_,
        OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: j_,
        OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: G_,
        OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
        OTEL_SPAN_LINK_COUNT_LIMIT: 128,
        OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: Cie,
        OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: Iie,
        OTEL_TRACES_EXPORTER: '',
        OTEL_TRACES_SAMPLER: da.ParentBasedAlwaysOn,
        OTEL_TRACES_SAMPLER_ARG: '',
        OTEL_LOGS_EXPORTER: '',
        OTEL_EXPORTER_OTLP_INSECURE: '',
        OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
        OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
        OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
        OTEL_EXPORTER_OTLP_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_COMPRESSION: '',
        OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
        OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
        OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
        OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
        OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
        OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
        OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
        OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
        OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
        OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
        OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
        OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
        OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
      })
    R3e = {
      ALL: Gr.ALL,
      VERBOSE: Gr.VERBOSE,
      DEBUG: Gr.DEBUG,
      INFO: Gr.INFO,
      WARN: Gr.WARN,
      ERROR: Gr.ERROR,
      NONE: Gr.NONE,
    }
  })
function bi() {
  var t = TE(process.env)
  return Object.assign({ HOSTNAME: wie.hostname() }, j2, t)
}
var wie,
  Aie = createGetter(() => {
    wie = handleDefaultExports(require('os'))
    fF()
  })
var P3e,
  Rie = createGetter(() => {
    P3e = typeof globalThis == 'object' ? globalThis : global
  })
function Die(t) {
  return t >= 48 && t <= 57 ? t - 48 : t >= 97 && t <= 102 ? t - 87 : t - 55
}
function O3e(t) {
  var e
  t.length === 16 ? (e = N3e) : t.length === 32 ? (e = k3e) : (e = Buffer.alloc(t.length / 2))
  for (var r = 0, n = 0; n < t.length; n += 2) {
    var i = Die(t.charCodeAt(n)),
      o = Die(t.charCodeAt(n + 1))
    e.writeUInt8((i << 4) | o, r++)
  }
  return e.toString('base64')
}
var N3e,
  k3e,
  Pie = createGetter(() => {
    ;(N3e = Buffer.alloc(8)), (k3e = Buffer.alloc(16))
  })
function Nie(t) {
  return function () {
    for (var r = 0; r < t / 4; r++) G2.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, r * 4)
    for (var r = 0; r < t && !(G2[r] > 0); r++) r === t - 1 && (G2[t - 1] = 1)
    return G2.toString('hex', 0, t)
  }
}
var L3e,
  kie,
  M3e,
  G2,
  Oie = createGetter(() => {
    ;(L3e = 8),
      (kie = 16),
      (M3e = (function () {
        function t() {
          ;(this.generateTraceId = Nie(kie)), (this.generateSpanId = Nie(L3e))
        }
        return t
      })()),
      (G2 = Buffer.allocUnsafe(kie))
  })
var Lie,
  wp,
  Mie = createGetter(() => {
    ;(Lie = require('perf_hooks')), (wp = Lie.performance)
  })
var mF,
  V2 = createGetter(() => {
    mF = '1.17.0'
  })
var Ap,
  F3e,
  U3e,
  B3e,
  q3e,
  H3e,
  j3e,
  G3e,
  V3e,
  z3e,
  $3e,
  W3e,
  K3e,
  Y3e,
  Fie = createGetter(() => {
    ;(Ap = {
      AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
      DB_SYSTEM: 'db.system',
      DB_CONNECTION_STRING: 'db.connection_string',
      DB_USER: 'db.user',
      DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
      DB_NAME: 'db.name',
      DB_STATEMENT: 'db.statement',
      DB_OPERATION: 'db.operation',
      DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
      DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
      DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
      DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
      DB_CASSANDRA_TABLE: 'db.cassandra.table',
      DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
      DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
      DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
      DB_HBASE_NAMESPACE: 'db.hbase.namespace',
      DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
      DB_MONGODB_COLLECTION: 'db.mongodb.collection',
      DB_SQL_TABLE: 'db.sql.table',
      EXCEPTION_TYPE: 'exception.type',
      EXCEPTION_MESSAGE: 'exception.message',
      EXCEPTION_STACKTRACE: 'exception.stacktrace',
      EXCEPTION_ESCAPED: 'exception.escaped',
      FAAS_TRIGGER: 'faas.trigger',
      FAAS_EXECUTION: 'faas.execution',
      FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
      FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
      FAAS_DOCUMENT_TIME: 'faas.document.time',
      FAAS_DOCUMENT_NAME: 'faas.document.name',
      FAAS_TIME: 'faas.time',
      FAAS_CRON: 'faas.cron',
      FAAS_COLDSTART: 'faas.coldstart',
      FAAS_INVOKED_NAME: 'faas.invoked_name',
      FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
      FAAS_INVOKED_REGION: 'faas.invoked_region',
      NET_TRANSPORT: 'net.transport',
      NET_PEER_IP: 'net.peer.ip',
      NET_PEER_PORT: 'net.peer.port',
      NET_PEER_NAME: 'net.peer.name',
      NET_HOST_IP: 'net.host.ip',
      NET_HOST_PORT: 'net.host.port',
      NET_HOST_NAME: 'net.host.name',
      NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
      NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
      NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
      NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
      NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
      NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
      PEER_SERVICE: 'peer.service',
      ENDUSER_ID: 'enduser.id',
      ENDUSER_ROLE: 'enduser.role',
      ENDUSER_SCOPE: 'enduser.scope',
      THREAD_ID: 'thread.id',
      THREAD_NAME: 'thread.name',
      CODE_FUNCTION: 'code.function',
      CODE_NAMESPACE: 'code.namespace',
      CODE_FILEPATH: 'code.filepath',
      CODE_LINENO: 'code.lineno',
      HTTP_METHOD: 'http.method',
      HTTP_URL: 'http.url',
      HTTP_TARGET: 'http.target',
      HTTP_HOST: 'http.host',
      HTTP_SCHEME: 'http.scheme',
      HTTP_STATUS_CODE: 'http.status_code',
      HTTP_FLAVOR: 'http.flavor',
      HTTP_USER_AGENT: 'http.user_agent',
      HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
      HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
      HTTP_SERVER_NAME: 'http.server_name',
      HTTP_ROUTE: 'http.route',
      HTTP_CLIENT_IP: 'http.client_ip',
      AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
      AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
      AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
      AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
      AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
      AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
      AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
      AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
      AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
      AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
      AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
      AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
      AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
      MESSAGING_SYSTEM: 'messaging.system',
      MESSAGING_DESTINATION: 'messaging.destination',
      MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
      MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
      MESSAGING_PROTOCOL: 'messaging.protocol',
      MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
      MESSAGING_URL: 'messaging.url',
      MESSAGING_MESSAGE_ID: 'messaging.message_id',
      MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
      MESSAGING_OPERATION: 'messaging.operation',
      MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
      MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
      MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
      MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
      MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
      MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
      MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
      RPC_SYSTEM: 'rpc.system',
      RPC_SERVICE: 'rpc.service',
      RPC_METHOD: 'rpc.method',
      RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
      RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
      RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
      RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
      RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
      MESSAGE_TYPE: 'message.type',
      MESSAGE_ID: 'message.id',
      MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
      MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
    }),
      (F3e = {
        OTHER_SQL: 'other_sql',
        MSSQL: 'mssql',
        MYSQL: 'mysql',
        ORACLE: 'oracle',
        DB2: 'db2',
        POSTGRESQL: 'postgresql',
        REDSHIFT: 'redshift',
        HIVE: 'hive',
        CLOUDSCAPE: 'cloudscape',
        HSQLDB: 'hsqldb',
        PROGRESS: 'progress',
        MAXDB: 'maxdb',
        HANADB: 'hanadb',
        INGRES: 'ingres',
        FIRSTSQL: 'firstsql',
        EDB: 'edb',
        CACHE: 'cache',
        ADABAS: 'adabas',
        FIREBIRD: 'firebird',
        DERBY: 'derby',
        FILEMAKER: 'filemaker',
        INFORMIX: 'informix',
        INSTANTDB: 'instantdb',
        INTERBASE: 'interbase',
        MARIADB: 'mariadb',
        NETEZZA: 'netezza',
        PERVASIVE: 'pervasive',
        POINTBASE: 'pointbase',
        SQLITE: 'sqlite',
        SYBASE: 'sybase',
        TERADATA: 'teradata',
        VERTICA: 'vertica',
        H2: 'h2',
        COLDFUSION: 'coldfusion',
        CASSANDRA: 'cassandra',
        HBASE: 'hbase',
        MONGODB: 'mongodb',
        REDIS: 'redis',
        COUCHBASE: 'couchbase',
        COUCHDB: 'couchdb',
        COSMOSDB: 'cosmosdb',
        DYNAMODB: 'dynamodb',
        NEO4J: 'neo4j',
        GEODE: 'geode',
        ELASTICSEARCH: 'elasticsearch',
        MEMCACHED: 'memcached',
        COCKROACHDB: 'cockroachdb',
      }),
      (U3e = {
        ALL: 'all',
        EACH_QUORUM: 'each_quorum',
        QUORUM: 'quorum',
        LOCAL_QUORUM: 'local_quorum',
        ONE: 'one',
        TWO: 'two',
        THREE: 'three',
        LOCAL_ONE: 'local_one',
        ANY: 'any',
        SERIAL: 'serial',
        LOCAL_SERIAL: 'local_serial',
      }),
      (B3e = { DATASOURCE: 'datasource', HTTP: 'http', PUBSUB: 'pubsub', TIMER: 'timer', OTHER: 'other' }),
      (q3e = { INSERT: 'insert', EDIT: 'edit', DELETE: 'delete' }),
      (H3e = { ALIBABA_CLOUD: 'alibaba_cloud', AWS: 'aws', AZURE: 'azure', GCP: 'gcp' }),
      (j3e = {
        IP_TCP: 'ip_tcp',
        IP_UDP: 'ip_udp',
        IP: 'ip',
        UNIX: 'unix',
        PIPE: 'pipe',
        INPROC: 'inproc',
        OTHER: 'other',
      }),
      (G3e = { WIFI: 'wifi', WIRED: 'wired', CELL: 'cell', UNAVAILABLE: 'unavailable', UNKNOWN: 'unknown' }),
      (V3e = {
        GPRS: 'gprs',
        EDGE: 'edge',
        UMTS: 'umts',
        CDMA: 'cdma',
        EVDO_0: 'evdo_0',
        EVDO_A: 'evdo_a',
        CDMA2000_1XRTT: 'cdma2000_1xrtt',
        HSDPA: 'hsdpa',
        HSUPA: 'hsupa',
        HSPA: 'hspa',
        IDEN: 'iden',
        EVDO_B: 'evdo_b',
        LTE: 'lte',
        EHRPD: 'ehrpd',
        HSPAP: 'hspap',
        GSM: 'gsm',
        TD_SCDMA: 'td_scdma',
        IWLAN: 'iwlan',
        NR: 'nr',
        NRNSA: 'nrnsa',
        LTE_CA: 'lte_ca',
      }),
      (z3e = { HTTP_1_0: '1.0', HTTP_1_1: '1.1', HTTP_2_0: '2.0', SPDY: 'SPDY', QUIC: 'QUIC' }),
      ($3e = { QUEUE: 'queue', TOPIC: 'topic' }),
      (W3e = { RECEIVE: 'receive', PROCESS: 'process' }),
      (K3e = {
        OK: 0,
        CANCELLED: 1,
        UNKNOWN: 2,
        INVALID_ARGUMENT: 3,
        DEADLINE_EXCEEDED: 4,
        NOT_FOUND: 5,
        ALREADY_EXISTS: 6,
        PERMISSION_DENIED: 7,
        RESOURCE_EXHAUSTED: 8,
        FAILED_PRECONDITION: 9,
        ABORTED: 10,
        OUT_OF_RANGE: 11,
        UNIMPLEMENTED: 12,
        INTERNAL: 13,
        UNAVAILABLE: 14,
        DATA_LOSS: 15,
        UNAUTHENTICATED: 16,
      }),
      (Y3e = { SENT: 'SENT', RECEIVED: 'RECEIVED' })
  })
var Uie = createGetter(() => {
  Fie()
})
var Bt,
  Q3e,
  X3e,
  J3e,
  Z3e,
  e8e,
  hF,
  Bie = createGetter(() => {
    ;(Bt = {
      CLOUD_PROVIDER: 'cloud.provider',
      CLOUD_ACCOUNT_ID: 'cloud.account.id',
      CLOUD_REGION: 'cloud.region',
      CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
      CLOUD_PLATFORM: 'cloud.platform',
      AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
      AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
      AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
      AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
      AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
      AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
      AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
      AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
      AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
      AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
      AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
      CONTAINER_NAME: 'container.name',
      CONTAINER_ID: 'container.id',
      CONTAINER_RUNTIME: 'container.runtime',
      CONTAINER_IMAGE_NAME: 'container.image.name',
      CONTAINER_IMAGE_TAG: 'container.image.tag',
      DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
      DEVICE_ID: 'device.id',
      DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
      DEVICE_MODEL_NAME: 'device.model.name',
      FAAS_NAME: 'faas.name',
      FAAS_ID: 'faas.id',
      FAAS_VERSION: 'faas.version',
      FAAS_INSTANCE: 'faas.instance',
      FAAS_MAX_MEMORY: 'faas.max_memory',
      HOST_ID: 'host.id',
      HOST_NAME: 'host.name',
      HOST_TYPE: 'host.type',
      HOST_ARCH: 'host.arch',
      HOST_IMAGE_NAME: 'host.image.name',
      HOST_IMAGE_ID: 'host.image.id',
      HOST_IMAGE_VERSION: 'host.image.version',
      K8S_CLUSTER_NAME: 'k8s.cluster.name',
      K8S_NODE_NAME: 'k8s.node.name',
      K8S_NODE_UID: 'k8s.node.uid',
      K8S_NAMESPACE_NAME: 'k8s.namespace.name',
      K8S_POD_UID: 'k8s.pod.uid',
      K8S_POD_NAME: 'k8s.pod.name',
      K8S_CONTAINER_NAME: 'k8s.container.name',
      K8S_REPLICASET_UID: 'k8s.replicaset.uid',
      K8S_REPLICASET_NAME: 'k8s.replicaset.name',
      K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
      K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
      K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
      K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
      K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
      K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
      K8S_JOB_UID: 'k8s.job.uid',
      K8S_JOB_NAME: 'k8s.job.name',
      K8S_CRONJOB_UID: 'k8s.cronjob.uid',
      K8S_CRONJOB_NAME: 'k8s.cronjob.name',
      OS_TYPE: 'os.type',
      OS_DESCRIPTION: 'os.description',
      OS_NAME: 'os.name',
      OS_VERSION: 'os.version',
      PROCESS_PID: 'process.pid',
      PROCESS_EXECUTABLE_NAME: 'process.executable.name',
      PROCESS_EXECUTABLE_PATH: 'process.executable.path',
      PROCESS_COMMAND: 'process.command',
      PROCESS_COMMAND_LINE: 'process.command_line',
      PROCESS_COMMAND_ARGS: 'process.command_args',
      PROCESS_OWNER: 'process.owner',
      PROCESS_RUNTIME_NAME: 'process.runtime.name',
      PROCESS_RUNTIME_VERSION: 'process.runtime.version',
      PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
      SERVICE_NAME: 'service.name',
      SERVICE_NAMESPACE: 'service.namespace',
      SERVICE_INSTANCE_ID: 'service.instance.id',
      SERVICE_VERSION: 'service.version',
      TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
      TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
      TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
      TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
      WEBENGINE_NAME: 'webengine.name',
      WEBENGINE_VERSION: 'webengine.version',
      WEBENGINE_DESCRIPTION: 'webengine.description',
    }),
      (Q3e = { ALIBABA_CLOUD: 'alibaba_cloud', AWS: 'aws', AZURE: 'azure', GCP: 'gcp' }),
      (X3e = {
        ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
        ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
        AWS_EC2: 'aws_ec2',
        AWS_ECS: 'aws_ecs',
        AWS_EKS: 'aws_eks',
        AWS_LAMBDA: 'aws_lambda',
        AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
        AZURE_VM: 'azure_vm',
        AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
        AZURE_AKS: 'azure_aks',
        AZURE_FUNCTIONS: 'azure_functions',
        AZURE_APP_SERVICE: 'azure_app_service',
        GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
        GCP_CLOUD_RUN: 'gcp_cloud_run',
        GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
        GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
        GCP_APP_ENGINE: 'gcp_app_engine',
      }),
      (J3e = { EC2: 'ec2', FARGATE: 'fargate' }),
      (Z3e = {
        AMD64: 'amd64',
        ARM32: 'arm32',
        ARM64: 'arm64',
        IA64: 'ia64',
        PPC32: 'ppc32',
        PPC64: 'ppc64',
        X86: 'x86',
      }),
      (e8e = {
        WINDOWS: 'windows',
        LINUX: 'linux',
        DARWIN: 'darwin',
        FREEBSD: 'freebsd',
        NETBSD: 'netbsd',
        OPENBSD: 'openbsd',
        DRAGONFLYBSD: 'dragonflybsd',
        HPUX: 'hpux',
        AIX: 'aix',
        SOLARIS: 'solaris',
        Z_OS: 'z_os',
      }),
      (hF = {
        CPP: 'cpp',
        DOTNET: 'dotnet',
        ERLANG: 'erlang',
        GO: 'go',
        JAVA: 'java',
        NODEJS: 'nodejs',
        PHP: 'php',
        PYTHON: 'python',
        RUBY: 'ruby',
        WEBJS: 'webjs',
      })
  })
var qie = createGetter(() => {
  Bie()
})
var gF = {}
defineProperties(gF, {
  AwsEcsLaunchtypeValues: () => J3e,
  CloudPlatformValues: () => X3e,
  CloudProviderValues: () => Q3e,
  DbCassandraConsistencyLevelValues: () => U3e,
  DbSystemValues: () => F3e,
  FaasDocumentOperationValues: () => q3e,
  FaasInvokedProviderValues: () => H3e,
  FaasTriggerValues: () => B3e,
  HostArchValues: () => Z3e,
  HttpFlavorValues: () => z3e,
  MessageTypeValues: () => Y3e,
  MessagingDestinationKindValues: () => $3e,
  MessagingOperationValues: () => W3e,
  NetHostConnectionSubtypeValues: () => V3e,
  NetHostConnectionTypeValues: () => G3e,
  NetTransportValues: () => j3e,
  OsTypeValues: () => e8e,
  RpcGrpcStatusCodeValues: () => K3e,
  SemanticAttributes: () => Ap,
  SemanticResourceAttributes: () => Bt,
  TelemetrySdkLanguageValues: () => hF,
})
var Hc = createGetter(() => {
  Uie()
  qie()
})
var V_,
  SE,
  Hie = createGetter(() => {
    V2()
    Hc()
    SE =
      ((V_ = {}),
      (V_[Bt.TELEMETRY_SDK_NAME] = 'opentelemetry'),
      (V_[Bt.PROCESS_RUNTIME_NAME] = 'node'),
      (V_[Bt.TELEMETRY_SDK_LANGUAGE] = hF.NODEJS),
      (V_[Bt.TELEMETRY_SDK_VERSION] = mF),
      V_)
  })
function vF(t) {
  t.unref()
}
var jie = createGetter(() => {})
var Gie = createGetter(() => {
  Aie()
  Rie()
  Pie()
  Oie()
  Mie()
  Hie()
  jie()
})
var _F = createGetter(() => {
  Gie()
})
function Yl(t) {
  var e = t / 1e3,
    r = Math.trunc(e),
    n = Math.round((t % 1e3) * r8e)
  return [r, n]
}
function CE() {
  var t = wp.timeOrigin
  if (typeof t != 'number') {
    var e = wp
    t = e.timing && e.timing.fetchStart
  }
  return t
}
function $2(t) {
  var e = Yl(CE()),
    r = Yl(typeof t == 'number' ? t : wp.now())
  return Y2(e, r)
}
function n8e(t) {
  if (IE(t)) return t
  if (typeof t == 'number') return t < CE() ? $2(t) : Yl(t)
  if (t instanceof Date) return Yl(t.getTime())
  throw TypeError('Invalid input type')
}
function yF(t, e) {
  var r = e[0] - t[0],
    n = e[1] - t[1]
  return n < 0 && ((r -= 1), (n += z2)), [r, n]
}
function i8e(t) {
  var e = Vie,
    r = '' + '0'.repeat(e) + t[1] + 'Z',
    n = r.substr(r.length - e - 1),
    i = new Date(t[0] * 1e3).toISOString()
  return i.replace('000Z', n)
}
function o8e(t) {
  return t[0] * z2 + t[1]
}
function s8e(t) {
  return t[0] * 1e3 + t[1] / 1e6
}
function W2(t) {
  return t[0] * 1e6 + t[1] / 1e3
}
function IE(t) {
  return Array.isArray(t) && t.length === 2 && typeof t[0] == 'number' && typeof t[1] == 'number'
}
function K2(t) {
  return IE(t) || typeof t == 'number' || t instanceof Date
}
function Y2(t, e) {
  var r = [t[0] + e[0], t[1] + e[1]]
  return r[1] >= z2 && ((r[1] -= z2), (r[0] += 1)), r
}
var Vie,
  t8e,
  r8e,
  z2,
  zie = createGetter(() => {
    _F()
    ;(Vie = 9), (t8e = 6), (r8e = Math.pow(10, t8e)), (z2 = Math.pow(10, Vie))
  })
var $ie = createGetter(() => {})
var Wa,
  Wie = createGetter(() => {
    ;(function (t) {
      ;(t[(t.SUCCESS = 0)] = 'SUCCESS'), (t[(t.FAILED = 1)] = 'FAILED')
    })(Wa || (Wa = {}))
  })
var a8e,
  xF,
  Kie = createGetter(() => {
    Yt()
    ;(a8e = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      (xF = (function () {
        function t(e) {
          e === void 0 && (e = {})
          var r
          ;(this._propagators = (r = e.propagators) !== null && r !== void 0 ? r : []),
            (this._fields = Array.from(
              new Set(
                this._propagators
                  .map(function (n) {
                    return typeof n.fields == 'function' ? n.fields() : []
                  })
                  .reduce(function (n, i) {
                    return n.concat(i)
                  }, [])
              )
            ))
        }
        return (
          (t.prototype.inject = function (e, r, n) {
            var i, o
            try {
              for (var s = a8e(this._propagators), a = s.next(); !a.done; a = s.next()) {
                var l = a.value
                try {
                  l.inject(e, r, n)
                } catch (c) {
                  at.warn('Failed to inject with ' + l.constructor.name + '. Err: ' + c.message)
                }
              }
            } catch (c) {
              i = { error: c }
            } finally {
              try {
                a && !a.done && (o = s.return) && o.call(s)
              } finally {
                if (i) throw i.error
              }
            }
          }),
          (t.prototype.extract = function (e, r, n) {
            return this._propagators.reduce(function (i, o) {
              try {
                return o.extract(i, r, n)
              } catch (s) {
                at.warn('Failed to inject with ' + o.constructor.name + '. Err: ' + s.message)
              }
              return i
            }, e)
          }),
          (t.prototype.fields = function () {
            return this._fields.slice()
          }),
          t
        )
      })())
  })
function Yie(t) {
  return u8e.test(t)
}
function Qie(t) {
  return p8e.test(t) && !d8e.test(t)
}
var bF,
  c8e,
  l8e,
  u8e,
  p8e,
  d8e,
  Xie = createGetter(() => {
    ;(bF = '[_0-9a-z-*/]'),
      (c8e = '[a-z]' + bF + '{0,255}'),
      (l8e = '[a-z0-9]' + bF + '{0,240}@[a-z]' + bF + '{0,13}'),
      (u8e = new RegExp('^(?:' + c8e + '|' + l8e + ')$')),
      (p8e = /^[ -~]{0,255}[!-~]$/),
      (d8e = /,|=/)
  })
var Jie,
  f8e,
  Zie,
  eoe,
  EF,
  TF = createGetter(() => {
    Xie()
    ;(Jie = 32),
      (f8e = 512),
      (Zie = ','),
      (eoe = '='),
      (EF = (function () {
        function t(e) {
          ;(this._internalState = new Map()), e && this._parse(e)
        }
        return (
          (t.prototype.set = function (e, r) {
            var n = this._clone()
            return n._internalState.has(e) && n._internalState.delete(e), n._internalState.set(e, r), n
          }),
          (t.prototype.unset = function (e) {
            var r = this._clone()
            return r._internalState.delete(e), r
          }),
          (t.prototype.get = function (e) {
            return this._internalState.get(e)
          }),
          (t.prototype.serialize = function () {
            var e = this
            return this._keys()
              .reduce(function (r, n) {
                return r.push(n + eoe + e.get(n)), r
              }, [])
              .join(Zie)
          }),
          (t.prototype._parse = function (e) {
            e.length > f8e ||
              ((this._internalState = e
                .split(Zie)
                .reverse()
                .reduce(function (r, n) {
                  var i = n.trim(),
                    o = i.indexOf(eoe)
                  if (o !== -1) {
                    var s = i.slice(0, o),
                      a = i.slice(o + 1, n.length)
                    Yie(s) && Qie(a) && r.set(s, a)
                  }
                  return r
                }, new Map())),
              this._internalState.size > Jie &&
                (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, Jie))))
          }),
          (t.prototype._keys = function () {
            return Array.from(this._internalState.keys()).reverse()
          }),
          (t.prototype._clone = function () {
            var e = new t()
            return (e._internalState = new Map(this._internalState)), e
          }),
          t
        )
      })())
  })
function toe(t) {
  var e = y8e.exec(t)
  return !e || (e[1] === '00' && e[5]) ? null : { traceId: e[2], spanId: e[3], traceFlags: parseInt(e[4], 16) }
}
var Q2,
  X2,
  m8e,
  h8e,
  g8e,
  v8e,
  _8e,
  y8e,
  SF,
  roe = createGetter(() => {
    Yt()
    EE()
    TF()
    ;(Q2 = 'traceparent'),
      (X2 = 'tracestate'),
      (m8e = '00'),
      (h8e = '(?!ff)[\\da-f]{2}'),
      (g8e = '(?![0]{32})[\\da-f]{32}'),
      (v8e = '(?![0]{16})[\\da-f]{16}'),
      (_8e = '[\\da-f]{2}'),
      (y8e = new RegExp('^\\s?(' + h8e + ')-(' + g8e + ')-(' + v8e + ')-(' + _8e + ')(-.*)?\\s?$'))
    SF = (function () {
      function t() {}
      return (
        (t.prototype.inject = function (e, r, n) {
          var i = xi.getSpanContext(e)
          if (!(!i || Pg(e) || !$a(i))) {
            var o = m8e + '-' + i.traceId + '-' + i.spanId + '-0' + Number(i.traceFlags || Vn.NONE).toString(16)
            n.set(r, Q2, o), i.traceState && n.set(r, X2, i.traceState.serialize())
          }
        }),
        (t.prototype.extract = function (e, r, n) {
          var i = n.get(r, Q2)
          if (!i) return e
          var o = Array.isArray(i) ? i[0] : i
          if (typeof o != 'string') return e
          var s = toe(o)
          if (!s) return e
          s.isRemote = !0
          var a = n.get(r, X2)
          if (a) {
            var l = Array.isArray(a) ? a.join(',') : a
            s.traceState = new EF(typeof l == 'string' ? l : void 0)
          }
          return xi.setSpanContext(e, s)
        }),
        (t.prototype.fields = function () {
          return [Q2, X2]
        }),
        t
      )
    })()
  })
var noe = createGetter(() => {})
function x8e(t, e) {
  return t.setValue(IF, e)
}
function b8e(t) {
  return t.deleteValue(IF)
}
function E8e(t) {
  return t.getValue(IF)
}
var IF,
  CF,
  ioe = createGetter(() => {
    Yt()
    IF = Kl('OpenTelemetry SDK Context Key RPC_METADATA')
    ;(function (t) {
      t.HTTP = 'http'
    })(CF || (CF = {}))
  })
var J2,
  wF = createGetter(() => {
    Yt()
    J2 = (function () {
      function t() {}
      return (
        (t.prototype.shouldSample = function () {
          return { decision: Cs.NOT_RECORD }
        }),
        (t.prototype.toString = function () {
          return 'AlwaysOffSampler'
        }),
        t
      )
    })()
  })
var wE,
  AF = createGetter(() => {
    Yt()
    wE = (function () {
      function t() {}
      return (
        (t.prototype.shouldSample = function () {
          return { decision: Cs.RECORD_AND_SAMPLED }
        }),
        (t.prototype.toString = function () {
          return 'AlwaysOnSampler'
        }),
        t
      )
    })()
  })
var T8e,
  ooe = createGetter(() => {
    Yt()
    uF()
    wF()
    AF()
    T8e = (function () {
      function t(e) {
        var r, n, i, o
        ;(this._root = e.root),
          this._root ||
            (Is(new Error('ParentBasedSampler must have a root sampler configured')), (this._root = new wE())),
          (this._remoteParentSampled = (r = e.remoteParentSampled) !== null && r !== void 0 ? r : new wE()),
          (this._remoteParentNotSampled = (n = e.remoteParentNotSampled) !== null && n !== void 0 ? n : new J2()),
          (this._localParentSampled = (i = e.localParentSampled) !== null && i !== void 0 ? i : new wE()),
          (this._localParentNotSampled = (o = e.localParentNotSampled) !== null && o !== void 0 ? o : new J2())
      }
      return (
        (t.prototype.shouldSample = function (e, r, n, i, o, s) {
          var a = xi.getSpanContext(e)
          return !a || !$a(a)
            ? this._root.shouldSample(e, r, n, i, o, s)
            : a.isRemote
            ? a.traceFlags & Vn.SAMPLED
              ? this._remoteParentSampled.shouldSample(e, r, n, i, o, s)
              : this._remoteParentNotSampled.shouldSample(e, r, n, i, o, s)
            : a.traceFlags & Vn.SAMPLED
            ? this._localParentSampled.shouldSample(e, r, n, i, o, s)
            : this._localParentNotSampled.shouldSample(e, r, n, i, o, s)
        }),
        (t.prototype.toString = function () {
          return (
            'ParentBased{root=' +
            this._root.toString() +
            ', remoteParentSampled=' +
            this._remoteParentSampled.toString() +
            ', remoteParentNotSampled=' +
            this._remoteParentNotSampled.toString() +
            ', localParentSampled=' +
            this._localParentSampled.toString() +
            ', localParentNotSampled=' +
            this._localParentNotSampled.toString() +
            '}'
          )
        }),
        t
      )
    })()
  })
var S8e,
  soe = createGetter(() => {
    Yt()
    S8e = (function () {
      function t(e) {
        e === void 0 && (e = 0),
          (this._ratio = e),
          (this._ratio = this._normalize(e)),
          (this._upperBound = Math.floor(this._ratio * 4294967295))
      }
      return (
        (t.prototype.shouldSample = function (e, r) {
          return { decision: Dg(r) && this._accumulate(r) < this._upperBound ? Cs.RECORD_AND_SAMPLED : Cs.NOT_RECORD }
        }),
        (t.prototype.toString = function () {
          return 'TraceIdRatioBased{' + this._ratio + '}'
        }),
        (t.prototype._normalize = function (e) {
          return typeof e != 'number' || isNaN(e) ? 0 : e >= 1 ? 1 : e <= 0 ? 0 : e
        }),
        (t.prototype._accumulate = function (e) {
          for (var r = 0, n = 0; n < e.length / 8; n++) {
            var i = n * 8,
              o = parseInt(e.slice(i, i + 8), 16)
            r = (r ^ o) >>> 0
          }
          return r
        }),
        t
      )
    })()
  })
function P8e(t, e) {
  return function (r) {
    return t(e(r))
  }
}
function RF(t) {
  if (!N8e(t) || k8e(t) !== C8e) return !1
  var e = D8e(t)
  if (e === null) return !0
  var r = loe.call(e, 'constructor') && e.constructor
  return typeof r == 'function' && r instanceof r && aoe.call(r) === R8e
}
function N8e(t) {
  return t != null && typeof t == 'object'
}
function k8e(t) {
  return t == null ? (t === void 0 ? w8e : I8e) : kg && kg in Object(t) ? O8e(t) : L8e(t)
}
function O8e(t) {
  var e = loe.call(t, kg),
    r = t[kg],
    n = !1
  try {
    ;(t[kg] = void 0), (n = !0)
  } catch {}
  var i = uoe.call(t)
  return n && (e ? (t[kg] = r) : delete t[kg]), i
}
function L8e(t) {
  return uoe.call(t)
}
var C8e,
  I8e,
  w8e,
  A8e,
  aoe,
  R8e,
  D8e,
  coe,
  loe,
  kg,
  uoe,
  poe = createGetter(() => {
    ;(C8e = '[object Object]'),
      (I8e = '[object Null]'),
      (w8e = '[object Undefined]'),
      (A8e = Function.prototype),
      (aoe = A8e.toString),
      (R8e = aoe.call(Object)),
      (D8e = P8e(Object.getPrototypeOf, Object)),
      (coe = Object.prototype),
      (loe = coe.hasOwnProperty),
      (kg = Symbol ? Symbol.toStringTag : void 0),
      (uoe = coe.toString)
  })
function PF() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
  for (var r = t.shift(), n = new WeakMap(); t.length > 0; ) r = foe(r, t.shift(), 0, n)
  return r
}
function DF(t) {
  return eR(t) ? t.slice() : t
}
function foe(t, e, r, n) {
  r === void 0 && (r = 0)
  var i
  if (!(r > M8e)) {
    if ((r++, Z2(t) || Z2(e) || moe(e))) i = DF(e)
    else if (eR(t)) {
      if (((i = t.slice()), eR(e))) for (var o = 0, s = e.length; o < s; o++) i.push(DF(e[o]))
      else if (AE(e))
        for (var a = Object.keys(e), o = 0, s = a.length; o < s; o++) {
          var l = a[o]
          i[l] = DF(e[l])
        }
    } else if (AE(t))
      if (AE(e)) {
        if (!F8e(t, e)) return e
        i = Object.assign({}, t)
        for (var a = Object.keys(e), o = 0, s = a.length; o < s; o++) {
          var l = a[o],
            c = e[l]
          if (Z2(c)) typeof c > 'u' ? delete i[l] : (i[l] = c)
          else {
            var u = i[l],
              p = c
            if (doe(t, l, n) || doe(e, l, n)) delete i[l]
            else {
              if (AE(u) && AE(p)) {
                var d = n.get(u) || [],
                  f = n.get(p) || []
                d.push({ obj: t, key: l }), f.push({ obj: e, key: l }), n.set(u, d), n.set(p, f)
              }
              i[l] = foe(i[l], c, r, n)
            }
          }
        }
      } else i = e
    return i
  }
}
function doe(t, e, r) {
  for (var n = r.get(t[e]) || [], i = 0, o = n.length; i < o; i++) {
    var s = n[i]
    if (s.key === e && s.obj === t) return !0
  }
  return !1
}
function eR(t) {
  return Array.isArray(t)
}
function moe(t) {
  return typeof t == 'function'
}
function AE(t) {
  return !Z2(t) && !eR(t) && !moe(t) && typeof t == 'object'
}
function Z2(t) {
  return (
    typeof t == 'string' ||
    typeof t == 'number' ||
    typeof t == 'boolean' ||
    typeof t > 'u' ||
    t instanceof Date ||
    t instanceof RegExp ||
    t === null
  )
}
function F8e(t, e) {
  return !(!RF(t) || !RF(e))
}
var M8e,
  hoe = createGetter(() => {
    poe()
    M8e = 20
  })
function B8e(t, e) {
  var r,
    n = new Promise(function (o, s) {
      r = setTimeout(function () {
        s(new goe('Operation timed out.'))
      }, e)
    })
  return Promise.race([t, n]).then(
    function (i) {
      return clearTimeout(r), i
    },
    function (i) {
      throw (clearTimeout(r), i)
    }
  )
}
var U8e,
  goe,
  voe = createGetter(() => {
    ;(U8e = (function () {
      var t = function (e, r) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i
              }) ||
            function (n, i) {
              for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
            }),
          t(e, r)
        )
      }
      return function (e, r) {
        if (typeof r != 'function' && r !== null)
          throw new TypeError('Class extends value ' + String(r) + ' is not a constructor or null')
        t(e, r)
        function n() {
          this.constructor = e
        }
        e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
      }
    })()),
      (goe = (function (t) {
        U8e(e, t)
        function e(r) {
          var n = t.call(this, r) || this
          return Object.setPrototypeOf(n, e.prototype), n
        }
        return e
      })(Error))
  })
function _oe(t, e) {
  return typeof e == 'string' ? t === e : !!t.match(e)
}
function H8e(t, e) {
  var r, n
  if (!e) return !1
  try {
    for (var i = q8e(e), o = i.next(); !o.done; o = i.next()) {
      var s = o.value
      if (_oe(t, s)) return !0
    }
  } catch (a) {
    r = { error: a }
  } finally {
    try {
      o && !o.done && (n = i.return) && n.call(i)
    } finally {
      if (r) throw r.error
    }
  }
  return !1
}
var q8e,
  yoe = createGetter(() => {
    q8e = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }
  })
function j8e(t) {
  return (
    typeof t == 'function' && typeof t.__original == 'function' && typeof t.__unwrap == 'function' && t.__wrapped === !0
  )
}
var xoe = createGetter(() => {})
var boe,
  Eoe = createGetter(() => {
    boe = (function () {
      function t() {
        var e = this
        this._promise = new Promise(function (r, n) {
          ;(e._resolve = r), (e._reject = n)
        })
      }
      return (
        Object.defineProperty(t.prototype, 'promise', {
          get: function () {
            return this._promise
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype.resolve = function (e) {
          this._resolve(e)
        }),
        (t.prototype.reject = function (e) {
          this._reject(e)
        }),
        t
      )
    })()
  })
var G8e,
  V8e,
  RE,
  Toe = createGetter(() => {
    Eoe()
    ;(G8e = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (V8e = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (RE = (function () {
        function t(e, r) {
          ;(this._callback = e), (this._that = r), (this._isCalled = !1), (this._deferred = new boe())
        }
        return (
          Object.defineProperty(t.prototype, 'isCalled', {
            get: function () {
              return this._isCalled
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, 'promise', {
            get: function () {
              return this._deferred.promise
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype.call = function () {
            for (var e, r = this, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i]
            if (!this._isCalled) {
              this._isCalled = !0
              try {
                Promise.resolve((e = this._callback).call.apply(e, V8e([this._that], G8e(n), !1))).then(
                  function (o) {
                    return r._deferred.resolve(o)
                  },
                  function (o) {
                    return r._deferred.reject(o)
                  }
                )
              } catch (o) {
                this._deferred.reject(o)
              }
            }
            return this._deferred.promise
          }),
          t
        )
      })())
  })
function Soe(t, e) {
  return new Promise(function (r) {
    Zo.with(bE(Zo.active()), function () {
      t.export(e, function (n) {
        r(n)
      })
    })
  })
}
var Coe = createGetter(() => {
  Yt()
  EE()
})
var Ioe = {}
defineProperties(Ioe, {
  AlwaysOffSampler: () => J2,
  AlwaysOnSampler: () => wE,
  AnchoredClock: () => f3e,
  BindOnceFuture: () => RE,
  CompositePropagator: () => xF,
  DEFAULT_ATTRIBUTE_COUNT_LIMIT: () => G_,
  DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: () => j_,
  DEFAULT_ENVIRONMENT: () => j2,
  DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: () => Cie,
  DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: () => Iie,
  ExportResultCode: () => Wa,
  ParentBasedSampler: () => T8e,
  RPCType: () => CF,
  RandomIdGenerator: () => M3e,
  SDK_INFO: () => SE,
  TRACE_PARENT_HEADER: () => Q2,
  TRACE_STATE_HEADER: () => X2,
  TimeoutError: () => goe,
  TraceIdRatioBasedSampler: () => S8e,
  TraceState: () => EF,
  TracesSamplerValues: () => da,
  VERSION: () => mF,
  W3CBaggagePropagator: () => aF,
  W3CTraceContextPropagator: () => SF,
  _globalThis: () => P3e,
  addHrTimes: () => Y2,
  baggageUtils: () => oF,
  callWithTimeout: () => B8e,
  deleteRPCMetadata: () => b8e,
  getEnv: () => bi,
  getEnvWithoutDefaults: () => dF,
  getRPCMetadata: () => E8e,
  getTimeOrigin: () => CE,
  globalErrorHandler: () => Is,
  hexToBase64: () => O3e,
  hrTime: () => $2,
  hrTimeDuration: () => yF,
  hrTimeToMicroseconds: () => W2,
  hrTimeToMilliseconds: () => s8e,
  hrTimeToNanoseconds: () => o8e,
  hrTimeToTimeStamp: () => i8e,
  internal: () => NF,
  isAttributeKey: () => yie,
  isAttributeValue: () => H2,
  isTimeInput: () => K2,
  isTimeInputHrTime: () => IE,
  isTracingSuppressed: () => Pg,
  isUrlIgnored: () => H8e,
  isWrapped: () => j8e,
  loggingErrorHandler: () => cF,
  merge: () => PF,
  millisToHrTime: () => Yl,
  otperformance: () => wp,
  parseEnvironment: () => TE,
  parseTraceParent: () => toe,
  sanitizeAttributes: () => Ng,
  setGlobalErrorHandler: () => _3e,
  setRPCMetadata: () => x8e,
  suppressTracing: () => bE,
  timeInputToHrTime: () => n8e,
  unrefTimer: () => vF,
  unsuppressTracing: () => u3e,
  urlMatches: () => _oe,
})
var NF,
  es = createGetter(() => {
    gie()
    vie()
    bie()
    uF()
    lF()
    zie()
    $ie()
    Wie()
    V2()
    sF()
    _F()
    Kie()
    roe()
    noe()
    ioe()
    wF()
    AF()
    ooe()
    soe()
    EE()
    TF()
    fF()
    hoe()
    pF()
    voe()
    yoe()
    xoe()
    Toe()
    V2()
    Coe()
    NF = { _export: Soe }
  })
var woe,
  Aoe = createGetter(() => {
    woe = 'exception'
  })
var z8e,
  $8e,
  kF,
  OF = createGetter(() => {
    Yt()
    es()
    Hc()
    Aoe()
    ;(z8e = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      ($8e = function (t, e) {
        var r = typeof Symbol == 'function' && t[Symbol.iterator]
        if (!r) return t
        var n = r.call(t),
          i,
          o = [],
          s
        try {
          for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
        } catch (a) {
          s = { error: a }
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n)
          } finally {
            if (s) throw s.error
          }
        }
        return o
      }),
      (kF = (function () {
        function t(e, r, n, i, o, s, a, l, c) {
          a === void 0 && (a = []),
            (this.attributes = {}),
            (this.links = []),
            (this.events = []),
            (this._droppedAttributesCount = 0),
            (this._droppedEventsCount = 0),
            (this._droppedLinksCount = 0),
            (this.status = { code: B_.UNSET }),
            (this.endTime = [0, 0]),
            (this._ended = !1),
            (this._duration = [-1, -1]),
            (this.name = n),
            (this._spanContext = i),
            (this.parentSpanId = s),
            (this.kind = o),
            (this.links = a)
          var u = Date.now()
          ;(this._performanceStartTime = wp.now()),
            (this._performanceOffset = u - (this._performanceStartTime + CE())),
            (this._startTimeProvided = l != null),
            (this.startTime = this._getTime(l ?? u)),
            (this.resource = e.resource),
            (this.instrumentationLibrary = e.instrumentationLibrary),
            (this._spanLimits = e.getSpanLimits()),
            (this._spanProcessor = e.getActiveSpanProcessor()),
            this._spanProcessor.onStart(this, r),
            (this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0)
        }
        return (
          (t.prototype.spanContext = function () {
            return this._spanContext
          }),
          (t.prototype.setAttribute = function (e, r) {
            return r == null || this._isSpanEnded()
              ? this
              : e.length === 0
              ? (at.warn('Invalid attribute key: ' + e), this)
              : H2(r)
              ? Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit &&
                !Object.prototype.hasOwnProperty.call(this.attributes, e)
                ? (this._droppedAttributesCount++, this)
                : ((this.attributes[e] = this._truncateToSize(r)), this)
              : (at.warn('Invalid attribute value set for key: ' + e), this)
          }),
          (t.prototype.setAttributes = function (e) {
            var r, n
            try {
              for (var i = z8e(Object.entries(e)), o = i.next(); !o.done; o = i.next()) {
                var s = $8e(o.value, 2),
                  a = s[0],
                  l = s[1]
                this.setAttribute(a, l)
              }
            } catch (c) {
              r = { error: c }
            } finally {
              try {
                o && !o.done && (n = i.return) && n.call(i)
              } finally {
                if (r) throw r.error
              }
            }
            return this
          }),
          (t.prototype.addEvent = function (e, r, n) {
            if (this._isSpanEnded()) return this
            if (this._spanLimits.eventCountLimit === 0)
              return at.warn('No events allowed.'), this._droppedEventsCount++, this
            this.events.length >= this._spanLimits.eventCountLimit &&
              (at.warn('Dropping extra events.'), this.events.shift(), this._droppedEventsCount++),
              K2(r) && (K2(n) || (n = r), (r = void 0))
            var i = Ng(r)
            return this.events.push({ name: e, attributes: i, time: this._getTime(n), droppedAttributesCount: 0 }), this
          }),
          (t.prototype.setStatus = function (e) {
            return this._isSpanEnded() ? this : ((this.status = e), this)
          }),
          (t.prototype.updateName = function (e) {
            return this._isSpanEnded() ? this : ((this.name = e), this)
          }),
          (t.prototype.end = function (e) {
            if (this._isSpanEnded()) {
              at.error(
                this.name +
                  ' ' +
                  this._spanContext.traceId +
                  '-' +
                  this._spanContext.spanId +
                  ' - You can only call end() on a span once.'
              )
              return
            }
            ;(this._ended = !0),
              (this.endTime = this._getTime(e)),
              (this._duration = yF(this.startTime, this.endTime)),
              this._duration[0] < 0 &&
                (at.warn(
                  'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',
                  this.startTime,
                  this.endTime
                ),
                (this.endTime = this.startTime.slice()),
                (this._duration = [0, 0])),
              this._spanProcessor.onEnd(this)
          }),
          (t.prototype._getTime = function (e) {
            if (typeof e == 'number' && e < wp.now()) return $2(e + this._performanceOffset)
            if (typeof e == 'number') return Yl(e)
            if (e instanceof Date) return Yl(e.getTime())
            if (IE(e)) return e
            if (this._startTimeProvided) return Yl(Date.now())
            var r = wp.now() - this._performanceStartTime
            return Y2(this.startTime, Yl(r))
          }),
          (t.prototype.isRecording = function () {
            return this._ended === !1
          }),
          (t.prototype.recordException = function (e, r) {
            var n = {}
            typeof e == 'string'
              ? (n[Ap.EXCEPTION_MESSAGE] = e)
              : e &&
                (e.code ? (n[Ap.EXCEPTION_TYPE] = e.code.toString()) : e.name && (n[Ap.EXCEPTION_TYPE] = e.name),
                e.message && (n[Ap.EXCEPTION_MESSAGE] = e.message),
                e.stack && (n[Ap.EXCEPTION_STACKTRACE] = e.stack)),
              n[Ap.EXCEPTION_TYPE] || n[Ap.EXCEPTION_MESSAGE]
                ? this.addEvent(woe, n, r)
                : at.warn('Failed to record an exception ' + e)
          }),
          Object.defineProperty(t.prototype, 'duration', {
            get: function () {
              return this._duration
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, 'ended', {
            get: function () {
              return this._ended
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, 'droppedAttributesCount', {
            get: function () {
              return this._droppedAttributesCount
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, 'droppedEventsCount', {
            get: function () {
              return this._droppedEventsCount
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, 'droppedLinksCount', {
            get: function () {
              return this._droppedLinksCount
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype._isSpanEnded = function () {
            return (
              this._ended &&
                at.warn(
                  'Can not execute the operation on ended Span {traceId: ' +
                    this._spanContext.traceId +
                    ', spanId: ' +
                    this._spanContext.spanId +
                    '}'
                ),
              this._ended
            )
          }),
          (t.prototype._truncateToLimitUtil = function (e, r) {
            return e.length <= r ? e : e.substr(0, r)
          }),
          (t.prototype._truncateToSize = function (e) {
            var r = this,
              n = this._attributeValueLengthLimit
            return n <= 0
              ? (at.warn('Attribute value limit must be positive, got ' + n), e)
              : typeof e == 'string'
              ? this._truncateToLimitUtil(e, n)
              : Array.isArray(e)
              ? e.map(function (i) {
                  return typeof i == 'string' ? r._truncateToLimitUtil(i, n) : i
                })
              : e
          }),
          t
        )
      })())
  })
var Ql,
  DE = createGetter(() => {
    ;(function (t) {
      ;(t[(t.NOT_RECORD = 0)] = 'NOT_RECORD'),
        (t[(t.RECORD = 1)] = 'RECORD'),
        (t[(t.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED')
    })(Ql || (Ql = {}))
  })
var Og,
  tR = createGetter(() => {
    DE()
    Og = (function () {
      function t() {}
      return (
        (t.prototype.shouldSample = function () {
          return { decision: Ql.NOT_RECORD }
        }),
        (t.prototype.toString = function () {
          return 'AlwaysOffSampler'
        }),
        t
      )
    })()
  })
var Rp,
  rR = createGetter(() => {
    DE()
    Rp = (function () {
      function t() {}
      return (
        (t.prototype.shouldSample = function () {
          return { decision: Ql.RECORD_AND_SAMPLED }
        }),
        (t.prototype.toString = function () {
          return 'AlwaysOnSampler'
        }),
        t
      )
    })()
  })
var PE,
  LF = createGetter(() => {
    Yt()
    es()
    tR()
    rR()
    PE = (function () {
      function t(e) {
        var r, n, i, o
        ;(this._root = e.root),
          this._root ||
            (Is(new Error('ParentBasedSampler must have a root sampler configured')), (this._root = new Rp())),
          (this._remoteParentSampled = (r = e.remoteParentSampled) !== null && r !== void 0 ? r : new Rp()),
          (this._remoteParentNotSampled = (n = e.remoteParentNotSampled) !== null && n !== void 0 ? n : new Og()),
          (this._localParentSampled = (i = e.localParentSampled) !== null && i !== void 0 ? i : new Rp()),
          (this._localParentNotSampled = (o = e.localParentNotSampled) !== null && o !== void 0 ? o : new Og())
      }
      return (
        (t.prototype.shouldSample = function (e, r, n, i, o, s) {
          var a = xi.getSpanContext(e)
          return !a || !$a(a)
            ? this._root.shouldSample(e, r, n, i, o, s)
            : a.isRemote
            ? a.traceFlags & Vn.SAMPLED
              ? this._remoteParentSampled.shouldSample(e, r, n, i, o, s)
              : this._remoteParentNotSampled.shouldSample(e, r, n, i, o, s)
            : a.traceFlags & Vn.SAMPLED
            ? this._localParentSampled.shouldSample(e, r, n, i, o, s)
            : this._localParentNotSampled.shouldSample(e, r, n, i, o, s)
        }),
        (t.prototype.toString = function () {
          return (
            'ParentBased{root=' +
            this._root.toString() +
            ', remoteParentSampled=' +
            this._remoteParentSampled.toString() +
            ', remoteParentNotSampled=' +
            this._remoteParentNotSampled.toString() +
            ', localParentSampled=' +
            this._localParentSampled.toString() +
            ', localParentNotSampled=' +
            this._localParentNotSampled.toString() +
            '}'
          )
        }),
        t
      )
    })()
  })
var nR,
  MF = createGetter(() => {
    Yt()
    DE()
    nR = (function () {
      function t(e) {
        e === void 0 && (e = 0),
          (this._ratio = e),
          (this._ratio = this._normalize(e)),
          (this._upperBound = Math.floor(this._ratio * 4294967295))
      }
      return (
        (t.prototype.shouldSample = function (e, r) {
          return { decision: Dg(r) && this._accumulate(r) < this._upperBound ? Ql.RECORD_AND_SAMPLED : Ql.NOT_RECORD }
        }),
        (t.prototype.toString = function () {
          return 'TraceIdRatioBased{' + this._ratio + '}'
        }),
        (t.prototype._normalize = function (e) {
          return typeof e != 'number' || isNaN(e) ? 0 : e >= 1 ? 1 : e <= 0 ? 0 : e
        }),
        (t.prototype._accumulate = function (e) {
          for (var r = 0, n = 0; n < e.length / 8; n++) {
            var i = n * 8,
              o = parseInt(e.slice(i, i + 8), 16)
            r = (r ^ o) >>> 0
          }
          return r
        }),
        t
      )
    })()
  })
function iR() {
  return {
    sampler: FF(W8e),
    forceFlushTimeoutMillis: 3e4,
    generalLimits: {
      attributeValueLengthLimit: bi().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: bi().OTEL_ATTRIBUTE_COUNT_LIMIT,
    },
    spanLimits: {
      attributeValueLengthLimit: bi().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: bi().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: bi().OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: bi().OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit: bi().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: bi().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    },
  }
}
function FF(t) {
  switch ((t === void 0 && (t = bi()), t.OTEL_TRACES_SAMPLER)) {
    case da.AlwaysOn:
      return new Rp()
    case da.AlwaysOff:
      return new Og()
    case da.ParentBasedAlwaysOn:
      return new PE({ root: new Rp() })
    case da.ParentBasedAlwaysOff:
      return new PE({ root: new Og() })
    case da.TraceIdRatio:
      return new nR(Roe(t))
    case da.ParentBasedTraceIdRatio:
      return new PE({ root: new nR(Roe(t)) })
    default:
      return (
        at.error('OTEL_TRACES_SAMPLER value "' + t.OTEL_TRACES_SAMPLER + ' invalid, defaulting to ' + K8e + '".'),
        new Rp()
      )
  }
}
function Roe(t) {
  if (t.OTEL_TRACES_SAMPLER_ARG === void 0 || t.OTEL_TRACES_SAMPLER_ARG === '')
    return at.error('OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ' + z_ + '.'), z_
  var e = Number(t.OTEL_TRACES_SAMPLER_ARG)
  return isNaN(e)
    ? (at.error(
        'OTEL_TRACES_SAMPLER_ARG=' +
          t.OTEL_TRACES_SAMPLER_ARG +
          ' was given, but it is invalid, defaulting to ' +
          z_ +
          '.'
      ),
      z_)
    : e < 0 || e > 1
    ? (at.error(
        'OTEL_TRACES_SAMPLER_ARG=' +
          t.OTEL_TRACES_SAMPLER_ARG +
          ' was given, but it is out of range ([0..1]), defaulting to ' +
          z_ +
          '.'
      ),
      z_)
    : e
}
var W8e,
  K8e,
  z_,
  UF = createGetter(() => {
    Yt()
    es()
    tR()
    rR()
    LF()
    MF()
    ;(W8e = bi()), (K8e = da.AlwaysOn), (z_ = 1)
  })
function Doe(t) {
  var e = { sampler: FF() },
    r = iR(),
    n = Object.assign({}, r, e, t)
  return (
    (n.generalLimits = Object.assign({}, r.generalLimits, t.generalLimits || {})),
    (n.spanLimits = Object.assign({}, r.spanLimits, t.spanLimits || {})),
    n
  )
}
function Poe(t) {
  var e,
    r,
    n,
    i,
    o,
    s,
    a,
    l,
    c,
    u,
    p,
    d,
    f = Object.assign({}, t.spanLimits),
    m = dF()
  return (
    (f.attributeCountLimit =
      (s =
        (o =
          (i =
            (r = (e = t.spanLimits) === null || e === void 0 ? void 0 : e.attributeCountLimit) !== null && r !== void 0
              ? r
              : (n = t.generalLimits) === null || n === void 0
              ? void 0
              : n.attributeCountLimit) !== null && i !== void 0
            ? i
            : m.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && o !== void 0
          ? o
          : m.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && s !== void 0
        ? s
        : G_),
    (f.attributeValueLengthLimit =
      (d =
        (p =
          (u =
            (l = (a = t.spanLimits) === null || a === void 0 ? void 0 : a.attributeValueLengthLimit) !== null &&
            l !== void 0
              ? l
              : (c = t.generalLimits) === null || c === void 0
              ? void 0
              : c.attributeValueLengthLimit) !== null && u !== void 0
            ? u
            : m.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && p !== void 0
          ? p
          : m.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && d !== void 0
        ? d
        : j_),
    Object.assign({}, t, { spanLimits: f })
  )
}
var BF = createGetter(() => {
  UF()
  es()
})
var Noe,
  koe = createGetter(() => {
    Yt()
    es()
    Noe = (function () {
      function t(e, r) {
        ;(this._exporter = e), (this._finishedSpans = []), (this._droppedSpansCount = 0)
        var n = bi()
        ;(this._maxExportBatchSize =
          typeof r?.maxExportBatchSize == 'number' ? r.maxExportBatchSize : n.OTEL_BSP_MAX_EXPORT_BATCH_SIZE),
          (this._maxQueueSize = typeof r?.maxQueueSize == 'number' ? r.maxQueueSize : n.OTEL_BSP_MAX_QUEUE_SIZE),
          (this._scheduledDelayMillis =
            typeof r?.scheduledDelayMillis == 'number' ? r.scheduledDelayMillis : n.OTEL_BSP_SCHEDULE_DELAY),
          (this._exportTimeoutMillis =
            typeof r?.exportTimeoutMillis == 'number' ? r.exportTimeoutMillis : n.OTEL_BSP_EXPORT_TIMEOUT),
          (this._shutdownOnce = new RE(this._shutdown, this)),
          this._maxExportBatchSize > this._maxQueueSize &&
            (at.warn(
              'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'
            ),
            (this._maxExportBatchSize = this._maxQueueSize))
      }
      return (
        (t.prototype.forceFlush = function () {
          return this._shutdownOnce.isCalled ? this._shutdownOnce.promise : this._flushAll()
        }),
        (t.prototype.onStart = function (e, r) {}),
        (t.prototype.onEnd = function (e) {
          this._shutdownOnce.isCalled || (e.spanContext().traceFlags & Vn.SAMPLED && this._addToBuffer(e))
        }),
        (t.prototype.shutdown = function () {
          return this._shutdownOnce.call()
        }),
        (t.prototype._shutdown = function () {
          var e = this
          return Promise.resolve()
            .then(function () {
              return e.onShutdown()
            })
            .then(function () {
              return e._flushAll()
            })
            .then(function () {
              return e._exporter.shutdown()
            })
        }),
        (t.prototype._addToBuffer = function (e) {
          if (this._finishedSpans.length >= this._maxQueueSize) {
            this._droppedSpansCount === 0 && at.debug('maxQueueSize reached, dropping spans'), this._droppedSpansCount++
            return
          }
          this._droppedSpansCount > 0 &&
            (at.warn('Dropped ' + this._droppedSpansCount + ' spans because maxQueueSize reached'),
            (this._droppedSpansCount = 0)),
            this._finishedSpans.push(e),
            this._maybeStartTimer()
        }),
        (t.prototype._flushAll = function () {
          var e = this
          return new Promise(function (r, n) {
            for (var i = [], o = Math.ceil(e._finishedSpans.length / e._maxExportBatchSize), s = 0, a = o; s < a; s++)
              i.push(e._flushOneBatch())
            Promise.all(i)
              .then(function () {
                r()
              })
              .catch(n)
          })
        }),
        (t.prototype._flushOneBatch = function () {
          var e = this
          return (
            this._clearTimer(),
            this._finishedSpans.length === 0
              ? Promise.resolve()
              : new Promise(function (r, n) {
                  var i = setTimeout(function () {
                    n(new Error('Timeout'))
                  }, e._exportTimeoutMillis)
                  Zo.with(bE(Zo.active()), function () {
                    var o = e._finishedSpans.splice(0, e._maxExportBatchSize),
                      s = function () {
                        return e._exporter.export(o, function (l) {
                          var c
                          clearTimeout(i),
                            l.code === Wa.SUCCESS
                              ? r()
                              : n(
                                  (c = l.error) !== null && c !== void 0
                                    ? c
                                    : new Error('BatchSpanProcessor: span export failed')
                                )
                        })
                      },
                      a = o
                        .map(function (l) {
                          return l.resource
                        })
                        .filter(function (l) {
                          return l.asyncAttributesPending
                        })
                    a.length === 0
                      ? s()
                      : Promise.all(
                          a.map(function (l) {
                            var c
                            return (c = l.waitForAsyncAttributes) === null || c === void 0 ? void 0 : c.call(l)
                          })
                        ).then(s, function (l) {
                          Is(l), n(l)
                        })
                  })
                })
          )
        }),
        (t.prototype._maybeStartTimer = function () {
          var e = this
          this._timer === void 0 &&
            ((this._timer = setTimeout(function () {
              e._flushOneBatch()
                .then(function () {
                  e._finishedSpans.length > 0 && (e._clearTimer(), e._maybeStartTimer())
                })
                .catch(function (r) {
                  Is(r)
                })
            }, this._scheduledDelayMillis)),
            vF(this._timer))
        }),
        (t.prototype._clearTimer = function () {
          this._timer !== void 0 && (clearTimeout(this._timer), (this._timer = void 0))
        }),
        t
      )
    })()
  })
var Y8e,
  qF,
  Ooe = createGetter(() => {
    koe()
    ;(Y8e = (function () {
      var t = function (e, r) {
        return (
          (t =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (n, i) {
                n.__proto__ = i
              }) ||
            function (n, i) {
              for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
            }),
          t(e, r)
        )
      }
      return function (e, r) {
        if (typeof r != 'function' && r !== null)
          throw new TypeError('Class extends value ' + String(r) + ' is not a constructor or null')
        t(e, r)
        function n() {
          this.constructor = e
        }
        e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
      }
    })()),
      (qF = (function (t) {
        Y8e(e, t)
        function e() {
          return (t !== null && t.apply(this, arguments)) || this
        }
        return (e.prototype.onShutdown = function () {}), e
      })(Noe))
  })
function Loe(t) {
  return function () {
    for (var r = 0; r < t / 4; r++) oR.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, r * 4)
    for (var r = 0; r < t && !(oR[r] > 0); r++) r === t - 1 && (oR[t - 1] = 1)
    return oR.toString('hex', 0, t)
  }
}
var Q8e,
  Moe,
  HF,
  oR,
  Foe = createGetter(() => {
    ;(Q8e = 8),
      (Moe = 16),
      (HF = (function () {
        function t() {
          ;(this.generateTraceId = Loe(Moe)), (this.generateSpanId = Loe(Q8e))
        }
        return t
      })()),
      (oR = Buffer.allocUnsafe(Moe))
  })
var Uoe = createGetter(() => {
  Ooe()
  Foe()
})
var sR = createGetter(() => {
  Uoe()
})
var jF,
  Boe = createGetter(() => {
    Yt()
    es()
    OF()
    BF()
    sR()
    jF = (function () {
      function t(e, r, n) {
        this._tracerProvider = n
        var i = Doe(r)
        ;(this._sampler = i.sampler),
          (this._generalLimits = i.generalLimits),
          (this._spanLimits = i.spanLimits),
          (this._idGenerator = r.idGenerator || new HF()),
          (this.resource = n.resource),
          (this.instrumentationLibrary = e)
      }
      return (
        (t.prototype.startSpan = function (e, r, n) {
          var i, o, s
          r === void 0 && (r = {}), n === void 0 && (n = Zo.active()), r.root && (n = xi.deleteSpan(n))
          var a = xi.getSpan(n)
          if (Pg(n)) {
            at.debug('Instrumentation suppressed, returning Noop Span')
            var l = xi.wrapSpanContext(F_)
            return l
          }
          var c = a?.spanContext(),
            u = this._idGenerator.generateSpanId(),
            p,
            d,
            f
          !c || !xi.isSpanContextValid(c)
            ? (p = this._idGenerator.generateTraceId())
            : ((p = c.traceId), (d = c.traceState), (f = c.spanId))
          var m = (i = r.kind) !== null && i !== void 0 ? i : U_.INTERNAL,
            h = ((o = r.links) !== null && o !== void 0 ? o : []).map(function (P) {
              return { context: P.context, attributes: Ng(P.attributes) }
            }),
            g = Ng(r.attributes),
            v = this._sampler.shouldSample(n, p, e, m, g, h)
          d = (s = v.traceState) !== null && s !== void 0 ? s : d
          var _ = v.decision === Cs.RECORD_AND_SAMPLED ? Vn.SAMPLED : Vn.NONE,
            y = { traceId: p, spanId: u, traceFlags: _, traceState: d }
          if (v.decision === Cs.NOT_RECORD) {
            at.debug('Recording is off, propagating context in a non-recording span')
            var l = xi.wrapSpanContext(y)
            return l
          }
          var b = new kF(this, n, e, y, m, f, h, r.startTime),
            x = Ng(Object.assign(g, v.attributes))
          return b.setAttributes(x), b
        }),
        (t.prototype.startActiveSpan = function (e, r, n, i) {
          var o, s, a
          if (!(arguments.length < 2)) {
            arguments.length === 2 ? (a = r) : arguments.length === 3 ? ((o = r), (a = n)) : ((o = r), (s = n), (a = i))
            var l = s ?? Zo.active(),
              c = this.startSpan(e, o, l),
              u = xi.setSpan(l, c)
            return Zo.with(u, a, void 0, c)
          }
        }),
        (t.prototype.getGeneralLimits = function () {
          return this._generalLimits
        }),
        (t.prototype.getSpanLimits = function () {
          return this._spanLimits
        }),
        (t.prototype.getActiveSpanProcessor = function () {
          return this._tracerProvider.getActiveSpanProcessor()
        }),
        t
      )
    })()
  })
function qoe() {
  return 'unknown_service:' + process.argv0
}
var Hoe = createGetter(() => {})
var joe,
  Goe,
  GF = createGetter(() => {
    ;(joe = function (t) {
      switch (t) {
        case 'arm':
          return 'arm32'
        case 'ppc':
          return 'ppc32'
        case 'x64':
          return 'amd64'
        default:
          return t
      }
    }),
      (Goe = function (t) {
        switch (t) {
          case 'sunos':
            return 'solaris'
          case 'win32':
            return 'windows'
          default:
            return t
        }
      })
  })
var Voe,
  zoe,
  $_,
  aR = createGetter(() => {
    ;(Voe = handleDefaultExports(require('child_process'))), (zoe = handleDefaultExports(require('util'))), ($_ = zoe.promisify(Voe.exec))
  })
var $oe = {}
defineProperties($oe, { getMachineId: () => Z8e })
function Z8e() {
  return X8e(this, void 0, void 0, function () {
    var t, e, r, n
    return J8e(this, function (i) {
      switch (i.label) {
        case 0:
          return i.trys.push([0, 2, , 3]), [4, $_('ioreg -rd1 -c "IOPlatformExpertDevice"')]
        case 1:
          return (
            (t = i.sent()),
            (e = t.stdout
              .split(
                `
`
              )
              .find(function (o) {
                return o.includes('IOPlatformUUID')
              })),
            e ? ((r = e.split('" = "')), r.length === 2 ? [2, r[1].slice(0, -1)] : [3, 3]) : [2, '']
          )
        case 2:
          return (n = i.sent()), at.debug('error reading machine id: ' + n), [3, 3]
        case 3:
          return [2, '']
      }
    })
  })
}
var X8e,
  J8e,
  Woe = createGetter(() => {
    aR()
    Yt()
    ;(X8e = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (J8e = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      })
  })
var Yoe = {}
defineProperties(Yoe, { getMachineId: () => nMe })
function nMe() {
  return eMe(this, void 0, void 0, function () {
    var t, e, r, n, i, o, s, a, l
    return tMe(this, function (c) {
      switch (c.label) {
        case 0:
          ;(t = ['/etc/machine-id', '/var/lib/dbus/machine-id']), (c.label = 1)
        case 1:
          c.trys.push([1, 8, 9, 10]), (e = rMe(t)), (r = e.next()), (c.label = 2)
        case 2:
          if (r.done) return [3, 7]
          ;(n = r.value), (c.label = 3)
        case 3:
          return c.trys.push([3, 5, , 6]), [4, Koe.promises.readFile(n, { encoding: 'utf8' })]
        case 4:
          return (i = c.sent()), [2, i.trim()]
        case 5:
          return (o = c.sent()), at.debug('error reading machine id: ' + o), [3, 6]
        case 6:
          return (r = e.next()), [3, 2]
        case 7:
          return [3, 10]
        case 8:
          return (s = c.sent()), (a = { error: s }), [3, 10]
        case 9:
          try {
            r && !r.done && (l = e.return) && l.call(e)
          } finally {
            if (a) throw a.error
          }
          return [7]
        case 10:
          return [2, '']
      }
    })
  })
}
var Koe,
  eMe,
  tMe,
  rMe,
  Qoe = createGetter(() => {
    Koe = require('fs')
    Yt()
    ;(eMe = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (tMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }),
      (rMe = function (t) {
        var e = typeof Symbol == 'function' && Symbol.iterator,
          r = e && t[e],
          n = 0
        if (r) return r.call(t)
        if (t && typeof t.length == 'number')
          return {
            next: function () {
              return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
            },
          }
        throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
      })
  })
var Joe = {}
defineProperties(Joe, { getMachineId: () => sMe })
function sMe() {
  return iMe(this, void 0, void 0, function () {
    var e, t, e, r
    return oMe(this, function (n) {
      switch (n.label) {
        case 0:
          return n.trys.push([0, 2, , 3]), [4, Xoe.promises.readFile('/etc/hostid', { encoding: 'utf8' })]
        case 1:
          return (e = n.sent()), [2, e.trim()]
        case 2:
          return (t = n.sent()), at.debug('error reading machine id: ' + t), [3, 3]
        case 3:
          return n.trys.push([3, 5, , 6]), [4, $_('kenv -q smbios.system.uuid')]
        case 4:
          return (e = n.sent()), [2, e.stdout.trim()]
        case 5:
          return (r = n.sent()), at.debug('error reading machine id: ' + r), [3, 6]
        case 6:
          return [2, '']
      }
    })
  })
}
var Xoe,
  iMe,
  oMe,
  Zoe = createGetter(() => {
    Xoe = require('fs')
    aR()
    Yt()
    ;(iMe = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (oMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      })
  })
var ese = {}
defineProperties(ese, { getMachineId: () => lMe })
function lMe() {
  return aMe(this, void 0, void 0, function () {
    var t, e, r, n, i
    return cMe(this, function (o) {
      switch (o.label) {
        case 0:
          ;(t = 'QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid'),
            (e = '%windir%\\System32\\REG.exe'),
            cR.arch === 'ia32' && 'PROCESSOR_ARCHITEW6432' in cR.env && (e = '%windir%\\sysnative\\cmd.exe /c ' + e),
            (o.label = 1)
        case 1:
          return o.trys.push([1, 3, , 4]), [4, $_(e + ' ' + t)]
        case 2:
          return (r = o.sent()), (n = r.stdout.split('REG_SZ')), n.length === 2 ? [2, n[1].trim()] : [3, 4]
        case 3:
          return (i = o.sent()), at.debug('error reading machine id: ' + i), [3, 4]
        case 4:
          return [2, '']
      }
    })
  })
}
var cR,
  aMe,
  cMe,
  tse = createGetter(() => {
    cR = handleDefaultExports(require('process'))
    aR()
    Yt()
    ;(aMe = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (cMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      })
  })
var rse = {}
defineProperties(rse, { getMachineId: () => dMe })
function dMe() {
  return uMe(this, void 0, void 0, function () {
    return pMe(this, function (t) {
      return at.debug('could not read machine-id: unsupported platform'), [2, '']
    })
  })
}
var uMe,
  pMe,
  nse = createGetter(() => {
    Yt()
    ;(uMe = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (pMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      })
  })
var ise,
  Lg,
  ose = createGetter(() => {
    ise = handleDefaultExports(require('process'))
    switch (ise.platform) {
      case 'darwin':
        Lg = (Woe(), handleEsModuleExports($oe)).getMachineId
        break
      case 'linux':
        Lg = (Qoe(), handleEsModuleExports(Yoe)).getMachineId
        break
      case 'freebsd':
        Lg = (Zoe(), handleEsModuleExports(Joe)).getMachineId
        break
      case 'win32':
        Lg = (tse(), handleEsModuleExports(ese)).getMachineId
        break
      default:
        Lg = (nse(), handleEsModuleExports(rse)).getMachineId
    }
  })
var lR,
  fMe,
  sse,
  VF = createGetter(() => {
    Hc()
    W_()
    lR = require('os')
    GF()
    ose()
    ;(fMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          var r,
            n = ((r = {}), (r[Bt.HOST_NAME] = (0, lR.hostname)()), (r[Bt.HOST_ARCH] = joe((0, lR.arch)())), r)
          return new ts(n, this._getAsyncAttributes())
        }),
        (t.prototype._getAsyncAttributes = function () {
          return Lg().then(function (e) {
            var r = {}
            return e && (r[Bt.HOST_ID] = e), r
          })
        }),
        t
      )
    })()),
      (sse = new fMe())
  })
var mMe,
  XEt,
  ase = createGetter(() => {
    VF()
    ;(mMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          return Promise.resolve(sse.detect(e))
        }),
        t
      )
    })()),
      (XEt = new mMe())
  })
var uR,
  hMe,
  cse,
  zF = createGetter(() => {
    Hc()
    W_()
    uR = require('os')
    GF()
    ;(hMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          var r,
            n = ((r = {}), (r[Bt.OS_TYPE] = Goe((0, uR.platform)())), (r[Bt.OS_VERSION] = (0, uR.release)()), r)
          return new ts(n)
        }),
        t
      )
    })()),
      (cse = new hMe())
  })
var gMe,
  iTt,
  lse = createGetter(() => {
    zF()
    ;(gMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          return Promise.resolve(cse.detect(e))
        }),
        t
      )
    })()),
      (iTt = new gMe())
  })
var dse,
  use,
  pse,
  vMe,
  fse,
  $F = createGetter(() => {
    Yt()
    Hc()
    W_()
    ;(dse = handleDefaultExports(require('os'))),
      (use = function (t, e) {
        var r = typeof Symbol == 'function' && t[Symbol.iterator]
        if (!r) return t
        var n = r.call(t),
          i,
          o = [],
          s
        try {
          for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
        } catch (a) {
          s = { error: a }
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n)
          } finally {
            if (s) throw s.error
          }
        }
        return o
      }),
      (pse = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (vMe = (function () {
        function t() {}
        return (
          (t.prototype.detect = function (e) {
            var r,
              n =
                ((r = {}),
                (r[Bt.PROCESS_PID] = process.pid),
                (r[Bt.PROCESS_EXECUTABLE_NAME] = process.title),
                (r[Bt.PROCESS_EXECUTABLE_PATH] = process.execPath),
                (r[Bt.PROCESS_COMMAND_ARGS] = pse(
                  pse([process.argv[0]], use(process.execArgv), !1),
                  use(process.argv.slice(1)),
                  !1
                )),
                (r[Bt.PROCESS_RUNTIME_VERSION] = process.versions.node),
                (r[Bt.PROCESS_RUNTIME_NAME] = 'nodejs'),
                (r[Bt.PROCESS_RUNTIME_DESCRIPTION] = 'Node.js'),
                r)
            process.argv.length > 1 && (n[Bt.PROCESS_COMMAND] = process.argv[1])
            try {
              var i = dse.userInfo()
              n[Bt.PROCESS_OWNER] = i.username
            } catch (o) {
              at.debug('error obtaining process owner: ' + o)
            }
            return new ts(n)
          }),
          t
        )
      })()),
      (fse = new vMe())
  })
var _Me,
  pTt,
  mse = createGetter(() => {
    $F()
    ;(_Me = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          return Promise.resolve(fse.detect(e))
        }),
        t
      )
    })()),
      (pTt = new _Me())
  })
var hse = createGetter(() => {
  Hoe()
  ase()
  lse()
  VF()
  zF()
  mse()
  $F()
})
var WF = createGetter(() => {
  hse()
})
var Ff,
  yMe,
  xMe,
  bMe,
  ts,
  W_ = createGetter(() => {
    Yt()
    Hc()
    es()
    WF()
    ;(Ff = function () {
      return (
        (Ff =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        Ff.apply(this, arguments)
      )
    }),
      (yMe = function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      }),
      (xMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }),
      (bMe = function (t, e) {
        var r = typeof Symbol == 'function' && t[Symbol.iterator]
        if (!r) return t
        var n = r.call(t),
          i,
          o = [],
          s
        try {
          for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
        } catch (a) {
          s = { error: a }
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n)
          } finally {
            if (s) throw s.error
          }
        }
        return o
      }),
      (ts = (function () {
        function t(e, r) {
          var n = this,
            i
          ;(this._attributes = e),
            (this.asyncAttributesPending = r != null),
            (this._syncAttributes = (i = this._attributes) !== null && i !== void 0 ? i : {}),
            (this._asyncAttributesPromise = r?.then(
              function (o) {
                return (n._attributes = Object.assign({}, n._attributes, o)), (n.asyncAttributesPending = !1), o
              },
              function (o) {
                return (
                  at.debug("a resource's async attributes promise rejected: %s", o), (n.asyncAttributesPending = !1), {}
                )
              }
            ))
        }
        return (
          (t.empty = function () {
            return t.EMPTY
          }),
          (t.default = function () {
            var e
            return new t(
              ((e = {}),
              (e[Bt.SERVICE_NAME] = qoe()),
              (e[Bt.TELEMETRY_SDK_LANGUAGE] = SE[Bt.TELEMETRY_SDK_LANGUAGE]),
              (e[Bt.TELEMETRY_SDK_NAME] = SE[Bt.TELEMETRY_SDK_NAME]),
              (e[Bt.TELEMETRY_SDK_VERSION] = SE[Bt.TELEMETRY_SDK_VERSION]),
              e)
            )
          }),
          Object.defineProperty(t.prototype, 'attributes', {
            get: function () {
              var e
              return (
                this.asyncAttributesPending &&
                  at.error('Accessing resource attributes before async attributes settled'),
                (e = this._attributes) !== null && e !== void 0 ? e : {}
              )
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype.waitForAsyncAttributes = function () {
            return yMe(this, void 0, void 0, function () {
              return xMe(this, function (e) {
                switch (e.label) {
                  case 0:
                    return this.asyncAttributesPending ? [4, this._asyncAttributesPromise] : [3, 2]
                  case 1:
                    e.sent(), (e.label = 2)
                  case 2:
                    return [2]
                }
              })
            })
          }),
          (t.prototype.merge = function (e) {
            var r = this,
              n
            if (!e) return this
            var i = Ff(
              Ff({}, this._syncAttributes),
              (n = e._syncAttributes) !== null && n !== void 0 ? n : e.attributes
            )
            if (!this._asyncAttributesPromise && !e._asyncAttributesPromise) return new t(i)
            var o = Promise.all([this._asyncAttributesPromise, e._asyncAttributesPromise]).then(function (s) {
              var a,
                l = bMe(s, 2),
                c = l[0],
                u = l[1]
              return Ff(
                Ff(
                  Ff(Ff({}, r._syncAttributes), c),
                  (a = e._syncAttributes) !== null && a !== void 0 ? a : e.attributes
                ),
                u
              )
            })
            return new t(i, o)
          }),
          (t.EMPTY = new t({})),
          t
        )
      })())
  })
var gse = createGetter(() => {})
var vse = createGetter(() => {})
var _se = createGetter(() => {})
var EMe,
  RTt,
  yse = createGetter(() => {
    pR()
    ;(EMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          return Promise.resolve(xse.detect(e))
        }),
        t
      )
    })()),
      (RTt = new EMe())
  })
var TMe,
  SMe,
  CMe,
  bse,
  KF = createGetter(() => {
    Yt()
    es()
    Hc()
    W_()
    ;(TMe = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      (SMe = function (t, e) {
        var r = typeof Symbol == 'function' && t[Symbol.iterator]
        if (!r) return t
        var n = r.call(t),
          i,
          o = [],
          s
        try {
          for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
        } catch (a) {
          s = { error: a }
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n)
          } finally {
            if (s) throw s.error
          }
        }
        return o
      }),
      (CMe = (function () {
        function t() {
          ;(this._MAX_LENGTH = 255),
            (this._COMMA_SEPARATOR = ','),
            (this._LABEL_KEY_VALUE_SPLITTER = '='),
            (this._ERROR_MESSAGE_INVALID_CHARS =
              'should be a ASCII string with a length greater than 0 and not exceed ' +
              this._MAX_LENGTH +
              ' characters.'),
            (this._ERROR_MESSAGE_INVALID_VALUE =
              'should be a ASCII string with a length not exceed ' + this._MAX_LENGTH + ' characters.')
        }
        return (
          (t.prototype.detect = function (e) {
            var r = {},
              n = bi(),
              i = n.OTEL_RESOURCE_ATTRIBUTES,
              o = n.OTEL_SERVICE_NAME
            if (i)
              try {
                var s = this._parseResourceAttributes(i)
                Object.assign(r, s)
              } catch (a) {
                at.debug('EnvDetector failed: ' + a.message)
              }
            return o && (r[Bt.SERVICE_NAME] = o), new ts(r)
          }),
          (t.prototype._parseResourceAttributes = function (e) {
            var r, n
            if (!e) return {}
            var i = {},
              o = e.split(this._COMMA_SEPARATOR, -1)
            try {
              for (var s = TMe(o), a = s.next(); !a.done; a = s.next()) {
                var l = a.value,
                  c = l.split(this._LABEL_KEY_VALUE_SPLITTER, -1)
                if (c.length === 2) {
                  var u = SMe(c, 2),
                    p = u[0],
                    d = u[1]
                  if (((p = p.trim()), (d = d.trim().split(/^"|"$/).join('')), !this._isValidAndNotEmpty(p)))
                    throw new Error('Attribute key ' + this._ERROR_MESSAGE_INVALID_CHARS)
                  if (!this._isValid(d)) throw new Error('Attribute value ' + this._ERROR_MESSAGE_INVALID_VALUE)
                  i[p] = decodeURIComponent(d)
                }
              }
            } catch (f) {
              r = { error: f }
            } finally {
              try {
                a && !a.done && (n = s.return) && n.call(s)
              } finally {
                if (r) throw r.error
              }
            }
            return i
          }),
          (t.prototype._isValid = function (e) {
            return e.length <= this._MAX_LENGTH && this._isBaggageOctetString(e)
          }),
          (t.prototype._isBaggageOctetString = function (e) {
            for (var r = 0; r < e.length; r++) {
              var n = e.charCodeAt(r)
              if (n < 33 || n === 44 || n === 59 || n === 92 || n > 126) return !1
            }
            return !0
          }),
          (t.prototype._isValidAndNotEmpty = function (e) {
            return e.length > 0 && this._isValid(e)
          }),
          t
        )
      })()),
      (bse = new CMe())
  })
var IMe,
  FTt,
  Ese = createGetter(() => {
    KF()
    ;(IMe = (function () {
      function t() {}
      return (
        (t.prototype.detect = function (e) {
          return Promise.resolve(bse.detect(e))
        }),
        t
      )
    })()),
      (FTt = new IMe())
  })
var YF,
  wMe,
  xse,
  Tse = createGetter(() => {
    Hc()
    pR()
    Yt()
    ;(YF = function () {
      return (
        (YF =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        YF.apply(this, arguments)
      )
    }),
      (wMe = (function () {
        function t() {}
        return (
          (t.prototype.detect = function (e) {
            var r,
              n = typeof navigator < 'u'
            if (!n) return ts.empty()
            var i =
              ((r = {}),
              (r[Bt.PROCESS_RUNTIME_NAME] = 'browser'),
              (r[Bt.PROCESS_RUNTIME_DESCRIPTION] = 'Web Browser'),
              (r[Bt.PROCESS_RUNTIME_VERSION] = navigator.userAgent),
              r)
            return this._getResourceAttributes(i, e)
          }),
          (t.prototype._getResourceAttributes = function (e, r) {
            return e[Bt.PROCESS_RUNTIME_VERSION] === ''
              ? (at.debug('BrowserDetector failed: Unable to find required browser resources. '), ts.empty())
              : new ts(YF({}, e))
          }),
          t
        )
      })()),
      (xse = new wMe())
  })
var Sse = createGetter(() => {
  yse()
  Ese()
  Tse()
  KF()
})
var Cse = createGetter(() => {})
var pR = createGetter(() => {
  W_()
  gse()
  WF()
  vse()
  _se()
  Sse()
  Cse()
})
var dR,
  Ise,
  wse = createGetter(() => {
    es()
    ;(dR = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      (Ise = (function () {
        function t(e) {
          this._spanProcessors = e
        }
        return (
          (t.prototype.forceFlush = function () {
            var e,
              r,
              n = []
            try {
              for (var i = dR(this._spanProcessors), o = i.next(); !o.done; o = i.next()) {
                var s = o.value
                n.push(s.forceFlush())
              }
            } catch (a) {
              e = { error: a }
            } finally {
              try {
                o && !o.done && (r = i.return) && r.call(i)
              } finally {
                if (e) throw e.error
              }
            }
            return new Promise(function (a) {
              Promise.all(n)
                .then(function () {
                  a()
                })
                .catch(function (l) {
                  Is(l || new Error('MultiSpanProcessor: forceFlush failed')), a()
                })
            })
          }),
          (t.prototype.onStart = function (e, r) {
            var n, i
            try {
              for (var o = dR(this._spanProcessors), s = o.next(); !s.done; s = o.next()) {
                var a = s.value
                a.onStart(e, r)
              }
            } catch (l) {
              n = { error: l }
            } finally {
              try {
                s && !s.done && (i = o.return) && i.call(o)
              } finally {
                if (n) throw n.error
              }
            }
          }),
          (t.prototype.onEnd = function (e) {
            var r, n
            try {
              for (var i = dR(this._spanProcessors), o = i.next(); !o.done; o = i.next()) {
                var s = o.value
                s.onEnd(e)
              }
            } catch (a) {
              r = { error: a }
            } finally {
              try {
                o && !o.done && (n = i.return) && n.call(i)
              } finally {
                if (r) throw r.error
              }
            }
          }),
          (t.prototype.shutdown = function () {
            var e,
              r,
              n = []
            try {
              for (var i = dR(this._spanProcessors), o = i.next(); !o.done; o = i.next()) {
                var s = o.value
                n.push(s.shutdown())
              }
            } catch (a) {
              e = { error: a }
            } finally {
              try {
                o && !o.done && (r = i.return) && r.call(i)
              } finally {
                if (e) throw e.error
              }
            }
            return new Promise(function (a, l) {
              Promise.all(n).then(function () {
                a()
              }, l)
            })
          }),
          t
        )
      })())
  })
var QF,
  XF = createGetter(() => {
    QF = (function () {
      function t() {}
      return (
        (t.prototype.onStart = function (e, r) {}),
        (t.prototype.onEnd = function (e) {}),
        (t.prototype.shutdown = function () {
          return Promise.resolve()
        }),
        (t.prototype.forceFlush = function () {
          return Promise.resolve()
        }),
        t
      )
    })()
  })
var Uf,
  AMe,
  Ase = createGetter(() => {
    Yt()
    es()
    pR()
    JF()
    UF()
    wse()
    XF()
    sR()
    BF()
    ;(function (t) {
      ;(t[(t.resolved = 0)] = 'resolved'),
        (t[(t.timeout = 1)] = 'timeout'),
        (t[(t.error = 2)] = 'error'),
        (t[(t.unresolved = 3)] = 'unresolved')
    })(Uf || (Uf = {}))
    AMe = (function () {
      function t(e) {
        e === void 0 && (e = {})
        var r
        ;(this._registeredSpanProcessors = []), (this._tracers = new Map())
        var n = PF({}, iR(), Poe(e))
        ;(this.resource = (r = n.resource) !== null && r !== void 0 ? r : ts.empty()),
          (this.resource = ts.default().merge(this.resource)),
          (this._config = Object.assign({}, n, { resource: this.resource }))
        var i = this._buildExporterFromEnv()
        if (i !== void 0) {
          var o = new qF(i)
          this.activeSpanProcessor = o
        } else this.activeSpanProcessor = new QF()
      }
      return (
        (t.prototype.getTracer = function (e, r, n) {
          var i = e + '@' + (r || '') + ':' + (n?.schemaUrl || '')
          return (
            this._tracers.has(i) ||
              this._tracers.set(i, new jF({ name: e, version: r, schemaUrl: n?.schemaUrl }, this._config, this)),
            this._tracers.get(i)
          )
        }),
        (t.prototype.addSpanProcessor = function (e) {
          this._registeredSpanProcessors.length === 0 &&
            this.activeSpanProcessor.shutdown().catch(function (r) {
              return at.error('Error while trying to shutdown current span processor', r)
            }),
            this._registeredSpanProcessors.push(e),
            (this.activeSpanProcessor = new Ise(this._registeredSpanProcessors))
        }),
        (t.prototype.getActiveSpanProcessor = function () {
          return this.activeSpanProcessor
        }),
        (t.prototype.register = function (e) {
          e === void 0 && (e = {}),
            xi.setGlobalTracerProvider(this),
            e.propagator === void 0 && (e.propagator = this._buildPropagatorFromEnv()),
            e.contextManager && Zo.setGlobalContextManager(e.contextManager),
            e.propagator && Ip.setGlobalPropagator(e.propagator)
        }),
        (t.prototype.forceFlush = function () {
          var e = this._config.forceFlushTimeoutMillis,
            r = this._registeredSpanProcessors.map(function (n) {
              return new Promise(function (i) {
                var o,
                  s = setTimeout(function () {
                    i(new Error('Span processor did not completed within timeout period of ' + e + ' ms')),
                      (o = Uf.timeout)
                  }, e)
                n.forceFlush()
                  .then(function () {
                    clearTimeout(s), o !== Uf.timeout && ((o = Uf.resolved), i(o))
                  })
                  .catch(function (a) {
                    clearTimeout(s), (o = Uf.error), i(a)
                  })
              })
            })
          return new Promise(function (n, i) {
            Promise.all(r)
              .then(function (o) {
                var s = o.filter(function (a) {
                  return a !== Uf.resolved
                })
                s.length > 0 ? i(s) : n()
              })
              .catch(function (o) {
                return i([o])
              })
          })
        }),
        (t.prototype.shutdown = function () {
          return this.activeSpanProcessor.shutdown()
        }),
        (t.prototype._getPropagator = function (e) {
          var r
          return (r = this.constructor._registeredPropagators.get(e)) === null || r === void 0 ? void 0 : r()
        }),
        (t.prototype._getSpanExporter = function (e) {
          var r
          return (r = this.constructor._registeredExporters.get(e)) === null || r === void 0 ? void 0 : r()
        }),
        (t.prototype._buildPropagatorFromEnv = function () {
          var e = this,
            r = Array.from(new Set(bi().OTEL_PROPAGATORS)),
            n = r.map(function (o) {
              var s = e._getPropagator(o)
              return s || at.warn('Propagator "' + o + '" requested through environment variable is unavailable.'), s
            }),
            i = n.reduce(function (o, s) {
              return s && o.push(s), o
            }, [])
          if (i.length !== 0) return r.length === 1 ? i[0] : new xF({ propagators: i })
        }),
        (t.prototype._buildExporterFromEnv = function () {
          var e = bi().OTEL_TRACES_EXPORTER
          if (!(e === 'none' || e === '')) {
            var r = this._getSpanExporter(e)
            return r || at.error('Exporter "' + e + '" requested through environment variable is unavailable.'), r
          }
        }),
        (t._registeredPropagators = new Map([
          [
            'tracecontext',
            function () {
              return new SF()
            },
          ],
          [
            'baggage',
            function () {
              return new aF()
            },
          ],
        ])),
        (t._registeredExporters = new Map()),
        t
      )
    })()
  })
var RMe,
  DMe,
  Rse = createGetter(() => {
    es()
    ;(RMe = function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        r = e && t[e],
        n = 0
      if (r) return r.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          },
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    }),
      (DMe = (function () {
        function t() {}
        return (
          (t.prototype.export = function (e, r) {
            return this._sendSpans(e, r)
          }),
          (t.prototype.shutdown = function () {
            return this._sendSpans([]), this.forceFlush()
          }),
          (t.prototype.forceFlush = function () {
            return Promise.resolve()
          }),
          (t.prototype._exportInfo = function (e) {
            var r
            return {
              traceId: e.spanContext().traceId,
              parentId: e.parentSpanId,
              traceState: (r = e.spanContext().traceState) === null || r === void 0 ? void 0 : r.serialize(),
              name: e.name,
              id: e.spanContext().spanId,
              kind: e.kind,
              timestamp: W2(e.startTime),
              duration: W2(e.duration),
              attributes: e.attributes,
              status: e.status,
              events: e.events,
              links: e.links,
            }
          }),
          (t.prototype._sendSpans = function (e, r) {
            var n, i
            try {
              for (var o = RMe(e), s = o.next(); !s.done; s = o.next()) {
                var a = s.value
                console.dir(this._exportInfo(a), { depth: 3 })
              }
            } catch (l) {
              n = { error: l }
            } finally {
              try {
                s && !s.done && (i = o.return) && i.call(o)
              } finally {
                if (n) throw n.error
              }
            }
            if (r) return r({ code: Wa.SUCCESS })
          }),
          t
        )
      })())
  })
var PMe,
  NMe,
  kMe,
  Dse = createGetter(() => {
    es()
    ;(PMe = function (t, e) {
      var r = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!r) return t
      var n = r.call(t),
        i,
        o = [],
        s
      try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) o.push(i.value)
      } catch (a) {
        s = { error: a }
      } finally {
        try {
          i && !i.done && (r = n.return) && r.call(n)
        } finally {
          if (s) throw s.error
        }
      }
      return o
    }),
      (NMe = function (t, e, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = e.length, o; n < i; n++)
            (o || !(n in e)) && (o || (o = Array.prototype.slice.call(e, 0, n)), (o[n] = e[n]))
        return t.concat(o || Array.prototype.slice.call(e))
      }),
      (kMe = (function () {
        function t() {
          ;(this._finishedSpans = []), (this._stopped = !1)
        }
        return (
          (t.prototype.export = function (e, r) {
            var n
            if (this._stopped) return r({ code: Wa.FAILED, error: new Error('Exporter has been stopped') })
            ;(n = this._finishedSpans).push.apply(n, NMe([], PMe(e), !1)),
              setTimeout(function () {
                return r({ code: Wa.SUCCESS })
              }, 0)
          }),
          (t.prototype.shutdown = function () {
            return (this._stopped = !0), (this._finishedSpans = []), this.forceFlush()
          }),
          (t.prototype.forceFlush = function () {
            return Promise.resolve()
          }),
          (t.prototype.reset = function () {
            this._finishedSpans = []
          }),
          (t.prototype.getFinishedSpans = function () {
            return this._finishedSpans
          }),
          t
        )
      })())
  })
var Pse = createGetter(() => {})
var OMe,
  LMe,
  MMe,
  Nse = createGetter(() => {
    Yt()
    es()
    ;(OMe = function (t, e, r, n) {
      function i(o) {
        return o instanceof r
          ? o
          : new r(function (s) {
              s(o)
            })
      }
      return new (r || (r = Promise))(function (o, s) {
        function a(u) {
          try {
            c(n.next(u))
          } catch (p) {
            s(p)
          }
        }
        function l(u) {
          try {
            c(n.throw(u))
          } catch (p) {
            s(p)
          }
        }
        function c(u) {
          u.done ? o(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
      })
    }),
      (LMe = function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }),
      (MMe = (function () {
        function t(e) {
          ;(this._exporter = e),
            (this._shutdownOnce = new RE(this._shutdown, this)),
            (this._unresolvedExports = new Set())
        }
        return (
          (t.prototype.forceFlush = function () {
            return OMe(this, void 0, void 0, function () {
              return LMe(this, function (e) {
                switch (e.label) {
                  case 0:
                    return [4, Promise.all(Array.from(this._unresolvedExports))]
                  case 1:
                    return e.sent(), this._exporter.forceFlush ? [4, this._exporter.forceFlush()] : [3, 3]
                  case 2:
                    e.sent(), (e.label = 3)
                  case 3:
                    return [2]
                }
              })
            })
          }),
          (t.prototype.onStart = function (e, r) {}),
          (t.prototype.onEnd = function (e) {
            var r = this,
              n,
              i
            if (!this._shutdownOnce.isCalled && e.spanContext().traceFlags & Vn.SAMPLED) {
              var o = function () {
                return NF._export(r._exporter, [e])
                  .then(function (a) {
                    var l
                    a.code !== Wa.SUCCESS &&
                      Is(
                        (l = a.error) !== null && l !== void 0
                          ? l
                          : new Error('SimpleSpanProcessor: span export failed (status ' + a + ')')
                      )
                  })
                  .catch(function (a) {
                    Is(a)
                  })
              }
              if (e.resource.asyncAttributesPending) {
                var s =
                  (i = (n = e.resource).waitForAsyncAttributes) === null || i === void 0
                    ? void 0
                    : i.call(n).then(
                        function () {
                          return s != null && r._unresolvedExports.delete(s), o()
                        },
                        function (a) {
                          return Is(a)
                        }
                      )
                s != null && this._unresolvedExports.add(s)
              } else o()
            }
          }),
          (t.prototype.shutdown = function () {
            return this._shutdownOnce.call()
          }),
          (t.prototype._shutdown = function () {
            return this._exporter.shutdown()
          }),
          t
        )
      })())
  })
var kse = createGetter(() => {})
var Ose = createGetter(() => {})
var Lse = createGetter(() => {})
var Mse = createGetter(() => {})
var Fse = createGetter(() => {})
var Use = {}
defineProperties(Use, {
  AlwaysOffSampler: () => Og,
  AlwaysOnSampler: () => Rp,
  BasicTracerProvider: () => AMe,
  BatchSpanProcessor: () => qF,
  ConsoleSpanExporter: () => DMe,
  ForceFlushState: () => Uf,
  InMemorySpanExporter: () => kMe,
  NoopSpanProcessor: () => QF,
  ParentBasedSampler: () => PE,
  RandomIdGenerator: () => HF,
  SamplingDecision: () => Ql,
  SimpleSpanProcessor: () => MMe,
  Span: () => kF,
  TraceIdRatioBasedSampler: () => nR,
  Tracer: () => jF,
})
var JF = createGetter(() => {
  Boe()
  Ase()
  sR()
  Rse()
  Dse()
  Pse()
  Nse()
  kse()
  XF()
  tR()
  rR()
  LF()
  MF()
  DE()
  OF()
  Ose()
  Lse()
  Mse()
  Fse()
})
var qse = handleExports(Ka => {
  'use strict'
  Object.defineProperty(Ka, '__esModule', { value: !0 })
  Ka.enable = Ka.azureCoreTracing = Ka.AzureMonitorSymbol = void 0
  var ZF = On()
  Ka.AzureMonitorSymbol = 'Azure_Monitor_Tracer'
  var e9 = 'azure-coretracing',
    Bse = !1,
    FMe = function (t) {
      if (Bse) return t
      try {
        var e = (JF(), handleEsModuleExports(Use)),
          r = (Yt(), handleEsModuleExports(q_)),
          n = new e.BasicTracerProvider(),
          i = n.getTracer('applicationinsights tracer')
        if (t.setTracer) {
          var o = t.setTracer
          ;(t.setTracer = function (c) {
            var u = c.startSpan
            ;(c.startSpan = function (p, d, f) {
              var m = u.call(this, p, d, f),
                h = m.end
              return (
                (m.end = function () {
                  var g = h.apply(this, arguments)
                  return ZF.channel.publish(e9, m), g
                }),
                m
              )
            }),
              (c[Ka.AzureMonitorSymbol] = !0),
              o.call(this, c)
          }),
            r.trace.getSpan(r.context.active()),
            t.setTracer(i)
        } else {
          var s = r.trace.setGlobalTracerProvider
          ;(r.trace.setGlobalTracerProvider = function (c) {
            var u = c.getTracer
            return (
              (c.getTracer = function (p, d) {
                var f = u.call(this, p, d)
                if (!f[Ka.AzureMonitorSymbol]) {
                  var m = f.startSpan
                  ;(f.startSpan = function (h, g, v) {
                    var _ = m.call(this, h, g, v),
                      y = _.end
                    return (
                      (_.end = function () {
                        var b = y.apply(this, arguments)
                        return ZF.channel.publish(e9, _), b
                      }),
                      _
                    )
                  }),
                    (f[Ka.AzureMonitorSymbol] = !0)
                }
                return f
              }),
              s.call(this, c)
            )
          }),
            n.register(),
            r.trace.getSpan(r.context.active())
          var a = require('@opentelemetry/instrumentation'),
            l = require('@azure/opentelemetry-instrumentation-azure-sdk')
          a.registerInstrumentations({ instrumentations: [l.createAzureSdkInstrumentation()] })
        }
        Bse = !0
      } catch {}
      return t
    }
  Ka.azureCoreTracing = { versionSpecifier: '>= 1.0.0 < 2.0.0', patch: FMe, publisherName: e9 }
  function UMe() {
    ZF.channel.registerMonkeyPatch('@azure/core-tracing', Ka.azureCoreTracing)
  }
  Ka.enable = UMe
})
var jse = handleExports(Mg => {
  'use strict'
  Object.defineProperty(Mg, '__esModule', { value: !0 })
  Mg.enable = Mg.bunyan = void 0
  var Hse = On(),
    BMe = function (t) {
      var e = t.prototype._emit
      return (
        (t.prototype._emit = function (r, n) {
          var i = e.apply(this, arguments)
          if (!n) {
            var o = i
            o || (o = e.call(this, r, !0)), Hse.channel.publish('bunyan', { level: r.level, result: o })
          }
          return i
        }),
        t
      )
    }
  Mg.bunyan = { versionSpecifier: '>= 1.0.0 < 2.0.0', patch: BMe }
  function qMe() {
    Hse.channel.registerMonkeyPatch('bunyan', Mg.bunyan)
  }
  Mg.enable = qMe
})
var Vse = handleExports(Fg => {
  'use strict'
  Object.defineProperty(Fg, '__esModule', { value: !0 })
  Fg.enable = Fg.console = void 0
  var t9 = On(),
    Gse = require('stream'),
    HMe = function (t) {
      var e = new Gse.Writable(),
        r = new Gse.Writable()
      ;(e.write = function (c) {
        if (!c) return !0
        var u = c.toString()
        return t9.channel.publish('console', { message: u }), !0
      }),
        (r.write = function (c) {
          if (!c) return !0
          var u = c.toString()
          return t9.channel.publish('console', { message: u, stderr: !0 }), !0
        })
      for (
        var n = new t.Console(e, r),
          i = ['log', 'info', 'warn', 'error', 'dir', 'time', 'timeEnd', 'trace', 'assert'],
          o = function (c) {
            var u = t[c]
            u &&
              (t[c] = function () {
                if (n[c])
                  try {
                    n[c].apply(n, arguments)
                  } catch {}
                return u.apply(t, arguments)
              })
          },
          s = 0,
          a = i;
        s < a.length;
        s++
      ) {
        var l = a[s]
        o(l)
      }
      return t
    }
  Fg.console = { versionSpecifier: '>= 4.0.0', patch: HMe }
  function jMe() {
    t9.channel.registerMonkeyPatch('console', Fg.console), require('console')
  }
  Fg.enable = jMe
})
var zse = handleExports(Ug => {
  'use strict'
  Object.defineProperty(Ug, '__esModule', { value: !0 })
  Ug.enable = Ug.mongoCore = void 0
  var r9 = On(),
    GMe = function (t) {
      var e = t.Server.prototype.connect
      return (
        (t.Server.prototype.connect = function () {
          var n = e.apply(this, arguments),
            i = this.s.pool.write
          this.s.pool.write = function () {
            var a = typeof arguments[1] == 'function' ? 1 : 2
            return (
              typeof arguments[a] == 'function' && (arguments[a] = r9.channel.bindToContext(arguments[a])),
              i.apply(this, arguments)
            )
          }
          var o = this.s.pool.logout
          return (
            (this.s.pool.logout = function () {
              return (
                typeof arguments[1] == 'function' && (arguments[1] = r9.channel.bindToContext(arguments[1])),
                o.apply(this, arguments)
              )
            }),
            n
          )
        }),
        t
      )
    }
  Ug.mongoCore = { versionSpecifier: '>= 2.0.0 < 4.0.0', patch: GMe }
  function VMe() {
    r9.channel.registerMonkeyPatch('mongodb-core', Ug.mongoCore)
  }
  Ug.enable = VMe
})
var $se = handleExports(rs => {
  'use strict'
  var K_ =
    (rs && rs.__assign) ||
    function () {
      return (
        (K_ =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        K_.apply(this, arguments)
      )
    }
  Object.defineProperty(rs, '__esModule', { value: !0 })
  rs.enable = rs.mongo330 = rs.mongo3 = rs.mongo2 = void 0
  var wo = On(),
    zMe = function (t) {
      var e = t.instrument({
          operationIdGenerator: {
            next: function () {
              return wo.channel.bindToContext(function (n) {
                return n()
              })
            },
          },
        }),
        r = {}
      return (
        e.on('started', function (n) {
          r[n.requestId] || (r[n.requestId] = K_(K_({}, n), { time: new Date() }))
        }),
        e.on('succeeded', function (n) {
          var i = r[n.requestId]
          i && delete r[n.requestId],
            typeof n.operationId == 'function'
              ? n.operationId(function () {
                  return wo.channel.publish('mongodb', { startedData: i, event: n, succeeded: !0 })
                })
              : wo.channel.publish('mongodb', { startedData: i, event: n, succeeded: !0 })
        }),
        e.on('failed', function (n) {
          var i = r[n.requestId]
          i && delete r[n.requestId],
            typeof n.operationId == 'function'
              ? n.operationId(function () {
                  return wo.channel.publish('mongodb', { startedData: i, event: n, succeeded: !1 })
                })
              : wo.channel.publish('mongodb', { startedData: i, event: n, succeeded: !1 })
        }),
        t
      )
    },
    $Me = function (t) {
      var e = t.instrument(),
        r = {},
        n = {}
      return (
        e.on('started', function (i) {
          r[i.requestId] ||
            ((n[i.requestId] = wo.channel.bindToContext(function (o) {
              return o()
            })),
            (r[i.requestId] = K_(K_({}, i), { time: new Date() })))
        }),
        e.on('succeeded', function (i) {
          var o = r[i.requestId]
          o && delete r[i.requestId],
            typeof i == 'object' &&
              typeof n[i.requestId] == 'function' &&
              (n[i.requestId](function () {
                return wo.channel.publish('mongodb', { startedData: o, event: i, succeeded: !0 })
              }),
              delete n[i.requestId])
        }),
        e.on('failed', function (i) {
          var o = r[i.requestId]
          o && delete r[i.requestId],
            typeof i == 'object' &&
              typeof n[i.requestId] == 'function' &&
              (n[i.requestId](function () {
                return wo.channel.publish('mongodb', { startedData: o, event: i, succeeded: !1 })
              }),
              delete n[i.requestId])
        }),
        t
      )
    },
    WMe = function (t) {
      var e = t.Server.prototype.connect
      return (
        (t.Server.prototype.connect = function () {
          var n = e.apply(this, arguments),
            i = this.s.coreTopology.s.pool.write
          this.s.coreTopology.s.pool.write = function () {
            var a = typeof arguments[1] == 'function' ? 1 : 2
            return (
              typeof arguments[a] == 'function' && (arguments[a] = wo.channel.bindToContext(arguments[a])),
              i.apply(this, arguments)
            )
          }
          var o = this.s.coreTopology.s.pool.logout
          return (
            (this.s.coreTopology.s.pool.logout = function () {
              return (
                typeof arguments[1] == 'function' && (arguments[1] = wo.channel.bindToContext(arguments[1])),
                o.apply(this, arguments)
              )
            }),
            n
          )
        }),
        t
      )
    },
    KMe = function (t) {
      WMe(t)
      var e = t.instrument(),
        r = {},
        n = {}
      return (
        e.on('started', function (i) {
          r[i.requestId] ||
            ((n[i.requestId] = wo.channel.bindToContext(function (o) {
              return o()
            })),
            (r[i.requestId] = i))
        }),
        e.on('succeeded', function (i) {
          var o = r[i.requestId]
          o && delete r[i.requestId],
            typeof i == 'object' &&
              typeof n[i.requestId] == 'function' &&
              (n[i.requestId](function () {
                return wo.channel.publish('mongodb', { startedData: o, event: i, succeeded: !0 })
              }),
              delete n[i.requestId])
        }),
        e.on('failed', function (i) {
          var o = r[i.requestId]
          o && delete r[i.requestId],
            typeof i == 'object' &&
              typeof n[i.requestId] == 'function' &&
              (n[i.requestId](function () {
                return wo.channel.publish('mongodb', { startedData: o, event: i, succeeded: !1 })
              }),
              delete n[i.requestId])
        }),
        t
      )
    }
  rs.mongo2 = { versionSpecifier: '>= 2.0.0 <= 3.0.5', patch: zMe }
  rs.mongo3 = { versionSpecifier: '> 3.0.5 < 3.3.0', patch: $Me }
  rs.mongo330 = { versionSpecifier: '>= 3.3.0 < 4.0.0', patch: KMe }
  function YMe() {
    wo.channel.registerMonkeyPatch('mongodb', rs.mongo2),
      wo.channel.registerMonkeyPatch('mongodb', rs.mongo3),
      wo.channel.registerMonkeyPatch('mongodb', rs.mongo330)
  }
  rs.enable = YMe
})
var Kse = handleExports(Bg => {
  'use strict'
  Object.defineProperty(Bg, '__esModule', { value: !0 })
  Bg.enable = Bg.mysql = void 0
  var fR = On(),
    Wse = require('path'),
    QMe = function (t, e) {
      var r = function (l, c) {
          return function (u, p) {
            var d = l[u]
            d &&
              (l[u] = function () {
                for (var m = arguments.length - 1, h = arguments.length - 1; h >= 0; --h)
                  if (typeof arguments[h] == 'function') {
                    m = h
                    break
                  } else if (typeof arguments[h] < 'u') break
                var g = arguments[m],
                  v = { result: null, startTime: null, startDate: null }
                typeof g == 'function' &&
                  (p
                    ? ((v.startTime = process.hrtime()),
                      (v.startDate = new Date()),
                      (arguments[m] = fR.channel.bindToContext(p(v, g))))
                    : (arguments[m] = fR.channel.bindToContext(g)))
                var _ = d.apply(this, arguments)
                return (v.result = _), _
              })
          }
        },
        n = function (l, c) {
          return r(l.prototype, c + '.prototype')
        },
        i = ['connect', 'changeUser', 'ping', 'statistics', 'end'],
        o = require(Wse.dirname(e) + '/lib/Connection')
      i.forEach(function (l) {
        return n(o, 'Connection')(l)
      }),
        r(o, 'Connection')('createQuery', function (l, c) {
          return function (u) {
            var p = process.hrtime(l.startTime),
              d = (p[0] * 1e3 + p[1] / 1e6) | 0
            fR.channel.publish('mysql', {
              query: l.result,
              callbackArgs: arguments,
              err: u,
              duration: d,
              time: l.startDate,
            }),
              c.apply(this, arguments)
          }
        })
      var s = ['_enqueueCallback'],
        a = require(Wse.dirname(e) + '/lib/Pool')
      return (
        s.forEach(function (l) {
          return n(a, 'Pool')(l)
        }),
        t
      )
    }
  Bg.mysql = { versionSpecifier: '>= 2.0.0 < 3.0.0', patch: QMe }
  function XMe() {
    fR.channel.registerMonkeyPatch('mysql', Bg.mysql)
  }
  Bg.enable = XMe
})
var Qse = handleExports(qg => {
  'use strict'
  Object.defineProperty(qg, '__esModule', { value: !0 })
  qg.enable = qg.postgresPool1 = void 0
  var Yse = On()
  function JMe(t) {
    var e = t.prototype.connect
    return (
      (t.prototype.connect = function (n) {
        return n && (arguments[0] = Yse.channel.bindToContext(n)), e.apply(this, arguments)
      }),
      t
    )
  }
  qg.postgresPool1 = { versionSpecifier: '>= 1.0.0 < 3.0.0', patch: JMe }
  function ZMe() {
    Yse.channel.registerMonkeyPatch('pg-pool', qg.postgresPool1)
  }
  qg.enable = ZMe
})
var Jse = handleExports(Xl => {
  'use strict'
  Object.defineProperty(Xl, '__esModule', { value: !0 })
  Xl.enable = Xl.postgres = Xl.postgres6 = void 0
  var Y_ = On(),
    Xse = require('events'),
    n9 = 'postgres'
  function e6e(t, e) {
    var r = t.Client.prototype.query,
      n = '__diagnosticOriginalFunc'
    return (
      (t.Client.prototype.query = function (o, s, a) {
        var l = {
            query: {},
            database: { host: this.connectionParameters.host, port: this.connectionParameters.port },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
          },
          c = process.hrtime(),
          u
        function p(d) {
          d && d[n] && (d = d[n])
          var f = Y_.channel.bindToContext(function (m, h) {
            var g = process.hrtime(c)
            if (
              ((l.result = h && { rowCount: h.rowCount, command: h.command }),
              (l.error = m),
              (l.duration = Math.ceil(g[0] * 1e3 + g[1] / 1e6)),
              Y_.channel.publish(n9, l),
              m)
            ) {
              if (d) return d.apply(this, arguments)
              u && u instanceof Xse.EventEmitter && u.emit('error', m)
            } else d && d.apply(this, arguments)
          })
          try {
            return Object.defineProperty(f, n, { value: d }), f
          } catch {
            return d
          }
        }
        try {
          typeof o == 'string'
            ? s instanceof Array
              ? ((l.query.preparable = { text: o, args: s }), (a = p(a)))
              : ((l.query.text = o), a ? (a = p(a)) : (s = p(s)))
            : (typeof o.name == 'string'
                ? (l.query.plan = o.name)
                : o.values instanceof Array
                ? (l.query.preparable = { text: o.text, args: o.values })
                : (l.query.text = o.text),
              a ? (a = p(a)) : s ? (s = p(s)) : (o.callback = p(o.callback)))
        } catch {
          return r.apply(this, arguments)
        }
        return (
          (arguments[0] = o),
          (arguments[1] = s),
          (arguments[2] = a),
          (arguments.length = arguments.length > 3 ? arguments.length : 3),
          (u = r.apply(this, arguments)),
          u
        )
      }),
      t
    )
  }
  function t6e(t, e) {
    var r = t.Client.prototype.query,
      n = '__diagnosticOriginalFunc'
    return (
      (t.Client.prototype.query = function (o, s, a) {
        var l = this,
          c,
          u,
          p = !!a,
          d = {
            query: {},
            database: { host: this.connectionParameters.host, port: this.connectionParameters.port },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
          },
          f,
          m = process.hrtime()
        function h(_) {
          _ && _[n] && (_ = _[n])
          var y = Y_.channel.bindToContext(function (b, x) {
            var P = process.hrtime(m)
            if (
              ((d.result = x && { rowCount: x.rowCount, command: x.command }),
              (d.error = b),
              (d.duration = Math.ceil(P[0] * 1e3 + P[1] / 1e6)),
              Y_.channel.publish(n9, d),
              b)
            ) {
              if (_) return _.apply(this, arguments)
              f && f instanceof Xse.EventEmitter && f.emit('error', b)
            } else _ && _.apply(this, arguments)
          })
          try {
            return Object.defineProperty(y, n, { value: _ }), y
          } catch {
            return _
          }
        }
        try {
          typeof o == 'string'
            ? s instanceof Array
              ? ((d.query.preparable = { text: o, args: s }), (p = typeof a == 'function'), (a = p ? h(a) : a))
              : ((d.query.text = o),
                a
                  ? ((p = typeof a == 'function'), (a = p ? h(a) : a))
                  : ((p = typeof s == 'function'), (s = p ? h(s) : s)))
            : (typeof o.name == 'string'
                ? (d.query.plan = o.name)
                : o.values instanceof Array
                ? (d.query.preparable = { text: o.text, args: o.values })
                : o.cursor
                ? (d.query.text = (c = o.cursor) === null || c === void 0 ? void 0 : c.text)
                : (d.query.text = o.text),
              a
                ? ((p = typeof a == 'function'), (a = h(a)))
                : s
                ? ((p = typeof s == 'function'), (s = p ? h(s) : s))
                : ((p = typeof o.callback == 'function'), (o.callback = p ? h(o.callback) : o.callback)))
        } catch {
          return r.apply(this, arguments)
        }
        ;(arguments[0] = o),
          (arguments[1] = s),
          (arguments[2] = a),
          (arguments.length = arguments.length > 3 ? arguments.length : 3)
        try {
          f = r.apply(this, arguments)
        } catch (_) {
          throw (h()(_, void 0), _)
        }
        if (!p) {
          if (f instanceof Promise)
            return f
              .then(function (_) {
                return (
                  h()(void 0, _),
                  new l._Promise(function (y, b) {
                    y(_)
                  })
                )
              })
              .catch(function (_) {
                return (
                  h()(_, void 0),
                  new l._Promise(function (y, b) {
                    b(_)
                  })
                )
              })
          var g = f.text ? f.text : ''
          if ((f.cursor && (g = (u = f.cursor) === null || u === void 0 ? void 0 : u.text), g)) {
            var v = { command: g, rowCount: 0 }
            h()(void 0, v)
          }
        }
        return f
      }),
      t
    )
  }
  Xl.postgres6 = { versionSpecifier: '6.*', patch: e6e }
  Xl.postgres = { versionSpecifier: '>=7.* <=8.*', patch: t6e, publisherName: n9 }
  function r6e() {
    Y_.channel.registerMonkeyPatch('pg', Xl.postgres6), Y_.channel.registerMonkeyPatch('pg', Xl.postgres)
  }
  Xl.enable = r6e
})
var Zse = handleExports(Hg => {
  'use strict'
  Object.defineProperty(Hg, '__esModule', { value: !0 })
  Hg.enable = Hg.redis = void 0
  var i9 = On(),
    n6e = function (t) {
      var e = t.RedisClient.prototype.internal_send_command
      return (
        (t.RedisClient.prototype.internal_send_command = function (r) {
          if (r) {
            var n = r.callback
            if (!n || !n.pubsubBound) {
              var i = this.address,
                o = process.hrtime(),
                s = new Date()
              ;(r.callback = i9.channel.bindToContext(function (a, l) {
                var c = process.hrtime(o),
                  u = (c[0] * 1e3 + c[1] / 1e6) | 0
                i9.channel.publish('redis', { duration: u, address: i, commandObj: r, err: a, result: l, time: s }),
                  typeof n == 'function' && n.apply(this, arguments)
              })),
                (r.callback.pubsubBound = !0)
            }
          }
          return e.call(this, r)
        }),
        t
      )
    }
  Hg.redis = { versionSpecifier: '>= 2.0.0 < 4.0.0', patch: n6e }
  function i6e() {
    i9.channel.registerMonkeyPatch('redis', Hg.redis)
  }
  Hg.enable = i6e
})
var eae = handleExports(Dp => {
  'use strict'
  var mR =
    (Dp && Dp.__assign) ||
    function () {
      return (
        (mR =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        mR.apply(this, arguments)
      )
    }
  Object.defineProperty(Dp, '__esModule', { value: !0 })
  Dp.enable = Dp.tedious = void 0
  var o9 = On(),
    o6e = function (t) {
      var e = t.Connection.prototype.makeRequest
      return (
        (t.Connection.prototype.makeRequest = function () {
          function n(o) {
            var s = process.hrtime(),
              a = { query: {}, database: { host: null, port: null }, result: null, error: null, duration: 0 }
            return o9.channel.bindToContext(function (l, c, u) {
              var p = process.hrtime(s)
              ;(a = mR(mR({}, a), {
                database: { host: this.connection.config.server, port: this.connection.config.options.port },
                result: !l && { rowCount: c, rows: u },
                query: { text: this.parametersByName.statement.value },
                error: l,
                duration: Math.ceil(p[0] * 1e3 + p[1] / 1e6),
              })),
                o9.channel.publish('tedious', a),
                o.call(this, l, c, u)
            })
          }
          var i = arguments[0]
          ;(arguments[0].callback = n(i.callback)), e.apply(this, arguments)
        }),
        t
      )
    }
  Dp.tedious = { versionSpecifier: '>= 6.0.0 < 9.0.0', patch: o6e }
  function s6e() {
    o9.channel.registerMonkeyPatch('tedious', Dp.tedious)
  }
  Dp.enable = s6e
})
var tae = handleExports(ws => {
  'use strict'
  var a6e =
      (ws && ws.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    c6e =
      (ws && ws.__rest) ||
      function (t, e) {
        var r = {}
        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n])
        if (t != null && typeof Object.getOwnPropertySymbols == 'function')
          for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
            e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]])
        return r
      }
  Object.defineProperty(ws, '__esModule', { value: !0 })
  ws.enable = ws.winston2 = ws.winston3 = void 0
  var hR = On(),
    l6e = function (t) {
      var e = t.Logger.prototype.log,
        r,
        n = function (i, o, s) {
          var a
          return (
            r === t.config.npm.levels ? (a = 'npm') : r === t.config.syslog.levels ? (a = 'syslog') : (a = 'unknown'),
            hR.channel.publish('winston', { level: i, message: o, meta: s, levelKind: a }),
            o
          )
        }
      return (
        (t.Logger.prototype.log = function () {
          return (
            (r = this.levels),
            !this.filters || this.filters.length === 0
              ? (this.filters = [n])
              : this.filters[this.filters.length - 1] !== n &&
                ((this.filters = this.filters.filter(function (o) {
                  return o !== n
                })),
                this.filters.push(n)),
            e.apply(this, arguments)
          )
        }),
        t
      )
    },
    u6e = function (t) {
      var e = function (s, a) {
          var l
          return (
            s.config.npm.levels[a] != null
              ? (l = 'npm')
              : s.config.syslog.levels[a] != null
              ? (l = 'syslog')
              : (l = 'unknown'),
            l
          )
        },
        r = (function (s) {
          a6e(a, s)
          function a(l, c) {
            var u = s.call(this, c) || this
            return (u.winston = l), u
          }
          return (
            (a.prototype.log = function (l, c) {
              var u = l.message,
                p = l.level,
                d = l.meta,
                f = c6e(l, ['message', 'level', 'meta'])
              ;(p = typeof Symbol.for == 'function' ? l[Symbol.for('level')] : p), (u = l instanceof Error ? l : u)
              var m = e(this.winston, p)
              d = d || {}
              for (var h in f) f.hasOwnProperty(h) && (d[h] = f[h])
              hR.channel.publish('winston', { message: u, level: p, levelKind: m, meta: d }), c()
            }),
            a
          )
        })(t.Transport)
      function n() {
        var s = t.config.npm.levels
        arguments && arguments[0] && arguments[0].levels && (s = arguments[0].levels)
        var a
        for (var l in s) s.hasOwnProperty(l) && (a = a === void 0 || s[l] > s[a] ? l : a)
        this.add(new r(t, { level: a }))
      }
      var i = t.createLogger
      t.createLogger = function () {
        var a = t.config.npm.levels
        arguments && arguments[0] && arguments[0].levels && (a = arguments[0].levels)
        var l
        for (var c in a) a.hasOwnProperty(c) && (l = l === void 0 || a[c] > a[l] ? c : l)
        var u = i.apply(this, arguments)
        u.add(new r(t, { level: l }))
        var p = u.configure
        return (
          (u.configure = function () {
            p.apply(this, arguments), n.apply(this, arguments)
          }),
          u
        )
      }
      var o = t.configure
      return (
        (t.configure = function () {
          o.apply(this, arguments), n.apply(this, arguments)
        }),
        t.add(new r(t)),
        t
      )
    }
  ws.winston3 = { versionSpecifier: '3.x', patch: u6e }
  ws.winston2 = { versionSpecifier: '2.x', patch: l6e }
  function p6e() {
    hR.channel.registerMonkeyPatch('winston', ws.winston2), hR.channel.registerMonkeyPatch('winston', ws.winston3)
  }
  ws.enable = p6e
})
var fae = handleExports(Vr => {
  'use strict'
  Object.defineProperty(Vr, '__esModule', { value: !0 })
  Vr.enable =
    Vr.tedious =
    Vr.pgPool =
    Vr.pg =
    Vr.winston =
    Vr.redis =
    Vr.mysql =
    Vr.mongodb =
    Vr.mongodbCore =
    Vr.console =
    Vr.bunyan =
    Vr.azuresdk =
      void 0
  var rae = qse()
  Vr.azuresdk = rae
  var nae = jse()
  Vr.bunyan = nae
  var iae = Vse()
  Vr.console = iae
  var oae = zse()
  Vr.mongodbCore = oae
  var sae = $se()
  Vr.mongodb = sae
  var aae = Kse()
  Vr.mysql = aae
  var cae = Qse()
  Vr.pgPool = cae
  var lae = Jse()
  Vr.pg = lae
  var uae = Zse()
  Vr.redis = uae
  var pae = eae()
  Vr.tedious = pae
  var dae = tae()
  Vr.winston = dae
  function d6e() {
    nae.enable(),
      iae.enable(),
      oae.enable(),
      sae.enable(),
      aae.enable(),
      lae.enable(),
      cae.enable(),
      uae.enable(),
      dae.enable(),
      rae.enable(),
      pae.enable()
  }
  Vr.enable = d6e
})
var _R = handleExports(Bf => {
  'use strict'
  Object.defineProperty(Bf, '__esModule', { value: !0 })
  Bf.registerContextPreservation = Bf.IsInitialized = void 0
  var s9 = on(),
    hae = d2()
  Bf.IsInitialized = !hae.JsonConfig.getInstance().noDiagnosticChannel
  var a9 = 'DiagnosticChannel'
  if (Bf.IsInitialized) {
    ;(jc = fae()),
      (mae = hae.JsonConfig.getInstance().noPatchModules),
      (gR = mae.split(',')),
      (c9 = {
        bunyan: jc.bunyan,
        console: jc.console,
        mongodb: jc.mongodb,
        mongodbCore: jc.mongodbCore,
        mysql: jc.mysql,
        redis: jc.redis,
        pg: jc.pg,
        pgPool: jc.pgPool,
        winston: jc.winston,
        azuresdk: jc.azuresdk,
      })
    for (vR in c9) gR.indexOf(vR) === -1 && (c9[vR].enable(), s9.info(a9, 'Subscribed to ' + vR + ' events'))
    gR.length > 0 && s9.info(a9, 'Some modules will not be patched', gR)
  } else
    s9.info(
      a9,
      'Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set'
    )
  var jc, mae, gR, c9, vR
  function f6e(t) {
    if (Bf.IsInitialized) {
      var e = On()
      e.channel.addContextPreservation(t)
    }
  }
  Bf.registerContextPreservation = f6e
})
var Q_ = handleExports((tCt, gae) => {
  'use strict'
  gae.exports = {
    requestContextHeader: 'request-context',
    requestContextSourceKey: 'appId',
    requestContextTargetKey: 'appId',
    requestIdHeader: 'request-id',
    parentIdHeader: 'x-ms-request-id',
    rootIdHeader: 'x-ms-request-root-id',
    correlationContextHeader: 'correlation-context',
    traceparentHeader: 'traceparent',
    traceStateHeader: 'tracestate',
  }
})
var oo = handleExports((p9, vae) => {
  'use strict'
  var Hf =
      (p9 && p9.__assign) ||
      function () {
        return (
          (Hf =
            Object.assign ||
            function (t) {
              for (var e, r = 1, n = arguments.length; r < n; r++) {
                e = arguments[r]
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
              }
              return t
            }),
          Hf.apply(this, arguments)
        )
      },
    m6e = require('http'),
    l9 = require('https'),
    u9 = require('url'),
    qf = require('constants'),
    jg = on(),
    X_ = Q_(),
    h6e = d2(),
    g6e = (function () {
      function t() {
        t._addCloseHandler()
      }
      return (
        (t.getCookie = function (e, r) {
          var n = ''
          if (e && e.length && typeof r == 'string')
            for (var i = e + '=', o = r.split(';'), s = 0; s < o.length; s++) {
              var r = o[s]
              if (((r = t.trim(r)), r && r.indexOf(i) === 0)) {
                n = r.substring(i.length, o[s].length)
                break
              }
            }
          return n
        }),
        (t.trim = function (e) {
          return typeof e == 'string' ? e.replace(/^\s+|\s+$/g, '') : ''
        }),
        (t.int32ArrayToBase64 = function (e) {
          var r = function (a, l) {
              return String.fromCharCode((a >> l) & 255)
            },
            n = function (a) {
              return r(a, 24) + r(a, 16) + r(a, 8) + r(a, 0)
            },
            i = e.map(n).join(''),
            o = Buffer.from ? Buffer.from(i, 'binary') : new Buffer(i, 'binary'),
            s = o.toString('base64')
          return s.substr(0, s.indexOf('='))
        }),
        (t.random32 = function () {
          return (4294967296 * Math.random()) | 0
        }),
        (t.randomu32 = function () {
          return t.random32() + 2147483648
        }),
        (t.w3cTraceId = function () {
          for (
            var e = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'], r = '', n, i = 0;
            i < 4;
            i++
          )
            (n = t.random32()),
              (r +=
                e[n & 15] +
                e[(n >> 4) & 15] +
                e[(n >> 8) & 15] +
                e[(n >> 12) & 15] +
                e[(n >> 16) & 15] +
                e[(n >> 20) & 15] +
                e[(n >> 24) & 15] +
                e[(n >> 28) & 15])
          var o = e[(8 + Math.random() * 4) | 0]
          return r.substr(0, 8) + r.substr(9, 4) + '4' + r.substr(13, 3) + o + r.substr(16, 3) + r.substr(19, 12)
        }),
        (t.w3cSpanId = function () {
          return t.w3cTraceId().substring(16)
        }),
        (t.isValidW3CId = function (e) {
          return e.length === 32 && e !== '00000000000000000000000000000000'
        }),
        (t.isArray = function (e) {
          return Object.prototype.toString.call(e) === '[object Array]'
        }),
        (t.isError = function (e) {
          return Object.prototype.toString.call(e) === '[object Error]'
        }),
        (t.isPrimitive = function (e) {
          var r = typeof e
          return r === 'string' || r === 'number' || r === 'boolean'
        }),
        (t.isDate = function (e) {
          return Object.prototype.toString.call(e) === '[object Date]'
        }),
        (t.msToTimeSpan = function (e) {
          ;(isNaN(e) || e < 0) && (e = 0)
          var r = ((e / 1e3) % 60).toFixed(7).replace(/0{0,4}$/, ''),
            n = '' + (Math.floor(e / (1e3 * 60)) % 60),
            i = '' + (Math.floor(e / (1e3 * 60 * 60)) % 24),
            o = Math.floor(e / (1e3 * 60 * 60 * 24))
          ;(r = r.indexOf('.') < 2 ? '0' + r : r), (n = n.length < 2 ? '0' + n : n), (i = i.length < 2 ? '0' + i : i)
          var s = o > 0 ? o + '.' : ''
          return s + i + ':' + n + ':' + r
        }),
        (t.extractError = function (e) {
          var r = e
          return { message: e.message, code: r.code || r.id || '' }
        }),
        (t.extractObject = function (e) {
          return e instanceof Error ? t.extractError(e) : typeof e.toJSON == 'function' ? e.toJSON() : e
        }),
        (t.validateStringMap = function (e) {
          if (typeof e != 'object') {
            jg.info('Invalid properties dropped from payload')
            return
          }
          var r = {}
          for (var n in e) {
            var i = '',
              o = e[n],
              s = typeof o
            if (t.isPrimitive(o)) i = o.toString()
            else if (o === null || s === 'undefined') i = ''
            else if (s === 'function') {
              jg.info('key: ' + n + ' was function; will not serialize')
              continue
            } else {
              var a = t.isArray(o) ? o : t.extractObject(o)
              try {
                t.isPrimitive(a) ? (i = a) : (i = JSON.stringify(a))
              } catch (l) {
                ;(i = o.constructor.name.toString() + ' (Error: ' + l.message + ')'),
                  jg.info('key: ' + n + ', could not be serialized')
              }
            }
            r[n] = i.substring(0, t.MAX_PROPERTY_LENGTH)
          }
          return r
        }),
        (t.canIncludeCorrelationHeader = function (e, r) {
          var n = e && e.config && e.config.correlationHeaderExcludedDomains
          if (!n || n.length == 0 || !r) return !0
          for (var i = 0; i < n.length; i++) {
            var o = new RegExp(n[i].replace(/\./g, '.').replace(/\*/g, '.*'))
            try {
              if (o.test(new u9.URL(r).hostname)) return !1
            } catch {}
          }
          return !0
        }),
        (t.getCorrelationContextTarget = function (e, r) {
          var n = e.headers && e.headers[X_.requestContextHeader]
          if (n)
            for (var i = n.split(','), o = 0; o < i.length; ++o) {
              var s = i[o].split('=')
              if (s.length == 2 && s[0] == r) return s[1]
            }
        }),
        (t.makeRequest = function (e, r, n, i, o, s) {
          o === void 0 && (o = !0), s === void 0 && (s = !0), r && r.indexOf('//') === 0 && (r = 'https:' + r)
          var a = new u9.URL(r),
            l = Hf(Hf({}, n), { host: a.hostname, port: a.port, path: a.pathname }),
            c = void 0
          if (
            o &&
            (a.protocol === 'https:' && (c = e.proxyHttpsUrl || void 0),
            a.protocol === 'http:' && (c = e.proxyHttpUrl || void 0),
            c)
          ) {
            c.indexOf('//') === 0 && (c = 'http:' + c)
            try {
              var u = new u9.URL(c)
              u.protocol === 'https:'
                ? (jg.info('Proxies that use HTTPS are not supported'), (c = void 0))
                : (l = Hf(Hf({}, l), {
                    host: u.hostname,
                    port: u.port || '80',
                    path: r,
                    headers: Hf(Hf({}, l.headers), { Host: a.hostname }),
                  }))
            } catch {
              jg.warn('Wrong proxy URL provided')
            }
          }
          var p = a.protocol === 'https:' && !c
          return (
            s &&
              (p && e.httpsAgent !== void 0
                ? (l.agent = e.httpsAgent)
                : !p && e.httpAgent !== void 0
                ? (l.agent = e.httpAgent)
                : p && (l.agent = t._useKeepAlive ? t.keepAliveAgent : t.tlsRestrictedAgent)),
            p ? l9.request(l, i) : m6e.request(l, i)
          )
        }),
        (t.safeIncludeCorrelationHeader = function (e, r, n) {
          var i
          if (typeof n == 'string') i = n
          else if (n instanceof Array) i = n.join(',')
          else if (n && typeof n.toString == 'function')
            try {
              i = n.toString()
            } catch (o) {
              jg.warn('Outgoing request-context header could not be read. Correlation of requests may be lost.', o, n)
            }
          i
            ? t.addCorrelationIdHeaderFromString(e, r, i)
            : r.setHeader(X_.requestContextHeader, X_.requestContextSourceKey + '=' + e.config.correlationId)
        }),
        (t.dumpObj = function (e) {
          if (e)
            try {
              var r = Object.prototype.toString.call(e),
                n = ''
              return (
                r === '[object Error]'
                  ? (n = "{ stack: '" + e.stack + "', message: '" + e.message + "', name: '" + e.name + "'")
                  : (n = this.stringify(e)),
                r + n
              )
            } catch {
              return e.toString()
            }
        }),
        (t.stringify = function (e) {
          try {
            return JSON.stringify(e)
          } catch (r) {
            jg.warn('Failed to serialize payload', r, e)
          }
        }),
        (t.addCorrelationIdHeaderFromString = function (e, r, n) {
          var i = n.split(','),
            o = X_.requestContextSourceKey + '=',
            s = i.some(function (a) {
              return a.substring(0, o.length) === o
            })
          s || r.setHeader(X_.requestContextHeader, n + ',' + X_.requestContextSourceKey + '=' + e.config.correlationId)
        }),
        (t._addCloseHandler = function () {
          t._listenerAttached ||
            (process.on('exit', function () {
              ;(t.isNodeExit = !0), (t._useKeepAlive = !1)
            }),
            (t._listenerAttached = !0))
        }),
        (t._useKeepAlive = !h6e.JsonConfig.getInstance().noHttpAgentKeepAlive),
        (t._listenerAttached = !1),
        (t.MAX_PROPERTY_LENGTH = 8192),
        (t.keepAliveAgent = new l9.Agent({
          keepAlive: !0,
          maxSockets: 25,
          secureOptions: qf.SSL_OP_NO_SSLv2 | qf.SSL_OP_NO_SSLv3 | qf.SSL_OP_NO_TLSv1 | qf.SSL_OP_NO_TLSv1_1,
        })),
        (t.tlsRestrictedAgent = new l9.Agent({
          secureOptions: qf.SSL_OP_NO_SSLv2 | qf.SSL_OP_NO_SSLv3 | qf.SSL_OP_NO_TLSv1 | qf.SSL_OP_NO_TLSv1_1,
        })),
        (t.isNodeExit = !1),
        t
      )
    })()
  vae.exports = g6e
})
var Gg = handleExports((rCt, _ae) => {
  'use strict'
  var d9 = oo(),
    v6e = (function () {
      function t() {}
      return (
        (t.queryCorrelationId = function (e, r) {}),
        (t.cancelCorrelationIdQuery = function (e, r) {}),
        (t.generateRequestId = function (e) {
          if (e) {
            ;(e = e[0] == '|' ? e : '|' + e), e[e.length - 1] !== '.' && (e += '.')
            var r = (t.currentRootId++).toString(16)
            return t.appendSuffix(e, r, '_')
          } else return t.generateRootId()
        }),
        (t.getRootId = function (e) {
          var r = e.indexOf('.')
          r < 0 && (r = e.length)
          var n = e[0] === '|' ? 1 : 0
          return e.substring(n, r)
        }),
        (t.generateRootId = function () {
          return '|' + d9.w3cTraceId() + '.'
        }),
        (t.appendSuffix = function (e, r, n) {
          if (e.length + r.length < t.requestIdMaxLength) return e + r + n
          var i = t.requestIdMaxLength - 9
          if (e.length > i)
            for (; i > 1; --i) {
              var o = e[i - 1]
              if (o === '.' || o === '_') break
            }
          if (i <= 1) return t.generateRootId()
          for (r = d9.randomu32().toString(16); r.length < 8; ) r = '0' + r
          return e.substring(0, i) + r + '#'
        }),
        (t.correlationIdPrefix = 'cid-v1:'),
        (t.w3cEnabled = !0),
        (t.HTTP_TIMEOUT = 2500),
        (t.requestIdMaxLength = 1024),
        (t.currentRootId = d9.randomu32()),
        t
      )
    })()
  _ae.exports = v6e
})
var yR = handleExports((nCt, yae) => {
  'use strict'
  var so = oo(),
    _6e = Gg(),
    y6e = (function () {
      function t(e, r) {
        if (((this.traceFlag = t.DEFAULT_TRACE_FLAG), (this.version = t.DEFAULT_VERSION), e && typeof e == 'string'))
          if (e.split(',').length > 1) (this.traceId = so.w3cTraceId()), (this.spanId = so.w3cTraceId().substr(0, 16))
          else {
            var n = e.trim().split('-'),
              i = n.length
            i >= 4
              ? ((this.version = n[0]), (this.traceId = n[1]), (this.spanId = n[2]), (this.traceFlag = n[3]))
              : ((this.traceId = so.w3cTraceId()), (this.spanId = so.w3cTraceId().substr(0, 16))),
              this.version.match(/^[0-9a-f]{2}$/g) ||
                ((this.version = t.DEFAULT_VERSION), (this.traceId = so.w3cTraceId())),
              this.version === '00' &&
                i !== 4 &&
                ((this.traceId = so.w3cTraceId()), (this.spanId = so.w3cTraceId().substr(0, 16))),
              this.version === 'ff' &&
                ((this.version = t.DEFAULT_VERSION),
                (this.traceId = so.w3cTraceId()),
                (this.spanId = so.w3cTraceId().substr(0, 16))),
              this.version.match(/^0[0-9a-f]$/g) || (this.version = t.DEFAULT_VERSION),
              this.traceFlag.match(/^[0-9a-f]{2}$/g) ||
                ((this.traceFlag = t.DEFAULT_TRACE_FLAG), (this.traceId = so.w3cTraceId())),
              t.isValidTraceId(this.traceId) || (this.traceId = so.w3cTraceId()),
              t.isValidSpanId(this.spanId) ||
                ((this.spanId = so.w3cTraceId().substr(0, 16)), (this.traceId = so.w3cTraceId())),
              (this.parentId = this.getBackCompatRequestId())
          }
        else if (r) {
          this.parentId = r.slice()
          var o = _6e.getRootId(r)
          t.isValidTraceId(o) || ((this.legacyRootId = o), (o = so.w3cTraceId())),
            r.indexOf('|') !== -1 && (r = r.substring(1 + r.substring(0, r.length - 1).lastIndexOf('.'), r.length - 1)),
            (this.traceId = o),
            (this.spanId = r)
        } else (this.traceId = so.w3cTraceId()), (this.spanId = so.w3cTraceId().substr(0, 16))
      }
      return (
        (t.isValidTraceId = function (e) {
          return e.match(/^[0-9a-f]{32}$/) && e !== '00000000000000000000000000000000'
        }),
        (t.isValidSpanId = function (e) {
          return e.match(/^[0-9a-f]{16}$/) && e !== '0000000000000000'
        }),
        (t.formatOpenTelemetryTraceFlags = function (e) {
          var r = '0' + e.toString(16)
          return r.substring(r.length - 2)
        }),
        (t.prototype.getBackCompatRequestId = function () {
          return '|' + this.traceId + '.' + this.spanId + '.'
        }),
        (t.prototype.toString = function () {
          return this.version + '-' + this.traceId + '-' + this.spanId + '-' + this.traceFlag
        }),
        (t.prototype.updateSpanId = function () {
          this.spanId = so.w3cTraceId().substr(0, 16)
        }),
        (t.DEFAULT_TRACE_FLAG = '01'),
        (t.DEFAULT_VERSION = '00'),
        t
      )
    })()
  yae.exports = y6e
})
var f9 = handleExports((iCt, xae) => {
  'use strict'
  var x6e = (function () {
    function t(e) {
      ;(this.fieldmap = []), e && (this.fieldmap = this.parseHeader(e))
    }
    return (
      (t.prototype.toString = function () {
        var e = this.fieldmap
        return !e || e.length == 0 ? null : e.join(', ')
      }),
      (t.validateKeyChars = function (e) {
        var r = e.split('@')
        if (r.length == 2) {
          var n = r[0].trim(),
            i = r[1].trim(),
            o = !!n.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/),
            s = !!i.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/)
          return o && s
        } else if (r.length == 1) return !!e.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/)
        return !1
      }),
      (t.prototype.parseHeader = function (e) {
        var r = [],
          n = {},
          i = e.split(',')
        if (i.length > 32) return null
        for (var o = 0, s = i; o < s.length; o++) {
          var a = s[o],
            l = a.trim()
          if (l.length !== 0) {
            var c = l.split('=')
            if (c.length !== 2 || !t.validateKeyChars(c[0]) || n[c[0]]) return null
            ;(n[c[0]] = !0), r.push(l)
          }
        }
        return r
      }),
      (t.strict = !0),
      t
    )
  })()
  xae.exports = x6e
})
var Pp = handleExports((oCt, bae) => {
  'use strict'
  var b6e = (function () {
    function t() {}
    return t
  })()
  bae.exports = b6e
})
var Tae = handleExports((m9, Eae) => {
  'use strict'
  var E6e =
      (m9 && m9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    T6e = Pp(),
    S6e = (function (t) {
      E6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(T6e)
  Eae.exports = S6e
})
var h9 = handleExports((sCt, Sae) => {
  'use strict'
  var C6e = (function () {
    function t() {}
    return t
  })()
  Sae.exports = C6e
})
var Iae = handleExports((aCt, Cae) => {
  'use strict'
  var I6e = (function () {
    function t() {
      ;(this.applicationVersion = 'ai.application.ver'),
        (this.deviceId = 'ai.device.id'),
        (this.deviceLocale = 'ai.device.locale'),
        (this.deviceModel = 'ai.device.model'),
        (this.deviceOEMName = 'ai.device.oemName'),
        (this.deviceOSVersion = 'ai.device.osVersion'),
        (this.deviceType = 'ai.device.type'),
        (this.locationIp = 'ai.location.ip'),
        (this.operationId = 'ai.operation.id'),
        (this.operationName = 'ai.operation.name'),
        (this.operationParentId = 'ai.operation.parentId'),
        (this.operationSyntheticSource = 'ai.operation.syntheticSource'),
        (this.operationCorrelationVector = 'ai.operation.correlationVector'),
        (this.sessionId = 'ai.session.id'),
        (this.sessionIsFirst = 'ai.session.isFirst'),
        (this.userAccountId = 'ai.user.accountId'),
        (this.userId = 'ai.user.id'),
        (this.userAuthUserId = 'ai.user.authUserId'),
        (this.cloudRole = 'ai.cloud.role'),
        (this.cloudRoleInstance = 'ai.cloud.roleInstance'),
        (this.internalSdkVersion = 'ai.internal.sdkVersion'),
        (this.internalAgentVersion = 'ai.internal.agentVersion'),
        (this.internalNodeName = 'ai.internal.nodeName')
    }
    return t
  })()
  Cae.exports = I6e
})
var Aae = handleExports((g9, wae) => {
  'use strict'
  var w6e =
      (g9 && g9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    A6e = h9(),
    R6e = (function (t) {
      w6e(e, t)
      function e() {
        return t.call(this) || this
      }
      return e
    })(A6e)
  wae.exports = R6e
})
var _9 = handleExports((cCt, Rae) => {
  'use strict'
  var v9
  ;(function (t) {
    ;(t[(t.Measurement = 0)] = 'Measurement'), (t[(t.Aggregation = 1)] = 'Aggregation')
  })(v9 || (v9 = {}))
  Rae.exports = v9
})
var Pae = handleExports((lCt, Dae) => {
  'use strict'
  var D6e = _9(),
    P6e = (function () {
      function t() {
        this.kind = D6e.Measurement
      }
      return t
    })()
  Dae.exports = P6e
})
var kae = handleExports((uCt, Nae) => {
  'use strict'
  var N6e = (function () {
    function t() {
      ;(this.ver = 1), (this.sampleRate = 100), (this.tags = {})
    }
    return t
  })()
  Nae.exports = N6e
})
var x9 = handleExports((y9, Oae) => {
  'use strict'
  var k6e =
      (y9 && y9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    O6e = Pp(),
    L6e = (function (t) {
      k6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(O6e)
  Oae.exports = L6e
})
var Mae = handleExports((b9, Lae) => {
  'use strict'
  var M6e =
      (b9 && b9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    F6e = Pp(),
    U6e = (function (t) {
      M6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.exceptions = []), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(F6e)
  Lae.exports = U6e
})
var Uae = handleExports((pCt, Fae) => {
  'use strict'
  var B6e = (function () {
    function t() {
      ;(this.hasFullStack = !0), (this.parsedStack = [])
    }
    return t
  })()
  Fae.exports = B6e
})
var qae = handleExports((E9, Bae) => {
  'use strict'
  var q6e =
      (E9 && E9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    H6e = Pp(),
    j6e = (function (t) {
      q6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.properties = {}), r
      }
      return e
    })(H6e)
  Bae.exports = j6e
})
var jae = handleExports((T9, Hae) => {
  'use strict'
  var G6e =
      (T9 && T9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    V6e = Pp(),
    z6e = (function (t) {
      G6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.metrics = []), (r.properties = {}), r
      }
      return e
    })(V6e)
  Hae.exports = z6e
})
var Vae = handleExports((S9, Gae) => {
  'use strict'
  var $6e =
      (S9 && S9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    W6e = x9(),
    K6e = (function (t) {
      $6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(W6e)
  Gae.exports = K6e
})
var $ae = handleExports((C9, zae) => {
  'use strict'
  var Y6e =
      (C9 && C9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    Q6e = Pp(),
    X6e = (function (t) {
      Y6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.success = !0), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(Q6e)
  zae.exports = X6e
})
var Kae = handleExports((I9, Wae) => {
  'use strict'
  var J6e =
      (I9 && I9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    Z6e = Pp(),
    eFe = (function (t) {
      J6e(e, t)
      function e() {
        var r = t.call(this) || this
        return (r.ver = 2), (r.properties = {}), (r.measurements = {}), r
      }
      return e
    })(Z6e)
  Wae.exports = eFe
})
var Qae = handleExports((dCt, Yae) => {
  'use strict'
  var w9
  ;(function (t) {
    ;(t[(t.Verbose = 0)] = 'Verbose'),
      (t[(t.Information = 1)] = 'Information'),
      (t[(t.Warning = 2)] = 'Warning'),
      (t[(t.Error = 3)] = 'Error'),
      (t[(t.Critical = 4)] = 'Critical')
  })(w9 || (w9 = {}))
  Yae.exports = w9
})
var Jae = handleExports((fCt, Xae) => {
  'use strict'
  var tFe = (function () {
    function t() {}
    return t
  })()
  Xae.exports = tFe
})
var A9 = handleExports(oi => {
  'use strict'
  Object.defineProperty(oi, '__esModule', { value: !0 })
  oi.AvailabilityData = Tae()
  oi.Base = h9()
  oi.ContextTagKeys = Iae()
  oi.Data = Aae()
  oi.DataPoint = Pae()
  oi.DataPointType = _9()
  oi.Domain = Pp()
  oi.Envelope = kae()
  oi.EventData = x9()
  oi.ExceptionData = Mae()
  oi.ExceptionDetails = Uae()
  oi.MessageData = qae()
  oi.MetricData = jae()
  oi.PageViewData = Vae()
  oi.RemoteDependencyData = $ae()
  oi.RequestData = Kae()
  oi.SeverityLevel = Qae()
  oi.StackFrame = Jae()
})
var Zae = handleExports(J_ => {
  'use strict'
  Object.defineProperty(J_, '__esModule', { value: !0 })
  J_.domainSupportsProperties = J_.RemoteDependencyDataConstants = void 0
  var Vg = A9(),
    rFe = (function () {
      function t() {}
      return (t.TYPE_HTTP = 'Http'), (t.TYPE_AI = 'Http (tracked component)'), t
    })()
  J_.RemoteDependencyDataConstants = rFe
  function nFe(t) {
    return (
      'properties' in t ||
      t instanceof Vg.EventData ||
      t instanceof Vg.ExceptionData ||
      t instanceof Vg.MessageData ||
      t instanceof Vg.MetricData ||
      t instanceof Vg.PageViewData ||
      t instanceof Vg.RemoteDependencyData ||
      t instanceof Vg.RequestData
    )
  }
  J_.domainSupportsProperties = nFe
})
var tce = handleExports(ece => {
  'use strict'
  Object.defineProperty(ece, '__esModule', { value: !0 })
})
var nce = handleExports(rce => {
  'use strict'
  Object.defineProperty(rce, '__esModule', { value: !0 })
})
var oce = handleExports(ice => {
  'use strict'
  Object.defineProperty(ice, '__esModule', { value: !0 })
})
var ace = handleExports(sce => {
  'use strict'
  Object.defineProperty(sce, '__esModule', { value: !0 })
})
var lce = handleExports(cce => {
  'use strict'
  Object.defineProperty(cce, '__esModule', { value: !0 })
})
var pce = handleExports(uce => {
  'use strict'
  Object.defineProperty(uce, '__esModule', { value: !0 })
})
var fce = handleExports(dce => {
  'use strict'
  Object.defineProperty(dce, '__esModule', { value: !0 })
})
var hce = handleExports(mce => {
  'use strict'
  Object.defineProperty(mce, '__esModule', { value: !0 })
})
var vce = handleExports(gce => {
  'use strict'
  Object.defineProperty(gce, '__esModule', { value: !0 })
})
var yce = handleExports(_ce => {
  'use strict'
  Object.defineProperty(_ce, '__esModule', { value: !0 })
})
var bce = handleExports(xce => {
  'use strict'
  Object.defineProperty(xce, '__esModule', { value: !0 })
})
var Tce = handleExports(Ece => {
  'use strict'
  Object.defineProperty(Ece, '__esModule', { value: !0 })
})
var Sce = handleExports(Gc => {
  'use strict'
  Object.defineProperty(Gc, '__esModule', { value: !0 })
  Gc.TelemetryType = Gc.TelemetryTypeString = Gc.baseTypeToTelemetryType = Gc.telemetryTypeToBaseType = void 0
  function iFe(t) {
    switch (t) {
      case ao.Event:
        return 'EventData'
      case ao.Exception:
        return 'ExceptionData'
      case ao.Trace:
        return 'MessageData'
      case ao.Metric:
        return 'MetricData'
      case ao.Request:
        return 'RequestData'
      case ao.Dependency:
        return 'RemoteDependencyData'
      case ao.Availability:
        return 'AvailabilityData'
      case ao.PageView:
        return 'PageViewData'
    }
  }
  Gc.telemetryTypeToBaseType = iFe
  function oFe(t) {
    switch (t) {
      case 'EventData':
        return ao.Event
      case 'ExceptionData':
        return ao.Exception
      case 'MessageData':
        return ao.Trace
      case 'MetricData':
        return ao.Metric
      case 'RequestData':
        return ao.Request
      case 'RemoteDependencyData':
        return ao.Dependency
      case 'AvailabilityData':
        return ao.Availability
      case 'PageViewData':
        return ao.PageView
    }
  }
  Gc.baseTypeToTelemetryType = oFe
  Gc.TelemetryTypeString = {
    Event: 'EventData',
    Exception: 'ExceptionData',
    Trace: 'MessageData',
    Metric: 'MetricData',
    Request: 'RequestData',
    Dependency: 'RemoteDependencyData',
    Availability: 'AvailabilityData',
    PageView: 'PageViewData',
  }
  var ao
  ;(function (t) {
    ;(t[(t.Event = 0)] = 'Event'),
      (t[(t.Exception = 1)] = 'Exception'),
      (t[(t.Trace = 2)] = 'Trace'),
      (t[(t.Metric = 3)] = 'Metric'),
      (t[(t.Request = 4)] = 'Request'),
      (t[(t.Dependency = 5)] = 'Dependency'),
      (t[(t.Availability = 6)] = 'Availability'),
      (t[(t.PageView = 7)] = 'PageView')
  })((ao = Gc.TelemetryType || (Gc.TelemetryType = {})))
})
var Cce = handleExports(Ei => {
  'use strict'
  var sFe =
      (Ei && Ei.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(t, n, {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              })
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    fa =
      (Ei && Ei.__exportStar) ||
      function (t, e) {
        for (var r in t) r !== 'default' && !Object.prototype.hasOwnProperty.call(e, r) && sFe(e, t, r)
      }
  Object.defineProperty(Ei, '__esModule', { value: !0 })
  fa(tce(), Ei)
  fa(nce(), Ei)
  fa(oce(), Ei)
  fa(ace(), Ei)
  fa(lce(), Ei)
  fa(pce(), Ei)
  fa(fce(), Ei)
  fa(hce(), Ei)
  fa(vce(), Ei)
  fa(yce(), Ei)
  fa(bce(), Ei)
  fa(Tce(), Ei)
  fa(Sce(), Ei)
})
var wce = handleExports(Ice => {
  'use strict'
  Object.defineProperty(Ice, '__esModule', { value: !0 })
})
var Rce = handleExports(Ace => {
  'use strict'
  Object.defineProperty(Ace, '__esModule', { value: !0 })
})
var Pce = handleExports(Dce => {
  'use strict'
  Object.defineProperty(Dce, '__esModule', { value: !0 })
})
var kce = handleExports(Nce => {
  'use strict'
  Object.defineProperty(Nce, '__esModule', { value: !0 })
})
var Lce = handleExports(Oce => {
  'use strict'
  Object.defineProperty(Oce, '__esModule', { value: !0 })
})
var Fce = handleExports(Mce => {
  'use strict'
  Object.defineProperty(Mce, '__esModule', { value: !0 })
})
var Bce = handleExports(Uce => {
  'use strict'
  Object.defineProperty(Uce, '__esModule', { value: !0 })
})
var Hce = handleExports(qce => {
  'use strict'
  Object.defineProperty(qce, '__esModule', { value: !0 })
})
var jce = handleExports(As => {
  'use strict'
  var aFe =
      (As && As.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(t, n, {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              })
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    jf =
      (As && As.__exportStar) ||
      function (t, e) {
        for (var r in t) r !== 'default' && !Object.prototype.hasOwnProperty.call(e, r) && aFe(e, t, r)
      }
  Object.defineProperty(As, '__esModule', { value: !0 })
  jf(wce(), As)
  jf(Rce(), As)
  jf(Pce(), As)
  jf(kce(), As)
  jf(Lce(), As)
  jf(Fce(), As)
  jf(Bce(), As)
  jf(Hce(), As)
})
var Ao = handleExports(Jl => {
  'use strict'
  var cFe =
      (Jl && Jl.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(t, n, {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              })
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    xR =
      (Jl && Jl.__exportStar) ||
      function (t, e) {
        for (var r in t) r !== 'default' && !Object.prototype.hasOwnProperty.call(e, r) && cFe(e, t, r)
      }
  Object.defineProperty(Jl, '__esModule', { value: !0 })
  xR(Zae(), Jl)
  xR(A9(), Jl)
  xR(Cce(), Jl)
  xR(jce(), Jl)
})
var R9 = handleExports((qCt, Gce) => {
  'use strict'
  var lFe = (function () {
    function t() {}
    return (
      (t.prototype.getUrl = function () {
        return this.url
      }),
      (t.prototype.RequestParser = function () {
        this.startTime = +new Date()
      }),
      (t.prototype._setStatus = function (e, r) {
        var n = +new Date()
        ;(this.duration = n - this.startTime), (this.statusCode = e)
        var i = this.properties || {}
        if (r) {
          if (typeof r == 'string') i.error = r
          else if (r instanceof Error) i.error = r.message
          else if (typeof r == 'object') for (var o in r) i[o] = r[o] && r[o].toString && r[o].toString()
        }
        this.properties = i
      }),
      (t.prototype._isSuccess = function () {
        return 0 < this.statusCode && this.statusCode < 400
      }),
      t
    )
  })()
  Gce.exports = lFe
})
var xn = handleExports(Me => {
  'use strict'
  var Vc
  Object.defineProperty(Me, '__esModule', { value: !0 })
  Me.WEB_INSTRUMENTATION_DEPRECATED_SOURCE =
    Me.WEB_INSTRUMENTATION_DEFAULT_SOURCE =
    Me.TIME_SINCE_ENQUEUED =
    Me.ENQUEUED_TIME =
    Me.MessageBusDestination =
    Me.MicrosoftEventHub =
    Me.AzNamespace =
    Me.HttpRequestCookieNames =
    Me.StatsbeatNetworkCategory =
    Me.StatsbeatFeatureType =
    Me.StatsbeatInstrumentation =
    Me.StatsbeatFeature =
    Me.StatsbeatCounter =
    Me.StatsbeatAttach =
    Me.StatsbeatResourceProvider =
    Me.StatsbeatTelemetryName =
    Me.HeartBeatMetricName =
    Me.DependencyTypeName =
    Me.TelemetryTypeStringToQuickPulseDocumentType =
    Me.TelemetryTypeStringToQuickPulseType =
    Me.QuickPulseType =
    Me.QuickPulseDocumentType =
    Me.PerformanceToQuickPulseCounter =
    Me.MetricId =
    Me.PerformanceCounter =
    Me.QuickPulseCounter =
    Me.DEFAULT_LIVEMETRICS_HOST =
    Me.DEFAULT_LIVEMETRICS_ENDPOINT =
    Me.DEFAULT_BREEZE_ENDPOINT =
    Me.APPLICATION_INSIGHTS_SDK_VERSION =
      void 0
  Me.APPLICATION_INSIGHTS_SDK_VERSION = '2.9.0'
  Me.DEFAULT_BREEZE_ENDPOINT = 'https://dc.services.visualstudio.com'
  Me.DEFAULT_LIVEMETRICS_ENDPOINT = 'https://rt.services.visualstudio.com'
  Me.DEFAULT_LIVEMETRICS_HOST = 'rt.services.visualstudio.com'
  var Ro
  ;(function (t) {
    ;(t.COMMITTED_BYTES = '\\Memory\\Committed Bytes'),
      (t.PROCESSOR_TIME = '\\Processor(_Total)\\% Processor Time'),
      (t.REQUEST_RATE = '\\ApplicationInsights\\Requests/Sec'),
      (t.REQUEST_FAILURE_RATE = '\\ApplicationInsights\\Requests Failed/Sec'),
      (t.REQUEST_DURATION = '\\ApplicationInsights\\Request Duration'),
      (t.DEPENDENCY_RATE = '\\ApplicationInsights\\Dependency Calls/Sec'),
      (t.DEPENDENCY_FAILURE_RATE = '\\ApplicationInsights\\Dependency Calls Failed/Sec'),
      (t.DEPENDENCY_DURATION = '\\ApplicationInsights\\Dependency Call Duration'),
      (t.EXCEPTION_RATE = '\\ApplicationInsights\\Exceptions/Sec')
  })((Ro = Me.QuickPulseCounter || (Me.QuickPulseCounter = {})))
  var bR
  ;(function (t) {
    ;(t.PRIVATE_BYTES = '\\Process(??APP_WIN32_PROC??)\\Private Bytes'),
      (t.AVAILABLE_BYTES = '\\Memory\\Available Bytes'),
      (t.PROCESSOR_TIME = '\\Processor(_Total)\\% Processor Time'),
      (t.PROCESS_TIME = '\\Process(??APP_WIN32_PROC??)\\% Processor Time'),
      (t.REQUEST_RATE = '\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec'),
      (t.REQUEST_DURATION = '\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time')
  })((bR = Me.PerformanceCounter || (Me.PerformanceCounter = {})))
  var uFe
  ;(function (t) {
    ;(t.REQUESTS_DURATION = 'requests/duration'),
      (t.DEPENDENCIES_DURATION = 'dependencies/duration'),
      (t.EXCEPTIONS_COUNT = 'exceptions/count'),
      (t.TRACES_COUNT = 'traces/count')
  })((uFe = Me.MetricId || (Me.MetricId = {})))
  Me.PerformanceToQuickPulseCounter =
    ((Vc = {}),
    (Vc[bR.PROCESSOR_TIME] = Ro.PROCESSOR_TIME),
    (Vc[bR.REQUEST_RATE] = Ro.REQUEST_RATE),
    (Vc[bR.REQUEST_DURATION] = Ro.REQUEST_DURATION),
    (Vc[Ro.COMMITTED_BYTES] = Ro.COMMITTED_BYTES),
    (Vc[Ro.REQUEST_FAILURE_RATE] = Ro.REQUEST_FAILURE_RATE),
    (Vc[Ro.DEPENDENCY_RATE] = Ro.DEPENDENCY_RATE),
    (Vc[Ro.DEPENDENCY_FAILURE_RATE] = Ro.DEPENDENCY_FAILURE_RATE),
    (Vc[Ro.DEPENDENCY_DURATION] = Ro.DEPENDENCY_DURATION),
    (Vc[Ro.EXCEPTION_RATE] = Ro.EXCEPTION_RATE),
    Vc)
  Me.QuickPulseDocumentType = {
    Event: 'Event',
    Exception: 'Exception',
    Trace: 'Trace',
    Metric: 'Metric',
    Request: 'Request',
    Dependency: 'RemoteDependency',
    Availability: 'Availability',
    PageView: 'PageView',
  }
  Me.QuickPulseType = {
    Event: 'EventTelemetryDocument',
    Exception: 'ExceptionTelemetryDocument',
    Trace: 'TraceTelemetryDocument',
    Metric: 'MetricTelemetryDocument',
    Request: 'RequestTelemetryDocument',
    Dependency: 'DependencyTelemetryDocument',
    Availability: 'AvailabilityTelemetryDocument',
    PageView: 'PageViewTelemetryDocument',
  }
  Me.TelemetryTypeStringToQuickPulseType = {
    EventData: Me.QuickPulseType.Event,
    ExceptionData: Me.QuickPulseType.Exception,
    MessageData: Me.QuickPulseType.Trace,
    MetricData: Me.QuickPulseType.Metric,
    RequestData: Me.QuickPulseType.Request,
    RemoteDependencyData: Me.QuickPulseType.Dependency,
    AvailabilityData: Me.QuickPulseType.Availability,
    PageViewData: Me.QuickPulseType.PageView,
  }
  Me.TelemetryTypeStringToQuickPulseDocumentType = {
    EventData: Me.QuickPulseDocumentType.Event,
    ExceptionData: Me.QuickPulseDocumentType.Exception,
    MessageData: Me.QuickPulseDocumentType.Trace,
    MetricData: Me.QuickPulseDocumentType.Metric,
    RequestData: Me.QuickPulseDocumentType.Request,
    RemoteDependencyData: Me.QuickPulseDocumentType.Dependency,
    AvailabilityData: Me.QuickPulseDocumentType.Availability,
    PageViewData: Me.QuickPulseDocumentType.PageView,
  }
  Me.DependencyTypeName = { Grpc: 'GRPC', Http: 'HTTP', InProc: 'InProc', Sql: 'SQL', QueueMessage: 'Queue Message' }
  Me.HeartBeatMetricName = 'HeartbeatState'
  Me.StatsbeatTelemetryName = 'Statsbeat'
  Me.StatsbeatResourceProvider = { appsvc: 'appsvc', functions: 'functions', vm: 'vm', unknown: 'unknown' }
  Me.StatsbeatAttach = { codeless: 'codeless', sdk: 'sdk' }
  Me.StatsbeatCounter = {
    REQUEST_SUCCESS: 'Request Success Count',
    REQUEST_FAILURE: 'Request Failure Count',
    REQUEST_DURATION: 'Request Duration',
    RETRY_COUNT: 'Retry Count',
    THROTTLE_COUNT: 'Throttle Count',
    EXCEPTION_COUNT: 'Exception Count',
    ATTACH: 'Attach',
    FEATURE: 'Feature',
  }
  var pFe
  ;(function (t) {
    ;(t[(t.NONE = 0)] = 'NONE'),
      (t[(t.DISK_RETRY = 1)] = 'DISK_RETRY'),
      (t[(t.AAD_HANDLING = 2)] = 'AAD_HANDLING'),
      (t[(t.WEB_SNIPPET = 4)] = 'WEB_SNIPPET')
  })((pFe = Me.StatsbeatFeature || (Me.StatsbeatFeature = {})))
  var dFe
  ;(function (t) {
    ;(t[(t.NONE = 0)] = 'NONE'),
      (t[(t.AZURE_CORE_TRACING = 1)] = 'AZURE_CORE_TRACING'),
      (t[(t.MONGODB = 2)] = 'MONGODB'),
      (t[(t.MYSQL = 4)] = 'MYSQL'),
      (t[(t.REDIS = 8)] = 'REDIS'),
      (t[(t.POSTGRES = 16)] = 'POSTGRES'),
      (t[(t.BUNYAN = 32)] = 'BUNYAN'),
      (t[(t.WINSTON = 64)] = 'WINSTON'),
      (t[(t.CONSOLE = 128)] = 'CONSOLE')
  })((dFe = Me.StatsbeatInstrumentation || (Me.StatsbeatInstrumentation = {})))
  var fFe
  ;(function (t) {
    ;(t[(t.Feature = 0)] = 'Feature'), (t[(t.Instrumentation = 1)] = 'Instrumentation')
  })((fFe = Me.StatsbeatFeatureType || (Me.StatsbeatFeatureType = {})))
  var mFe
  ;(function (t) {
    ;(t[(t.Breeze = 0)] = 'Breeze'), (t[(t.Quickpulse = 1)] = 'Quickpulse')
  })((mFe = Me.StatsbeatNetworkCategory || (Me.StatsbeatNetworkCategory = {})))
  var hFe
  ;(function (t) {
    ;(t.SESSION = 'ai_session'), (t.USER = 'ai_user'), (t.AUTH_USER = 'ai_authUser')
  })((hFe = Me.HttpRequestCookieNames || (Me.HttpRequestCookieNames = {})))
  Me.AzNamespace = 'az.namespace'
  Me.MicrosoftEventHub = 'Microsoft.EventHub'
  Me.MessageBusDestination = 'message_bus.destination'
  Me.ENQUEUED_TIME = 'enqueuedTime'
  Me.TIME_SINCE_ENQUEUED = 'timeSinceEnqueued'
  Me.WEB_INSTRUMENTATION_DEFAULT_SOURCE = 'https://js.monitor.azure.com/scripts/b/ai'
  Me.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = 'https://az416426.vo.msecnd.net/scripts/b/ai'
})
var k9 = handleExports((N9, Vce) => {
  'use strict'
  var gFe =
      (N9 && N9.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    ER = require('url'),
    vFe = Ao(),
    D9 = oo(),
    ma = Q_(),
    _Fe = R9(),
    Gf = Gg(),
    yFe = f9(),
    P9 = yR(),
    xFe = on(),
    TR = xn(),
    bFe = (function (t) {
      gFe(e, t)
      function e(r, n) {
        var i = t.call(this) || this
        return (
          r &&
            ((i.method = r.method),
            (i.url = i._getAbsoluteUrl(r)),
            (i.startTime = +new Date()),
            (i.socketRemoteAddress = r.socket && r.socket.remoteAddress),
            i.parseHeaders(r, n),
            r.connection &&
              ((i.connectionRemoteAddress = r.connection.remoteAddress),
              (i.legacySocketRemoteAddress = r.connection.socket && r.connection.socket.remoteAddress))),
          i
        )
      }
      return (
        (e.prototype.onError = function (r, n) {
          this._setStatus(void 0, r), n && (this.duration = n)
        }),
        (e.prototype.onResponse = function (r, n) {
          this._setStatus(r.statusCode, void 0), n && (this.duration = n)
        }),
        (e.prototype.getRequestTelemetry = function (r) {
          var n = this.method
          try {
            n += ' ' + new ER.URL(this.url).pathname
          } catch {}
          var i = {
            id: this.requestId,
            name: n,
            url: this.url,
            source: this.sourceCorrelationId,
            duration: this.duration,
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            success: this._isSuccess(),
            properties: this.properties,
          }
          if ((r && r.time ? (i.time = r.time) : this.startTime && (i.time = new Date(this.startTime)), r)) {
            for (var o in r) i[o] || (i[o] = r[o])
            if (r.properties) for (var o in r.properties) i.properties[o] = r.properties[o]
          }
          return i
        }),
        (e.prototype.getRequestTags = function (r) {
          var n = {}
          for (var i in r) n[i] = r[i]
          return (
            (n[e.keys.locationIp] = r[e.keys.locationIp] || this._getIp()),
            (n[e.keys.sessionId] = r[e.keys.sessionId] || this._getId(TR.HttpRequestCookieNames.SESSION)),
            (n[e.keys.userId] = r[e.keys.userId] || this._getId(TR.HttpRequestCookieNames.USER)),
            (n[e.keys.userAuthUserId] = r[e.keys.userAuthUserId] || this._getId(TR.HttpRequestCookieNames.AUTH_USER)),
            (n[e.keys.operationName] = this.getOperationName(r)),
            (n[e.keys.operationParentId] = this.getOperationParentId(r)),
            (n[e.keys.operationId] = this.getOperationId(r)),
            n
          )
        }),
        (e.prototype.getOperationId = function (r) {
          return r[e.keys.operationId] || this.operationId
        }),
        (e.prototype.getOperationParentId = function (r) {
          return r[e.keys.operationParentId] || this.parentId || this.getOperationId(r)
        }),
        (e.prototype.getOperationName = function (r) {
          if (r[e.keys.operationName]) return r[e.keys.operationName]
          var n = ''
          try {
            n = new ER.URL(this.url).pathname
          } catch {}
          var i = this.method
          return n && (i += ' ' + n), i
        }),
        (e.prototype.getRequestId = function () {
          return this.requestId
        }),
        (e.prototype.getCorrelationContextHeader = function () {
          return this.correlationContextHeader
        }),
        (e.prototype.getTraceparent = function () {
          return this.traceparent
        }),
        (e.prototype.getTracestate = function () {
          return this.tracestate
        }),
        (e.prototype.getLegacyRootId = function () {
          return this.legacyRootId
        }),
        (e.prototype._getAbsoluteUrl = function (r) {
          if (!r.headers) return r.url
          var n = r.connection ? r.connection.encrypted : null,
            i = n || r.headers['x-forwarded-proto'] == 'https' ? 'https' : 'http',
            o = i + '://' + r.headers.host + '/',
            s = '',
            a = ''
          try {
            var l = new ER.URL(r.url, o)
            ;(s = l.pathname), (a = l.search)
          } catch {}
          var c = ER.format({ protocol: i, host: r.headers.host, pathname: s, search: a })
          return c
        }),
        (e.prototype._getIp = function () {
          var r = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/,
            n = function (o) {
              var s = r.exec(o)
              if (s) return s[0]
            },
            i =
              n(this.rawHeaders['x-forwarded-for']) ||
              n(this.rawHeaders['x-client-ip']) ||
              n(this.rawHeaders['x-real-ip']) ||
              n(this.connectionRemoteAddress) ||
              n(this.socketRemoteAddress) ||
              n(this.legacySocketRemoteAddress)
          return (
            !i &&
              this.connectionRemoteAddress &&
              this.connectionRemoteAddress.substr &&
              this.connectionRemoteAddress.substr(0, 2) === '::' &&
              (i = '127.0.0.1'),
            i
          )
        }),
        (e.prototype._getId = function (r) {
          var n =
            (this.rawHeaders &&
              this.rawHeaders.cookie &&
              typeof this.rawHeaders.cookie == 'string' &&
              this.rawHeaders.cookie) ||
            ''
          if (r === TR.HttpRequestCookieNames.AUTH_USER)
            try {
              n = decodeURI(n)
            } catch (o) {
              ;(n = ''), xFe.warn('Could not decode the auth cookie with error: ', D9.dumpObj(o))
            }
          var i = e.parseId(D9.getCookie(r, n))
          return i
        }),
        (e.prototype.setBackCompatFromThisTraceContext = function () {
          ;(this.operationId = this.traceparent.traceId),
            this.traceparent.legacyRootId && (this.legacyRootId = this.traceparent.legacyRootId),
            (this.parentId = this.traceparent.parentId),
            this.traceparent.updateSpanId(),
            (this.requestId = this.traceparent.getBackCompatRequestId())
        }),
        (e.prototype.parseHeaders = function (r, n) {
          if (
            ((this.rawHeaders = r.headers || r.rawHeaders),
            (this.userAgent = r.headers && r.headers['user-agent']),
            (this.sourceCorrelationId = D9.getCorrelationContextTarget(r, ma.requestContextSourceKey)),
            r.headers)
          ) {
            var i = r.headers[ma.traceStateHeader] ? r.headers[ma.traceStateHeader].toString() : null,
              o = r.headers[ma.traceparentHeader] ? r.headers[ma.traceparentHeader].toString() : null,
              s = r.headers[ma.requestIdHeader] ? r.headers[ma.requestIdHeader].toString() : null,
              a = r.headers[ma.parentIdHeader] ? r.headers[ma.parentIdHeader].toString() : null,
              l = r.headers[ma.rootIdHeader] ? r.headers[ma.rootIdHeader].toString() : null
            ;(this.correlationContextHeader = r.headers[ma.correlationContextHeader]
              ? r.headers[ma.correlationContextHeader].toString()
              : null),
              Gf.w3cEnabled && (o || i)
                ? ((this.traceparent = new P9(o ? o.toString() : null)),
                  (this.tracestate = o && i && new yFe(i ? i.toString() : null)),
                  this.setBackCompatFromThisTraceContext())
                : s
                ? Gf.w3cEnabled
                  ? ((this.traceparent = new P9(null, s)), this.setBackCompatFromThisTraceContext())
                  : ((this.parentId = s),
                    (this.requestId = Gf.generateRequestId(this.parentId)),
                    (this.operationId = Gf.getRootId(this.requestId)))
                : Gf.w3cEnabled
                ? ((this.traceparent = new P9()),
                  (this.traceparent.parentId = a),
                  (this.traceparent.legacyRootId = l || a),
                  this.setBackCompatFromThisTraceContext())
                : ((this.parentId = a),
                  (this.requestId = Gf.generateRequestId(l || this.parentId)),
                  (this.correlationContextHeader = null),
                  (this.operationId = Gf.getRootId(this.requestId))),
              n && ((this.requestId = n), (this.operationId = Gf.getRootId(this.requestId)))
          }
        }),
        (e.parseId = function (r) {
          var n = r.split('|')
          return n.length > 0 ? n[0] : ''
        }),
        (e.keys = new vFe.ContextTagKeys()),
        e
      )
    })(_Fe)
  Vce.exports = bFe
})
var ale = handleExports((Tt, sle) => {
  Tt = sle.exports = er
  var Rr
  typeof process == 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (Rr = function () {
        var t = Array.prototype.slice.call(arguments, 0)
        t.unshift('SEMVER'), console.log.apply(console, t)
      })
    : (Rr = function () {})
  Tt.SEMVER_SPEC_VERSION = '2.0.0'
  var NE = 256,
    SR = Number.MAX_SAFE_INTEGER || 9007199254740991,
    O9 = 16,
    EFe = NE - 6,
    kE = (Tt.re = []),
    zr = (Tt.safeRe = []),
    Re = (Tt.src = []),
    Qt = 0,
    B9 = '[a-zA-Z0-9-]',
    L9 = [
      ['\\s', 1],
      ['\\d', NE],
      [B9, EFe],
    ]
  function DR(t) {
    for (var e = 0; e < L9.length; e++) {
      var r = L9[e][0],
        n = L9[e][1]
      t = t
        .split(r + '*')
        .join(r + '{0,' + n + '}')
        .split(r + '+')
        .join(r + '{1,' + n + '}')
    }
    return t
  }
  var Z_ = Qt++
  Re[Z_] = '0|[1-9]\\d*'
  var ey = Qt++
  Re[ey] = '\\d+'
  var q9 = Qt++
  Re[q9] = '\\d*[a-zA-Z-]' + B9 + '*'
  var $ce = Qt++
  Re[$ce] = '(' + Re[Z_] + ')\\.(' + Re[Z_] + ')\\.(' + Re[Z_] + ')'
  var Wce = Qt++
  Re[Wce] = '(' + Re[ey] + ')\\.(' + Re[ey] + ')\\.(' + Re[ey] + ')'
  var M9 = Qt++
  Re[M9] = '(?:' + Re[Z_] + '|' + Re[q9] + ')'
  var F9 = Qt++
  Re[F9] = '(?:' + Re[ey] + '|' + Re[q9] + ')'
  var H9 = Qt++
  Re[H9] = '(?:-(' + Re[M9] + '(?:\\.' + Re[M9] + ')*))'
  var j9 = Qt++
  Re[j9] = '(?:-?(' + Re[F9] + '(?:\\.' + Re[F9] + ')*))'
  var U9 = Qt++
  Re[U9] = B9 + '+'
  var LE = Qt++
  Re[LE] = '(?:\\+(' + Re[U9] + '(?:\\.' + Re[U9] + ')*))'
  var G9 = Qt++,
    Kce = 'v?' + Re[$ce] + Re[H9] + '?' + Re[LE] + '?'
  Re[G9] = '^' + Kce + '$'
  var V9 = '[v=\\s]*' + Re[Wce] + Re[j9] + '?' + Re[LE] + '?',
    z9 = Qt++
  Re[z9] = '^' + V9 + '$'
  var oy = Qt++
  Re[oy] = '((?:<|>)?=?)'
  var CR = Qt++
  Re[CR] = Re[ey] + '|x|X|\\*'
  var IR = Qt++
  Re[IR] = Re[Z_] + '|x|X|\\*'
  var zg = Qt++
  Re[zg] = '[v=\\s]*(' + Re[IR] + ')(?:\\.(' + Re[IR] + ')(?:\\.(' + Re[IR] + ')(?:' + Re[H9] + ')?' + Re[LE] + '?)?)?'
  var ry = Qt++
  Re[ry] = '[v=\\s]*(' + Re[CR] + ')(?:\\.(' + Re[CR] + ')(?:\\.(' + Re[CR] + ')(?:' + Re[j9] + ')?' + Re[LE] + '?)?)?'
  var Yce = Qt++
  Re[Yce] = '^' + Re[oy] + '\\s*' + Re[zg] + '$'
  var Qce = Qt++
  Re[Qce] = '^' + Re[oy] + '\\s*' + Re[ry] + '$'
  var Xce = Qt++
  Re[Xce] = '(?:^|[^\\d])(\\d{1,' + O9 + '})(?:\\.(\\d{1,' + O9 + '}))?(?:\\.(\\d{1,' + O9 + '}))?(?:$|[^\\d])'
  var PR = Qt++
  Re[PR] = '(?:~>?)'
  var ny = Qt++
  Re[ny] = '(\\s*)' + Re[PR] + '\\s+'
  kE[ny] = new RegExp(Re[ny], 'g')
  zr[ny] = new RegExp(DR(Re[ny]), 'g')
  var TFe = '$1~',
    Jce = Qt++
  Re[Jce] = '^' + Re[PR] + Re[zg] + '$'
  var Zce = Qt++
  Re[Zce] = '^' + Re[PR] + Re[ry] + '$'
  var NR = Qt++
  Re[NR] = '(?:\\^)'
  var iy = Qt++
  Re[iy] = '(\\s*)' + Re[NR] + '\\s+'
  kE[iy] = new RegExp(Re[iy], 'g')
  zr[iy] = new RegExp(DR(Re[iy]), 'g')
  var SFe = '$1^',
    ele = Qt++
  Re[ele] = '^' + Re[NR] + Re[zg] + '$'
  var tle = Qt++
  Re[tle] = '^' + Re[NR] + Re[ry] + '$'
  var $9 = Qt++
  Re[$9] = '^' + Re[oy] + '\\s*(' + V9 + ')$|^$'
  var W9 = Qt++
  Re[W9] = '^' + Re[oy] + '\\s*(' + Kce + ')$|^$'
  var $g = Qt++
  Re[$g] = '(\\s*)' + Re[oy] + '\\s*(' + V9 + '|' + Re[zg] + ')'
  kE[$g] = new RegExp(Re[$g], 'g')
  zr[$g] = new RegExp(DR(Re[$g]), 'g')
  var CFe = '$1$2$3',
    rle = Qt++
  Re[rle] = '^\\s*(' + Re[zg] + ')\\s+-\\s+(' + Re[zg] + ')\\s*$'
  var nle = Qt++
  Re[nle] = '^\\s*(' + Re[ry] + ')\\s+-\\s+(' + Re[ry] + ')\\s*$'
  var ile = Qt++
  Re[ile] = '(<|>)?=?\\s*\\*'
  for (Zl = 0; Zl < Qt; Zl++)
    Rr(Zl, Re[Zl]), kE[Zl] || ((kE[Zl] = new RegExp(Re[Zl])), (zr[Zl] = new RegExp(DR(Re[Zl]))))
  var Zl
  Tt.parse = Wg
  function Wg(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof er)) return t
    if (typeof t != 'string' || t.length > NE) return null
    var r = e.loose ? zr[z9] : zr[G9]
    if (!r.test(t)) return null
    try {
      return new er(t, e)
    } catch {
      return null
    }
  }
  Tt.valid = IFe
  function IFe(t, e) {
    var r = Wg(t, e)
    return r ? r.version : null
  }
  Tt.clean = wFe
  function wFe(t, e) {
    var r = Wg(t.trim().replace(/^[=v]+/, ''), e)
    return r ? r.version : null
  }
  Tt.SemVer = er
  function er(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof er)) {
      if (t.loose === e.loose) return t
      t = t.version
    } else if (typeof t != 'string') throw new TypeError('Invalid Version: ' + t)
    if (t.length > NE) throw new TypeError('version is longer than ' + NE + ' characters')
    if (!(this instanceof er)) return new er(t, e)
    Rr('SemVer', t, e), (this.options = e), (this.loose = !!e.loose)
    var r = t.trim().match(e.loose ? zr[z9] : zr[G9])
    if (!r) throw new TypeError('Invalid Version: ' + t)
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > SR || this.major < 0)
    )
      throw new TypeError('Invalid major version')
    if (this.minor > SR || this.minor < 0) throw new TypeError('Invalid minor version')
    if (this.patch > SR || this.patch < 0) throw new TypeError('Invalid patch version')
    r[4]
      ? (this.prerelease = r[4].split('.').map(function (n) {
          if (/^[0-9]+$/.test(n)) {
            var i = +n
            if (i >= 0 && i < SR) return i
          }
          return n
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split('.') : []),
      this.format()
  }
  er.prototype.format = function () {
    return (
      (this.version = this.major + '.' + this.minor + '.' + this.patch),
      this.prerelease.length && (this.version += '-' + this.prerelease.join('.')),
      this.version
    )
  }
  er.prototype.toString = function () {
    return this.version
  }
  er.prototype.compare = function (t) {
    return (
      Rr('SemVer.compare', this.version, this.options, t),
      t instanceof er || (t = new er(t, this.options)),
      this.compareMain(t) || this.comparePre(t)
    )
  }
  er.prototype.compareMain = function (t) {
    return (
      t instanceof er || (t = new er(t, this.options)),
      ty(this.major, t.major) || ty(this.minor, t.minor) || ty(this.patch, t.patch)
    )
  }
  er.prototype.comparePre = function (t) {
    if ((t instanceof er || (t = new er(t, this.options)), this.prerelease.length && !t.prerelease.length)) return -1
    if (!this.prerelease.length && t.prerelease.length) return 1
    if (!this.prerelease.length && !t.prerelease.length) return 0
    var e = 0
    do {
      var r = this.prerelease[e],
        n = t.prerelease[e]
      if ((Rr('prerelease compare', e, r, n), r === void 0 && n === void 0)) return 0
      if (n === void 0) return 1
      if (r === void 0) return -1
      if (r === n) continue
      return ty(r, n)
    } while (++e)
  }
  er.prototype.inc = function (t, e) {
    switch (t) {
      case 'premajor':
        ;(this.prerelease.length = 0), (this.patch = 0), (this.minor = 0), this.major++, this.inc('pre', e)
        break
      case 'preminor':
        ;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', e)
        break
      case 'prepatch':
        ;(this.prerelease.length = 0), this.inc('patch', e), this.inc('pre', e)
        break
      case 'prerelease':
        this.prerelease.length === 0 && this.inc('patch', e), this.inc('pre', e)
        break
      case 'major':
        ;(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = [])
        break
      case 'minor':
        ;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++, (this.patch = 0), (this.prerelease = [])
        break
      case 'patch':
        this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
        break
      case 'pre':
        if (this.prerelease.length === 0) this.prerelease = [0]
        else {
          for (var r = this.prerelease.length; --r >= 0; )
            typeof this.prerelease[r] == 'number' && (this.prerelease[r]++, (r = -2))
          r === -1 && this.prerelease.push(0)
        }
        e &&
          (this.prerelease[0] === e
            ? isNaN(this.prerelease[1]) && (this.prerelease = [e, 0])
            : (this.prerelease = [e, 0]))
        break
      default:
        throw new Error('invalid increment argument: ' + t)
    }
    return this.format(), (this.raw = this.version), this
  }
  Tt.inc = AFe
  function AFe(t, e, r, n) {
    typeof r == 'string' && ((n = r), (r = void 0))
    try {
      return new er(t, r).inc(e, n).version
    } catch {
      return null
    }
  }
  Tt.diff = RFe
  function RFe(t, e) {
    if (K9(t, e)) return null
    var r = Wg(t),
      n = Wg(e),
      i = ''
    if (r.prerelease.length || n.prerelease.length) {
      i = 'pre'
      var o = 'prerelease'
    }
    for (var s in r) if ((s === 'major' || s === 'minor' || s === 'patch') && r[s] !== n[s]) return i + s
    return o
  }
  Tt.compareIdentifiers = ty
  var zce = /^[0-9]+$/
  function ty(t, e) {
    var r = zce.test(t),
      n = zce.test(e)
    return r && n && ((t = +t), (e = +e)), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1
  }
  Tt.rcompareIdentifiers = DFe
  function DFe(t, e) {
    return ty(e, t)
  }
  Tt.major = PFe
  function PFe(t, e) {
    return new er(t, e).major
  }
  Tt.minor = NFe
  function NFe(t, e) {
    return new er(t, e).minor
  }
  Tt.patch = kFe
  function kFe(t, e) {
    return new er(t, e).patch
  }
  Tt.compare = Np
  function Np(t, e, r) {
    return new er(t, r).compare(new er(e, r))
  }
  Tt.compareLoose = OFe
  function OFe(t, e) {
    return Np(t, e, !0)
  }
  Tt.rcompare = LFe
  function LFe(t, e, r) {
    return Np(e, t, r)
  }
  Tt.sort = MFe
  function MFe(t, e) {
    return t.sort(function (r, n) {
      return Tt.compare(r, n, e)
    })
  }
  Tt.rsort = FFe
  function FFe(t, e) {
    return t.sort(function (r, n) {
      return Tt.rcompare(r, n, e)
    })
  }
  Tt.gt = OE
  function OE(t, e, r) {
    return Np(t, e, r) > 0
  }
  Tt.lt = wR
  function wR(t, e, r) {
    return Np(t, e, r) < 0
  }
  Tt.eq = K9
  function K9(t, e, r) {
    return Np(t, e, r) === 0
  }
  Tt.neq = ole
  function ole(t, e, r) {
    return Np(t, e, r) !== 0
  }
  Tt.gte = Y9
  function Y9(t, e, r) {
    return Np(t, e, r) >= 0
  }
  Tt.lte = Q9
  function Q9(t, e, r) {
    return Np(t, e, r) <= 0
  }
  Tt.cmp = AR
  function AR(t, e, r, n) {
    switch (e) {
      case '===':
        return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t === r
      case '!==':
        return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t !== r
      case '':
      case '=':
      case '==':
        return K9(t, r, n)
      case '!=':
        return ole(t, r, n)
      case '>':
        return OE(t, r, n)
      case '>=':
        return Y9(t, r, n)
      case '<':
        return wR(t, r, n)
      case '<=':
        return Q9(t, r, n)
      default:
        throw new TypeError('Invalid operator: ' + e)
    }
  }
  Tt.Comparator = Ya
  function Ya(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof Ya)) {
      if (t.loose === !!e.loose) return t
      t = t.value
    }
    if (!(this instanceof Ya)) return new Ya(t, e)
    ;(t = t.trim().split(/\s+/).join(' ')),
      Rr('comparator', t, e),
      (this.options = e),
      (this.loose = !!e.loose),
      this.parse(t),
      this.semver === ME ? (this.value = '') : (this.value = this.operator + this.semver.version),
      Rr('comp', this)
  }
  var ME = {}
  Ya.prototype.parse = function (t) {
    var e = this.options.loose ? zr[$9] : zr[W9],
      r = t.match(e)
    if (!r) throw new TypeError('Invalid comparator: ' + t)
    ;(this.operator = r[1]),
      this.operator === '=' && (this.operator = ''),
      r[2] ? (this.semver = new er(r[2], this.options.loose)) : (this.semver = ME)
  }
  Ya.prototype.toString = function () {
    return this.value
  }
  Ya.prototype.test = function (t) {
    return (
      Rr('Comparator.test', t, this.options.loose),
      this.semver === ME
        ? !0
        : (typeof t == 'string' && (t = new er(t, this.options)), AR(t, this.operator, this.semver, this.options))
    )
  }
  Ya.prototype.intersects = function (t, e) {
    if (!(t instanceof Ya)) throw new TypeError('a Comparator is required')
    ;(!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 })
    var r
    if (this.operator === '') return (r = new bn(t.value, e)), RR(this.value, r, e)
    if (t.operator === '') return (r = new bn(this.value, e)), RR(t.semver, r, e)
    var n = (this.operator === '>=' || this.operator === '>') && (t.operator === '>=' || t.operator === '>'),
      i = (this.operator === '<=' || this.operator === '<') && (t.operator === '<=' || t.operator === '<'),
      o = this.semver.version === t.semver.version,
      s = (this.operator === '>=' || this.operator === '<=') && (t.operator === '>=' || t.operator === '<='),
      a =
        AR(this.semver, '<', t.semver, e) &&
        (this.operator === '>=' || this.operator === '>') &&
        (t.operator === '<=' || t.operator === '<'),
      l =
        AR(this.semver, '>', t.semver, e) &&
        (this.operator === '<=' || this.operator === '<') &&
        (t.operator === '>=' || t.operator === '>')
    return n || i || (o && s) || a || l
  }
  Tt.Range = bn
  function bn(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof bn))
      return t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease ? t : new bn(t.raw, e)
    if (t instanceof Ya) return new bn(t.value, e)
    if (!(this instanceof bn)) return new bn(t, e)
    if (
      ((this.options = e),
      (this.loose = !!e.loose),
      (this.includePrerelease = !!e.includePrerelease),
      (this.raw = t.trim().split(/\s+/).join(' ')),
      (this.set = this.raw
        .split('||')
        .map(function (r) {
          return this.parseRange(r.trim())
        }, this)
        .filter(function (r) {
          return r.length
        })),
      !this.set.length)
    )
      throw new TypeError('Invalid SemVer Range: ' + this.raw)
    this.format()
  }
  bn.prototype.format = function () {
    return (
      (this.range = this.set
        .map(function (t) {
          return t.join(' ').trim()
        })
        .join('||')
        .trim()),
      this.range
    )
  }
  bn.prototype.toString = function () {
    return this.range
  }
  bn.prototype.parseRange = function (t) {
    var e = this.options.loose,
      r = e ? zr[nle] : zr[rle]
    ;(t = t.replace(r, WFe)),
      Rr('hyphen replace', t),
      (t = t.replace(zr[$g], CFe)),
      Rr('comparator trim', t, zr[$g]),
      (t = t.replace(zr[ny], TFe)),
      (t = t.replace(zr[iy], SFe))
    var n = e ? zr[$9] : zr[W9],
      i = t
        .split(' ')
        .map(function (o) {
          return BFe(o, this.options)
        }, this)
        .join(' ')
        .split(/\s+/)
    return (
      this.options.loose &&
        (i = i.filter(function (o) {
          return !!o.match(n)
        })),
      (i = i.map(function (o) {
        return new Ya(o, this.options)
      }, this)),
      i
    )
  }
  bn.prototype.intersects = function (t, e) {
    if (!(t instanceof bn)) throw new TypeError('a Range is required')
    return this.set.some(function (r) {
      return r.every(function (n) {
        return t.set.some(function (i) {
          return i.every(function (o) {
            return n.intersects(o, e)
          })
        })
      })
    })
  }
  Tt.toComparators = UFe
  function UFe(t, e) {
    return new bn(t, e).set.map(function (r) {
      return r
        .map(function (n) {
          return n.value
        })
        .join(' ')
        .trim()
        .split(' ')
    })
  }
  function BFe(t, e) {
    return (
      Rr('comp', t, e),
      (t = jFe(t, e)),
      Rr('caret', t),
      (t = qFe(t, e)),
      Rr('tildes', t),
      (t = VFe(t, e)),
      Rr('xrange', t),
      (t = $Fe(t, e)),
      Rr('stars', t),
      t
    )
  }
  function ns(t) {
    return !t || t.toLowerCase() === 'x' || t === '*'
  }
  function qFe(t, e) {
    return t
      .trim()
      .split(/\s+/)
      .map(function (r) {
        return HFe(r, e)
      })
      .join(' ')
  }
  function HFe(t, e) {
    var r = e.loose ? zr[Zce] : zr[Jce]
    return t.replace(r, function (n, i, o, s, a) {
      Rr('tilde', t, n, i, o, s, a)
      var l
      return (
        ns(i)
          ? (l = '')
          : ns(o)
          ? (l = '>=' + i + '.0.0 <' + (+i + 1) + '.0.0')
          : ns(s)
          ? (l = '>=' + i + '.' + o + '.0 <' + i + '.' + (+o + 1) + '.0')
          : a
          ? (Rr('replaceTilde pr', a), (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + (+o + 1) + '.0'))
          : (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + (+o + 1) + '.0'),
        Rr('tilde return', l),
        l
      )
    })
  }
  function jFe(t, e) {
    return t
      .trim()
      .split(/\s+/)
      .map(function (r) {
        return GFe(r, e)
      })
      .join(' ')
  }
  function GFe(t, e) {
    Rr('caret', t, e)
    var r = e.loose ? zr[tle] : zr[ele]
    return t.replace(r, function (n, i, o, s, a) {
      Rr('caret', t, n, i, o, s, a)
      var l
      return (
        ns(i)
          ? (l = '')
          : ns(o)
          ? (l = '>=' + i + '.0.0 <' + (+i + 1) + '.0.0')
          : ns(s)
          ? i === '0'
            ? (l = '>=' + i + '.' + o + '.0 <' + i + '.' + (+o + 1) + '.0')
            : (l = '>=' + i + '.' + o + '.0 <' + (+i + 1) + '.0.0')
          : a
          ? (Rr('replaceCaret pr', a),
            i === '0'
              ? o === '0'
                ? (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + o + '.' + (+s + 1))
                : (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + (+o + 1) + '.0')
              : (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + (+i + 1) + '.0.0'))
          : (Rr('no pr'),
            i === '0'
              ? o === '0'
                ? (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + o + '.' + (+s + 1))
                : (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + (+o + 1) + '.0')
              : (l = '>=' + i + '.' + o + '.' + s + ' <' + (+i + 1) + '.0.0')),
        Rr('caret return', l),
        l
      )
    })
  }
  function VFe(t, e) {
    return (
      Rr('replaceXRanges', t, e),
      t
        .split(/\s+/)
        .map(function (r) {
          return zFe(r, e)
        })
        .join(' ')
    )
  }
  function zFe(t, e) {
    t = t.trim()
    var r = e.loose ? zr[Qce] : zr[Yce]
    return t.replace(r, function (n, i, o, s, a, l) {
      Rr('xRange', t, n, i, o, s, a, l)
      var c = ns(o),
        u = c || ns(s),
        p = u || ns(a),
        d = p
      return (
        i === '=' && d && (i = ''),
        c
          ? i === '>' || i === '<'
            ? (n = '<0.0.0')
            : (n = '*')
          : i && d
          ? (u && (s = 0),
            (a = 0),
            i === '>'
              ? ((i = '>='), u ? ((o = +o + 1), (s = 0), (a = 0)) : ((s = +s + 1), (a = 0)))
              : i === '<=' && ((i = '<'), u ? (o = +o + 1) : (s = +s + 1)),
            (n = i + o + '.' + s + '.' + a))
          : u
          ? (n = '>=' + o + '.0.0 <' + (+o + 1) + '.0.0')
          : p && (n = '>=' + o + '.' + s + '.0 <' + o + '.' + (+s + 1) + '.0'),
        Rr('xRange return', n),
        n
      )
    })
  }
  function $Fe(t, e) {
    return Rr('replaceStars', t, e), t.trim().replace(zr[ile], '')
  }
  function WFe(t, e, r, n, i, o, s, a, l, c, u, p, d) {
    return (
      ns(r) ? (e = '') : ns(n) ? (e = '>=' + r + '.0.0') : ns(i) ? (e = '>=' + r + '.' + n + '.0') : (e = '>=' + e),
      ns(l)
        ? (a = '')
        : ns(c)
        ? (a = '<' + (+l + 1) + '.0.0')
        : ns(u)
        ? (a = '<' + l + '.' + (+c + 1) + '.0')
        : p
        ? (a = '<=' + l + '.' + c + '.' + u + '-' + p)
        : (a = '<=' + a),
      (e + ' ' + a).trim()
    )
  }
  bn.prototype.test = function (t) {
    if (!t) return !1
    typeof t == 'string' && (t = new er(t, this.options))
    for (var e = 0; e < this.set.length; e++) if (KFe(this.set[e], t, this.options)) return !0
    return !1
  }
  function KFe(t, e, r) {
    for (var n = 0; n < t.length; n++) if (!t[n].test(e)) return !1
    if (e.prerelease.length && !r.includePrerelease) {
      for (n = 0; n < t.length; n++)
        if ((Rr(t[n].semver), t[n].semver !== ME && t[n].semver.prerelease.length > 0)) {
          var i = t[n].semver
          if (i.major === e.major && i.minor === e.minor && i.patch === e.patch) return !0
        }
      return !1
    }
    return !0
  }
  Tt.satisfies = RR
  function RR(t, e, r) {
    try {
      e = new bn(e, r)
    } catch {
      return !1
    }
    return e.test(t)
  }
  Tt.maxSatisfying = YFe
  function YFe(t, e, r) {
    var n = null,
      i = null
    try {
      var o = new bn(e, r)
    } catch {
      return null
    }
    return (
      t.forEach(function (s) {
        o.test(s) && (!n || i.compare(s) === -1) && ((n = s), (i = new er(n, r)))
      }),
      n
    )
  }
  Tt.minSatisfying = QFe
  function QFe(t, e, r) {
    var n = null,
      i = null
    try {
      var o = new bn(e, r)
    } catch {
      return null
    }
    return (
      t.forEach(function (s) {
        o.test(s) && (!n || i.compare(s) === 1) && ((n = s), (i = new er(n, r)))
      }),
      n
    )
  }
  Tt.minVersion = XFe
  function XFe(t, e) {
    t = new bn(t, e)
    var r = new er('0.0.0')
    if (t.test(r) || ((r = new er('0.0.0-0')), t.test(r))) return r
    r = null
    for (var n = 0; n < t.set.length; ++n) {
      var i = t.set[n]
      i.forEach(function (o) {
        var s = new er(o.semver.version)
        switch (o.operator) {
          case '>':
            s.prerelease.length === 0 ? s.patch++ : s.prerelease.push(0), (s.raw = s.format())
          case '':
          case '>=':
            ;(!r || OE(r, s)) && (r = s)
            break
          case '<':
          case '<=':
            break
          default:
            throw new Error('Unexpected operation: ' + o.operator)
        }
      })
    }
    return r && t.test(r) ? r : null
  }
  Tt.validRange = JFe
  function JFe(t, e) {
    try {
      return new bn(t, e).range || '*'
    } catch {
      return null
    }
  }
  Tt.ltr = ZFe
  function ZFe(t, e, r) {
    return X9(t, e, '<', r)
  }
  Tt.gtr = e9e
  function e9e(t, e, r) {
    return X9(t, e, '>', r)
  }
  Tt.outside = X9
  function X9(t, e, r, n) {
    ;(t = new er(t, n)), (e = new bn(e, n))
    var i, o, s, a, l
    switch (r) {
      case '>':
        ;(i = OE), (o = Q9), (s = wR), (a = '>'), (l = '>=')
        break
      case '<':
        ;(i = wR), (o = Y9), (s = OE), (a = '<'), (l = '<=')
        break
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }
    if (RR(t, e, n)) return !1
    for (var c = 0; c < e.set.length; ++c) {
      var u = e.set[c],
        p = null,
        d = null
      if (
        (u.forEach(function (f) {
          f.semver === ME && (f = new Ya('>=0.0.0')),
            (p = p || f),
            (d = d || f),
            i(f.semver, p.semver, n) ? (p = f) : s(f.semver, d.semver, n) && (d = f)
        }),
        p.operator === a || p.operator === l || ((!d.operator || d.operator === a) && o(t, d.semver)))
      )
        return !1
      if (d.operator === l && s(t, d.semver)) return !1
    }
    return !0
  }
  Tt.prerelease = t9e
  function t9e(t, e) {
    var r = Wg(t, e)
    return r && r.prerelease.length ? r.prerelease : null
  }
  Tt.intersects = r9e
  function r9e(t, e, r) {
    return (t = new bn(t, r)), (e = new bn(e, r)), t.intersects(e)
  }
  Tt.coerce = n9e
  function n9e(t) {
    if (t instanceof er) return t
    if (typeof t != 'string') return null
    var e = t.match(zr[Xce])
    return e == null ? null : Wg(e[1] + '.' + (e[2] || '0') + '.' + (e[3] || '0'))
  }
})
var kR = handleExports((jCt, ule) => {
  'use strict'
  function J9(t) {
    return typeof t == 'function'
  }
  var is = console.error.bind(console)
  function FE(t, e, r) {
    var n = !!t[e] && t.propertyIsEnumerable(e)
    Object.defineProperty(t, e, { configurable: !0, enumerable: n, writable: !0, value: r })
  }
  function UE(t) {
    t && t.logger && (J9(t.logger) ? (is = t.logger) : is("new logger isn't a function, not replacing"))
  }
  function cle(t, e, r) {
    if (!t || !t[e]) {
      is('no original function ' + e + ' to wrap')
      return
    }
    if (!r) {
      is('no wrapper function'), is(new Error().stack)
      return
    }
    if (!J9(t[e]) || !J9(r)) {
      is('original object and wrapper must be functions')
      return
    }
    var n = t[e],
      i = r(n, e)
    return (
      FE(i, '__original', n),
      FE(i, '__unwrap', function () {
        t[e] === i && FE(t, e, n)
      }),
      FE(i, '__wrapped', !0),
      FE(t, e, i),
      i
    )
  }
  function i9e(t, e, r) {
    if (t) Array.isArray(t) || (t = [t])
    else {
      is('must provide one or more modules to patch'), is(new Error().stack)
      return
    }
    if (!(e && Array.isArray(e))) {
      is('must provide one or more functions to wrap on modules')
      return
    }
    t.forEach(function (n) {
      e.forEach(function (i) {
        cle(n, i, r)
      })
    })
  }
  function lle(t, e) {
    if (!t || !t[e]) {
      is('no function to unwrap.'), is(new Error().stack)
      return
    }
    if (!t[e].__unwrap) is('no original to unwrap to -- has ' + e + ' already been unwrapped?')
    else return t[e].__unwrap()
  }
  function o9e(t, e) {
    if (t) Array.isArray(t) || (t = [t])
    else {
      is('must provide one or more modules to patch'), is(new Error().stack)
      return
    }
    if (!(e && Array.isArray(e))) {
      is('must provide one or more functions to unwrap on modules')
      return
    }
    t.forEach(function (r) {
      e.forEach(function (n) {
        lle(r, n)
      })
    })
  }
  UE.wrap = cle
  UE.massWrap = i9e
  UE.unwrap = lle
  UE.massUnwrap = o9e
  ule.exports = UE
})
var MR = handleExports((GCt, mle) => {
  'use strict'
  var dle = kR(),
    sy = dle.wrap,
    OR = dle.unwrap,
    kp = 'wrap@before'
  function LR(t, e, r) {
    var n = !!t[e] && t.propertyIsEnumerable(e)
    Object.defineProperty(t, e, { configurable: !0, enumerable: n, writable: !0, value: r })
  }
  function s9e(t, e) {
    for (var r = e.length, n = 0; n < r; n++) {
      var i = e[n],
        o = t[kp]
      if (typeof o == 'function') o(i)
      else if (Array.isArray(o)) for (var s = o.length, a = 0; a < s; a++) o[a](i)
    }
  }
  function fle(t, e) {
    var r
    return (r = t._events && t._events[e]), Array.isArray(r) || (r ? (r = [r]) : (r = [])), r
  }
  function a9e(t, e, r) {
    var n = fle(t, e),
      i = n.filter(function (o) {
        return r.indexOf(o) === -1
      })
    i.length > 0 && s9e(t, i)
  }
  function ple(t, e) {
    if (t) {
      var r = t
      if (typeof t == 'function') r = e(t)
      else if (Array.isArray(t)) {
        r = []
        for (var n = 0; n < t.length; n++) r[n] = e(t[n])
      }
      return r
    }
  }
  mle.exports = function (e, r, n) {
    if (!e || !e.on || !e.addListener || !e.removeListener || !e.emit) throw new Error('can only wrap real EEs')
    if (!r) throw new Error('must have function to run on listener addition')
    if (!n) throw new Error('must have function to wrap listeners when emitting')
    function i(s) {
      return function (l, c) {
        var u = fle(this, l).slice()
        try {
          var p = s.call(this, l, c)
          return a9e(this, l, u), p
        } finally {
          this.on.__wrapped || sy(this, 'on', i), this.addListener.__wrapped || sy(this, 'addListener', i)
        }
      }
    }
    function o(s) {
      return function (l) {
        if (!this._events || !this._events[l]) return s.apply(this, arguments)
        var c = this._events[l]
        function u(p) {
          return function () {
            this._events[l] = c
            try {
              return p.apply(this, arguments)
            } finally {
              ;(c = this._events[l]), (this._events[l] = ple(c, n))
            }
          }
        }
        sy(this, 'removeListener', u)
        try {
          return (this._events[l] = ple(c, n)), s.apply(this, arguments)
        } finally {
          OR(this, 'removeListener'), (this._events[l] = c)
        }
      }
    }
    e[kp] ? (typeof e[kp] == 'function' ? LR(e, kp, [e[kp], r]) : Array.isArray(e[kp]) && e[kp].push(r)) : LR(e, kp, r),
      e.__wrapped ||
        (sy(e, 'addListener', i),
        sy(e, 'on', i),
        sy(e, 'emit', o),
        LR(e, '__unwrap', function () {
          OR(e, 'addListener'), OR(e, 'on'), OR(e, 'emit'), delete e[kp], delete e.__wrapped
        }),
        LR(e, '__wrapped', !0))
  }
})
var _le = handleExports((VCt, vle) => {
  'use strict'
  var yr = require('util'),
    Op = require('assert'),
    c9e = MR(),
    an = require('async_hooks'),
    BE = 'cls@contexts',
    qE = 'error@context',
    En = process.env.DEBUG_CLS_HOOKED,
    _r = -1
  vle.exports = { getNamespace: hle, createNamespace: l9e, destroyNamespace: gle, reset: u9e, ERROR_SYMBOL: qE }
  function Qa(t) {
    ;(this.name = t),
      (this.active = null),
      (this._set = []),
      (this.id = null),
      (this._contexts = new Map()),
      (this._indent = 0)
  }
  Qa.prototype.set = function (e, r) {
    if (!this.active) throw new Error('No context available. ns.run() or ns.bind() must be called first.')
    if (((this.active[e] = r), En)) {
      let n = ' '.repeat(this._indent < 0 ? 0 : this._indent)
      pn(
        n +
          'CONTEXT-SET KEY:' +
          e +
          '=' +
          r +
          ' in ns:' +
          this.name +
          ' currentUid:' +
          _r +
          ' active:' +
          yr.inspect(this.active, { showHidden: !0, depth: 2, colors: !0 })
      )
    }
    return r
  }
  Qa.prototype.get = function (e) {
    if (!this.active) {
      if (En) {
        let r = an.currentId(),
          n = an.triggerAsyncId(),
          i = ' '.repeat(this._indent < 0 ? 0 : this._indent)
        pn(
          `${i}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${e}=undefined currentUid:${_r} asyncHooksCurrentId:${r} triggerId:${n} len:${this._set.length}`
        )
      }
      return
    }
    if (En) {
      let r = an.executionAsyncId(),
        n = an.triggerAsyncId(),
        i = ' '.repeat(this._indent < 0 ? 0 : this._indent)
      pn(
        i +
          'CONTEXT-GETTING KEY:' +
          e +
          '=' +
          this.active[e] +
          ' (' +
          this.name +
          ') currentUid:' +
          _r +
          ' active:' +
          yr.inspect(this.active, { showHidden: !0, depth: 2, colors: !0 })
      ),
        pn(
          `${i}CONTEXT-GETTING KEY: (${this.name}) ${e}=${
            this.active[e]
          } currentUid:${_r} asyncHooksCurrentId:${r} triggerId:${n} len:${this._set.length} active:${yr.inspect(
            this.active
          )}`
        )
    }
    return this.active[e]
  }
  Qa.prototype.createContext = function () {
    let e = Object.create(this.active ? this.active : Object.prototype)
    if (((e._ns_name = this.name), (e.id = _r), En)) {
      let r = an.executionAsyncId(),
        n = an.triggerAsyncId(),
        i = ' '.repeat(this._indent < 0 ? 0 : this._indent)
      pn(
        `${i}CONTEXT-CREATED Context: (${this.name}) currentUid:${_r} asyncHooksCurrentId:${r} triggerId:${n} len:${
          this._set.length
        } context:${yr.inspect(e, { showHidden: !0, depth: 2, colors: !0 })}`
      )
    }
    return e
  }
  Qa.prototype.run = function (e) {
    let r = this.createContext()
    this.enter(r)
    try {
      if (En) {
        let n = an.triggerAsyncId(),
          i = an.executionAsyncId(),
          o = ' '.repeat(this._indent < 0 ? 0 : this._indent)
        pn(
          `${o}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${_r} triggerId:${n} asyncHooksCurrentId:${i} len:${
            this._set.length
          } context:${yr.inspect(r)}`
        )
      }
      return e(r), r
    } catch (n) {
      throw (n && (n[qE] = r), n)
    } finally {
      if (En) {
        let n = an.triggerAsyncId(),
          i = an.executionAsyncId(),
          o = ' '.repeat(this._indent < 0 ? 0 : this._indent)
        pn(
          `${o}CONTEXT-RUN END: (${this.name}) currentUid:${_r} triggerId:${n} asyncHooksCurrentId:${i} len:${
            this._set.length
          } ${yr.inspect(r)}`
        )
      }
      this.exit(r)
    }
  }
  Qa.prototype.runAndReturn = function (e) {
    let r
    return (
      this.run(function (n) {
        r = e(n)
      }),
      r
    )
  }
  Qa.prototype.runPromise = function (e) {
    let r = this.createContext()
    this.enter(r)
    let n = e(r)
    if (!n || !n.then || !n.catch) throw new Error('fn must return a promise.')
    return (
      En &&
        pn(
          'CONTEXT-runPromise BEFORE: (' +
            this.name +
            ') currentUid:' +
            _r +
            ' len:' +
            this._set.length +
            ' ' +
            yr.inspect(r)
        ),
      n
        .then(
          i => (
            En &&
              pn(
                'CONTEXT-runPromise AFTER then: (' +
                  this.name +
                  ') currentUid:' +
                  _r +
                  ' len:' +
                  this._set.length +
                  ' ' +
                  yr.inspect(r)
              ),
            this.exit(r),
            i
          )
        )
        .catch(i => {
          throw (
            ((i[qE] = r),
            En &&
              pn(
                'CONTEXT-runPromise AFTER catch: (' +
                  this.name +
                  ') currentUid:' +
                  _r +
                  ' len:' +
                  this._set.length +
                  ' ' +
                  yr.inspect(r)
              ),
            this.exit(r),
            i)
          )
        })
    )
  }
  Qa.prototype.bind = function (e, r) {
    r || (this.active ? (r = this.active) : (r = this.createContext()))
    let n = this
    return function () {
      n.enter(r)
      try {
        return e.apply(this, arguments)
      } catch (o) {
        throw (o && (o[qE] = r), o)
      } finally {
        n.exit(r)
      }
    }
  }
  Qa.prototype.enter = function (e) {
    if ((Op.ok(e, 'context must be provided for entering'), En)) {
      let r = an.executionAsyncId(),
        n = an.triggerAsyncId(),
        i = ' '.repeat(this._indent < 0 ? 0 : this._indent)
      pn(
        `${i}CONTEXT-ENTER: (${this.name}) currentUid:${_r} triggerId:${n} asyncHooksCurrentId:${r} len:${
          this._set.length
        } ${yr.inspect(e)}`
      )
    }
    this._set.push(this.active), (this.active = e)
  }
  Qa.prototype.exit = function (e) {
    if ((Op.ok(e, 'context must be provided for exiting'), En)) {
      let n = an.executionAsyncId(),
        i = an.triggerAsyncId(),
        o = ' '.repeat(this._indent < 0 ? 0 : this._indent)
      pn(
        `${o}CONTEXT-EXIT: (${this.name}) currentUid:${_r} triggerId:${i} asyncHooksCurrentId:${n} len:${
          this._set.length
        } ${yr.inspect(e)}`
      )
    }
    if (this.active === e) {
      Op.ok(this._set.length, "can't remove top context"), (this.active = this._set.pop())
      return
    }
    let r = this._set.lastIndexOf(e)
    r < 0
      ? (En && pn('??ERROR?? context exiting but not entered - ignoring: ' + yr.inspect(e)),
        Op.ok(
          r >= 0,
          `context not currently entered; can't exit.
` +
            yr.inspect(this) +
            `
` +
            yr.inspect(e)
        ))
      : (Op.ok(r, "can't remove top context"), this._set.splice(r, 1))
  }
  Qa.prototype.bindEmitter = function (e) {
    Op.ok(e.on && e.addListener && e.emit, 'can only bind real EEs')
    let r = this,
      n = 'context@' + this.name
    function i(s) {
      s && (s[BE] || (s[BE] = Object.create(null)), (s[BE][n] = { namespace: r, context: r.active }))
    }
    function o(s) {
      if (!(s && s[BE])) return s
      let a = s,
        l = s[BE]
      return (
        Object.keys(l).forEach(function (c) {
          let u = l[c]
          a = u.namespace.bind(a, u.context)
        }),
        a
      )
    }
    c9e(e, i, o)
  }
  Qa.prototype.fromException = function (e) {
    return e[qE]
  }
  function hle(t) {
    return process.namespaces[t]
  }
  function l9e(t) {
    Op.ok(t, 'namespace must be given a name.'), En && pn(`NS-CREATING NAMESPACE (${t})`)
    let e = new Qa(t)
    return (
      (e.id = _r),
      an
        .createHook({
          init(n, i, o, s) {
            if (((_r = an.executionAsyncId()), e.active)) {
              if ((e._contexts.set(n, e.active), En)) {
                let a = ' '.repeat(e._indent < 0 ? 0 : e._indent)
                pn(
                  `${a}INIT [${i}] (${t}) asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(e.active, {
                    showHidden: !0,
                    depth: 2,
                    colors: !0,
                  })} resource:${s}`
                )
              }
            } else if (_r === 0) {
              let a = an.triggerAsyncId(),
                l = e._contexts.get(a)
              if (l) {
                if ((e._contexts.set(n, l), En)) {
                  let c = ' '.repeat(e._indent < 0 ? 0 : e._indent)
                  pn(
                    `${c}INIT USING CONTEXT FROM TRIGGERID [${i}] (${t}) asyncId:${n} currentUid:${_r} triggerId:${a} active:${yr.inspect(
                      e.active,
                      { showHidden: !0, depth: 2, colors: !0 }
                    )} resource:${s}`
                  )
                }
              } else if (En) {
                let c = ' '.repeat(e._indent < 0 ? 0 : e._indent)
                pn(
                  `${c}INIT MISSING CONTEXT [${i}] (${t}) asyncId:${n} currentUid:${_r} triggerId:${a} active:${yr.inspect(
                    e.active,
                    { showHidden: !0, depth: 2, colors: !0 }
                  )} resource:${s}`
                )
              }
            }
            if (En && i === 'PROMISE') {
              pn(yr.inspect(s, { showHidden: !0 }))
              let a = s.parentId,
                l = ' '.repeat(e._indent < 0 ? 0 : e._indent)
              pn(
                `${l}INIT RESOURCE-PROMISE [${i}] (${t}) parentId:${a} asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(
                  e.active,
                  { showHidden: !0, depth: 2, colors: !0 }
                )} resource:${s}`
              )
            }
          },
          before(n) {
            _r = an.executionAsyncId()
            let i
            if (((i = e._contexts.get(n) || e._contexts.get(_r)), i)) {
              if (En) {
                let o = an.triggerAsyncId(),
                  s = ' '.repeat(e._indent < 0 ? 0 : e._indent)
                pn(
                  `${s}BEFORE (${t}) asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(e.active, {
                    showHidden: !0,
                    depth: 2,
                    colors: !0,
                  })} context:${yr.inspect(i)}`
                ),
                  (e._indent += 2)
              }
              e.enter(i)
            } else if (En) {
              let o = an.triggerAsyncId(),
                s = ' '.repeat(e._indent < 0 ? 0 : e._indent)
              pn(
                `${s}BEFORE MISSING CONTEXT (${t}) asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(
                  e.active,
                  { showHidden: !0, depth: 2, colors: !0 }
                )} namespace._contexts:${yr.inspect(e._contexts, { showHidden: !0, depth: 2, colors: !0 })}`
              ),
                (e._indent += 2)
            }
          },
          after(n) {
            _r = an.executionAsyncId()
            let i
            if (((i = e._contexts.get(n) || e._contexts.get(_r)), i)) {
              if (En) {
                let o = an.triggerAsyncId()
                e._indent -= 2
                let s = ' '.repeat(e._indent < 0 ? 0 : e._indent)
                pn(
                  `${s}AFTER (${t}) asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(e.active, {
                    showHidden: !0,
                    depth: 2,
                    colors: !0,
                  })} context:${yr.inspect(i)}`
                )
              }
              e.exit(i)
            } else if (En) {
              let o = an.triggerAsyncId()
              e._indent -= 2
              let s = ' '.repeat(e._indent < 0 ? 0 : e._indent)
              pn(
                `${s}AFTER MISSING CONTEXT (${t}) asyncId:${n} currentUid:${_r} triggerId:${o} active:${yr.inspect(
                  e.active,
                  { showHidden: !0, depth: 2, colors: !0 }
                )} context:${yr.inspect(i)}`
              )
            }
          },
          destroy(n) {
            if (((_r = an.executionAsyncId()), En)) {
              let i = an.triggerAsyncId(),
                o = ' '.repeat(e._indent < 0 ? 0 : e._indent)
              pn(
                `${o}DESTROY (${t}) currentUid:${_r} asyncId:${n} triggerId:${i} active:${yr.inspect(e.active, {
                  showHidden: !0,
                  depth: 2,
                  colors: !0,
                })} context:${yr.inspect(e._contexts.get(_r))}`
              )
            }
            e._contexts.delete(n)
          },
        })
        .enable(),
      (process.namespaces[t] = e),
      e
    )
  }
  function gle(t) {
    let e = hle(t)
    Op.ok(e, `can't delete nonexistent namespace! "` + t + '"'),
      Op.ok(e.id, "don't assign to process.namespaces directly! " + yr.inspect(e)),
      (process.namespaces[t] = null)
  }
  function u9e() {
    process.namespaces &&
      Object.keys(process.namespaces).forEach(function (t) {
        gle(t)
      }),
      (process.namespaces = Object.create(null))
  }
  process.namespaces = {}
  function pn(...t) {
    En && process._rawDebug(`${yr.format(...t)}`)
  }
})
var xle = handleExports((zCt, yle) => {
  'use strict'
  function p9e() {}
  yle.exports = function () {
    let e = this._hooks,
      r = this._state,
      n = process.nextTick
    process.nextTick = function () {
      if (!r.enabled) return n.apply(process, arguments)
      let i = new Array(arguments.length)
      for (let l = 0; l < arguments.length; l++) i[l] = arguments[l]
      let o = i[0]
      if (typeof o != 'function') throw new TypeError('callback is not a function')
      let s = new p9e(),
        a = --r.counter
      return (
        e.init.call(s, a, 0, null, null),
        (i[0] = function () {
          e.pre.call(s, a)
          let l = !0
          try {
            o.apply(this, arguments), (l = !1)
          } finally {
            l &&
              process.listenerCount('uncaughtException') > 0 &&
              process.once('uncaughtException', function () {
                e.post.call(s, a, !0), e.destroy.call(null, a)
              })
          }
          e.post.call(s, a, !1), e.destroy.call(null, a)
        }),
        n.apply(process, i)
      )
    }
  }
})
var Ele = handleExports(($Ct, ble) => {
  'use strict'
  function d9e() {}
  ble.exports = function () {
    let e = this._hooks,
      r = this._state,
      n = global.Promise,
      i = n.prototype.then
    n.prototype.then = l
    function o(c, u, p, d) {
      return typeof c != 'function'
        ? d
          ? s(p)
          : a(p)
        : function () {
            e.pre.call(u, p)
            try {
              return c.apply(this, arguments)
            } finally {
              e.post.call(u, p, !1), e.destroy.call(null, p)
            }
          }
    }
    function s(c) {
      return function (p) {
        return e.destroy.call(null, c), p
      }
    }
    function a(c) {
      return function (p) {
        throw (e.destroy.call(null, c), p)
      }
    }
    function l(c, u) {
      if (!r.enabled) return i.call(this, c, u)
      let p = new d9e(),
        d = --r.counter
      return e.init.call(p, d, 0, null, null), i.call(this, o(c, p, d, !0), o(u, p, d, !1))
    }
  }
})
var Sle = handleExports((WCt, Tle) => {
  'use strict'
  var ha = require('timers')
  function f9e() {}
  function m9e() {}
  function h9e() {}
  var g9e = new Map(),
    v9e = new Map(),
    _9e = new Map(),
    Z9 = null,
    e7 = !1
  Tle.exports = function () {
    t7(this._hooks, this._state, 'setTimeout', 'clearTimeout', f9e, g9e, !0),
      t7(this._hooks, this._state, 'setInterval', 'clearInterval', m9e, v9e, !1),
      t7(this._hooks, this._state, 'setImmediate', 'clearImmediate', h9e, _9e, !0),
      (global.setTimeout = ha.setTimeout),
      (global.setInterval = ha.setInterval),
      (global.setImmediate = ha.setImmediate),
      (global.clearTimeout = ha.clearTimeout),
      (global.clearInterval = ha.clearInterval),
      (global.clearImmediate = ha.clearImmediate)
  }
  function t7(t, e, r, n, i, o, s) {
    let a = ha[r],
      l = ha[n]
    ;(ha[r] = function () {
      if (!e.enabled) return a.apply(ha, arguments)
      let c = new Array(arguments.length)
      for (let m = 0; m < arguments.length; m++) c[m] = arguments[m]
      let u = c[0]
      if (typeof u != 'function') throw new TypeError('"callback" argument must be a function')
      let p = new i(),
        d = --e.counter,
        f
      return (
        t.init.call(p, d, 0, null, null),
        (c[0] = function () {
          ;(Z9 = f), t.pre.call(p, d)
          let m = !0
          try {
            u.apply(this, arguments), (m = !1)
          } finally {
            m &&
              process.listenerCount('uncaughtException') > 0 &&
              process.once('uncaughtException', function () {
                t.post.call(p, d, !0), o.delete(f), t.destroy.call(null, d)
              })
          }
          t.post.call(p, d, !1), (Z9 = null), (s || e7) && ((e7 = !1), o.delete(f), t.destroy.call(null, d))
        }),
        (f = a.apply(ha, c)),
        o.set(f, d),
        f
      )
    }),
      (ha[n] = function (c) {
        if (Z9 === c && c !== null) e7 = !0
        else if (o.has(c)) {
          let u = o.get(c)
          o.delete(c), t.destroy.call(null, u)
        }
        l.apply(ha, arguments)
      })
  }
})
var r7 = handleExports((KCt, y9e) => {
  y9e.exports = {
    name: 'async-hook-jl',
    description: 'Inspect the life of handle objects in node',
    version: '1.7.6',
    author: 'Andreas Madsen <amwebdk@gmail.com>',
    main: './index.js',
    scripts: { test: 'node ./test/runner.js && eslint .' },
    repository: { type: 'git', url: 'git://github.com/jeff-lewis/async-hook-jl.git' },
    keywords: ['async', 'async hooks', 'inspect', 'async wrap'],
    license: 'MIT',
    dependencies: { 'stack-chain': '^1.3.7' },
    devDependencies: { async: '1.5.x', 'cli-color': '1.1.x', eslint: '^3.4.0', endpoint: '0.4.x' },
    engines: { node: '^4.7 || >=6.9 || >=7.3' },
  }
})
var wle = handleExports((YCt, Ile) => {
  'use strict'
  var jE = process.binding('async_wrap'),
    x9e = jE.Providers.TIMERWRAP,
    Cle = { nextTick: xle(), promise: Ele(), timers: Sle() },
    HE = new Set()
  function b9e() {
    ;(this.enabled = !1), (this.counter = 0)
  }
  function n7() {
    let t = (this.initFns = []),
      e = (this.preFns = []),
      r = (this.postFns = []),
      n = (this.destroyFns = [])
    ;(this.init = function (i, o, s, a) {
      if (o === x9e) {
        HE.add(i)
        return
      }
      for (let l of t) l(i, this, o, s, a)
    }),
      (this.pre = function (i) {
        if (!HE.has(i)) for (let o of e) o(i, this)
      }),
      (this.post = function (i, o) {
        if (!HE.has(i)) for (let s of r) s(i, this, o)
      }),
      (this.destroy = function (i) {
        if (HE.has(i)) {
          HE.delete(i)
          return
        }
        for (let o of n) o(i)
      })
  }
  n7.prototype.add = function (t) {
    t.init && this.initFns.push(t.init),
      t.pre && this.preFns.push(t.pre),
      t.post && this.postFns.push(t.post),
      t.destroy && this.destroyFns.push(t.destroy)
  }
  function FR(t, e) {
    let r = t.indexOf(e)
    r !== -1 && t.splice(r, 1)
  }
  n7.prototype.remove = function (t) {
    t.init && FR(this.initFns, t.init),
      t.pre && FR(this.preFns, t.pre),
      t.post && FR(this.postFns, t.post),
      t.destroy && FR(this.destroyFns, t.destroy)
  }
  function GE() {
    ;(this._state = new b9e()), (this._hooks = new n7()), (this.version = r7().version), (this.providers = jE.Providers)
    for (let t of Object.keys(Cle)) Cle[t].call(this)
    process.env.hasOwnProperty('NODE_ASYNC_HOOK_WARNING') &&
      console.warn('warning: you are using async-hook-jl which is unstable.'),
      jE.setupHooks({
        init: this._hooks.init,
        pre: this._hooks.pre,
        post: this._hooks.post,
        destroy: this._hooks.destroy,
      })
  }
  Ile.exports = GE
  GE.prototype.addHooks = function (t) {
    this._hooks.add(t)
  }
  GE.prototype.removeHooks = function (t) {
    this._hooks.remove(t)
  }
  GE.prototype.enable = function () {
    ;(this._state.enabled = !0), jE.enable()
  }
  GE.prototype.disable = function () {
    ;(this._state.enabled = !1), jE.disable()
  }
})
var i7 = handleExports((QCt, E9e) => {
  E9e.exports = {
    name: 'stack-chain',
    description: 'API for combining call site modifiers',
    version: '1.3.7',
    author: 'Andreas Madsen <amwebdk@gmail.com>',
    scripts: { test: 'tap ./test/simple' },
    repository: { type: 'git', url: 'git://github.com/AndreasMadsen/stack-chain.git' },
    keywords: ['stack', 'chain', 'trace', 'call site', 'concat', 'format'],
    devDependencies: { tap: '2.x.x', 'uglify-js': '2.5.x' },
    license: 'MIT',
  }
})
var Rle = handleExports((XCt, Ale) => {
  function T9e(t) {
    try {
      return Error.prototype.toString.call(t)
    } catch (e) {
      try {
        return '<error: ' + e + '>'
      } catch {
        return '<error>'
      }
    }
  }
  Ale.exports = function (e, r) {
    var n = []
    n.push(T9e(e))
    for (var i = 0; i < r.length; i++) {
      var o = r[i],
        s
      try {
        s = o.toString()
      } catch (a) {
        try {
          s = '<error: ' + a + '>'
        } catch {
          s = '<error>'
        }
      }
      n.push('    at ' + s)
    }
    return n.join(`
`)
  }
})
var kle = handleExports((JCt, Nle) => {
  var UR = Rle()
  function Ple() {
    ;(this.extend = new VE()), (this.filter = new VE()), (this.format = new zE()), (this.version = i7().version)
  }
  var s7 = !1
  Ple.prototype.callSite = function t(e) {
    e || (e = {}), (s7 = !0)
    var r = {}
    Error.captureStackTrace(r, t)
    var n = r.stack
    return (
      (s7 = !1),
      (n = n.slice(e.slice || 0)),
      e.extend && (n = this.extend._modify(r, n)),
      e.filter && (n = this.filter._modify(r, n)),
      n
    )
  }
  var Vf = new Ple()
  function VE() {
    this._modifiers = []
  }
  VE.prototype._modify = function (t, e) {
    for (var r = 0, n = this._modifiers.length; r < n; r++) e = this._modifiers[r](t, e)
    return e
  }
  VE.prototype.attach = function (t) {
    this._modifiers.push(t)
  }
  VE.prototype.deattach = function (t) {
    var e = this._modifiers.indexOf(t)
    return e === -1 ? !1 : (this._modifiers.splice(e, 1), !0)
  }
  function zE() {
    ;(this._formater = UR), (this._previous = void 0)
  }
  zE.prototype.replace = function (t) {
    t ? (this._formater = t) : this.restore()
  }
  zE.prototype.restore = function () {
    ;(this._formater = UR), (this._previous = void 0)
  }
  zE.prototype._backup = function () {
    this._previous = this._formater
  }
  zE.prototype._roolback = function () {
    this._previous === UR ? this.replace(void 0) : this.replace(this._previous), (this._previous = void 0)
  }
  Error.prepareStackTrace && Vf.format.replace(Error.prepareStackTrace)
  var o7 = !1
  function Dle(t, e) {
    if (s7) return e
    if (o7) return UR(t, e)
    var r = e.concat()
    ;(r = Vf.extend._modify(t, r)),
      (r = Vf.filter._modify(t, r)),
      (r = r.slice(0, Error.stackTraceLimit)),
      Object.isExtensible(t) &&
        Object.getOwnPropertyDescriptor(t, 'callSite') === void 0 &&
        (t.callSite = { original: e, mutated: r }),
      (o7 = !0)
    var n = Vf.format._formater(t, r)
    return (o7 = !1), n
  }
  Object.defineProperty(Error, 'prepareStackTrace', {
    get: function () {
      return Dle
    },
    set: function (t) {
      t === Dle ? Vf.format._roolback() : (Vf.format._backup(), Vf.format.replace(t))
    },
  })
  function S9e() {
    return this.stack, this.callSite
  }
  Object.defineProperty(Error.prototype, 'callSite', {
    get: S9e,
    set: function (t) {
      Object.defineProperty(this, 'callSite', { value: t, writable: !0, configurable: !0 })
    },
    configurable: !0,
  })
  Nle.exports = Vf
})
var c7 = handleExports((ZCt, a7) => {
  if (global._stackChain)
    if (global._stackChain.version === i7().version) a7.exports = global._stackChain
    else throw new Error('Conflicting version of stack-chain found')
  else a7.exports = global._stackChain = kle()
})
var Ole = handleExports((eIt, l7) => {
  'use strict'
  var C9e = wle()
  if (global._asyncHook)
    if (global._asyncHook.version === r7().version) l7.exports = global._asyncHook
    else throw new Error('Conflicting version of async-hook-jl found')
  else
    c7().filter.attach(function (e, r) {
      return r.filter(function (n) {
        let i = n.getFileName()
        return !(i && i.slice(0, __dirname.length) === __dirname)
      })
    }),
      (l7.exports = global._asyncHook = new C9e())
})
var qle = handleExports((tIt, Ble) => {
  'use strict'
  var $n = require('util'),
    Lp = require('assert'),
    I9e = MR(),
    ay = Ole(),
    $E = 'cls@contexts',
    WE = 'error@context',
    Mle = []
  for (let t in ay.providers) Mle[ay.providers[t]] = t
  var Ln = process.env.DEBUG_CLS_HOOKED,
    si = -1
  Ble.exports = { getNamespace: Fle, createNamespace: w9e, destroyNamespace: Ule, reset: A9e, ERROR_SYMBOL: WE }
  function Xa(t) {
    ;(this.name = t), (this.active = null), (this._set = []), (this.id = null), (this._contexts = new Map())
  }
  Xa.prototype.set = function (e, r) {
    if (!this.active) throw new Error('No context available. ns.run() or ns.bind() must be called first.')
    return (
      Ln &&
        zn(
          '    SETTING KEY:' +
            e +
            '=' +
            r +
            ' in ns:' +
            this.name +
            ' uid:' +
            si +
            ' active:' +
            $n.inspect(this.active, !0)
        ),
      (this.active[e] = r),
      r
    )
  }
  Xa.prototype.get = function (e) {
    if (!this.active) {
      Ln &&
        zn('    GETTING KEY:' + e + '=undefined ' + this.name + ' uid:' + si + ' active:' + $n.inspect(this.active, !0))
      return
    }
    return (
      Ln &&
        zn(
          '    GETTING KEY:' +
            e +
            '=' +
            this.active[e] +
            ' ' +
            this.name +
            ' uid:' +
            si +
            ' active:' +
            $n.inspect(this.active, !0)
        ),
      this.active[e]
    )
  }
  Xa.prototype.createContext = function () {
    Ln &&
      zn(
        '   CREATING Context: ' +
          this.name +
          ' uid:' +
          si +
          ' len:' +
          this._set.length +
          '  active:' +
          $n.inspect(this.active, !0, 2, !0)
      )
    let e = Object.create(this.active ? this.active : Object.prototype)
    return (
      (e._ns_name = this.name),
      (e.id = si),
      Ln &&
        zn(
          '   CREATED Context: ' +
            this.name +
            ' uid:' +
            si +
            ' len:' +
            this._set.length +
            '  context:' +
            $n.inspect(e, !0, 2, !0)
        ),
      e
    )
  }
  Xa.prototype.run = function (e) {
    let r = this.createContext()
    this.enter(r)
    try {
      return (
        Ln && zn(' BEFORE RUN: ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' ' + $n.inspect(r)), e(r), r
      )
    } catch (n) {
      throw (n && (n[WE] = r), n)
    } finally {
      Ln && zn(' AFTER RUN: ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' ' + $n.inspect(r)),
        this.exit(r)
    }
  }
  Xa.prototype.runAndReturn = function (e) {
    var r
    return (
      this.run(function (n) {
        r = e(n)
      }),
      r
    )
  }
  Xa.prototype.runPromise = function (e) {
    let r = this.createContext()
    this.enter(r)
    let n = e(r)
    if (!n || !n.then || !n.catch) throw new Error('fn must return a promise.')
    return (
      Ln && zn(' BEFORE runPromise: ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' ' + $n.inspect(r)),
      n
        .then(
          i => (
            Ln &&
              zn(' AFTER runPromise: ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' ' + $n.inspect(r)),
            this.exit(r),
            i
          )
        )
        .catch(i => {
          throw (
            ((i[WE] = r),
            Ln &&
              zn(' AFTER runPromise: ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' ' + $n.inspect(r)),
            this.exit(r),
            i)
          )
        })
    )
  }
  Xa.prototype.bind = function (e, r) {
    r || (this.active ? (r = this.active) : (r = this.createContext()))
    let n = this
    return function () {
      n.enter(r)
      try {
        return e.apply(this, arguments)
      } catch (o) {
        throw (o && (o[WE] = r), o)
      } finally {
        n.exit(r)
      }
    }
  }
  Xa.prototype.enter = function (e) {
    Lp.ok(e, 'context must be provided for entering'),
      Ln && zn('  ENTER ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' context: ' + $n.inspect(e)),
      this._set.push(this.active),
      (this.active = e)
  }
  Xa.prototype.exit = function (e) {
    if (
      (Lp.ok(e, 'context must be provided for exiting'),
      Ln && zn('  EXIT ' + this.name + ' uid:' + si + ' len:' + this._set.length + ' context: ' + $n.inspect(e)),
      this.active === e)
    ) {
      Lp.ok(this._set.length, "can't remove top context"), (this.active = this._set.pop())
      return
    }
    let r = this._set.lastIndexOf(e)
    r < 0
      ? (Ln && zn('??ERROR?? context exiting but not entered - ignoring: ' + $n.inspect(e)),
        Lp.ok(
          r >= 0,
          `context not currently entered; can't exit.
` +
            $n.inspect(this) +
            `
` +
            $n.inspect(e)
        ))
      : (Lp.ok(r, "can't remove top context"), this._set.splice(r, 1))
  }
  Xa.prototype.bindEmitter = function (e) {
    Lp.ok(e.on && e.addListener && e.emit, 'can only bind real EEs')
    let r = this,
      n = 'context@' + this.name
    function i(s) {
      s && (s[$E] || (s[$E] = Object.create(null)), (s[$E][n] = { namespace: r, context: r.active }))
    }
    function o(s) {
      if (!(s && s[$E])) return s
      let a = s,
        l = s[$E]
      return (
        Object.keys(l).forEach(function (c) {
          let u = l[c]
          a = u.namespace.bind(a, u.context)
        }),
        a
      )
    }
    I9e(e, i, o)
  }
  Xa.prototype.fromException = function (e) {
    return e[WE]
  }
  function Fle(t) {
    return process.namespaces[t]
  }
  function w9e(t) {
    Lp.ok(t, 'namespace must be given a name.'), Ln && zn('CREATING NAMESPACE ' + t)
    let e = new Xa(t)
    return (
      (e.id = si),
      ay.addHooks({
        init(r, n, i, o, s) {
          ;(si = r),
            o
              ? (e._contexts.set(r, e._contexts.get(o)),
                Ln && zn('PARENTID: ' + t + ' uid:' + r + ' parent:' + o + ' provider:' + i))
              : e._contexts.set(si, e.active),
            Ln &&
              zn(
                'INIT ' +
                  t +
                  ' uid:' +
                  r +
                  ' parent:' +
                  o +
                  ' provider:' +
                  Mle[i] +
                  ' active:' +
                  $n.inspect(e.active, !0)
              )
        },
        pre(r, n) {
          si = r
          let i = e._contexts.get(r)
          i
            ? (Ln && zn(' PRE ' + t + ' uid:' + r + ' handle:' + BR(n) + ' context:' + $n.inspect(i)), e.enter(i))
            : Ln && zn(' PRE MISSING CONTEXT ' + t + ' uid:' + r + ' handle:' + BR(n))
        },
        post(r, n) {
          si = r
          let i = e._contexts.get(r)
          i
            ? (Ln && zn(' POST ' + t + ' uid:' + r + ' handle:' + BR(n) + ' context:' + $n.inspect(i)), e.exit(i))
            : Ln && zn(' POST MISSING CONTEXT ' + t + ' uid:' + r + ' handle:' + BR(n))
        },
        destroy(r) {
          ;(si = r),
            Ln &&
              zn(
                'DESTROY ' +
                  t +
                  ' uid:' +
                  r +
                  ' context:' +
                  $n.inspect(e._contexts.get(si)) +
                  ' active:' +
                  $n.inspect(e.active, !0)
              ),
            e._contexts.delete(r)
        },
      }),
      (process.namespaces[t] = e),
      e
    )
  }
  function Ule(t) {
    let e = Fle(t)
    Lp.ok(e, `can't delete nonexistent namespace! "` + t + '"'),
      Lp.ok(e.id, "don't assign to process.namespaces directly! " + $n.inspect(e)),
      (process.namespaces[t] = null)
  }
  function A9e() {
    process.namespaces &&
      Object.keys(process.namespaces).forEach(function (t) {
        Ule(t)
      }),
      (process.namespaces = Object.create(null))
  }
  process.namespaces = {}
  ay._state && !ay._state.enabled && ay.enable()
  function zn(t) {
    process.env.DEBUG && process._rawDebug(t)
  }
  function BR(t) {
    if (!t) return t
    if (typeof t == 'function')
      return t.name
        ? t.name
        : (t
            .toString()
            .trim()
            .match(/^function\s*([^\s(]+)/) || [])[1]
    if (t.constructor && t.constructor.name) return t.constructor.name
  }
  if (Ln) {
    u7 = c7()
    for (Lle in u7.filter._modifiers) u7.filter.deattach(Lle)
  }
  var u7, Lle
})
var Hle = handleExports((rIt, p7) => {
  'use strict'
  var R9e = ale()
  process && R9e.gte(process.versions.node, '8.0.0') ? (p7.exports = _le()) : (p7.exports = qle())
})
var iue = handleExports((St, nue) => {
  St = nue.exports = tr
  var Dr
  typeof process == 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (Dr = function () {
        var t = Array.prototype.slice.call(arguments, 0)
        t.unshift('SEMVER'), console.log.apply(console, t)
      })
    : (Dr = function () {})
  St.SEMVER_SPEC_VERSION = '2.0.0'
  var KE = 256,
    qR = Number.MAX_SAFE_INTEGER || 9007199254740991,
    d7 = 16,
    D9e = KE - 6,
    YE = (St.re = []),
    $r = (St.safeRe = []),
    De = (St.src = []),
    Xt = 0,
    v7 = '[a-zA-Z0-9-]',
    f7 = [
      ['\\s', 1],
      ['\\d', KE],
      [v7, D9e],
    ]
  function $R(t) {
    for (var e = 0; e < f7.length; e++) {
      var r = f7[e][0],
        n = f7[e][1]
      t = t
        .split(r + '*')
        .join(r + '{0,' + n + '}')
        .split(r + '+')
        .join(r + '{1,' + n + '}')
    }
    return t
  }
  var cy = Xt++
  De[cy] = '0|[1-9]\\d*'
  var ly = Xt++
  De[ly] = '\\d+'
  var _7 = Xt++
  De[_7] = '\\d*[a-zA-Z-]' + v7 + '*'
  var Gle = Xt++
  De[Gle] = '(' + De[cy] + ')\\.(' + De[cy] + ')\\.(' + De[cy] + ')'
  var Vle = Xt++
  De[Vle] = '(' + De[ly] + ')\\.(' + De[ly] + ')\\.(' + De[ly] + ')'
  var m7 = Xt++
  De[m7] = '(?:' + De[cy] + '|' + De[_7] + ')'
  var h7 = Xt++
  De[h7] = '(?:' + De[ly] + '|' + De[_7] + ')'
  var y7 = Xt++
  De[y7] = '(?:-(' + De[m7] + '(?:\\.' + De[m7] + ')*))'
  var x7 = Xt++
  De[x7] = '(?:-?(' + De[h7] + '(?:\\.' + De[h7] + ')*))'
  var g7 = Xt++
  De[g7] = v7 + '+'
  var XE = Xt++
  De[XE] = '(?:\\+(' + De[g7] + '(?:\\.' + De[g7] + ')*))'
  var b7 = Xt++,
    zle = 'v?' + De[Gle] + De[y7] + '?' + De[XE] + '?'
  De[b7] = '^' + zle + '$'
  var E7 = '[v=\\s]*' + De[Vle] + De[x7] + '?' + De[XE] + '?',
    T7 = Xt++
  De[T7] = '^' + E7 + '$'
  var my = Xt++
  De[my] = '((?:<|>)?=?)'
  var HR = Xt++
  De[HR] = De[ly] + '|x|X|\\*'
  var jR = Xt++
  De[jR] = De[cy] + '|x|X|\\*'
  var Kg = Xt++
  De[Kg] = '[v=\\s]*(' + De[jR] + ')(?:\\.(' + De[jR] + ')(?:\\.(' + De[jR] + ')(?:' + De[y7] + ')?' + De[XE] + '?)?)?'
  var py = Xt++
  De[py] = '[v=\\s]*(' + De[HR] + ')(?:\\.(' + De[HR] + ')(?:\\.(' + De[HR] + ')(?:' + De[x7] + ')?' + De[XE] + '?)?)?'
  var $le = Xt++
  De[$le] = '^' + De[my] + '\\s*' + De[Kg] + '$'
  var Wle = Xt++
  De[Wle] = '^' + De[my] + '\\s*' + De[py] + '$'
  var Kle = Xt++
  De[Kle] = '(?:^|[^\\d])(\\d{1,' + d7 + '})(?:\\.(\\d{1,' + d7 + '}))?(?:\\.(\\d{1,' + d7 + '}))?(?:$|[^\\d])'
  var WR = Xt++
  De[WR] = '(?:~>?)'
  var dy = Xt++
  De[dy] = '(\\s*)' + De[WR] + '\\s+'
  YE[dy] = new RegExp(De[dy], 'g')
  $r[dy] = new RegExp($R(De[dy]), 'g')
  var P9e = '$1~',
    Yle = Xt++
  De[Yle] = '^' + De[WR] + De[Kg] + '$'
  var Qle = Xt++
  De[Qle] = '^' + De[WR] + De[py] + '$'
  var KR = Xt++
  De[KR] = '(?:\\^)'
  var fy = Xt++
  De[fy] = '(\\s*)' + De[KR] + '\\s+'
  YE[fy] = new RegExp(De[fy], 'g')
  $r[fy] = new RegExp($R(De[fy]), 'g')
  var N9e = '$1^',
    Xle = Xt++
  De[Xle] = '^' + De[KR] + De[Kg] + '$'
  var Jle = Xt++
  De[Jle] = '^' + De[KR] + De[py] + '$'
  var S7 = Xt++
  De[S7] = '^' + De[my] + '\\s*(' + E7 + ')$|^$'
  var C7 = Xt++
  De[C7] = '^' + De[my] + '\\s*(' + zle + ')$|^$'
  var Yg = Xt++
  De[Yg] = '(\\s*)' + De[my] + '\\s*(' + E7 + '|' + De[Kg] + ')'
  YE[Yg] = new RegExp(De[Yg], 'g')
  $r[Yg] = new RegExp($R(De[Yg]), 'g')
  var k9e = '$1$2$3',
    Zle = Xt++
  De[Zle] = '^\\s*(' + De[Kg] + ')\\s+-\\s+(' + De[Kg] + ')\\s*$'
  var eue = Xt++
  De[eue] = '^\\s*(' + De[py] + ')\\s+-\\s+(' + De[py] + ')\\s*$'
  var tue = Xt++
  De[tue] = '(<|>)?=?\\s*\\*'
  for (eu = 0; eu < Xt; eu++)
    Dr(eu, De[eu]), YE[eu] || ((YE[eu] = new RegExp(De[eu])), ($r[eu] = new RegExp($R(De[eu]))))
  var eu
  St.parse = Qg
  function Qg(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof tr)) return t
    if (typeof t != 'string' || t.length > KE) return null
    var r = e.loose ? $r[T7] : $r[b7]
    if (!r.test(t)) return null
    try {
      return new tr(t, e)
    } catch {
      return null
    }
  }
  St.valid = O9e
  function O9e(t, e) {
    var r = Qg(t, e)
    return r ? r.version : null
  }
  St.clean = L9e
  function L9e(t, e) {
    var r = Qg(t.trim().replace(/^[=v]+/, ''), e)
    return r ? r.version : null
  }
  St.SemVer = tr
  function tr(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof tr)) {
      if (t.loose === e.loose) return t
      t = t.version
    } else if (typeof t != 'string') throw new TypeError('Invalid Version: ' + t)
    if (t.length > KE) throw new TypeError('version is longer than ' + KE + ' characters')
    if (!(this instanceof tr)) return new tr(t, e)
    Dr('SemVer', t, e), (this.options = e), (this.loose = !!e.loose)
    var r = t.trim().match(e.loose ? $r[T7] : $r[b7])
    if (!r) throw new TypeError('Invalid Version: ' + t)
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > qR || this.major < 0)
    )
      throw new TypeError('Invalid major version')
    if (this.minor > qR || this.minor < 0) throw new TypeError('Invalid minor version')
    if (this.patch > qR || this.patch < 0) throw new TypeError('Invalid patch version')
    r[4]
      ? (this.prerelease = r[4].split('.').map(function (n) {
          if (/^[0-9]+$/.test(n)) {
            var i = +n
            if (i >= 0 && i < qR) return i
          }
          return n
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split('.') : []),
      this.format()
  }
  tr.prototype.format = function () {
    return (
      (this.version = this.major + '.' + this.minor + '.' + this.patch),
      this.prerelease.length && (this.version += '-' + this.prerelease.join('.')),
      this.version
    )
  }
  tr.prototype.toString = function () {
    return this.version
  }
  tr.prototype.compare = function (t) {
    return (
      Dr('SemVer.compare', this.version, this.options, t),
      t instanceof tr || (t = new tr(t, this.options)),
      this.compareMain(t) || this.comparePre(t)
    )
  }
  tr.prototype.compareMain = function (t) {
    return (
      t instanceof tr || (t = new tr(t, this.options)),
      uy(this.major, t.major) || uy(this.minor, t.minor) || uy(this.patch, t.patch)
    )
  }
  tr.prototype.comparePre = function (t) {
    if ((t instanceof tr || (t = new tr(t, this.options)), this.prerelease.length && !t.prerelease.length)) return -1
    if (!this.prerelease.length && t.prerelease.length) return 1
    if (!this.prerelease.length && !t.prerelease.length) return 0
    var e = 0
    do {
      var r = this.prerelease[e],
        n = t.prerelease[e]
      if ((Dr('prerelease compare', e, r, n), r === void 0 && n === void 0)) return 0
      if (n === void 0) return 1
      if (r === void 0) return -1
      if (r === n) continue
      return uy(r, n)
    } while (++e)
  }
  tr.prototype.inc = function (t, e) {
    switch (t) {
      case 'premajor':
        ;(this.prerelease.length = 0), (this.patch = 0), (this.minor = 0), this.major++, this.inc('pre', e)
        break
      case 'preminor':
        ;(this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', e)
        break
      case 'prepatch':
        ;(this.prerelease.length = 0), this.inc('patch', e), this.inc('pre', e)
        break
      case 'prerelease':
        this.prerelease.length === 0 && this.inc('patch', e), this.inc('pre', e)
        break
      case 'major':
        ;(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = [])
        break
      case 'minor':
        ;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++, (this.patch = 0), (this.prerelease = [])
        break
      case 'patch':
        this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
        break
      case 'pre':
        if (this.prerelease.length === 0) this.prerelease = [0]
        else {
          for (var r = this.prerelease.length; --r >= 0; )
            typeof this.prerelease[r] == 'number' && (this.prerelease[r]++, (r = -2))
          r === -1 && this.prerelease.push(0)
        }
        e &&
          (this.prerelease[0] === e
            ? isNaN(this.prerelease[1]) && (this.prerelease = [e, 0])
            : (this.prerelease = [e, 0]))
        break
      default:
        throw new Error('invalid increment argument: ' + t)
    }
    return this.format(), (this.raw = this.version), this
  }
  St.inc = M9e
  function M9e(t, e, r, n) {
    typeof r == 'string' && ((n = r), (r = void 0))
    try {
      return new tr(t, r).inc(e, n).version
    } catch {
      return null
    }
  }
  St.diff = F9e
  function F9e(t, e) {
    if (I7(t, e)) return null
    var r = Qg(t),
      n = Qg(e),
      i = ''
    if (r.prerelease.length || n.prerelease.length) {
      i = 'pre'
      var o = 'prerelease'
    }
    for (var s in r) if ((s === 'major' || s === 'minor' || s === 'patch') && r[s] !== n[s]) return i + s
    return o
  }
  St.compareIdentifiers = uy
  var jle = /^[0-9]+$/
  function uy(t, e) {
    var r = jle.test(t),
      n = jle.test(e)
    return r && n && ((t = +t), (e = +e)), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1
  }
  St.rcompareIdentifiers = U9e
  function U9e(t, e) {
    return uy(e, t)
  }
  St.major = B9e
  function B9e(t, e) {
    return new tr(t, e).major
  }
  St.minor = q9e
  function q9e(t, e) {
    return new tr(t, e).minor
  }
  St.patch = H9e
  function H9e(t, e) {
    return new tr(t, e).patch
  }
  St.compare = Mp
  function Mp(t, e, r) {
    return new tr(t, r).compare(new tr(e, r))
  }
  St.compareLoose = j9e
  function j9e(t, e) {
    return Mp(t, e, !0)
  }
  St.rcompare = G9e
  function G9e(t, e, r) {
    return Mp(e, t, r)
  }
  St.sort = V9e
  function V9e(t, e) {
    return t.sort(function (r, n) {
      return St.compare(r, n, e)
    })
  }
  St.rsort = z9e
  function z9e(t, e) {
    return t.sort(function (r, n) {
      return St.rcompare(r, n, e)
    })
  }
  St.gt = QE
  function QE(t, e, r) {
    return Mp(t, e, r) > 0
  }
  St.lt = GR
  function GR(t, e, r) {
    return Mp(t, e, r) < 0
  }
  St.eq = I7
  function I7(t, e, r) {
    return Mp(t, e, r) === 0
  }
  St.neq = rue
  function rue(t, e, r) {
    return Mp(t, e, r) !== 0
  }
  St.gte = w7
  function w7(t, e, r) {
    return Mp(t, e, r) >= 0
  }
  St.lte = A7
  function A7(t, e, r) {
    return Mp(t, e, r) <= 0
  }
  St.cmp = VR
  function VR(t, e, r, n) {
    switch (e) {
      case '===':
        return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t === r
      case '!==':
        return typeof t == 'object' && (t = t.version), typeof r == 'object' && (r = r.version), t !== r
      case '':
      case '=':
      case '==':
        return I7(t, r, n)
      case '!=':
        return rue(t, r, n)
      case '>':
        return QE(t, r, n)
      case '>=':
        return w7(t, r, n)
      case '<':
        return GR(t, r, n)
      case '<=':
        return A7(t, r, n)
      default:
        throw new TypeError('Invalid operator: ' + e)
    }
  }
  St.Comparator = Ja
  function Ja(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof Ja)) {
      if (t.loose === !!e.loose) return t
      t = t.value
    }
    if (!(this instanceof Ja)) return new Ja(t, e)
    ;(t = t.trim().split(/\s+/).join(' ')),
      Dr('comparator', t, e),
      (this.options = e),
      (this.loose = !!e.loose),
      this.parse(t),
      this.semver === JE ? (this.value = '') : (this.value = this.operator + this.semver.version),
      Dr('comp', this)
  }
  var JE = {}
  Ja.prototype.parse = function (t) {
    var e = this.options.loose ? $r[S7] : $r[C7],
      r = t.match(e)
    if (!r) throw new TypeError('Invalid comparator: ' + t)
    ;(this.operator = r[1]),
      this.operator === '=' && (this.operator = ''),
      r[2] ? (this.semver = new tr(r[2], this.options.loose)) : (this.semver = JE)
  }
  Ja.prototype.toString = function () {
    return this.value
  }
  Ja.prototype.test = function (t) {
    return (
      Dr('Comparator.test', t, this.options.loose),
      this.semver === JE
        ? !0
        : (typeof t == 'string' && (t = new tr(t, this.options)), VR(t, this.operator, this.semver, this.options))
    )
  }
  Ja.prototype.intersects = function (t, e) {
    if (!(t instanceof Ja)) throw new TypeError('a Comparator is required')
    ;(!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 })
    var r
    if (this.operator === '') return (r = new Tn(t.value, e)), zR(this.value, r, e)
    if (t.operator === '') return (r = new Tn(this.value, e)), zR(t.semver, r, e)
    var n = (this.operator === '>=' || this.operator === '>') && (t.operator === '>=' || t.operator === '>'),
      i = (this.operator === '<=' || this.operator === '<') && (t.operator === '<=' || t.operator === '<'),
      o = this.semver.version === t.semver.version,
      s = (this.operator === '>=' || this.operator === '<=') && (t.operator === '>=' || t.operator === '<='),
      a =
        VR(this.semver, '<', t.semver, e) &&
        (this.operator === '>=' || this.operator === '>') &&
        (t.operator === '<=' || t.operator === '<'),
      l =
        VR(this.semver, '>', t.semver, e) &&
        (this.operator === '<=' || this.operator === '<') &&
        (t.operator === '>=' || t.operator === '>')
    return n || i || (o && s) || a || l
  }
  St.Range = Tn
  function Tn(t, e) {
    if (((!e || typeof e != 'object') && (e = { loose: !!e, includePrerelease: !1 }), t instanceof Tn))
      return t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease ? t : new Tn(t.raw, e)
    if (t instanceof Ja) return new Tn(t.value, e)
    if (!(this instanceof Tn)) return new Tn(t, e)
    if (
      ((this.options = e),
      (this.loose = !!e.loose),
      (this.includePrerelease = !!e.includePrerelease),
      (this.raw = t.trim().split(/\s+/).join(' ')),
      (this.set = this.raw
        .split('||')
        .map(function (r) {
          return this.parseRange(r.trim())
        }, this)
        .filter(function (r) {
          return r.length
        })),
      !this.set.length)
    )
      throw new TypeError('Invalid SemVer Range: ' + this.raw)
    this.format()
  }
  Tn.prototype.format = function () {
    return (
      (this.range = this.set
        .map(function (t) {
          return t.join(' ').trim()
        })
        .join('||')
        .trim()),
      this.range
    )
  }
  Tn.prototype.toString = function () {
    return this.range
  }
  Tn.prototype.parseRange = function (t) {
    var e = this.options.loose,
      r = e ? $r[eue] : $r[Zle]
    ;(t = t.replace(r, t7e)),
      Dr('hyphen replace', t),
      (t = t.replace($r[Yg], k9e)),
      Dr('comparator trim', t, $r[Yg]),
      (t = t.replace($r[dy], P9e)),
      (t = t.replace($r[fy], N9e))
    var n = e ? $r[S7] : $r[C7],
      i = t
        .split(' ')
        .map(function (o) {
          return W9e(o, this.options)
        }, this)
        .join(' ')
        .split(/\s+/)
    return (
      this.options.loose &&
        (i = i.filter(function (o) {
          return !!o.match(n)
        })),
      (i = i.map(function (o) {
        return new Ja(o, this.options)
      }, this)),
      i
    )
  }
  Tn.prototype.intersects = function (t, e) {
    if (!(t instanceof Tn)) throw new TypeError('a Range is required')
    return this.set.some(function (r) {
      return r.every(function (n) {
        return t.set.some(function (i) {
          return i.every(function (o) {
            return n.intersects(o, e)
          })
        })
      })
    })
  }
  St.toComparators = $9e
  function $9e(t, e) {
    return new Tn(t, e).set.map(function (r) {
      return r
        .map(function (n) {
          return n.value
        })
        .join(' ')
        .trim()
        .split(' ')
    })
  }
  function W9e(t, e) {
    return (
      Dr('comp', t, e),
      (t = Q9e(t, e)),
      Dr('caret', t),
      (t = K9e(t, e)),
      Dr('tildes', t),
      (t = J9e(t, e)),
      Dr('xrange', t),
      (t = e7e(t, e)),
      Dr('stars', t),
      t
    )
  }
  function os(t) {
    return !t || t.toLowerCase() === 'x' || t === '*'
  }
  function K9e(t, e) {
    return t
      .trim()
      .split(/\s+/)
      .map(function (r) {
        return Y9e(r, e)
      })
      .join(' ')
  }
  function Y9e(t, e) {
    var r = e.loose ? $r[Qle] : $r[Yle]
    return t.replace(r, function (n, i, o, s, a) {
      Dr('tilde', t, n, i, o, s, a)
      var l
      return (
        os(i)
          ? (l = '')
          : os(o)
          ? (l = '>=' + i + '.0.0 <' + (+i + 1) + '.0.0')
          : os(s)
          ? (l = '>=' + i + '.' + o + '.0 <' + i + '.' + (+o + 1) + '.0')
          : a
          ? (Dr('replaceTilde pr', a), (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + (+o + 1) + '.0'))
          : (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + (+o + 1) + '.0'),
        Dr('tilde return', l),
        l
      )
    })
  }
  function Q9e(t, e) {
    return t
      .trim()
      .split(/\s+/)
      .map(function (r) {
        return X9e(r, e)
      })
      .join(' ')
  }
  function X9e(t, e) {
    Dr('caret', t, e)
    var r = e.loose ? $r[Jle] : $r[Xle]
    return t.replace(r, function (n, i, o, s, a) {
      Dr('caret', t, n, i, o, s, a)
      var l
      return (
        os(i)
          ? (l = '')
          : os(o)
          ? (l = '>=' + i + '.0.0 <' + (+i + 1) + '.0.0')
          : os(s)
          ? i === '0'
            ? (l = '>=' + i + '.' + o + '.0 <' + i + '.' + (+o + 1) + '.0')
            : (l = '>=' + i + '.' + o + '.0 <' + (+i + 1) + '.0.0')
          : a
          ? (Dr('replaceCaret pr', a),
            i === '0'
              ? o === '0'
                ? (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + o + '.' + (+s + 1))
                : (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + i + '.' + (+o + 1) + '.0')
              : (l = '>=' + i + '.' + o + '.' + s + '-' + a + ' <' + (+i + 1) + '.0.0'))
          : (Dr('no pr'),
            i === '0'
              ? o === '0'
                ? (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + o + '.' + (+s + 1))
                : (l = '>=' + i + '.' + o + '.' + s + ' <' + i + '.' + (+o + 1) + '.0')
              : (l = '>=' + i + '.' + o + '.' + s + ' <' + (+i + 1) + '.0.0')),
        Dr('caret return', l),
        l
      )
    })
  }
  function J9e(t, e) {
    return (
      Dr('replaceXRanges', t, e),
      t
        .split(/\s+/)
        .map(function (r) {
          return Z9e(r, e)
        })
        .join(' ')
    )
  }
  function Z9e(t, e) {
    t = t.trim()
    var r = e.loose ? $r[Wle] : $r[$le]
    return t.replace(r, function (n, i, o, s, a, l) {
      Dr('xRange', t, n, i, o, s, a, l)
      var c = os(o),
        u = c || os(s),
        p = u || os(a),
        d = p
      return (
        i === '=' && d && (i = ''),
        c
          ? i === '>' || i === '<'
            ? (n = '<0.0.0')
            : (n = '*')
          : i && d
          ? (u && (s = 0),
            (a = 0),
            i === '>'
              ? ((i = '>='), u ? ((o = +o + 1), (s = 0), (a = 0)) : ((s = +s + 1), (a = 0)))
              : i === '<=' && ((i = '<'), u ? (o = +o + 1) : (s = +s + 1)),
            (n = i + o + '.' + s + '.' + a))
          : u
          ? (n = '>=' + o + '.0.0 <' + (+o + 1) + '.0.0')
          : p && (n = '>=' + o + '.' + s + '.0 <' + o + '.' + (+s + 1) + '.0'),
        Dr('xRange return', n),
        n
      )
    })
  }
  function e7e(t, e) {
    return Dr('replaceStars', t, e), t.trim().replace($r[tue], '')
  }
  function t7e(t, e, r, n, i, o, s, a, l, c, u, p, d) {
    return (
      os(r) ? (e = '') : os(n) ? (e = '>=' + r + '.0.0') : os(i) ? (e = '>=' + r + '.' + n + '.0') : (e = '>=' + e),
      os(l)
        ? (a = '')
        : os(c)
        ? (a = '<' + (+l + 1) + '.0.0')
        : os(u)
        ? (a = '<' + l + '.' + (+c + 1) + '.0')
        : p
        ? (a = '<=' + l + '.' + c + '.' + u + '-' + p)
        : (a = '<=' + a),
      (e + ' ' + a).trim()
    )
  }
  Tn.prototype.test = function (t) {
    if (!t) return !1
    typeof t == 'string' && (t = new tr(t, this.options))
    for (var e = 0; e < this.set.length; e++) if (r7e(this.set[e], t, this.options)) return !0
    return !1
  }
  function r7e(t, e, r) {
    for (var n = 0; n < t.length; n++) if (!t[n].test(e)) return !1
    if (e.prerelease.length && !r.includePrerelease) {
      for (n = 0; n < t.length; n++)
        if ((Dr(t[n].semver), t[n].semver !== JE && t[n].semver.prerelease.length > 0)) {
          var i = t[n].semver
          if (i.major === e.major && i.minor === e.minor && i.patch === e.patch) return !0
        }
      return !1
    }
    return !0
  }
  St.satisfies = zR
  function zR(t, e, r) {
    try {
      e = new Tn(e, r)
    } catch {
      return !1
    }
    return e.test(t)
  }
  St.maxSatisfying = n7e
  function n7e(t, e, r) {
    var n = null,
      i = null
    try {
      var o = new Tn(e, r)
    } catch {
      return null
    }
    return (
      t.forEach(function (s) {
        o.test(s) && (!n || i.compare(s) === -1) && ((n = s), (i = new tr(n, r)))
      }),
      n
    )
  }
  St.minSatisfying = i7e
  function i7e(t, e, r) {
    var n = null,
      i = null
    try {
      var o = new Tn(e, r)
    } catch {
      return null
    }
    return (
      t.forEach(function (s) {
        o.test(s) && (!n || i.compare(s) === 1) && ((n = s), (i = new tr(n, r)))
      }),
      n
    )
  }
  St.minVersion = o7e
  function o7e(t, e) {
    t = new Tn(t, e)
    var r = new tr('0.0.0')
    if (t.test(r) || ((r = new tr('0.0.0-0')), t.test(r))) return r
    r = null
    for (var n = 0; n < t.set.length; ++n) {
      var i = t.set[n]
      i.forEach(function (o) {
        var s = new tr(o.semver.version)
        switch (o.operator) {
          case '>':
            s.prerelease.length === 0 ? s.patch++ : s.prerelease.push(0), (s.raw = s.format())
          case '':
          case '>=':
            ;(!r || QE(r, s)) && (r = s)
            break
          case '<':
          case '<=':
            break
          default:
            throw new Error('Unexpected operation: ' + o.operator)
        }
      })
    }
    return r && t.test(r) ? r : null
  }
  St.validRange = s7e
  function s7e(t, e) {
    try {
      return new Tn(t, e).range || '*'
    } catch {
      return null
    }
  }
  St.ltr = a7e
  function a7e(t, e, r) {
    return R7(t, e, '<', r)
  }
  St.gtr = c7e
  function c7e(t, e, r) {
    return R7(t, e, '>', r)
  }
  St.outside = R7
  function R7(t, e, r, n) {
    ;(t = new tr(t, n)), (e = new Tn(e, n))
    var i, o, s, a, l
    switch (r) {
      case '>':
        ;(i = QE), (o = A7), (s = GR), (a = '>'), (l = '>=')
        break
      case '<':
        ;(i = GR), (o = w7), (s = QE), (a = '<'), (l = '<=')
        break
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }
    if (zR(t, e, n)) return !1
    for (var c = 0; c < e.set.length; ++c) {
      var u = e.set[c],
        p = null,
        d = null
      if (
        (u.forEach(function (f) {
          f.semver === JE && (f = new Ja('>=0.0.0')),
            (p = p || f),
            (d = d || f),
            i(f.semver, p.semver, n) ? (p = f) : s(f.semver, d.semver, n) && (d = f)
        }),
        p.operator === a || p.operator === l || ((!d.operator || d.operator === a) && o(t, d.semver)))
      )
        return !1
      if (d.operator === l && s(t, d.semver)) return !1
    }
    return !0
  }
  St.prerelease = l7e
  function l7e(t, e) {
    var r = Qg(t, e)
    return r && r.prerelease.length ? r.prerelease : null
  }
  St.intersects = u7e
  function u7e(t, e, r) {
    return (t = new Tn(t, r)), (e = new Tn(e, r)), t.intersects(e)
  }
  St.coerce = p7e
  function p7e(t) {
    if (t instanceof tr) return t
    if (typeof t != 'string') return null
    var e = t.match($r[Kle])
    return e == null ? null : Qg(e[1] + '.' + (e[2] || '0') + '.' + (e[3] || '0'))
  }
})
var aue = handleExports((nIt, sue) => {
  var d7e = kR().wrap,
    P7 = 1,
    N7 = 2,
    k7 = 4,
    QR = 8,
    Ur = [],
    f7e = 0,
    Do = !1,
    zf = [],
    hy,
    O7
  function L7(t, e) {
    var r = t.length,
      n = e.length,
      i = []
    if (r === 0 && n === 0) return i
    for (var o = 0; o < r; o++) i[o] = t[o]
    if (n === 0) return i
    for (var s = 0; s < n; s++) {
      var a = !0
      for (o = 0; o < r; o++)
        if (t[o].uid === e[s].uid) {
          a = !1
          break
        }
      a && i.push(e[s])
    }
    return i
  }
  process._fatalException
    ? ((YR = !1),
      (hy = function (e) {
        var r = Ur.length
        if (YR || r === 0) return !1
        var n = !1
        YR = !0
        for (var i = 0; i < r; ++i) {
          var o = Ur[i]
          if (o.flags & QR) {
            var s = gy && gy[o.uid]
            n = o.error(s, e) || n
          }
        }
        return (YR = !1), zf.length > 0 && (Ur = zf.pop()), (gy = void 0), n && !Do
      }),
      (O7 = function (e, r, n) {
        var i = []
        Do = !0
        for (var o = 0; o < n; ++o) {
          var s = r[o]
          if (((i[s.uid] = s.data), !!(s.flags & P7))) {
            var a = s.create(s.data)
            a !== void 0 && (i[s.uid] = a)
          }
        }
        return (
          (Do = !1),
          function () {
            ;(gy = i), zf.push(Ur), (Ur = L7(r, Ur)), (Do = !0)
            for (var l = 0; l < n; ++l) (r[l].flags & N7) > 0 && r[l].before(this, i[r[l].uid])
            Do = !1
            var c = e.apply(this, arguments)
            for (Do = !0, l = 0; l < n; ++l) (r[l].flags & k7) > 0 && r[l].after(this, i[r[l].uid])
            return (Do = !1), (Ur = zf.pop()), (gy = void 0), c
          }
        )
      }),
      d7e(process, '_fatalException', function (t) {
        return function (r) {
          return hy(r) || t(r)
        }
      }))
    : ((D7 = !1),
      (hy = function (e) {
        if (D7) throw e
        for (var r = !1, n = Ur.length, i = 0; i < n; ++i) {
          var o = Ur[i]
          o.flags & QR && (r = o.error(null, e) || r)
        }
        if (!r && Do) throw e
      }),
      (O7 = function (e, r, n) {
        var i = []
        Do = !0
        for (var o = 0; o < n; ++o) {
          var s = r[o]
          if (((i[s.uid] = s.data), !!(s.flags & P7))) {
            var a = s.create(s.data)
            a !== void 0 && (i[s.uid] = a)
          }
        }
        return (
          (Do = !1),
          function () {
            var l = !1,
              c = !1
            zf.push(Ur), (Ur = L7(r, Ur)), (Do = !0)
            for (var u = 0; u < n; ++u) (r[u].flags & N7) > 0 && r[u].before(this, i[r[u].uid])
            Do = !1
            var p
            try {
              p = e.apply(this, arguments)
            } catch (d) {
              l = !0
              for (var u = 0; u < n; ++u)
                if (Ur[u].flags & QR)
                  try {
                    c = Ur[u].error(i[r[u].uid], d) || c
                  } catch (m) {
                    throw ((D7 = !0), m)
                  }
              if (!c)
                throw (
                  (process.removeListener('uncaughtException', hy),
                  process._originalNextTick(function () {
                    process.addListener('uncaughtException', hy)
                  }),
                  d)
                )
            } finally {
              if (!l || c) {
                for (Do = !0, u = 0; u < n; ++u) (r[u].flags & k7) > 0 && r[u].after(this, i[r[u].uid])
                Do = !1
              }
              Ur = zf.pop()
            }
            return p
          }
        )
      }),
      process.addListener('uncaughtException', hy))
  var YR, gy, D7
  function m7e(t, e, r) {
    Do = !0
    for (var n = 0; n < r; ++n) {
      var i = e[n]
      i.create && i.create(i.data)
    }
    return (
      (Do = !1),
      function () {
        zf.push(Ur), (Ur = L7(e, Ur))
        var o = t.apply(this, arguments)
        return (Ur = zf.pop()), o
      }
    )
  }
  function h7e(t) {
    var e = Ur.length
    if (e === 0) return t
    for (var r = Ur.slice(), n = 0; n < e; ++n) if (r[n].flags > 0) return O7(t, r, e)
    return m7e(t, r, e)
  }
  function tu(t, e) {
    typeof t.create == 'function' && ((this.create = t.create), (this.flags |= P7)),
      typeof t.before == 'function' && ((this.before = t.before), (this.flags |= N7)),
      typeof t.after == 'function' && ((this.after = t.after), (this.flags |= k7)),
      typeof t.error == 'function' && ((this.error = t.error), (this.flags |= QR)),
      (this.uid = ++f7e),
      (this.data = e === void 0 ? null : e)
  }
  tu.prototype.create = void 0
  tu.prototype.before = void 0
  tu.prototype.after = void 0
  tu.prototype.error = void 0
  tu.prototype.data = void 0
  tu.prototype.uid = 0
  tu.prototype.flags = 0
  function oue(t, e) {
    if (typeof t != 'object' || !t) throw new TypeError('callbacks argument must be an object')
    return t instanceof tu ? t : new tu(t, e)
  }
  function g7e(t, e) {
    var r
    t instanceof tu ? (r = t) : (r = oue(t, e))
    for (var n = !1, i = 0; i < Ur.length; i++)
      if (r === Ur[i]) {
        n = !0
        break
      }
    return n || Ur.push(r), r
  }
  function v7e(t) {
    for (var e = 0; e < Ur.length; e++)
      if (t === Ur[e]) {
        Ur.splice(e, 1)
        break
      }
  }
  process.createAsyncListener = oue
  process.addAsyncListener = g7e
  process.removeAsyncListener = v7e
  sue.exports = h7e
})
var lue = handleExports((oIt, cue) => {
  'use strict'
  cue.exports = (t, e) =>
    class extends t {
      constructor(n) {
        var i, o
        super(a)
        var s = this
        try {
          n.apply(i, o)
        } catch (l) {
          o[1](l)
        }
        return s
        function a(l, c) {
          ;(i = this), (o = [u, p])
          function u(d) {
            return e(s, !1), l(d)
          }
          function p(d) {
            return e(s, !1), c(d)
          }
        }
      }
    }
})
var gue = handleExports(() => {
  'use strict'
  if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed")
  var fue = kR(),
    JR = iue(),
    Rs = fue.wrap,
    $f = fue.massWrap,
    Sn = aue(),
    _7e = require('util'),
    y7e = JR.gte(process.version, '6.0.0'),
    U7 = JR.gte(process.version, '7.0.0'),
    x7e = JR.gte(process.version, '8.0.0'),
    b7e = JR.gte(process.version, '11.0.0'),
    ru = require('net')
  U7 && !ru._normalizeArgs
    ? (ru._normalizeArgs = function (t) {
        if (t.length === 0) return [{}, null]
        var e = t[0],
          r = {}
        typeof e == 'object' && e !== null
          ? (r = e)
          : I7e(e)
          ? (r.path = e)
          : ((r.port = e), t.length > 1 && typeof t[1] == 'string' && (r.host = t[1]))
        var n = t[t.length - 1]
        return typeof n != 'function' ? [r, null] : [r, n]
      })
    : !U7 &&
      !ru._normalizeConnectArgs &&
      (ru._normalizeConnectArgs = function (t) {
        var e = {}
        function r(i) {
          return (i = Number(i)) >= 0 ? i : !1
        }
        typeof t[0] == 'object' && t[0] !== null
          ? (e = t[0])
          : typeof t[0] == 'string' && r(t[0]) === !1
          ? (e.path = t[0])
          : ((e.port = t[0]), typeof t[1] == 'string' && (e.host = t[1]))
        var n = t[t.length - 1]
        return typeof n == 'function' ? [e, n] : [e]
      })
  '_setUpListenHandle' in ru.Server.prototype
    ? Rs(ru.Server.prototype, '_setUpListenHandle', uue)
    : Rs(ru.Server.prototype, '_listen2', uue)
  function uue(t) {
    return function () {
      this.on('connection', function (e) {
        e._handle && (e._handle.onread = Sn(e._handle.onread))
      })
      try {
        return t.apply(this, arguments)
      } finally {
        this._handle && this._handle.onconnection && (this._handle.onconnection = Sn(this._handle.onconnection))
      }
    }
  }
  function mue(t) {
    if (t && t._handle) {
      var e = t._handle
      e._originalOnread || (e._originalOnread = e.onread), (e.onread = Sn(e._originalOnread))
    }
  }
  Rs(ru.Socket.prototype, 'connect', function (t) {
    return function () {
      var e
      x7e && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0
        ? (e = arguments[0])
        : (e = U7 ? ru._normalizeArgs(arguments) : ru._normalizeConnectArgs(arguments)),
        e[1] && (e[1] = Sn(e[1]))
      var r = t.apply(this, e)
      return mue(this), r
    }
  })
  var E7e = require('http')
  Rs(E7e.Agent.prototype, 'addRequest', function (t) {
    return function (e) {
      var r = e.onSocket
      return (
        (e.onSocket = Sn(function (n) {
          return mue(n), r.apply(this, arguments)
        })),
        t.apply(this, arguments)
      )
    }
  })
  var M7 = require('child_process')
  function pue(t) {
    Array.isArray(t.stdio) &&
      t.stdio.forEach(function (e) {
        e && e._handle && ((e._handle.onread = Sn(e._handle.onread)), Rs(e._handle, 'close', ZR))
      }),
      t._handle && (t._handle.onexit = Sn(t._handle.onexit))
  }
  M7.ChildProcess
    ? Rs(M7.ChildProcess.prototype, 'spawn', function (t) {
        return function () {
          var e = t.apply(this, arguments)
          return pue(this), e
        }
      })
    : $f(M7, ['execFile', 'fork', 'spawn'], function (t) {
        return function () {
          var e = t.apply(this, arguments)
          return pue(e), e
        }
      })
  process._fatalException || (process._originalNextTick = process.nextTick)
  var H7 = []
  process._nextDomainTick && H7.push('_nextDomainTick')
  process._tickDomainCallback && H7.push('_tickDomainCallback')
  $f(process, H7, nu)
  Rs(process, 'nextTick', ZR)
  var j7 = ['setTimeout', 'setInterval']
  global.setImmediate && j7.push('setImmediate')
  var hue = require('timers'),
    T7e = global.setTimeout === hue.setTimeout
  $f(hue, j7, ZR)
  T7e && $f(global, j7, ZR)
  var B7 = require('dns')
  $f(
    B7,
    [
      'lookup',
      'resolve',
      'resolve4',
      'resolve6',
      'resolveCname',
      'resolveMx',
      'resolveNs',
      'resolveTxt',
      'resolveSrv',
      'reverse',
    ],
    nu
  )
  B7.resolveNaptr && Rs(B7, 'resolveNaptr', nu)
  var Jg = require('fs')
  $f(
    Jg,
    [
      'watch',
      'rename',
      'truncate',
      'chown',
      'fchown',
      'chmod',
      'fchmod',
      'stat',
      'lstat',
      'fstat',
      'link',
      'symlink',
      'readlink',
      'realpath',
      'unlink',
      'rmdir',
      'mkdir',
      'readdir',
      'close',
      'open',
      'utimes',
      'futimes',
      'fsync',
      'write',
      'read',
      'readFile',
      'writeFile',
      'appendFile',
      'watchFile',
      'unwatchFile',
      'exists',
    ],
    nu
  )
  Jg.lchown && Rs(Jg, 'lchown', nu)
  Jg.lchmod && Rs(Jg, 'lchmod', nu)
  Jg.ftruncate && Rs(Jg, 'ftruncate', nu)
  var ZE
  try {
    ZE = require('zlib')
  } catch {}
  ZE &&
    ZE.Deflate &&
    ZE.Deflate.prototype &&
    ((Xg = Object.getPrototypeOf(ZE.Deflate.prototype)),
    Xg._transform ? Rs(Xg, '_transform', nu) : Xg.write && Xg.flush && Xg.end && $f(Xg, ['write', 'flush', 'end'], nu))
  var Xg, q7
  try {
    q7 = require('crypto')
  } catch {}
  q7 && ((F7 = ['pbkdf2', 'randomBytes']), b7e || F7.push('pseudoRandomBytes'), $f(q7, F7, nu))
  var F7,
    XR =
      !!global.Promise &&
      Promise.toString() === 'function Promise() { [native code] }' &&
      Promise.toString.toString() === 'function toString() { [native code] }'
  XR &&
    ((due = process.addAsyncListener({
      create: function () {
        XR = !1
      },
    })),
    global.Promise.resolve(!0).then(function () {
      XR = !1
    }),
    process.removeAsyncListener(due))
  var due
  XR && S7e()
  function S7e() {
    var t = global.Promise
    function e(s) {
      if (!(this instanceof e)) return t(s)
      if (typeof s != 'function') return new t(s)
      var a,
        l,
        c = new t(u)
      c.__proto__ = e.prototype
      try {
        s.apply(a, l)
      } catch (p) {
        l[1](p)
      }
      return c
      function u(p, d) {
        ;(a = this), (l = [f, m])
        function f(h) {
          return n(c, !1), p(h)
        }
        function m(h) {
          return n(c, !1), d(h)
        }
      }
    }
    if ((_7e.inherits(e, t), Rs(t.prototype, 'then', o), t.prototype.chain && Rs(t.prototype, 'chain', o), y7e))
      global.Promise = lue()(t, n)
    else {
      var r = ['all', 'race', 'reject', 'resolve', 'accept', 'defer']
      r.forEach(function (s) {
        typeof t[s] == 'function' && (e[s] = t[s])
      }),
        (global.Promise = e)
    }
    function n(s, a) {
      ;(!s.__asl_wrapper || a) && (s.__asl_wrapper = Sn(i))
    }
    function i(s, a, l, c) {
      var u
      try {
        return (u = a.call(s, l)), { returnVal: u, error: !1 }
      } catch (p) {
        return { errorVal: p, error: !0 }
      } finally {
        u instanceof t
          ? (c.__asl_wrapper = function () {
              var d = u.__asl_wrapper || i
              return d.apply(this, arguments)
            })
          : n(c, !0)
      }
    }
    function o(s) {
      return function () {
        var l = this,
          c = s.apply(l, Array.prototype.map.call(arguments, u))
        return (
          (c.__asl_wrapper = function (d, f, m, h) {
            return l.__asl_wrapper
              ? (l.__asl_wrapper(d, function () {}, null, c), c.__asl_wrapper(d, f, m, h))
              : i(d, f, m, h)
          }),
          c
        )
        function u(p) {
          return typeof p != 'function'
            ? p
            : Sn(function (d) {
                var f = (l.__asl_wrapper || i)(this, p, d, c)
                if (f.error) throw f.errorVal
                return f.returnVal
              })
        }
      }
    }
  }
  function nu(t) {
    var e = function () {
      var r,
        n = arguments.length - 1
      if (typeof arguments[n] == 'function') {
        r = Array(arguments.length)
        for (var i = 0; i < arguments.length - 1; i++) r[i] = arguments[i]
        r[n] = Sn(arguments[n])
      }
      return t.apply(this, r || arguments)
    }
    switch (t.length) {
      case 1:
        return function (r) {
          return arguments.length !== 1
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r))
        }
      case 2:
        return function (r, n) {
          return arguments.length !== 2
            ? e.apply(this, arguments)
            : (typeof n == 'function' && (n = Sn(n)), t.call(this, r, n))
        }
      case 3:
        return function (r, n, i) {
          return arguments.length !== 3
            ? e.apply(this, arguments)
            : (typeof i == 'function' && (i = Sn(i)), t.call(this, r, n, i))
        }
      case 4:
        return function (r, n, i, o) {
          return arguments.length !== 4
            ? e.apply(this, arguments)
            : (typeof o == 'function' && (o = Sn(o)), t.call(this, r, n, i, o))
        }
      case 5:
        return function (r, n, i, o, s) {
          return arguments.length !== 5
            ? e.apply(this, arguments)
            : (typeof s == 'function' && (s = Sn(s)), t.call(this, r, n, i, o, s))
        }
      case 6:
        return function (r, n, i, o, s, a) {
          return arguments.length !== 6
            ? e.apply(this, arguments)
            : (typeof a == 'function' && (a = Sn(a)), t.call(this, r, n, i, o, s, a))
        }
      default:
        return e
    }
  }
  function ZR(t) {
    var e = function () {
      var r
      if (typeof arguments[0] == 'function') {
        ;(r = Array(arguments.length)), (r[0] = Sn(arguments[0]))
        for (var n = 1; n < arguments.length; n++) r[n] = arguments[n]
      }
      return t.apply(this, r || arguments)
    }
    switch (t.length) {
      case 1:
        return function (r) {
          return arguments.length !== 1
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r))
        }
      case 2:
        return function (r, n) {
          return arguments.length !== 2
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r, n))
        }
      case 3:
        return function (r, n, i) {
          return arguments.length !== 3
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r, n, i))
        }
      case 4:
        return function (r, n, i, o) {
          return arguments.length !== 4
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r, n, i, o))
        }
      case 5:
        return function (r, n, i, o, s) {
          return arguments.length !== 5
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r, n, i, o, s))
        }
      case 6:
        return function (r, n, i, o, s, a) {
          return arguments.length !== 6
            ? e.apply(this, arguments)
            : (typeof r == 'function' && (r = Sn(r)), t.call(this, r, n, i, o, s, a))
        }
      default:
        return e
    }
  }
  function C7e(t) {
    return (t = Number(t)) >= 0 ? t : !1
  }
  function I7e(t) {
    return typeof t == 'string' && C7e(t) === !1
  }
})
var bue = handleExports((cIt, xue) => {
  'use strict'
  var Fp = require('assert'),
    w7e = MR(),
    eT = 'cls@contexts',
    G7 = 'error@context'
  process.addAsyncListener || gue()
  function zc(t) {
    ;(this.name = t), (this.active = null), (this._set = []), (this.id = null)
  }
  zc.prototype.set = function (t, e) {
    if (!this.active) throw new Error('No context available. ns.run() or ns.bind() must be called first.')
    return (this.active[t] = e), e
  }
  zc.prototype.get = function (t) {
    if (this.active) return this.active[t]
  }
  zc.prototype.createContext = function () {
    return Object.create(this.active)
  }
  zc.prototype.run = function (t) {
    var e = this.createContext()
    this.enter(e)
    try {
      return t(e), e
    } catch (r) {
      throw (r && (r[G7] = e), r)
    } finally {
      this.exit(e)
    }
  }
  zc.prototype.runAndReturn = function (t) {
    var e
    return (
      this.run(function (r) {
        e = t(r)
      }),
      e
    )
  }
  zc.prototype.bind = function (t, e) {
    e || (this.active ? (e = this.active) : (e = this.createContext()))
    var r = this
    return function () {
      r.enter(e)
      try {
        return t.apply(this, arguments)
      } catch (n) {
        throw (n && (n[G7] = e), n)
      } finally {
        r.exit(e)
      }
    }
  }
  zc.prototype.enter = function (t) {
    Fp.ok(t, 'context must be provided for entering'), this._set.push(this.active), (this.active = t)
  }
  zc.prototype.exit = function (t) {
    if ((Fp.ok(t, 'context must be provided for exiting'), this.active === t)) {
      Fp.ok(this._set.length, "can't remove top context"), (this.active = this._set.pop())
      return
    }
    var e = this._set.lastIndexOf(t)
    Fp.ok(e >= 0, "context not currently entered; can't exit"),
      Fp.ok(e, "can't remove top context"),
      this._set.splice(e, 1)
  }
  zc.prototype.bindEmitter = function (t) {
    Fp.ok(t.on && t.addListener && t.emit, 'can only bind real EEs')
    var e = this,
      r = 'context@' + this.name
    function n(o) {
      o && (o[eT] || (o[eT] = Object.create(null)), (o[eT][r] = { namespace: e, context: e.active }))
    }
    function i(o) {
      if (!(o && o[eT])) return o
      var s = o,
        a = o[eT]
      return (
        Object.keys(a).forEach(function (l) {
          var c = a[l]
          s = c.namespace.bind(s, c.context)
        }),
        s
      )
    }
    w7e(t, n, i)
  }
  zc.prototype.fromException = function (t) {
    return t[G7]
  }
  function vue(t) {
    return process.namespaces[t]
  }
  function A7e(t) {
    Fp.ok(t, 'namespace must be given a name!')
    var e = new zc(t)
    return (
      (e.id = process.addAsyncListener({
        create: function () {
          return e.active
        },
        before: function (r, n) {
          n && e.enter(n)
        },
        after: function (r, n) {
          n && e.exit(n)
        },
        error: function (r) {
          r && e.exit(r)
        },
      })),
      (process.namespaces[t] = e),
      e
    )
  }
  function _ue(t) {
    var e = vue(t)
    Fp.ok(e, "can't delete nonexistent namespace!"),
      Fp.ok(e.id, "don't assign to process.namespaces directly!"),
      process.removeAsyncListener(e.id),
      (process.namespaces[t] = null)
  }
  function yue() {
    process.namespaces &&
      Object.keys(process.namespaces).forEach(function (t) {
        _ue(t)
      }),
      (process.namespaces = Object.create(null))
  }
  process.namespaces || yue()
  xue.exports = { getNamespace: vue, createNamespace: A7e, destroyNamespace: _ue, reset: yue }
})
var Wf = handleExports(tD => {
  'use strict'
  Object.defineProperty(tD, '__esModule', { value: !0 })
  tD.CorrelationContextManager = void 0
  var vy = on(),
    R7e = _R(),
    Zg = yR(),
    V7 = f9(),
    Eue = k9(),
    eD = oo(),
    D7e = (function () {
      function t() {}
      return (
        (t.getCurrentContext = function () {
          if (!t.enabled) return null
          var e = t.session.get(t.CONTEXT_NAME)
          return e === void 0 ? null : e
        }),
        (t.generateContextObject = function (e, r, n, i, o, s) {
          return (
            (r = r || e),
            this.enabled
              ? {
                  operation: { name: n, id: e, parentId: r, traceparent: o, tracestate: s },
                  customProperties: new P7e(i),
                }
              : null
          )
        }),
        (t.spanToContextObject = function (e, r, n) {
          var i = new Zg()
          return (
            (i.traceId = e.traceId),
            (i.spanId = e.spanId),
            (i.traceFlag = Zg.formatOpenTelemetryTraceFlags(e.traceFlags) || Zg.DEFAULT_TRACE_FLAG),
            (i.parentId = r),
            t.generateContextObject(i.traceId, i.parentId, n, null, i)
          )
        }),
        (t.runWithContext = function (e, r) {
          var n
          if (t.enabled)
            try {
              return t.session.bind(r, ((n = {}), (n[t.CONTEXT_NAME] = e), n))()
            } catch (i) {
              vy.warn('Error binding to session context', eD.dumpObj(i))
            }
          return r()
        }),
        (t.wrapEmitter = function (e) {
          if (t.enabled)
            try {
              t.session.bindEmitter(e)
            } catch (r) {
              vy.warn('Error binding to session context', eD.dumpObj(r))
            }
        }),
        (t.wrapCallback = function (e, r) {
          var n
          if (t.enabled)
            try {
              return t.session.bind(e, r ? ((n = {}), (n[t.CONTEXT_NAME] = r), n) : void 0)
            } catch (i) {
              vy.warn('Error binding to session context', eD.dumpObj(i))
            }
          return e
        }),
        (t.enable = function (e) {
          if (!this.enabled) {
            if (!this.isNodeVersionCompatible()) {
              this.enabled = !1
              return
            }
            t.hasEverEnabled ||
              ((this.forceClsHooked = e),
              (this.hasEverEnabled = !0),
              typeof this.cls > 'u' &&
                (t.forceClsHooked === !0 || (t.forceClsHooked === void 0 && t.shouldUseClsHooked())
                  ? (this.cls = Hle())
                  : (this.cls = bue())),
              (t.session = this.cls.createNamespace('AI-CLS-Session')),
              R7e.registerContextPreservation(function (r) {
                try {
                  return t.session.bind(r)
                } catch (n) {
                  vy.warn('Error binding to session context', eD.dumpObj(n))
                }
              })),
              (this.enabled = !0)
          }
        }),
        (t.startOperation = function (e, r) {
          var n = (e && e.traceContext) || null,
            i = e && e.spanContext ? e : null,
            o = e && e.traceId ? e : null,
            s = e && e.headers
          if (i) return this.spanToContextObject(i.spanContext(), i.parentSpanId, i.name)
          if (o)
            return this.spanToContextObject(o, '|' + o.traceId + '.' + o.spanId + '.', typeof r == 'string' ? r : '')
          var a = typeof r == 'string' ? r : ''
          if (n) {
            var l = null,
              c = null
            if (((a = n.attributes.OperationName || a), r)) {
              var u = r
              u.headers &&
                (u.headers.traceparent
                  ? (l = new Zg(u.headers.traceparent))
                  : u.headers['request-id'] && (l = new Zg(null, u.headers['request-id'])),
                u.headers.tracestate && (c = new V7(u.headers.tracestate)))
            }
            l || (l = new Zg(n.traceParent || n.traceparent)), c || (c = new V7(n.traceState || n.tracestate))
            var p = void 0
            if (typeof r == 'object') {
              var d = new Eue(r)
              ;(p = d.getCorrelationContextHeader()), (a = d.getOperationName({}))
            }
            var f = t.generateContextObject(l.traceId, l.parentId, a, p, l, c)
            return f
          }
          if (s) {
            var l = new Zg(s.traceparent ? s.traceparent.toString() : null),
              c = new V7(s.tracestate ? s.tracestate.toString() : null),
              d = new Eue(e),
              f = t.generateContextObject(
                l.traceId,
                l.parentId,
                d.getOperationName({}),
                d.getCorrelationContextHeader(),
                l,
                c
              )
            return f
          }
          return vy.warn('startOperation was called with invalid arguments', arguments), null
        }),
        (t.disable = function () {
          this.enabled = !1
        }),
        (t.reset = function () {
          t.hasEverEnabled && ((t.session = null), (t.session = this.cls.createNamespace('AI-CLS-Session')))
        }),
        (t.isNodeVersionCompatible = function () {
          var e = process.versions.node.split('.')
          return parseInt(e[0]) > 3 || (parseInt(e[0]) > 2 && parseInt(e[1]) > 2)
        }),
        (t.shouldUseClsHooked = function () {
          var e = process.versions.node.split('.')
          return parseInt(e[0]) > 8 || (parseInt(e[0]) >= 8 && parseInt(e[1]) >= 2)
        }),
        (t.canUseClsHooked = function () {
          var e = process.versions.node.split('.'),
            r = parseInt(e[0]) > 8 || (parseInt(e[0]) >= 8 && parseInt(e[1]) >= 0),
            n = parseInt(e[0]) < 8 || (parseInt(e[0]) <= 8 && parseInt(e[1]) < 2),
            i = parseInt(e[0]) > 4 || (parseInt(e[0]) >= 4 && parseInt(e[1]) >= 7)
          return !(r && n) && i
        }),
        (t.enabled = !1),
        (t.hasEverEnabled = !1),
        (t.forceClsHooked = void 0),
        (t.CONTEXT_NAME = 'ApplicationInsights-Context'),
        t
      )
    })()
  tD.CorrelationContextManager = D7e
  var P7e = (function () {
    function t(e) {
      ;(this.props = []), this.addHeaderData(e)
    }
    return (
      (t.prototype.addHeaderData = function (e) {
        var r = e ? e.split(', ') : []
        this.props = r
          .map(function (n) {
            var i = n.split('=')
            return { key: i[0], value: i[1] }
          })
          .concat(this.props)
      }),
      (t.prototype.serializeToHeader = function () {
        return this.props
          .map(function (e) {
            return e.key + '=' + e.value
          })
          .join(', ')
      }),
      (t.prototype.getProperty = function (e) {
        for (var r = 0; r < this.props.length; ++r) {
          var n = this.props[r]
          if (n.key === e) return n.value
        }
      }),
      (t.prototype.setProperty = function (e, r) {
        if (t.bannedCharacters.test(e) || t.bannedCharacters.test(r)) {
          vy.warn(
            "Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " +
              e +
              ' and value: ' +
              r
          )
          return
        }
        for (var n = 0; n < this.props.length; ++n) {
          var i = this.props[n]
          if (i.key === e) {
            i.value = r
            return
          }
        }
        this.props.push({ key: e, value: r })
      }),
      (t.bannedCharacters = /[,=]/),
      t
    )
  })()
})
var Tue = handleExports(_y => {
  'use strict'
  Object.defineProperty(_y, '__esModule', { value: !0 })
  _y.dispose = _y.enable = void 0
  var rD = Ao(),
    N7e = xn(),
    nD = On(),
    Kf = [],
    z7 = function (t) {
      var e = t.data.message
      Kf.forEach(function (r) {
        e instanceof Error && !r.config.enableLoggerErrorToTrace
          ? r.trackException({ exception: e })
          : e instanceof Error
          ? r.trackTrace({
              message: e.toString(),
              severity: t.data.stderr ? rD.SeverityLevel.Error : rD.SeverityLevel.Information,
            })
          : (e.lastIndexOf(`
`) ==
              e.length - 1 && (e = e.substring(0, e.length - 1)),
            r.trackTrace({
              message: e,
              severity: t.data.stderr ? rD.SeverityLevel.Warning : rD.SeverityLevel.Information,
            }))
      })
    }
  function k7e(t, e) {
    if (t) {
      var r = Kf.find(function (n) {
        return n == e
      })
      if (r) return
      Kf.length === 0 &&
        nD.channel.subscribe('console', z7, nD.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(N7e.StatsbeatInstrumentation.CONSOLE)
        }),
        Kf.push(e)
    } else
      (Kf = Kf.filter(function (n) {
        return n != e
      })),
        Kf.length === 0 && nD.channel.unsubscribe('console', z7)
  }
  _y.enable = k7e
  function O7e() {
    nD.channel.unsubscribe('console', z7), (Kf = [])
  }
  _y.dispose = O7e
})
var Sue = handleExports(xy => {
  'use strict'
  Object.defineProperty(xy, '__esModule', { value: !0 })
  xy.dispose = xy.enable = void 0
  var yy = Ao(),
    L7e = xn(),
    iD = On(),
    Yf = [],
    M7e = {
      10: yy.SeverityLevel.Verbose,
      20: yy.SeverityLevel.Verbose,
      30: yy.SeverityLevel.Information,
      40: yy.SeverityLevel.Warning,
      50: yy.SeverityLevel.Error,
      60: yy.SeverityLevel.Critical,
    },
    $7 = function (t) {
      var e = t.data.result,
        r = M7e[t.data.level]
      Yf.forEach(function (n) {
        try {
          var i = JSON.parse(e)
          if (i.err) {
            var o = new Error(i.err.message)
            if (((o.name = i.err.name), (o.stack = i.err.stack), n.config.enableLoggerErrorToTrace)) {
              n.trackTrace({ message: e, severity: r })
              return
            }
            n.trackException({ exception: o })
            return
          }
        } catch {}
        n.trackTrace({ message: e, severity: r })
      })
    }
  function F7e(t, e) {
    if (t) {
      var r = Yf.find(function (n) {
        return n == e
      })
      if (r) return
      Yf.length === 0 &&
        iD.channel.subscribe('bunyan', $7, iD.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(L7e.StatsbeatInstrumentation.BUNYAN)
        }),
        Yf.push(e)
    } else
      (Yf = Yf.filter(function (n) {
        return n != e
      })),
        Yf.length === 0 && iD.channel.unsubscribe('bunyan', $7)
  }
  xy.enable = F7e
  function U7e() {
    iD.channel.unsubscribe('bunyan', $7), (Yf = [])
  }
  xy.dispose = U7e
})
var Cue = handleExports(by => {
  'use strict'
  Object.defineProperty(by, '__esModule', { value: !0 })
  by.dispose = by.enable = void 0
  var B7e = xn(),
    co = Ao(),
    oD = On(),
    Qf = [],
    q7e = {
      syslog: function (t) {
        var e = {
          emerg: co.SeverityLevel.Critical,
          alert: co.SeverityLevel.Critical,
          crit: co.SeverityLevel.Critical,
          error: co.SeverityLevel.Error,
          warning: co.SeverityLevel.Warning,
          notice: co.SeverityLevel.Information,
          info: co.SeverityLevel.Information,
          debug: co.SeverityLevel.Verbose,
        }
        return e[t] === void 0 ? co.SeverityLevel.Information : e[t]
      },
      npm: function (t) {
        var e = {
          error: co.SeverityLevel.Error,
          warn: co.SeverityLevel.Warning,
          info: co.SeverityLevel.Information,
          verbose: co.SeverityLevel.Verbose,
          debug: co.SeverityLevel.Verbose,
          silly: co.SeverityLevel.Verbose,
        }
        return e[t] === void 0 ? co.SeverityLevel.Information : e[t]
      },
      unknown: function (t) {
        return co.SeverityLevel.Information
      },
    },
    W7 = function (t) {
      var e = t.data.message,
        r = q7e[t.data.levelKind](t.data.level)
      Qf.forEach(function (n) {
        e instanceof Error && !n.config.enableLoggerErrorToTrace
          ? n.trackException({ exception: e, properties: t.data.meta })
          : e instanceof Error
          ? n.trackTrace({ message: e.toString(), severity: r, properties: t.data.meta })
          : n.trackTrace({ message: e, severity: r, properties: t.data.meta })
      })
    }
  function H7e(t, e) {
    if (t) {
      var r = Qf.find(function (n) {
        return n == e
      })
      if (r) return
      Qf.length === 0 &&
        oD.channel.subscribe('winston', W7, oD.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(B7e.StatsbeatInstrumentation.WINSTON)
        }),
        Qf.push(e)
    } else
      (Qf = Qf.filter(function (n) {
        return n != e
      })),
        Qf.length === 0 && oD.channel.unsubscribe('winston', W7)
  }
  by.enable = H7e
  function j7e() {
    oD.channel.unsubscribe('winston', W7), (Qf = [])
  }
  by.dispose = j7e
})
var wue = handleExports((fIt, Iue) => {
  'use strict'
  var G7e = _R(),
    V7e = (function () {
      function t(e) {
        if (t.INSTANCE)
          throw new Error('Console logging adapter tracking should be configured from the applicationInsights object')
        ;(this._client = e), (t.INSTANCE = this)
      }
      return (
        (t.prototype.enable = function (e, r) {
          G7e.IsInitialized &&
            (Tue().enable(e && r, this._client), Sue().enable(e, this._client), Cue().enable(e, this._client))
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1, !1)
        }),
        (t._methodNames = ['debug', 'info', 'log', 'warn', 'error']),
        t
      )
    })()
  Iue.exports = V7e
})
var Rue = handleExports((mIt, Aue) => {
  'use strict'
  var z7e = (function () {
    function t(e) {
      if (t.INSTANCE) throw new Error('Exception tracking should be configured from the applicationInsights object')
      ;(t.INSTANCE = this), (this._client = e)
      var r = process.versions.node.split('.')
      t._canUseUncaughtExceptionMonitor = parseInt(r[0]) > 13 || (parseInt(r[0]) === 13 && parseInt(r[1]) >= 7)
    }
    return (
      (t.prototype.isInitialized = function () {
        return this._isInitialized
      }),
      (t.prototype.enable = function (e) {
        var r = this
        if (e) {
          if (((this._isInitialized = !0), !this._exceptionListenerHandle)) {
            var n = function (i, o, s) {
              s === void 0 && (s = new Error(t._FALLBACK_ERROR_MESSAGE))
              var a = { exception: s }
              ;(a.contextObjects = {}),
                (a.contextObjects.Error = s),
                r._client.trackException(a),
                r._client.flush({ isAppCrashing: !0 }),
                i && o && process.listeners(o).length === 1 && (console.error(s), process.exit(1))
            }
            t._canUseUncaughtExceptionMonitor
              ? ((this._exceptionListenerHandle = n.bind(this, !1, void 0)),
                process.on(t.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle))
              : ((this._exceptionListenerHandle = n.bind(this, !0, t.UNCAUGHT_EXCEPTION_HANDLER_NAME)),
                (this._rejectionListenerHandle = n.bind(this, !1, void 0)),
                process.on(t.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle),
                process.on(t.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle))
          }
        } else
          this._exceptionListenerHandle &&
            (t._canUseUncaughtExceptionMonitor
              ? process.removeListener(t.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle)
              : (process.removeListener(t.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle),
                process.removeListener(t.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle)),
            (this._exceptionListenerHandle = void 0),
            (this._rejectionListenerHandle = void 0),
            delete this._exceptionListenerHandle,
            delete this._rejectionListenerHandle)
      }),
      (t.prototype.dispose = function () {
        ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
      }),
      (t.INSTANCE = null),
      (t.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = 'uncaughtExceptionMonitor'),
      (t.UNCAUGHT_EXCEPTION_HANDLER_NAME = 'uncaughtException'),
      (t.UNHANDLED_REJECTION_HANDLER_NAME = 'unhandledRejection'),
      (t._RETHROW_EXIT_MESSAGE = 'Application Insights Rethrow Exception Handler'),
      (t._FALLBACK_ERROR_MESSAGE =
        'A promise was rejected without providing an error. Application Insights generated this error stack for you.'),
      (t._canUseUncaughtExceptionMonitor = !1),
      t
    )
  })()
  Aue.exports = z7e
})
var aD = handleExports((hIt, Due) => {
  'use strict'
  var sD = require('os'),
    Za = xn(),
    $7e = (function () {
      function t(e, r, n) {
        r === void 0 && (r = 6e4),
          n === void 0 && (n = !1),
          (this._lastIntervalRequestExecutionTime = 0),
          (this._lastIntervalDependencyExecutionTime = 0),
          t.INSTANCE || (t.INSTANCE = this),
          (this._lastRequests = { totalRequestCount: 0, totalFailedRequestCount: 0, time: 0 }),
          (this._lastDependencies = { totalDependencyCount: 0, totalFailedDependencyCount: 0, time: 0 }),
          (this._lastExceptions = { totalExceptionCount: 0, time: 0 }),
          (this._isInitialized = !1),
          (this._client = e),
          (this._collectionInterval = r),
          (this._enableLiveMetricsCounters = n)
      }
      return (
        (t.prototype.enable = function (e, r) {
          var n = this
          ;(this._isEnabled = e),
            this._isEnabled && !this._isInitialized && (this._isInitialized = !0),
            e
              ? this._handle ||
                ((this._lastCpus = sD.cpus()),
                (this._lastRequests = {
                  totalRequestCount: t._totalRequestCount,
                  totalFailedRequestCount: t._totalFailedRequestCount,
                  time: +new Date(),
                }),
                (this._lastDependencies = {
                  totalDependencyCount: t._totalDependencyCount,
                  totalFailedDependencyCount: t._totalFailedDependencyCount,
                  time: +new Date(),
                }),
                (this._lastExceptions = { totalExceptionCount: t._totalExceptionCount, time: +new Date() }),
                typeof process.cpuUsage == 'function' && (this._lastAppCpuUsage = process.cpuUsage()),
                (this._lastHrtime = process.hrtime()),
                (this._collectionInterval = r || this._collectionInterval),
                (this._handle = setInterval(function () {
                  return n.trackPerformance()
                }, this._collectionInterval)),
                this._handle.unref())
              : this._handle && (clearInterval(this._handle), (this._handle = void 0))
        }),
        (t.countRequest = function (e, r) {
          var n
          if (t.isEnabled()) {
            if (typeof e == 'string') n = +new Date('1970-01-01T' + e + 'Z')
            else if (typeof e == 'number') n = e
            else return
            ;(t._intervalRequestExecutionTime += n), r === !1 && t._totalFailedRequestCount++, t._totalRequestCount++
          }
        }),
        (t.countException = function () {
          t._totalExceptionCount++
        }),
        (t.countDependency = function (e, r) {
          var n
          if (t.isEnabled()) {
            if (typeof e == 'string') n = +new Date('1970-01-01T' + e + 'Z')
            else if (typeof e == 'number') n = e
            else return
            ;(t._intervalDependencyExecutionTime += n),
              r === !1 && t._totalFailedDependencyCount++,
              t._totalDependencyCount++
          }
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.isEnabled = function () {
          return t.INSTANCE && t.INSTANCE._isEnabled
        }),
        (t.prototype.trackPerformance = function () {
          this._trackCpu(),
            this._trackMemory(),
            this._trackNetwork(),
            this._trackDependencyRate(),
            this._trackExceptionRate()
        }),
        (t.prototype._trackCpu = function () {
          var e = sD.cpus()
          if (e && e.length && this._lastCpus && e.length === this._lastCpus.length) {
            for (var r = 0, n = 0, i = 0, o = 0, s = 0, a = 0; e && a < e.length; a++) {
              var l = e[a],
                c = this._lastCpus[a],
                u = '% cpu(' + a + ') ',
                p = l.model,
                d = l.speed,
                f = l.times,
                m = c.times,
                h = f.user - m.user || 0
              r += h
              var g = f.sys - m.sys || 0
              n += g
              var v = f.nice - m.nice || 0
              i += v
              var _ = f.idle - m.idle || 0
              o += _
              var y = f.irq - m.irq || 0
              s += y
            }
            var b = void 0
            if (typeof process.cpuUsage == 'function') {
              var x = process.cpuUsage(),
                P = process.hrtime(),
                U = x.user - this._lastAppCpuUsage.user + (x.system - this._lastAppCpuUsage.system) || 0
              if (typeof this._lastHrtime < 'u' && this._lastHrtime.length === 2) {
                var H = (P[0] - this._lastHrtime[0]) * 1e6 + (P[1] - this._lastHrtime[1]) / 1e3 || 0
                b = (100 * U) / (H * e.length)
              }
              ;(this._lastAppCpuUsage = x), (this._lastHrtime = P)
            }
            var j = r + n + i + o + s || 1
            this._client.trackMetric({ name: Za.PerformanceCounter.PROCESSOR_TIME, value: ((j - o) / j) * 100 }),
              this._client.trackMetric({ name: Za.PerformanceCounter.PROCESS_TIME, value: b || (r / j) * 100 })
          }
          this._lastCpus = e
        }),
        (t.prototype._trackMemory = function () {
          var e = sD.freemem(),
            r = process.memoryUsage().rss,
            n = sD.totalmem() - e
          this._client.trackMetric({ name: Za.PerformanceCounter.PRIVATE_BYTES, value: r }),
            this._client.trackMetric({ name: Za.PerformanceCounter.AVAILABLE_BYTES, value: e }),
            this._enableLiveMetricsCounters &&
              this._client.trackMetric({ name: Za.QuickPulseCounter.COMMITTED_BYTES, value: n })
        }),
        (t.prototype._trackNetwork = function () {
          var e = this._lastRequests,
            r = {
              totalRequestCount: t._totalRequestCount,
              totalFailedRequestCount: t._totalFailedRequestCount,
              time: +new Date(),
            },
            n = r.totalRequestCount - e.totalRequestCount || 0,
            i = r.totalFailedRequestCount - e.totalFailedRequestCount || 0,
            o = r.time - e.time,
            s = o / 1e3,
            a = (t._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / n || 0
          if (((this._lastIntervalRequestExecutionTime = t._intervalRequestExecutionTime), o > 0)) {
            var l = n / s,
              c = i / s
            this._client.trackMetric({ name: Za.PerformanceCounter.REQUEST_RATE, value: l }),
              (!this._enableLiveMetricsCounters || n > 0) &&
                this._client.trackMetric({ name: Za.PerformanceCounter.REQUEST_DURATION, value: a }),
              this._enableLiveMetricsCounters &&
                this._client.trackMetric({ name: Za.QuickPulseCounter.REQUEST_FAILURE_RATE, value: c })
          }
          this._lastRequests = r
        }),
        (t.prototype._trackDependencyRate = function () {
          if (this._enableLiveMetricsCounters) {
            var e = this._lastDependencies,
              r = {
                totalDependencyCount: t._totalDependencyCount,
                totalFailedDependencyCount: t._totalFailedDependencyCount,
                time: +new Date(),
              },
              n = r.totalDependencyCount - e.totalDependencyCount || 0,
              i = r.totalFailedDependencyCount - e.totalFailedDependencyCount || 0,
              o = r.time - e.time,
              s = o / 1e3,
              a = (t._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / n || 0
            if (((this._lastIntervalDependencyExecutionTime = t._intervalDependencyExecutionTime), o > 0)) {
              var l = n / s,
                c = i / s
              this._client.trackMetric({ name: Za.QuickPulseCounter.DEPENDENCY_RATE, value: l }),
                this._client.trackMetric({ name: Za.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: c }),
                (!this._enableLiveMetricsCounters || n > 0) &&
                  this._client.trackMetric({ name: Za.QuickPulseCounter.DEPENDENCY_DURATION, value: a })
            }
            this._lastDependencies = r
          }
        }),
        (t.prototype._trackExceptionRate = function () {
          if (this._enableLiveMetricsCounters) {
            var e = this._lastExceptions,
              r = { totalExceptionCount: t._totalExceptionCount, time: +new Date() },
              n = r.totalExceptionCount - e.totalExceptionCount || 0,
              i = r.time - e.time,
              o = i / 1e3
            if (i > 0) {
              var s = n / o
              this._client.trackMetric({ name: Za.QuickPulseCounter.EXCEPTION_RATE, value: s })
            }
            this._lastExceptions = r
          }
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
        }),
        (t._totalRequestCount = 0),
        (t._totalFailedRequestCount = 0),
        (t._totalDependencyCount = 0),
        (t._totalFailedDependencyCount = 0),
        (t._totalExceptionCount = 0),
        (t._intervalDependencyExecutionTime = 0),
        (t._intervalRequestExecutionTime = 0),
        t
      )
    })()
  Due.exports = $7e
})
var Pue = handleExports(cD => {
  'use strict'
  Object.defineProperty(cD, '__esModule', { value: !0 })
  cD.AggregatedMetricCounter = void 0
  var W7e = (function () {
    function t(e) {
      ;(this.dimensions = e),
        (this.totalCount = 0),
        (this.lastTotalCount = 0),
        (this.intervalExecutionTime = 0),
        (this.lastTime = +new Date()),
        (this.lastIntervalExecutionTime = 0)
    }
    return t
  })()
  cD.AggregatedMetricCounter = W7e
})
var Nue = handleExports(lD => {
  'use strict'
  Object.defineProperty(lD, '__esModule', { value: !0 })
  lD.PreaggregatedMetricPropertyNames = void 0
  lD.PreaggregatedMetricPropertyNames = {
    cloudRoleInstance: 'cloud/roleInstance',
    cloudRoleName: 'cloud/roleName',
    operationSynthetic: 'operation/synthetic',
    requestSuccess: 'Request.Success',
    requestResultCode: 'request/resultCode',
    dependencyType: 'Dependency.Type',
    dependencyTarget: 'dependency/target',
    dependencySuccess: 'Dependency.Success',
    dependencyResultCode: 'dependency/resultCode',
    traceSeverityLevel: 'trace/severityLevel',
  }
})
var Y7 = handleExports((K7, kue) => {
  'use strict'
  var pD =
      (K7 && K7.__assign) ||
      function () {
        return (
          (pD =
            Object.assign ||
            function (t) {
              for (var e, r = 1, n = arguments.length; r < n; r++) {
                e = arguments[r]
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
              }
              return t
            }),
          pD.apply(this, arguments)
        )
      },
    uD = xn(),
    K7e = Pue(),
    Y7e = Nue(),
    Q7e = (function () {
      function t(e, r) {
        r === void 0 && (r = 6e4),
          t.INSTANCE || (t.INSTANCE = this),
          (this._isInitialized = !1),
          (t._dependencyCountersCollection = []),
          (t._requestCountersCollection = []),
          (t._exceptionCountersCollection = []),
          (t._traceCountersCollection = []),
          (this._client = e),
          (this._collectionInterval = r)
      }
      return (
        (t.prototype.enable = function (e, r) {
          var n = this
          ;(this._isEnabled = e),
            this._isEnabled && !this._isInitialized && (this._isInitialized = !0),
            e
              ? this._handle ||
                ((this._collectionInterval = r || this._collectionInterval),
                (this._handle = setInterval(function () {
                  return n.trackPreAggregatedMetrics()
                }, this._collectionInterval)),
                this._handle.unref())
              : this._handle && (clearInterval(this._handle), (this._handle = void 0))
        }),
        (t.countException = function (e) {
          if (t.isEnabled()) {
            var r = t._getAggregatedCounter(e, this._exceptionCountersCollection)
            r.totalCount++
          }
        }),
        (t.countTrace = function (e) {
          if (t.isEnabled()) {
            var r = t._getAggregatedCounter(e, this._traceCountersCollection)
            r.totalCount++
          }
        }),
        (t.countRequest = function (e, r) {
          if (t.isEnabled()) {
            var n,
              i = t._getAggregatedCounter(r, this._requestCountersCollection)
            if (typeof e == 'string') n = +new Date('1970-01-01T' + e + 'Z')
            else if (typeof e == 'number') n = e
            else return
            ;(i.intervalExecutionTime += n), i.totalCount++
          }
        }),
        (t.countDependency = function (e, r) {
          if (t.isEnabled()) {
            var n = t._getAggregatedCounter(r, this._dependencyCountersCollection),
              i
            if (typeof e == 'string') i = +new Date('1970-01-01T' + e + 'Z')
            else if (typeof e == 'number') i = e
            else return
            ;(n.intervalExecutionTime += i), n.totalCount++
          }
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.isEnabled = function () {
          return t.INSTANCE && t.INSTANCE._isEnabled
        }),
        (t.prototype.trackPreAggregatedMetrics = function () {
          this._trackRequestMetrics(),
            this._trackDependencyMetrics(),
            this._trackExceptionMetrics(),
            this._trackTraceMetrics()
        }),
        (t._getAggregatedCounter = function (e, r) {
          for (var n = !1, i = 0; i < r.length; i++) {
            if (e === r[i].dimensions) return r[i]
            if (Object.keys(e).length === Object.keys(r[i].dimensions).length) {
              for (var o in e)
                if (e[o] != r[i].dimensions[o]) {
                  n = !0
                  break
                }
              if (!n) return r[i]
              n = !1
            }
          }
          var s = new K7e.AggregatedMetricCounter(e)
          return r.push(s), s
        }),
        (t.prototype._trackRequestMetrics = function () {
          for (var e = 0; e < t._requestCountersCollection.length; e++) {
            var r = t._requestCountersCollection[e]
            r.time = +new Date()
            var n = r.totalCount - r.lastTotalCount || 0,
              i = r.time - r.lastTime,
              o = (r.intervalExecutionTime - r.lastIntervalExecutionTime) / n || 0
            ;(r.lastIntervalExecutionTime = r.intervalExecutionTime),
              i > 0 &&
                n > 0 &&
                this._trackPreAggregatedMetric({
                  name: 'Server response time',
                  dimensions: r.dimensions,
                  value: o,
                  count: n,
                  aggregationInterval: i,
                  metricType: uD.MetricId.REQUESTS_DURATION,
                }),
              (r.lastTotalCount = r.totalCount),
              (r.lastTime = r.time)
          }
        }),
        (t.prototype._trackDependencyMetrics = function () {
          for (var e = 0; e < t._dependencyCountersCollection.length; e++) {
            var r = t._dependencyCountersCollection[e]
            r.time = +new Date()
            var n = r.totalCount - r.lastTotalCount || 0,
              i = r.time - r.lastTime,
              o = (r.intervalExecutionTime - r.lastIntervalExecutionTime) / n || 0
            ;(r.lastIntervalExecutionTime = r.intervalExecutionTime),
              i > 0 &&
                n > 0 &&
                this._trackPreAggregatedMetric({
                  name: 'Dependency duration',
                  dimensions: r.dimensions,
                  value: o,
                  count: n,
                  aggregationInterval: i,
                  metricType: uD.MetricId.DEPENDENCIES_DURATION,
                }),
              (r.lastTotalCount = r.totalCount),
              (r.lastTime = r.time)
          }
        }),
        (t.prototype._trackExceptionMetrics = function () {
          for (var e = 0; e < t._exceptionCountersCollection.length; e++) {
            var r = t._exceptionCountersCollection[e]
            r.time = +new Date()
            var n = r.totalCount - r.lastTotalCount || 0,
              i = r.time - r.lastTime
            i > 0 &&
              n > 0 &&
              this._trackPreAggregatedMetric({
                name: 'Exceptions',
                dimensions: r.dimensions,
                value: n,
                count: n,
                aggregationInterval: i,
                metricType: uD.MetricId.EXCEPTIONS_COUNT,
              }),
              (r.lastTotalCount = r.totalCount),
              (r.lastTime = r.time)
          }
        }),
        (t.prototype._trackTraceMetrics = function () {
          for (var e = 0; e < t._traceCountersCollection.length; e++) {
            var r = t._traceCountersCollection[e]
            r.time = +new Date()
            var n = r.totalCount - r.lastTotalCount || 0,
              i = r.time - r.lastTime
            i > 0 &&
              n > 0 &&
              this._trackPreAggregatedMetric({
                name: 'Traces',
                dimensions: r.dimensions,
                value: n,
                count: n,
                aggregationInterval: i,
                metricType: uD.MetricId.TRACES_COUNT,
              }),
              (r.lastTotalCount = r.totalCount),
              (r.lastTime = r.time)
          }
        }),
        (t.prototype._trackPreAggregatedMetric = function (e) {
          var r = {}
          for (var n in e.dimensions) r[Y7e.PreaggregatedMetricPropertyNames[n]] = e.dimensions[n]
          r = pD(pD({}, r), {
            '_MS.MetricId': e.metricType,
            '_MS.AggregationIntervalMs': String(e.aggregationInterval),
            '_MS.IsAutocollected': 'True',
          })
          var i = { name: e.name, value: e.value, count: e.count, properties: r, kind: 'Aggregation' }
          this._client.trackMetric(i)
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
        }),
        t
      )
    })()
  kue.exports = Q7e
})
var Ey = handleExports((_It, Oue) => {
  'use strict'
  var Up = require('os'),
    X7e = require('fs'),
    J7e = require('path'),
    Z7e = Ao(),
    eUe = xn(),
    tUe = on(),
    rUe = (function () {
      function t(e) {
        ;(this.keys = new Z7e.ContextTagKeys()),
          (this.tags = {}),
          this._loadApplicationContext(e),
          this._loadDeviceContext(),
          this._loadInternalContext()
      }
      return (
        (t.prototype._loadApplicationContext = function (e) {
          try {
            if (((e = e || J7e.resolve(__dirname, '../../../../package.json')), !t.appVersion[e])) {
              t.appVersion[e] = 'unknown'
              var r = JSON.parse(X7e.readFileSync(e, 'utf8'))
              r && typeof r.version == 'string' && (t.appVersion[e] = r.version)
            }
            this.tags[this.keys.applicationVersion] = t.appVersion[e]
          } catch (n) {
            tUe.info('Failed to read app version: ', n)
          }
        }),
        (t.prototype._loadDeviceContext = function () {
          var e = Up && Up.hostname(),
            r = t.DefaultRoleName
          process.env.WEBSITE_SITE_NAME && (r = process.env.WEBSITE_SITE_NAME),
            process.env.WEBSITE_INSTANCE_ID && (e = process.env.WEBSITE_INSTANCE_ID),
            (this.tags[this.keys.deviceId] = ''),
            (this.tags[this.keys.cloudRoleInstance] = e),
            (this.tags[this.keys.deviceOSVersion] = Up && Up.type() + ' ' + Up.release()),
            (this.tags[this.keys.cloudRole] = r),
            (this.tags['ai.device.osArchitecture'] = Up && Up.arch()),
            (this.tags['ai.device.osPlatform'] = Up && Up.platform())
        }),
        (t.prototype._loadInternalContext = function () {
          ;(t.sdkVersion = eUe.APPLICATION_INSIGHTS_SDK_VERSION),
            (this.tags[this.keys.internalSdkVersion] = 'node:' + t.sdkVersion)
        }),
        (t.DefaultRoleName = 'Web'),
        (t.appVersion = {}),
        (t.sdkVersion = null),
        t
      )
    })()
  Oue.exports = rUe
})
var Fue = handleExports((yIt, Mue) => {
  'use strict'
  var nUe = require('crypto'),
    Lue = require('os'),
    iUe = xn(),
    oUe = Ey(),
    sUe = (function () {
      function t(e) {
        ;(this._collectionInterval = 9e5),
          t.INSTANCE || (t.INSTANCE = this),
          (this._isInitialized = !1),
          (this._client = e)
      }
      return (
        (t.prototype.enable = function (e) {
          var r = this
          ;(this._isEnabled = e),
            this._isEnabled && !this._isInitialized && (this._isInitialized = !0),
            e
              ? this._handle ||
                ((this._handle = setInterval(function () {
                  return r.trackHeartBeat(r._client.config, function () {})
                }, this._collectionInterval)),
                this._handle.unref())
              : this._handle && (clearInterval(this._handle), (this._handle = null))
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.isEnabled = function () {
          return t.INSTANCE && t.INSTANCE._isEnabled
        }),
        (t.prototype.trackHeartBeat = function (e, r) {
          var n = {},
            i = oUe.sdkVersion
          ;(n.sdkVersion = i),
            (n.osType = Lue.type()),
            (n.osVersion = Lue.release()),
            this._uniqueProcessId || (this._uniqueProcessId = nUe.randomBytes(16).toString('hex')),
            (n.processSessionId = this._uniqueProcessId),
            process.env.WEBSITE_SITE_NAME && (n.appSrv_SiteName = process.env.WEBSITE_SITE_NAME),
            process.env.WEBSITE_HOME_STAMPNAME && (n.appSrv_wsStamp = process.env.WEBSITE_HOME_STAMPNAME),
            process.env.WEBSITE_HOSTNAME && (n.appSrv_wsHost = process.env.WEBSITE_HOSTNAME),
            process.env.WEBSITE_OWNER_NAME && (n.appSrv_wsOwner = process.env.WEBSITE_OWNER_NAME),
            process.env.WEBSITE_RESOURCE_GROUP && (n.appSrv_ResourceGroup = process.env.WEBSITE_RESOURCE_GROUP),
            process.env.WEBSITE_SLOT_NAME && (n.appSrv_SlotName = process.env.WEBSITE_SLOT_NAME),
            this._client.trackMetric({ name: iUe.HeartBeatMetricName, value: 0, properties: n }),
            r()
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
        }),
        t
      )
    })()
  Mue.exports = sUe
})
var Uue = handleExports(Ct => {
  'use strict'
  Object.defineProperty(Ct, '__esModule', { value: !0 })
  Ct.isContentTypeHeaderHtml =
    Ct.insertSnippetByIndex =
    Ct.getContentEncodingFromHeaders =
    Ct.isSupportedContentEncoding =
    Ct.findBufferEncodingType =
    Ct.isBufferType =
    Ct.getBrotliDecompressSync =
    Ct.getBrotliDecompressAsync =
    Ct.getBrotliCompressSync =
    Ct.getBrotliCompressAsync =
    Ct.inflateAsync =
    Ct.deflateAsync =
    Ct.gunzipAsync =
    Ct.gzipAsync =
    Ct.isBrotliSupperted =
    Ct.bufferEncodingTypes =
    Ct.contentEncodingMethod =
      void 0
  var fD = require('zlib'),
    Ty = require('util'),
    dD
  ;(function (t) {
    ;(t.GZIP = 'gzip'), (t.DEFLATE = 'deflate'), (t.BR = 'br')
  })((dD = Ct.contentEncodingMethod || (Ct.contentEncodingMethod = {})))
  Ct.bufferEncodingTypes = ['utf8', 'utf16le', 'latin1', 'base64', 'hex', 'ascii', 'binary', 'ucs2']
  var aUe = function () {
    var t = process.versions.node.split('.')[0]
    return parseInt(t) >= 10
  }
  Ct.isBrotliSupperted = aUe
  Ct.gzipAsync = Ty.promisify(fD.gzip)
  Ct.gunzipAsync = Ty.promisify(fD.gunzip)
  Ct.deflateAsync = Ty.promisify(fD.deflate)
  Ct.inflateAsync = Ty.promisify(fD.inflate)
  var cUe = function (t) {
    var e = Ct.isBrotliSupperted()
    return e && typeof t.brotliCompress == 'function' ? Ty.promisify(t.brotliCompress) : null
  }
  Ct.getBrotliCompressAsync = cUe
  var lUe = function (t) {
    var e = Ct.isBrotliSupperted()
    return e && typeof t.brotliCompressSync == 'function' ? t.brotliCompressSync : null
  }
  Ct.getBrotliCompressSync = lUe
  var uUe = function (t) {
    var e = Ct.isBrotliSupperted()
    return e && typeof t.brotliDecompress == 'function' ? Ty.promisify(t.brotliDecompress) : null
  }
  Ct.getBrotliDecompressAsync = uUe
  var pUe = function (t) {
    var e = Ct.isBrotliSupperted()
    return e && typeof t.brotliDecompressSync == 'function' ? t.brotliDecompressSync : null
  }
  Ct.getBrotliDecompressSync = pUe
  var dUe = function (t, e) {
    var r = e || 'utf8',
      n = !1
    if (Buffer.isEncoding(r)) {
      var i = Buffer.from(t.toString(r), r)
      n = i.toJSON().data.toString() === t.toJSON().data.toString()
    }
    return n
  }
  Ct.isBufferType = dUe
  var fUe = function (t) {
    var e = null
    for (var r in Ct.bufferEncodingTypes) {
      var n = Ct.bufferEncodingTypes[r]
      if (Buffer.isEncoding(n) && Ct.isBufferType(t, n)) {
        e = n
        break
      }
    }
    return e
  }
  Ct.findBufferEncodingType = fUe
  var mUe = function (t) {
    var e = null
    switch (t) {
      case 'gzip':
        e = dD.GZIP
        break
      case 'br':
        e = dD.BR
        break
      case 'deflate':
        e = dD.DEFLATE
        break
      default:
    }
    return e
  }
  Ct.isSupportedContentEncoding = mUe
  var hUe = function (t) {
    var e = [],
      r = t.getHeader('Content-Encoding')
    if (!r) return null
    if (typeof r == 'string') {
      var n = Ct.isSupportedContentEncoding(r)
      n && e.push(n)
    }
    return e
  }
  Ct.getContentEncodingFromHeaders = hUe
  var gUe = function (t, e, r) {
    if (t < 0) return null
    var n = null,
      i = e.substring(0, t),
      o = e.substring(t)
    return (n = i + '<script type="text/javascript">' + r + '</script>' + o), n
  }
  Ct.insertSnippetByIndex = gUe
  var vUe = function (t) {
    var e = !1,
      r = t.getHeader('Content-Type')
    return r && (typeof r == 'string' ? (e = r.indexOf('html') >= 0) : (e = r.toString().indexOf('html') >= 0)), e
  }
  Ct.isContentTypeHeaderHtml = vUe
})
var Bue = handleExports(qi => {
  'use strict'
  Object.defineProperty(qi, '__esModule', { value: !0 })
  qi.getResourceProvider = qi.getOsPrefix = qi.isFunctionApp = qi.isWebApp = qi.isLinux = qi.isWindows = void 0
  var _Ue = function () {
    return process.platform === 'win32'
  }
  qi.isWindows = _Ue
  var yUe = function () {
    return process.platform === 'linux'
  }
  qi.isLinux = yUe
  var xUe = function () {
    return !!process.env.WEBSITE_SITE_NAME
  }
  qi.isWebApp = xUe
  var bUe = function () {
    return !!process.env.FUNCTIONS_WORKER_RUNTIME
  }
  qi.isFunctionApp = bUe
  var EUe = function () {
    return qi.isWindows() ? 'w' : qi.isLinux() ? 'l' : 'u'
  }
  qi.getOsPrefix = EUe
  var TUe = function () {
    return qi.isWebApp() ? 'a' : qi.isFunctionApp() ? 'f' : 'u'
  }
  qi.getResourceProvider = TUe
})
var Q7 = handleExports((EIt, Hue) => {
  'use strict'
  var que = xn(),
    SUe = (function () {
      function t() {}
      return (
        (t.parse = function (e) {
          if (!e) return {}
          var r = e.split(t._FIELDS_SEPARATOR),
            n = r.reduce(function (o, s) {
              var a = s.split(t._FIELD_KEY_VALUE_SEPARATOR)
              if (a.length === 2) {
                var l = a[0].toLowerCase(),
                  c = a[1]
                o[l] = c
              }
              return o
            }, {})
          if (Object.keys(n).length > 0) {
            if (n.endpointsuffix) {
              var i = n.location ? n.location + '.' : ''
              ;(n.ingestionendpoint = n.ingestionendpoint || 'https://' + i + 'dc.' + n.endpointsuffix),
                (n.liveendpoint = n.liveendpoint || 'https://' + i + 'live.' + n.endpointsuffix)
            }
            ;(n.ingestionendpoint = n.ingestionendpoint || que.DEFAULT_BREEZE_ENDPOINT),
              (n.liveendpoint = n.liveendpoint || que.DEFAULT_LIVEMETRICS_ENDPOINT)
          }
          return n
        }),
        (t.isIkeyValid = function (e) {
          if (!e || e == '') return !1
          var r = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
            n = new RegExp(r)
          return n.test(e)
        }),
        (t._FIELDS_SEPARATOR = ';'),
        (t._FIELD_KEY_VALUE_SEPARATOR = '='),
        t
      )
    })()
  Hue.exports = SUe
})
var jue = {}
defineProperties(jue, { webSnippet: () => CUe })
var CUe,
  Gue = createGetter(() => {
    CUe = `!function(T,l,y){var S=T.location,k="script",D="instrumentationKey",C="ingestionendpoint",I="disableExceptionTracking",E="ai.device.",b="toLowerCase",w="crossOrigin",N="POST",e="appInsightsSDK",t=y.name||"appInsights";(y.name||T[e])&&(T[e]=t);var n=T[t]||function(d){var g=!1,f=!1,m={initialize:!0,queue:[],sv:"5",version:2,config:d};function v(e,t){var n={},a="Browser";return n[E+"id"]=a[b](),n[E+"type"]=a,n["ai.operation.name"]=S&&S.pathname||"_unknown_",n["ai.internal.sdkVersion"]="javascript:snippet_"+(m.sv||m.version),{time:function(){var e=new Date;function t(e){var t=""+e;return 1===t.length&&(t="0"+t),t}return e.getUTCFullYear()+"-"+t(1+e.getUTCMonth())+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+((e.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),iKey:e,name:"Microsoft.ApplicationInsights."+e.replace(/-/g,"")+"."+t,sampleRate:100,tags:n,data:{baseData:{ver:2}}}}var h=d.url||y.src;if(h){function a(e){var t,n,a,i,r,o,s,c,u,p,l;g=!0,m.queue=[],f||(f=!0,t=h,s=function(){var e={},t=d.connectionString;if(t)for(var n=t.split(";"),a=0;a<n.length;a++){var i=n[a].split("=");2===i.length&&(e[i[0][b]()]=i[1])}if(!e[C]){var r=e.endpointsuffix,o=r?e.location:null;e[C]="https://"+(o?o+".":"")+"dc."+(r||"services.visualstudio.com")}return e}(),c=s[D]||d[D]||"",u=s[C],p=u?u+"/v2/track":d.endpointUrl,(l=[]).push((n="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",a=t,i=p,(o=(r=v(c,"Exception")).data).baseType="ExceptionData",o.baseData.exceptions=[{typeName:"SDKLoadFailed",message:n.replace(/\\./g,"-"),hasFullStack:!1,stack:n+"\\nSnippet failed to load ["+a+"] -- Telemetry is disabled\\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\\nHost: "+(S&&S.pathname||"_unknown_")+"\\nEndpoint: "+i,parsedStack:[]}],r)),l.push(function(e,t,n,a){var i=v(c,"Message"),r=i.data;r.baseType="MessageData";var o=r.baseData;return o.message='AI (Internal): 99 message:"'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+n+")").replace(/\\"/g,"")+'"',o.properties={endpoint:a},i}(0,0,t,p)),function(e,t){if(JSON){var n=T.fetch;if(n&&!y.useXhr)n(t,{method:N,body:JSON.stringify(e),mode:"cors"});else if(XMLHttpRequest){var a=new XMLHttpRequest;a.open(N,t),a.setRequestHeader("Content-type","application/json"),a.send(JSON.stringify(e))}}}(l,p))}function i(e,t){f||setTimeout(function(){!t&&m.core||a()},500)}var e=function(){var n=l.createElement(k);n.src=h;var e=y[w];return!e&&""!==e||"undefined"==n[w]||(n[w]=e),n.onload=i,n.onerror=a,n.onreadystatechange=function(e,t){"loaded"!==n.readyState&&"complete"!==n.readyState||i(0,t)},n}();y.ld<0?l.getElementsByTagName("head")[0].appendChild(e):setTimeout(function(){l.getElementsByTagName(k)[0].parentNode.appendChild(e)},y.ld||0)}try{m.cookie=l.cookie}catch(p){}function t(e){for(;e.length;)!function(t){m[t]=function(){var e=arguments;g||m.queue.push(function(){m[t].apply(m,e)})}}(e.pop())}var n="track",r="TrackPage",o="TrackEvent";t([n+"Event",n+"PageView",n+"Exception",n+"Trace",n+"DependencyData",n+"Metric",n+"PageViewPerformance","start"+r,"stop"+r,"start"+o,"stop"+o,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),m.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4};var s=(d.extensionConfig||{}).ApplicationInsightsAnalytics||{};if(!0!==d[I]&&!0!==s[I]){var c="onerror";t(["_"+c]);var u=T[c];T[c]=function(e,t,n,a,i){var r=u&&u(e,t,n,a,i);return!0!==r&&m["_"+c]({message:e,url:t,lineNumber:n,columnNumber:a,error:i}),r},d.autoExceptionInstrumented=!0}return m}(y.cfg);function a(){y.onInit&&y.onInit(n)}(T[t]=n).queue&&0===n.queue.length?(n.queue.push(a),n.trackPageView({})):a()}(window,document,{\r
src: "https://js.monitor.azure.com/scripts/b/ai.2.min.js", // The SDK URL Source\r
// name: "appInsights", // Global SDK Instance name defaults to "appInsights" when not supplied\r
// ld: 0, // Defines the load delay (in ms) before attempting to load the sdk. -1 = block page load and add to head. (default) = 0ms load after timeout,\r
// useXhr: 1, // Use XHR instead of fetch to report failures (if available),\r
// crossOrigin: "anonymous", // When supplied this will add the provided value as the cross origin attribute on the script tag\r
// onInit: null, // Once the application insights instance has loaded and initialized this callback function will be called with 1 argument -- the sdk instance (DO NOT ADD anything to the sdk.queue -- As they won't get called)\r
cfg: { // Application Insights Configuration\r
    instrumentationKey: "INSTRUMENTATION_KEY"\r
}});`
  })
var Yue = handleExports((TIt, Kue) => {
  'use strict'
  var Vue = require('http'),
    zue = require('https'),
    Sy = require('zlib'),
    iu = on(),
    ec = Uue(),
    $ue = Bue(),
    tT = xn(),
    Wue = Q7(),
    IUe = (Gue(), handleEsModuleExports(jue)),
    wUe = (function () {
      function t(e) {
        var r
        if (((this._isIkeyValid = !0), t.INSTANCE))
          throw new Error('Web snippet injection should be configured from the applicationInsights object')
        ;(t.INSTANCE = this),
          (t._aiUrl = tT.WEB_INSTRUMENTATION_DEFAULT_SOURCE),
          (t._aiDeprecatedUrl = tT.WEB_INSTRUMENTATION_DEPRECATED_SOURCE)
        var n = this._getWebSnippetIkey(
          (r = e.config) === null || r === void 0 ? void 0 : r.webInstrumentationConnectionString
        )
        ;(this._webInstrumentationIkey = n || e.config.instrumentationKey),
          (this._clientWebInstrumentationConfig = e.config.webInstrumentationConfig),
          (this._clientWebInstrumentationSrc = e.config.webInstrumentationSrc),
          (this._statsbeat = e.getStatsbeat())
      }
      return (
        (t.prototype.enable = function (e, r) {
          ;(this._isEnabled = e),
            (this._webInstrumentationIkey = this._getWebSnippetIkey(r) || this._webInstrumentationIkey),
            (t._snippet = this._getWebInstrumentationReplacedStr()),
            this._isEnabled && !this._isInitialized && this._isIkeyValid
              ? (this._statsbeat && this._statsbeat.addFeature(tT.StatsbeatFeature.WEB_SNIPPET), this._initialize())
              : this._isEnabled || (this._statsbeat && this._statsbeat.removeFeature(tT.StatsbeatFeature.WEB_SNIPPET))
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.prototype._getWebSnippetIkey = function (e) {
          var r = null
          try {
            var n = Wue.parse(e),
              i = n.instrumentationkey || ''
            Wue.isIkeyValid(i)
              ? ((this._isIkeyValid = !0), (r = i))
              : ((this._isIkeyValid = !1),
                iu.info('Invalid web Instrumentation connection string, web Instrumentation is not enabled.'))
          } catch (o) {
            iu.info('get web snippet ikey error: ' + o)
          }
          return r
        }),
        (t.prototype._getWebInstrumentationReplacedStr = function () {
          var e = this._getClientWebInstrumentationConfigStr(this._clientWebInstrumentationConfig),
            r = $ue.getOsPrefix(),
            n = $ue.getResourceProvider(),
            i =
              this._webInstrumentationIkey +
              `",\r
` +
              e +
              ` disableIkeyDeprecationMessage: true,\r
 sdkExtension: "` +
              n +
              r +
              'd_n_',
            o = IUe.webSnippet.replace('INSTRUMENTATION_KEY', i)
          return this._clientWebInstrumentationSrc
            ? o.replace(tT.WEB_INSTRUMENTATION_DEFAULT_SOURCE + '.2.min.js', this._clientWebInstrumentationSrc)
            : o
        }),
        (t.prototype._getClientWebInstrumentationConfigStr = function (e) {
          var r = ''
          try {
            e != null &&
              e.length > 0 &&
              e.forEach(function (n) {
                var i = n.name
                if (i !== void 0) {
                  var o = n.value,
                    s = ''
                  switch (typeof o) {
                    case 'function':
                      break
                    case 'object':
                      break
                    case 'string':
                      ;(s =
                        ' ' +
                        i +
                        ': "' +
                        o +
                        `",\r
`),
                        (r += s)
                      break
                    default:
                      ;(s =
                        ' ' +
                        i +
                        ': ' +
                        o +
                        `,\r
`),
                        (r += s)
                      break
                  }
                }
              })
          } catch {
            ;(this._isEnabled = !1), iu.info('Parse client web instrumentation error. Web Instrumentation is disabled')
          }
          return r
        }),
        (t.prototype._initialize = function () {
          this._isInitialized = !0
          var e = Vue.createServer,
            r = zue.createServer,
            n = this._isEnabled
          ;(Vue.createServer = function (i) {
            var o = i
            return (
              o &&
                (i = function (s, a) {
                  var l = a.write,
                    c = s.method == 'GET'
                  a.write = function (d, f, m) {
                    try {
                      if (n && c) {
                        var h = ec.getContentEncodingFromHeaders(a),
                          g = void 0
                        if ((typeof f == 'string' && (g = f), h == null))
                          t.INSTANCE.ValidateInjection(a, d) &&
                            (arguments[0] = t.INSTANCE.InjectWebSnippet(a, d, void 0, g))
                        else if (h.length) {
                          var v = h[0]
                          arguments[0] = t.INSTANCE.InjectWebSnippet(a, d, v)
                        }
                      }
                    } catch (_) {
                      iu.warn('Inject snippet error: ' + _)
                    }
                    return l.apply(a, arguments)
                  }
                  var u = a.end
                  return (
                    (a.end = function (d, f, m) {
                      if (n && c)
                        try {
                          if (n && c) {
                            var h = ec.getContentEncodingFromHeaders(a),
                              g = void 0
                            if ((typeof f == 'string' && (g = f), h == null))
                              t.INSTANCE.ValidateInjection(a, d) &&
                                (arguments[0] = t.INSTANCE.InjectWebSnippet(a, d, void 0, g))
                            else if (h.length) {
                              var v = h[0]
                              arguments[0] = t.INSTANCE.InjectWebSnippet(a, d, v)
                            }
                          }
                        } catch (_) {
                          iu.warn('Inject snipet error: ' + _)
                        }
                      return u.apply(a, arguments)
                    }),
                    o(s, a)
                  )
                }),
              e(i)
            )
          }),
            (zue.createServer = function (i, o) {
              var s = o
              if (s)
                return (
                  (o = function (a, l) {
                    var c = a.method == 'GET',
                      u = l.write,
                      p = l.end
                    return (
                      (l.write = function (f, m, h) {
                        try {
                          if (n && c) {
                            var g = ec.getContentEncodingFromHeaders(l),
                              v = void 0
                            if ((typeof m == 'string' && (v = m), g == null))
                              t.INSTANCE.ValidateInjection(l, f) &&
                                (arguments[0] = this.InjectWebSnippet(l, f, void 0, v))
                            else if (g.length) {
                              var _ = g[0]
                              arguments[0] = t.INSTANCE.InjectWebSnippet(l, f, _)
                            }
                          }
                        } catch (y) {
                          iu.warn('Inject snippet error: ' + y)
                        }
                        return u.apply(l, arguments)
                      }),
                      (l.end = function (f, m, h) {
                        try {
                          if (n && c) {
                            var g = ec.getContentEncodingFromHeaders(l),
                              v = void 0
                            if ((typeof m == 'string' && (v = m), g == null))
                              t.INSTANCE.ValidateInjection(l, f) &&
                                (arguments[0] = t.INSTANCE.InjectWebSnippet(l, f, void 0, v))
                            else if (g.length) {
                              var _ = g[0]
                              arguments[0] = t.INSTANCE.InjectWebSnippet(l, f, _)
                            }
                          }
                        } catch (y) {
                          iu.warn('Inject snippet error: ' + y)
                        }
                        return p.apply(l, arguments)
                      }),
                      s(a, l)
                    )
                  }),
                  r(i, o)
                )
            })
        }),
        (t.prototype.ValidateInjection = function (e, r) {
          try {
            if (!e || !r || e.statusCode != 200) return !1
            var n = ec.isContentTypeHeaderHtml(e)
            if (!n) return !1
            var i = r.slice().toString()
            if (
              i.indexOf('<head>') >= 0 &&
              i.indexOf('</head>') >= 0 &&
              i.indexOf(t._aiUrl) < 0 &&
              i.indexOf(t._aiDeprecatedUrl) < 0
            )
              return !0
          } catch (o) {
            iu.info('validate injections error: ' + o)
          }
          return !1
        }),
        (t.prototype.InjectWebSnippet = function (e, r, n, i) {
          try {
            var o = !!n
            if (o)
              e.removeHeader('Content-Length'),
                (r = this._getInjectedCompressBuffer(e, r, n)),
                e.setHeader('Content-Length', r.length)
            else {
              var s = r.toString(),
                a = s.indexOf('</head>')
              if (a < 0) return r
              var l = ec.insertSnippetByIndex(a, s, t._snippet)
              if (typeof r == 'string')
                e.removeHeader('Content-Length'), (r = l), e.setHeader('Content-Length', Buffer.byteLength(r))
              else if (Buffer.isBuffer(r)) {
                var c = i || 'utf8',
                  u = ec.isBufferType(r, c)
                if (u) {
                  e.removeHeader('Content-Length')
                  var p = Buffer.from(l).toString(c)
                  ;(r = Buffer.from(p, c)), e.setHeader('Content-Length', r.length)
                }
              }
            }
          } catch (d) {
            iu.warn('Failed to inject web snippet and change content-lenght headers. Exception:' + d)
          }
          return r
        }),
        (t.prototype._getInjectedCompressBuffer = function (e, r, n) {
          try {
            switch (n) {
              case ec.contentEncodingMethod.GZIP:
                var i = Sy.gunzipSync(r)
                if (this.ValidateInjection(e, i)) {
                  var o = this.InjectWebSnippet(e, i)
                  r = Sy.gzipSync(o)
                }
                break
              case ec.contentEncodingMethod.DEFLATE:
                var s = Sy.inflateSync(r)
                if (this.ValidateInjection(e, s)) {
                  var a = this.InjectWebSnippet(e, s)
                  r = Sy.deflateSync(a)
                }
                break
              case ec.contentEncodingMethod.BR:
                var l = ec.getBrotliDecompressSync(Sy),
                  c = ec.getBrotliCompressSync(Sy)
                if (l && c) {
                  var u = l(r)
                  if (this.ValidateInjection(e, u)) {
                    var p = this.InjectWebSnippet(e, u)
                    r = c(p)
                  }
                  break
                }
            }
          } catch (d) {
            iu.info('get web injection compress buffer error: ' + d)
          }
          return r
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
        }),
        t
      )
    })()
  Kue.exports = wUe
})
var Xue = handleExports((J7, Que) => {
  'use strict'
  var AUe =
      (J7 && J7.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    tc = require('url'),
    X7 = Ao(),
    RUe = oo(),
    DUe = Q_(),
    PUe = R9(),
    NUe = Gg(),
    kUe = (function (t) {
      AUe(e, t)
      function e(r, n) {
        var i = t.call(this) || this
        return (
          n &&
            n.method &&
            r &&
            ((i.method = n.method), (i.url = e._getUrlFromRequestOptions(r, n)), (i.startTime = +new Date())),
          i
        )
      }
      return (
        (e.prototype.onError = function (r) {
          this._setStatus(void 0, r)
        }),
        (e.prototype.onResponse = function (r) {
          this._setStatus(r.statusCode, void 0),
            (this.correlationId = RUe.getCorrelationContextTarget(r, DUe.requestContextTargetKey))
        }),
        (e.prototype.getDependencyTelemetry = function (r, n) {
          var i = this.method.toUpperCase(),
            o = X7.RemoteDependencyDataConstants.TYPE_HTTP,
            s = ''
          try {
            var a = new tc.URL(this.url)
            ;(a.search = void 0),
              (a.hash = void 0),
              (i += ' ' + a.pathname),
              (s = a.hostname),
              a.port && (s += ':' + a.port)
          } catch {}
          this.correlationId
            ? ((o = X7.RemoteDependencyDataConstants.TYPE_AI),
              this.correlationId !== NUe.correlationIdPrefix && (s += ' | ' + this.correlationId))
            : (o = X7.RemoteDependencyDataConstants.TYPE_HTTP)
          var l = {
            id: n,
            name: i,
            data: this.url,
            duration: this.duration,
            success: this._isSuccess(),
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            properties: this.properties || {},
            dependencyTypeName: o,
            target: s,
          }
          if ((r && r.time ? (l.time = r.time) : this.startTime && (l.time = new Date(this.startTime)), r)) {
            for (var c in r) l[c] || (l[c] = r[c])
            if (r.properties) for (var c in r.properties) l.properties[c] = r.properties[c]
          }
          return l
        }),
        (e._getUrlFromRequestOptions = function (r, n) {
          if (typeof r == 'string')
            if (r.indexOf('http://') === 0 || r.indexOf('https://') === 0)
              try {
                r = new tc.URL(r)
              } catch {}
            else
              try {
                var i = new tc.URL('http://' + r)
                i.port === '443' ? (r = new tc.URL('https://' + r)) : (r = new tc.URL('http://' + r))
              } catch {}
          else {
            if (r && typeof tc.URL == 'function' && r instanceof tc.URL) return tc.format(r)
            var o = r
            ;(r = {}),
              o &&
                Object.keys(o).forEach(function (l) {
                  r[l] = o[l]
                })
          }
          if (r.path && r.host)
            try {
              var s = new tc.URL(r.path, 'http://' + r.host + r.path)
              ;(r.pathname = s.pathname), (r.search = s.search)
            } catch {}
          if (r.path && r.hostname && !r.host)
            try {
              var s = new tc.URL(r.path, 'http://' + r.hostname + r.path)
              ;(r.pathname = s.pathname), (r.search = s.search)
            } catch {}
          if (r.host && r.port)
            try {
              var a = new tc.URL('http://' + r.host)
              !a.port && r.port && ((r.hostname = r.host), delete r.host)
            } catch {}
          return (
            (r.protocol = r.protocol || (n.agent && n.agent.protocol) || n.protocol || void 0),
            (r.hostname = r.hostname || 'localhost'),
            tc.format(r)
          )
        }),
        e
      )
    })(PUe)
  Que.exports = kUe
})
var Jue = handleExports(Cy => {
  'use strict'
  var mD =
    (Cy && Cy.__assign) ||
    function () {
      return (
        (mD =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        mD.apply(this, arguments)
      )
    }
  Object.defineProperty(Cy, '__esModule', { value: !0 })
  Cy.parseEventHubSpan = void 0
  var Z7 = (Yt(), handleEsModuleExports(q_)),
    OUe = (es(), handleEsModuleExports(Ioe)),
    LUe = (Hc(), handleEsModuleExports(gF)),
    rT = xn(),
    MUe = function (t) {
      var e = 0,
        r = 0,
        n = OUe.hrTimeToMilliseconds(t.startTime)
      return (
        t.links.forEach(function (i) {
          var o = i.attributes,
            s = o?.[rT.ENQUEUED_TIME]
          s && ((e += 1), (r += n - (parseFloat(s.toString()) || 0)))
        }),
        Math.max(r / (e || 1), 0)
      )
    },
    FUe = function (t, e) {
      var r,
        n = t.attributes[rT.AzNamespace],
        i = (t.attributes[LUe.SemanticAttributes.NET_PEER_NAME] || t.attributes['peer.address'] || 'unknown').replace(
          /\/$/g,
          ''
        ),
        o = t.attributes[rT.MessageBusDestination] || 'unknown'
      switch (t.kind) {
        case Z7.SpanKind.CLIENT:
          ;(e.dependencyTypeName = n), (e.target = i + '/' + o)
          break
        case Z7.SpanKind.PRODUCER:
          ;(e.dependencyTypeName = rT.DependencyTypeName.QueueMessage + ' | ' + n), (e.target = i + '/' + o)
          break
        case Z7.SpanKind.CONSUMER:
          ;(e.source = i + '/' + o),
            (e.measurements = mD(mD({}, e.measurements), ((r = {}), (r[rT.TIME_SINCE_ENQUEUED] = MUe(t)), r)))
          break
        default:
      }
    }
  Cy.parseEventHubSpan = FUe
})
var tpe = handleExports(hD => {
  'use strict'
  Object.defineProperty(hD, '__esModule', { value: !0 })
  hD.spanToTelemetryContract = void 0
  var Zue = require('url'),
    $c = (Yt(), handleEsModuleExports(q_)),
    Ut = (Hc(), handleEsModuleExports(gF)),
    Bp = xn(),
    UUe = Jue(),
    BUe = oo()
  function qUe(t) {
    for (var e = {}, r = 0, n = Object.keys(t.attributes); r < n.length; r++) {
      var i = n[r]
      i.startsWith('http.') ||
        i.startsWith('rpc.') ||
        i.startsWith('db.') ||
        i.startsWith('peer.') ||
        i.startsWith('net.') ||
        (e[i] = t.attributes[i])
    }
    var o = t.links.map(function (s) {
      return { operation_Id: s.context.traceId, id: s.context.spanId }
    })
    return o.length > 0 && (e['_MS.links'] = BUe.stringify(o)), e
  }
  function HUe(t) {
    return (
      t === Ut.DbSystemValues.DB2 ||
      t === Ut.DbSystemValues.DERBY ||
      t === Ut.DbSystemValues.MARIADB ||
      t === Ut.DbSystemValues.MSSQL ||
      t === Ut.DbSystemValues.ORACLE ||
      t === Ut.DbSystemValues.SQLITE ||
      t === Ut.DbSystemValues.OTHER_SQL ||
      t === Ut.DbSystemValues.HSQLDB ||
      t === Ut.DbSystemValues.H2
    )
  }
  function epe(t) {
    var e = t.attributes[Ut.SemanticAttributes.HTTP_METHOD]
    if (e) {
      var r = t.attributes[Ut.SemanticAttributes.HTTP_URL]
      if (r) return String(r)
      var n = t.attributes[Ut.SemanticAttributes.HTTP_SCHEME],
        i = t.attributes[Ut.SemanticAttributes.HTTP_TARGET]
      if (n && i) {
        var o = t.attributes[Ut.SemanticAttributes.HTTP_HOST]
        if (o) return n + '://' + o + i
        var s = t.attributes[Ut.SemanticAttributes.NET_PEER_PORT]
        if (s) {
          var a = t.attributes[Ut.SemanticAttributes.NET_PEER_NAME]
          if (a) return n + '://' + a + ':' + s + i
          var l = t.attributes[Ut.SemanticAttributes.NET_PEER_IP]
          if (l) return n + '://' + l + ':' + s + i
        }
      }
    }
    return ''
  }
  function eU(t) {
    var e = t.attributes[Ut.SemanticAttributes.PEER_SERVICE],
      r = t.attributes[Ut.SemanticAttributes.HTTP_HOST],
      n = t.attributes[Ut.SemanticAttributes.HTTP_URL],
      i = t.attributes[Ut.SemanticAttributes.NET_PEER_NAME],
      o = t.attributes[Ut.SemanticAttributes.NET_PEER_IP]
    return e ? String(e) : r ? String(r) : n ? String(n) : i ? String(i) : o ? String(o) : ''
  }
  function jUe(t) {
    var e = {
      name: t.name,
      success: t.status.code != $c.SpanStatusCode.ERROR,
      resultCode: '0',
      duration: 0,
      data: '',
      dependencyTypeName: '',
    }
    t.kind === $c.SpanKind.PRODUCER && (e.dependencyTypeName = Bp.DependencyTypeName.QueueMessage),
      t.kind === $c.SpanKind.INTERNAL && t.parentSpanId && (e.dependencyTypeName = Bp.DependencyTypeName.InProc)
    var r = t.attributes[Ut.SemanticAttributes.HTTP_METHOD],
      n = t.attributes[Ut.SemanticAttributes.DB_SYSTEM],
      i = t.attributes[Ut.SemanticAttributes.RPC_SYSTEM]
    if (r) {
      e.dependencyTypeName = Bp.DependencyTypeName.Http
      var o = t.attributes[Ut.SemanticAttributes.HTTP_URL]
      if (o) {
        var s = ''
        try {
          var a = new Zue.URL(String(o))
          s = a.pathname
        } catch {}
        e.name = r + ' ' + s
      }
      e.data = epe(t)
      var l = t.attributes[Ut.SemanticAttributes.HTTP_STATUS_CODE]
      l && (e.resultCode = String(l))
      var c = eU(t)
      if (c) {
        try {
          var u = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/),
            p = u.exec(c)
          if (p != null) {
            var d = p[1],
              f = p[3]
            ;((d == 'https' && f == ':443') || (d == 'http' && f == ':80')) && (c = p[1] + p[2] + p[4])
          }
        } catch {}
        e.target = '' + c
      }
    } else if (n) {
      String(n) === Ut.DbSystemValues.MYSQL
        ? (e.dependencyTypeName = 'mysql')
        : String(n) === Ut.DbSystemValues.POSTGRESQL
        ? (e.dependencyTypeName = 'postgresql')
        : String(n) === Ut.DbSystemValues.MONGODB
        ? (e.dependencyTypeName = 'mongodb')
        : String(n) === Ut.DbSystemValues.REDIS
        ? (e.dependencyTypeName = 'redis')
        : HUe(String(n))
        ? (e.dependencyTypeName = 'SQL')
        : (e.dependencyTypeName = String(n))
      var m = t.attributes[Ut.SemanticAttributes.DB_STATEMENT],
        h = t.attributes[Ut.SemanticAttributes.DB_OPERATION]
      m ? (e.data = String(m)) : h && (e.data = String(h))
      var c = eU(t),
        g = t.attributes[Ut.SemanticAttributes.DB_NAME]
      c ? (e.target = g ? c + '|' + g : '' + c) : (e.target = g ? '' + g : '' + n)
    } else if (i) {
      e.dependencyTypeName = Bp.DependencyTypeName.Grpc
      var v = t.attributes[Ut.SemanticAttributes.RPC_GRPC_STATUS_CODE]
      v && (e.resultCode = String(v))
      var c = eU(t)
      c ? (e.target = '' + c) : i && (e.target = String(i))
    }
    return e
  }
  function GUe(t) {
    var e = {
        name: t.name,
        success: t.status.code != $c.SpanStatusCode.ERROR,
        resultCode: '0',
        duration: 0,
        url: '',
        source: void 0,
      },
      r = t.attributes[Ut.SemanticAttributes.HTTP_METHOD],
      n = t.attributes[Ut.SemanticAttributes.RPC_GRPC_STATUS_CODE]
    if (r) {
      if (t.kind == $c.SpanKind.SERVER) {
        var i = t.attributes[Ut.SemanticAttributes.HTTP_ROUTE],
          o = t.attributes[Ut.SemanticAttributes.HTTP_URL]
        if (i) e.name = r + ' ' + i
        else if (o)
          try {
            var s = new Zue.URL(String(o))
            e.name = r + ' ' + s.pathname
          } catch {}
      }
      e.url = epe(t)
      var a = t.attributes[Ut.SemanticAttributes.HTTP_STATUS_CODE]
      a && (e.resultCode = String(a))
    } else n && (e.resultCode = String(n))
    return e
  }
  function VUe(t) {
    var e
    switch (t.kind) {
      case $c.SpanKind.CLIENT:
      case $c.SpanKind.PRODUCER:
      case $c.SpanKind.INTERNAL:
        e = jUe(t)
        break
      case $c.SpanKind.SERVER:
      case $c.SpanKind.CONSUMER:
        e = GUe(t)
        break
    }
    var r = t.spanContext ? t.spanContext() : t.context(),
      n = '' + r.spanId,
      i = Math.round(t.duration[0] * 1e3 + t.duration[1] / 1e6)
    return (
      (e.id = n),
      (e.duration = i),
      (e.properties = qUe(t)),
      t.attributes[Bp.AzNamespace] &&
        (t.kind === $c.SpanKind.INTERNAL &&
          (e.dependencyTypeName = Bp.DependencyTypeName.InProc + ' | ' + t.attributes[Bp.AzNamespace]),
        t.attributes[Bp.AzNamespace] === Bp.MicrosoftEventHub && UUe.parseEventHubSpan(t, e)),
      e
    )
  }
  hD.spanToTelemetryContract = VUe
})
var npe = handleExports(Jf => {
  'use strict'
  var Iy =
    (Jf && Jf.__assign) ||
    function () {
      return (
        (Iy =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        Iy.apply(this, arguments)
      )
    }
  Object.defineProperty(Jf, '__esModule', { value: !0 })
  Jf.AsyncScopeManager = Jf.OpenTelemetryScopeManagerWrapper = void 0
  var Xf = Wf(),
    zUe = require('events'),
    rpe = (function () {
      function t() {}
      return (
        (t.prototype.active = function () {
          var e = this,
            r = Xf.CorrelationContextManager.getCurrentContext()
          return Iy(Iy({}, r), {
            getValue: function (n) {
              return e._activeSymbol ? (n === e._activeSymbol ? r : !1) : ((e._activeSymbol = n), r)
            },
            setValue: function () {},
          })
        }),
        (t.prototype.with = function (e, r) {
          var n = e.parentSpanId,
            i = e.name,
            o = t._spanToContext(e, n, i)
          return Xf.CorrelationContextManager.runWithContext(o, r)()
        }),
        (t.prototype.bind = function (e) {
          return typeof e == 'function'
            ? Xf.CorrelationContextManager.wrapCallback(e)
            : (e instanceof zUe.EventEmitter && Xf.CorrelationContextManager.wrapEmitter(e), e)
        }),
        (t.prototype.enable = function () {
          return Xf.CorrelationContextManager.enable(), this
        }),
        (t.prototype.disable = function () {
          return Xf.CorrelationContextManager.disable(), this
        }),
        (t._spanToContext = function (e, r, n) {
          var i = e.spanContext ? e.spanContext() : e.context(),
            o = Iy(Iy({}, e.spanContext()), { traceFlags: e.spanContext().traceFlags }),
            s = r ? '|' + i.traceId + '.' + r + '.' : i.traceId,
            a = Xf.CorrelationContextManager.getCurrentContext()
          a && ((o.traceId = a.operation.id), r || (s = a.operation.parentId))
          var l = Xf.CorrelationContextManager.spanToContextObject(o, s, n)
          return l
        }),
        t
      )
    })()
  Jf.OpenTelemetryScopeManagerWrapper = rpe
  Jf.AsyncScopeManager = new rpe()
})
var ipe = handleExports(Zf => {
  'use strict'
  Object.defineProperty(Zf, '__esModule', { value: !0 })
  Zf.enable = Zf.subscriber = void 0
  var nT = (Yt(), handleEsModuleExports(q_)),
    $Ue = xn(),
    tU = On(),
    WUe = tpe(),
    KUe = npe(),
    ev = [],
    YUe = function (t) {
      try {
        var e = t.data,
          r = WUe.spanToTelemetryContract(e)
        KUe.AsyncScopeManager.with(e, function () {
          ev.forEach(function (n) {
            e.kind === nT.SpanKind.SERVER || e.kind === nT.SpanKind.CONSUMER
              ? n.trackRequest(r)
              : (e.kind === nT.SpanKind.CLIENT || e.kind === nT.SpanKind.INTERNAL || e.kind === nT.SpanKind.PRODUCER) &&
                n.trackDependency(r)
          })
        })
      } catch {}
    }
  Zf.subscriber = YUe
  function QUe(t, e) {
    if (t) {
      var r = ev.find(function (n) {
        return n == e
      })
      if (r) return
      ev.length === 0 &&
        tU.channel.subscribe('azure-coretracing', Zf.subscriber, tU.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation($Ue.StatsbeatInstrumentation.AZURE_CORE_TRACING)
        }),
        ev.push(e)
    } else
      (ev = ev.filter(function (n) {
        return n != e
      })),
        ev.length === 0 && tU.channel.unsubscribe('azure-coretracing', Zf.subscriber)
  }
  Zf.enable = QUe
})
var ope = handleExports(em => {
  'use strict'
  Object.defineProperty(em, '__esModule', { value: !0 })
  em.enable = em.subscriber = void 0
  var XUe = xn(),
    rU = On(),
    tv = [],
    JUe = function (t) {
      t.data.event.commandName !== 'ismaster' &&
        tv.forEach(function (e) {
          var r = (t.data.startedData && t.data.startedData.databaseName) || 'Unknown database'
          e.trackDependency({
            target: r,
            data: t.data.event.commandName,
            name: t.data.event.commandName,
            duration: t.data.event.duration,
            success: t.data.succeeded,
            resultCode: t.data.succeeded ? '0' : '1',
            time: t.data.startedData.time,
            dependencyTypeName: 'mongodb',
          })
        })
    }
  em.subscriber = JUe
  function ZUe(t, e) {
    if (t) {
      var r = tv.find(function (n) {
        return n == e
      })
      if (r) return
      tv.length === 0 &&
        rU.channel.subscribe('mongodb', em.subscriber, rU.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(XUe.StatsbeatInstrumentation.MONGODB)
        }),
        tv.push(e)
    } else
      (tv = tv.filter(function (n) {
        return n != e
      })),
        tv.length === 0 && rU.channel.unsubscribe('mongodb', em.subscriber)
  }
  em.enable = ZUe
})
var spe = handleExports(tm => {
  'use strict'
  Object.defineProperty(tm, '__esModule', { value: !0 })
  tm.enable = tm.subscriber = void 0
  var eBe = xn(),
    nU = On(),
    rv = [],
    tBe = function (t) {
      rv.forEach(function (e) {
        var r = t.data.query || {},
          n = r.sql || 'Unknown query',
          i = !t.data.err,
          o = r._connection || {},
          s = o.config || {},
          a = s.socketPath ? s.socketPath : (s.host || 'localhost') + ':' + s.port
        e.trackDependency({
          target: a,
          data: n,
          name: n,
          duration: t.data.duration,
          success: i,
          resultCode: i ? '0' : '1',
          time: t.data.time,
          dependencyTypeName: 'mysql',
        })
      })
    }
  tm.subscriber = tBe
  function rBe(t, e) {
    if (t) {
      var r = rv.find(function (n) {
        return n == e
      })
      if (r) return
      rv.length === 0 &&
        nU.channel.subscribe('mysql', tm.subscriber, nU.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(eBe.StatsbeatInstrumentation.MYSQL)
        }),
        rv.push(e)
    } else
      (rv = rv.filter(function (n) {
        return n != e
      })),
        rv.length === 0 && nU.channel.unsubscribe('mysql', tm.subscriber)
  }
  tm.enable = rBe
})
var ape = handleExports(rm => {
  'use strict'
  Object.defineProperty(rm, '__esModule', { value: !0 })
  rm.enable = rm.subscriber = void 0
  var nBe = xn(),
    iU = On(),
    nv = [],
    iBe = function (t) {
      nv.forEach(function (e) {
        t.data.commandObj.command !== 'info' &&
          e.trackDependency({
            target: t.data.address,
            name: t.data.commandObj.command,
            data: t.data.commandObj.command,
            duration: t.data.duration,
            success: !t.data.err,
            resultCode: t.data.err ? '1' : '0',
            time: t.data.time,
            dependencyTypeName: 'redis',
          })
      })
    }
  rm.subscriber = iBe
  function oBe(t, e) {
    if (t) {
      var r = nv.find(function (n) {
        return n == e
      })
      if (r) return
      nv.length === 0 &&
        iU.channel.subscribe('redis', rm.subscriber, iU.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(nBe.StatsbeatInstrumentation.REDIS)
        }),
        nv.push(e)
    } else
      (nv = nv.filter(function (n) {
        return n != e
      })),
        nv.length === 0 && iU.channel.unsubscribe('redis', rm.subscriber)
  }
  rm.enable = oBe
})
var cpe = handleExports(nm => {
  'use strict'
  Object.defineProperty(nm, '__esModule', { value: !0 })
  nm.enable = nm.subscriber = void 0
  var sBe = xn(),
    oU = On(),
    iv = [],
    aBe = function (t) {
      iv.forEach(function (e) {
        var r = t.data.query,
          n = (r.preparable && r.preparable.text) || r.plan || r.text || 'unknown query',
          i = !t.data.error,
          o = t.data.database.host + ':' + t.data.database.port
        e.trackDependency({
          target: o,
          data: n,
          name: n,
          duration: t.data.duration,
          success: i,
          resultCode: i ? '0' : '1',
          time: t.data.time,
          dependencyTypeName: 'postgres',
        })
      })
    }
  nm.subscriber = aBe
  function cBe(t, e) {
    if (t) {
      var r = iv.find(function (n) {
        return n == e
      })
      if (r) return
      iv.length === 0 &&
        oU.channel.subscribe('postgres', nm.subscriber, oU.trueFilter, function (n, i) {
          var o = e.getStatsbeat()
          o && o.addInstrumentation(sBe.StatsbeatInstrumentation.POSTGRES)
        }),
        iv.push(e)
    } else
      (iv = iv.filter(function (n) {
        return n != e
      })),
        iv.length === 0 && oU.channel.unsubscribe('postgres', nm.subscriber)
  }
  nm.enable = cBe
})
var Ry = handleExports((aU, lpe) => {
  'use strict'
  var gD =
      (aU && aU.__spreadArrays) ||
      function () {
        for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length
        for (var n = Array(t), i = 0, e = 0; e < r; e++)
          for (var o = arguments[e], s = 0, a = o.length; s < a; s++, i++) n[i] = o[s]
        return n
      },
    wy = require('http'),
    Ay = require('https'),
    vD = on(),
    sU = oo(),
    im = Q_(),
    lBe = Xue(),
    iT = Wf(),
    _D = yR(),
    uBe = _R(),
    oT = Gg(),
    pBe = (function () {
      function t(e) {
        if (t.INSTANCE)
          throw new Error('Client request tracking should be configured from the applicationInsights object')
        ;(t.INSTANCE = this), (this._client = e)
      }
      return (
        (t.prototype.enable = function (e) {
          ;(this._isEnabled = e),
            this._isEnabled && !this._isInitialized && this._initialize(),
            uBe.IsInitialized &&
              (ipe().enable(e, this._client),
              ope().enable(e, this._client),
              spe().enable(e, this._client),
              ape().enable(e, this._client),
              cpe().enable(e, this._client))
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.prototype._initialize = function () {
          var e = this
          this._isInitialized = !0
          var r = wy.request,
            n = Ay.request,
            i = function (o, s) {
              try {
                var a = !s[t.disableCollectionRequestOption] && !o[t.alreadyAutoCollectedFlag],
                  l = null
                if (
                  (s.headers &&
                    ((l = s.headers['User-Agent'] || s.headers['user-agent']),
                    l && l.toString().indexOf('azsdk-js') !== -1 && (a = !1)),
                  o && s && a && (iT.CorrelationContextManager.wrapEmitter(o), e._isEnabled))
                )
                  if (((o[t.alreadyAutoCollectedFlag] = !0), iT.CorrelationContextManager.getCurrentContext()))
                    t.trackRequest(e._client, { options: s, request: o })
                  else {
                    var c = null
                    if (oT.w3cEnabled) {
                      var u = new _D()
                      c = u.traceId
                    } else {
                      var p = oT.generateRequestId(null)
                      c = oT.getRootId(p)
                    }
                    var d = iT.CorrelationContextManager.generateContextObject(c)
                    iT.CorrelationContextManager.runWithContext(d, function () {
                      t.trackRequest(e._client, { options: s, request: o })
                    })
                  }
              } catch (f) {
                vD.warn('Failed to generate dependency telemetry.', sU.dumpObj(f))
              }
            }
          ;(wy.request = function (o) {
            for (var s = [], a = 1; a < arguments.length; a++) s[a - 1] = arguments[a]
            var l = r.call.apply(r, gD([wy, o], s))
            return i(l, o), l
          }),
            (Ay.request = function (o) {
              for (var s = [], a = 1; a < arguments.length; a++) s[a - 1] = arguments[a]
              var l = n.call.apply(n, gD([Ay, o], s))
              return i(l, o), l
            }),
            (wy.get = function (o) {
              for (var s, a = [], l = 1; l < arguments.length; l++) a[l - 1] = arguments[l]
              var c = (s = wy.request).call.apply(s, gD([wy, o], a))
              return c.end(), c
            }),
            (Ay.get = function (o) {
              for (var s, a = [], l = 1; l < arguments.length; l++) a[l - 1] = arguments[l]
              var c = (s = Ay.request).call.apply(s, gD([Ay, o], a))
              return c.end(), c
            })
        }),
        (t.trackRequest = function (e, r) {
          if (!r.options || !r.request || !e) {
            vD.info(
              'AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ',
              !r.options,
              !r.request,
              !e
            )
            return
          }
          var n = new lBe(r.options, r.request),
            i = iT.CorrelationContextManager.getCurrentContext(),
            o,
            s
          if (i && i.operation && i.operation.traceparent && _D.isValidTraceId(i.operation.traceparent.traceId))
            i.operation.traceparent.updateSpanId(), (o = i.operation.traceparent.getBackCompatRequestId())
          else if (oT.w3cEnabled) {
            var a = new _D()
            ;(s = a.toString()), (o = a.getBackCompatRequestId())
          } else o = i && i.operation && i.operation.parentId + t.requestNumber++ + '.'
          if (
            sU.canIncludeCorrelationHeader(e, n.getUrl()) &&
            r.request.getHeader &&
            r.request.setHeader &&
            e.config &&
            e.config.correlationId
          ) {
            var l = r.request.getHeader(im.requestContextHeader)
            try {
              sU.safeIncludeCorrelationHeader(e, r.request, l)
            } catch (p) {
              vD.warn('Request-Context header could not be set. Correlation of requests may be lost', p)
            }
            if (i && i.operation)
              try {
                if (
                  (r.request.setHeader(im.requestIdHeader, o),
                  e.config.ignoreLegacyHeaders ||
                    (r.request.setHeader(im.parentIdHeader, i.operation.id), r.request.setHeader(im.rootIdHeader, o)),
                  s || i.operation.traceparent)
                )
                  r.request.setHeader(im.traceparentHeader, s || i.operation.traceparent.toString())
                else if (oT.w3cEnabled) {
                  var a = new _D().toString()
                  r.request.setHeader(im.traceparentHeader, a)
                }
                if (i.operation.tracestate) {
                  var c = i.operation.tracestate.toString()
                  c && r.request.setHeader(im.traceStateHeader, c)
                }
                var u = i.customProperties.serializeToHeader()
                u && r.request.setHeader(im.correlationContextHeader, u)
              } catch (p) {
                vD.warn('Correlation headers could not be set. Correlation of requests may be lost.', p)
              }
          }
          r.request.on &&
            (r.request.on('response', function (p) {
              if (!r.isProcessed) {
                ;(r.isProcessed = !0), n.onResponse(p)
                var d = n.getDependencyTelemetry(r, o)
                ;(d.contextObjects = d.contextObjects || {}),
                  (d.contextObjects['http.RequestOptions'] = r.options),
                  (d.contextObjects['http.ClientRequest'] = r.request),
                  (d.contextObjects['http.ClientResponse'] = p),
                  e.trackDependency(d)
              }
            }),
            r.request.on('error', function (p) {
              if (!r.isProcessed) {
                ;(r.isProcessed = !0), n.onError(p)
                var d = n.getDependencyTelemetry(r, o)
                ;(d.contextObjects = d.contextObjects || {}),
                  (d.contextObjects['http.RequestOptions'] = r.options),
                  (d.contextObjects['http.ClientRequest'] = r.request),
                  (d.contextObjects.Error = p),
                  e.trackDependency(d)
              }
            }),
            r.request.on('abort', function () {
              if (!r.isProcessed) {
                ;(r.isProcessed = !0),
                  n.onError(new Error('The request has been aborted and the network socket has closed.'))
                var p = n.getDependencyTelemetry(r, o)
                ;(p.contextObjects = p.contextObjects || {}),
                  (p.contextObjects['http.RequestOptions'] = r.options),
                  (p.contextObjects['http.ClientRequest'] = r.request),
                  e.trackDependency(p)
              }
            }))
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null), this.enable(!1), (this._isInitialized = !1)
        }),
        (t.disableCollectionRequestOption = 'disableAppInsightsAutoCollection'),
        (t.requestNumber = 1),
        (t.alreadyAutoCollectedFlag = '_appInsightsAutoCollected'),
        t
      )
    })()
  lpe.exports = pBe
})
var lU = handleExports((NIt, mpe) => {
  'use strict'
  var upe = require('http'),
    ppe = require('https'),
    dpe = on(),
    fpe = oo(),
    dBe = Q_(),
    cU = k9(),
    qp = Wf(),
    fBe = aD(),
    mBe = (function () {
      function t(e) {
        if (t.INSTANCE)
          throw new Error('Server request tracking should be configured from the applicationInsights object')
        ;(t.INSTANCE = this), (this._client = e)
      }
      return (
        (t.prototype.enable = function (e) {
          ;(this._isEnabled = e),
            (this._isAutoCorrelating || this._isEnabled || fBe.isEnabled()) &&
              !this._isInitialized &&
              (this.useAutoCorrelation(this._isAutoCorrelating), this._initialize())
        }),
        (t.prototype.useAutoCorrelation = function (e, r) {
          e && !this._isAutoCorrelating
            ? qp.CorrelationContextManager.enable(r)
            : !e && this._isAutoCorrelating && qp.CorrelationContextManager.disable(),
            (this._isAutoCorrelating = e)
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.prototype.isAutoCorrelating = function () {
          return this._isAutoCorrelating
        }),
        (t.prototype._generateCorrelationContext = function (e) {
          if (this._isAutoCorrelating)
            return qp.CorrelationContextManager.generateContextObject(
              e.getOperationId(this._client.context.tags),
              e.getRequestId(),
              e.getOperationName(this._client.context.tags),
              e.getCorrelationContextHeader(),
              e.getTraceparent(),
              e.getTracestate()
            )
        }),
        (t.prototype._registerRequest = function (e, r, n) {
          var i = this,
            o = new cU(e),
            s = this._generateCorrelationContext(o)
          qp.CorrelationContextManager.runWithContext(s, function () {
            i._isEnabled &&
              ((e[t.alreadyAutoCollectedFlag] = !0), t.trackRequest(i._client, { request: e, response: r }, o)),
              typeof n == 'function' && n(e, r)
          })
        }),
        (t.prototype._initialize = function () {
          if (((this._isInitialized = !0), !t.HANDLER_READY)) {
            t.HANDLER_READY = !0
            var e = function (o) {
                if (o) {
                  if (typeof o != 'function') throw new Error('onRequest handler must be a function')
                  return function (s, a) {
                    qp.CorrelationContextManager.wrapEmitter(s), qp.CorrelationContextManager.wrapEmitter(a)
                    var l = s && !s[t.alreadyAutoCollectedFlag]
                    s && l && t.INSTANCE ? t.INSTANCE._registerRequest(s, a, o) : o(s, a)
                  }
                }
              },
              r = function (o) {
                var s = o.addListener.bind(o)
                ;(o.addListener = function (a, l) {
                  switch (a) {
                    case 'request':
                    case 'checkContinue':
                      return s(a, e(l))
                    default:
                      return s(a, l)
                  }
                }),
                  (o.on = o.addListener)
              },
              n = upe.createServer
            upe.createServer = function (o, s) {
              if (s && typeof s == 'function') {
                var a = n(o, e(s))
                return r(a), a
              } else {
                var a = n(e(o))
                return r(a), a
              }
            }
            var i = ppe.createServer
            ppe.createServer = function (o, s) {
              var a = i(o, e(s))
              return r(a), a
            }
          }
        }),
        (t.trackRequestSync = function (e, r) {
          if (!r.request || !r.response || !e) {
            dpe.info(
              'AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ',
              !r.request,
              !r.response,
              !e
            )
            return
          }
          ;(r.isProcessed = !1), t.addResponseCorrelationIdHeader(e, r.response)
          var n = qp.CorrelationContextManager.getCurrentContext(),
            i = new cU(r.request, n && n.operation.parentId)
          n &&
            ((n.operation.id = i.getOperationId(e.context.tags) || n.operation.id),
            (n.operation.name = i.getOperationName(e.context.tags) || n.operation.name),
            (n.operation.parentId = i.getRequestId() || n.operation.parentId),
            n.customProperties.addHeaderData(i.getCorrelationContextHeader())),
            t.endRequest(e, i, r, r.duration, r.error)
        }),
        (t.trackRequest = function (e, r, n) {
          if (!r.request || !r.response || !e) {
            dpe.info(
              'AutoCollectHttpRequests.trackRequest was called with invalid parameters: ',
              !r.request,
              !r.response,
              !e
            )
            return
          }
          r.isProcessed = !1
          var i = qp.CorrelationContextManager.getCurrentContext(),
            o = n || new cU(r.request, i && i.operation.parentId)
          fpe.canIncludeCorrelationHeader(e, o.getUrl()) && t.addResponseCorrelationIdHeader(e, r.response),
            i &&
              !n &&
              ((i.operation.id = o.getOperationId(e.context.tags) || i.operation.id),
              (i.operation.name = o.getOperationName(e.context.tags) || i.operation.name),
              (i.operation.parentId = o.getOperationParentId(e.context.tags) || i.operation.parentId),
              i.customProperties.addHeaderData(o.getCorrelationContextHeader())),
            r.response.once &&
              r.response.once('finish', function () {
                t.endRequest(e, o, r, null, null)
              }),
            r.request.on &&
              r.request.on('error', function (s) {
                t.endRequest(e, o, r, null, s)
              }),
            r.request.on &&
              r.request.on('aborted', function () {
                var s = 'The request has been aborted and the network socket has closed.'
                t.endRequest(e, o, r, null, s)
              })
        }),
        (t.addResponseCorrelationIdHeader = function (e, r) {
          if (e.config && e.config.correlationId && r.getHeader && r.setHeader && !r.headersSent) {
            var n = r.getHeader(dBe.requestContextHeader)
            fpe.safeIncludeCorrelationHeader(e, r, n)
          }
        }),
        (t.endRequest = function (e, r, n, i, o) {
          if (!n.isProcessed) {
            ;(n.isProcessed = !0), o ? r.onError(o, i) : r.onResponse(n.response, i)
            var s = r.getRequestTelemetry(n)
            if (((s.tagOverrides = r.getRequestTags(e.context.tags)), n.tagOverrides))
              for (var a in n.tagOverrides) s.tagOverrides[a] = n.tagOverrides[a]
            var l = r.getLegacyRootId()
            l && (s.properties.ai_legacyRootId = l),
              (s.contextObjects = s.contextObjects || {}),
              (s.contextObjects['http.ServerRequest'] = n.request),
              (s.contextObjects['http.ServerResponse'] = n.response),
              e.trackRequest(s)
          }
        }),
        (t.prototype.dispose = function () {
          ;(t.INSTANCE = null),
            this.enable(!1),
            (this._isInitialized = !1),
            qp.CorrelationContextManager.disable(),
            (this._isAutoCorrelating = !1)
        }),
        (t.HANDLER_READY = !1),
        (t.alreadyAutoCollectedFlag = '_appInsightsAutoCollected'),
        t
      )
    })()
  mpe.exports = mBe
})
var vpe = handleExports((pU, gpe) => {
  'use strict'
  var rc =
      (pU && pU.__assign) ||
      function () {
        return (
          (rc =
            Object.assign ||
            function (t) {
              for (var e, r = 1, n = arguments.length; r < n; r++) {
                e = arguments[r]
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
              }
              return t
            }),
          rc.apply(this, arguments)
        )
      },
    uU = require('os'),
    ov = Ao(),
    hpe = xn(),
    hBe = oo(),
    gBe = on(),
    vBe = hBe.w3cTraceId(),
    _Be = (function () {
      function t() {}
      return (
        (t.createQuickPulseEnvelope = function (e, r, n, i) {
          var o = (uU && typeof uU.hostname == 'function' && uU.hostname()) || 'Unknown',
            s = (i.tags && i.keys && i.keys.cloudRoleInstance && i.tags[i.keys.cloudRoleInstance]) || o,
            a = (i.tags && i.keys && i.keys.cloudRole && i.tags[i.keys.cloudRole]) || null,
            l = {
              Documents: r.length > 0 ? r : null,
              InstrumentationKey: n.instrumentationKey || '',
              Metrics: e.length > 0 ? e : null,
              InvariantVersion: 1,
              Timestamp: '/Date(' + Date.now() + ')/',
              Version: i.tags[i.keys.internalSdkVersion],
              StreamId: vBe,
              MachineName: o,
              Instance: s,
              RoleName: a,
            }
          return l
        }),
        (t.createQuickPulseMetric = function (e) {
          var r
          return (r = { Name: e.name, Value: e.value, Weight: e.count || 1 }), r
        }),
        (t.telemetryEnvelopeToQuickPulseDocument = function (e) {
          switch (e.data.baseType) {
            case ov.TelemetryTypeString.Event:
              return t.createQuickPulseEventDocument(e)
            case ov.TelemetryTypeString.Exception:
              return t.createQuickPulseExceptionDocument(e)
            case ov.TelemetryTypeString.Trace:
              return t.createQuickPulseTraceDocument(e)
            case ov.TelemetryTypeString.Dependency:
              return t.createQuickPulseDependencyDocument(e)
            case ov.TelemetryTypeString.Request:
              return t.createQuickPulseRequestDocument(e)
          }
          return null
        }),
        (t.createQuickPulseEventDocument = function (e) {
          var r = t.createQuickPulseDocument(e),
            n = e.data.baseData.name,
            i = rc(rc({}, r), { Name: n })
          return i
        }),
        (t.createQuickPulseTraceDocument = function (e) {
          var r = t.createQuickPulseDocument(e),
            n = e.data.baseData.severityLevel || 0,
            i = rc(rc({}, r), { Message: e.data.baseData.message, SeverityLevel: ov.SeverityLevel[n] })
          return i
        }),
        (t.createQuickPulseExceptionDocument = function (e) {
          var r = t.createQuickPulseDocument(e),
            n = e.data.baseData.exceptions,
            i = '',
            o = '',
            s = ''
          n &&
            n.length > 0 &&
            (n[0].parsedStack && n[0].parsedStack.length > 0
              ? n[0].parsedStack.forEach(function (l) {
                  i +=
                    l.assembly +
                    `
`
                })
              : n[0].stack && n[0].stack.length > 0 && (i = n[0].stack),
            (o = n[0].message),
            (s = n[0].typeName))
          var a = rc(rc({}, r), { Exception: i, ExceptionMessage: o, ExceptionType: s })
          return a
        }),
        (t.createQuickPulseRequestDocument = function (e) {
          var r = t.createQuickPulseDocument(e),
            n = e.data.baseData,
            i = rc(rc({}, r), {
              Name: n.name,
              Success: n.success,
              Duration: n.duration,
              ResponseCode: n.responseCode,
              OperationName: n.name,
            })
          return i
        }),
        (t.createQuickPulseDependencyDocument = function (e) {
          var r = t.createQuickPulseDocument(e),
            n = e.data.baseData,
            i = rc(rc({}, r), {
              Name: n.name,
              Target: n.target,
              Success: n.success,
              Duration: n.duration,
              ResultCode: n.resultCode,
              CommandName: n.data,
              OperationName: r.OperationId,
              DependencyTypeName: n.type,
            })
          return i
        }),
        (t.createQuickPulseDocument = function (e) {
          var r, n, i, o
          e.data.baseType
            ? ((n = hpe.TelemetryTypeStringToQuickPulseType[e.data.baseType]),
              (r = hpe.TelemetryTypeStringToQuickPulseDocumentType[e.data.baseType]))
            : gBe.warn('Document type invalid; not sending live metric document', e.data.baseType),
            (i = e.tags[t.keys.operationId]),
            (o = t.aggregateProperties(e))
          var s = { DocumentType: r, __type: n, OperationId: i, Version: '1.0', Properties: o }
          return s
        }),
        (t.aggregateProperties = function (e) {
          var r = [],
            n = e.data.baseData.measurements || {}
          for (var i in n)
            if (n.hasOwnProperty(i)) {
              var o = n[i],
                s = { key: i, value: o }
              r.push(s)
            }
          var a = e.data.baseData.properties || {}
          for (var i in a)
            if (a.hasOwnProperty(i)) {
              var o = a[i],
                s = { key: i, value: o }
              r.push(s)
            }
          return r
        }),
        (t.keys = new ov.ContextTagKeys()),
        t
      )
    })()
  gpe.exports = _Be
})
var ype = handleExports((kIt, _pe) => {
  'use strict'
  var yBe = function () {
    return (Date.now() + 621355968e5) * 1e4
  }
  _pe.exports = { getTransmissionTime: yBe }
})
var Tpe = handleExports((sT, Epe) => {
  'use strict'
  var xpe =
      (sT && sT.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    bpe =
      (sT && sT.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    xBe = require('https'),
    bBe = Ry(),
    dU = on(),
    EBe = ype(),
    fU = oo(),
    TBe = require('url'),
    nc = {
      method: 'POST',
      time: 'x-ms-qps-transmission-time',
      pollingIntervalHint: 'x-ms-qps-service-polling-interval-hint',
      endpointRedirect: 'x-ms-qps-service-endpoint-redirect-v2',
      instanceName: 'x-ms-qps-instance-name',
      streamId: 'x-ms-qps-stream-id',
      machineName: 'x-ms-qps-machine-name',
      roleName: 'x-ms-qps-role-name',
      streamid: 'x-ms-qps-stream-id',
      invariantVersion: 'x-ms-qps-invariant-version',
      subscribed: 'x-ms-qps-subscribed',
    },
    SBe = (function () {
      function t(e, r) {
        ;(this._config = e), (this._consecutiveErrors = 0), (this._getAuthorizationHandler = r)
      }
      return (
        (t.prototype.ping = function (e, r, n) {
          var i = [
            { name: nc.streamId, value: e.StreamId },
            { name: nc.machineName, value: e.MachineName },
            { name: nc.roleName, value: e.RoleName },
            { name: nc.instanceName, value: e.Instance },
            { name: nc.invariantVersion, value: e.InvariantVersion.toString() },
          ]
          this._submitData(e, r, n, 'ping', i)
        }),
        (t.prototype.post = function (e, r, n) {
          return xpe(this, void 0, void 0, function () {
            return bpe(this, function (i) {
              switch (i.label) {
                case 0:
                  return [4, this._submitData([e], r, n, 'post')]
                case 1:
                  return i.sent(), [2]
              }
            })
          })
        }),
        (t.prototype._submitData = function (e, r, n, i, o) {
          return xpe(this, void 0, void 0, function () {
            var s,
              a,
              l,
              c,
              u,
              p,
              d,
              f,
              m = this
            return bpe(this, function (h) {
              switch (h.label) {
                case 0:
                  if (
                    ((s = fU.stringify(e)),
                    (a =
                      ((d = {}),
                      (d[bBe.disableCollectionRequestOption] = !0),
                      (d.host = r && r.length > 0 ? r : this._config.quickPulseHost),
                      (d.method = nc.method),
                      (d.path = '/QuickPulseService.svc/' + i + '?ikey=' + this._config.instrumentationKey),
                      (d.headers =
                        ((f = { Expect: '100-continue' }),
                        (f[nc.time] = EBe.getTransmissionTime()),
                        (f['Content-Type'] = 'application/json'),
                        (f['Content-Length'] = Buffer.byteLength(s)),
                        f)),
                      d)),
                    o &&
                      o.length > 0 &&
                      o.forEach(function (g) {
                        return (a.headers[g.name] = g.value)
                      }),
                    i !== 'post')
                  )
                    return [3, 4]
                  if (((l = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null), !l))
                    return [3, 4]
                  h.label = 1
                case 1:
                  return h.trys.push([1, 3, , 4]), [4, l.addAuthorizationHeader(a)]
                case 2:
                  return h.sent(), [3, 4]
                case 3:
                  return (
                    (c = h.sent()),
                    (u = 'Failed to get AAD bearer token for the Application. Error:'),
                    dU.info(t.TAG, u, c),
                    [2]
                  )
                case 4:
                  return (
                    this._config.httpsAgent ? (a.agent = this._config.httpsAgent) : (a.agent = fU.tlsRestrictedAgent),
                    (p = xBe.request(a, function (g) {
                      if (g.statusCode == 200) {
                        var v = g.headers[nc.subscribed] === 'true',
                          _ = null
                        try {
                          _ = g.headers[nc.endpointRedirect]
                            ? new TBe.URL(g.headers[nc.endpointRedirect].toString()).host
                            : null
                        } catch (b) {
                          m._onError('Failed to parse redirect header from QuickPulse: ' + fU.dumpObj(b))
                        }
                        var y = g.headers[nc.pollingIntervalHint]
                          ? parseInt(g.headers[nc.pollingIntervalHint].toString())
                          : null
                        ;(m._consecutiveErrors = 0), n(v, g, _, y)
                      } else m._onError('StatusCode:' + g.statusCode + ' StatusMessage:' + g.statusMessage), n()
                    })),
                    p.on('error', function (g) {
                      m._onError(g), n()
                    }),
                    p.write(s),
                    p.end(),
                    [2]
                  )
              }
            })
          })
        }),
        (t.prototype._onError = function (e) {
          this._consecutiveErrors++
          var r =
            'Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:'
          this._consecutiveErrors % t.MAX_QPS_FAILURES_BEFORE_WARN === 0
            ? ((r =
                'Live Metrics endpoint could not be reached ' +
                this._consecutiveErrors +
                ' consecutive times. Most recent error:'),
              dU.warn(t.TAG, r, e))
            : dU.info(t.TAG, r, e)
        }),
        (t.TAG = 'QuickPulseSender'),
        (t.MAX_QPS_FAILURES_BEFORE_WARN = 25),
        t
      )
    })()
  Epe.exports = SBe
})
var Ape = handleExports((aT, wpe) => {
  'use strict'
  var Spe =
      (aT && aT.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    Cpe =
      (aT && aT.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    Ipe = on(),
    mU = vpe(),
    CBe = Tpe(),
    IBe = xn(),
    wBe = Ey(),
    ABe = (function () {
      function t(e, r, n) {
        ;(this._isCollectingData = !1),
          (this._lastSuccessTime = Date.now()),
          (this._lastSendSucceeded = !0),
          (this._metrics = {}),
          (this._documents = []),
          (this._collectors = []),
          (this._redirectedHost = null),
          (this._pollingIntervalHint = -1),
          (this.config = e),
          (this.context = r || new wBe()),
          (this._sender = new CBe(this.config, n)),
          (this._isEnabled = !1)
      }
      return (
        (t.prototype.addCollector = function (e) {
          this._collectors.push(e)
        }),
        (t.prototype.trackMetric = function (e) {
          this._addMetric(e)
        }),
        (t.prototype.addDocument = function (e) {
          if (this._isCollectingData) {
            var r = mU.telemetryEnvelopeToQuickPulseDocument(e)
            r && this._documents.push(r)
          }
        }),
        (t.prototype.enable = function (e) {
          e && !this._isEnabled
            ? ((this._isEnabled = !0), this._goQuickPulse())
            : !e && this._isEnabled && ((this._isEnabled = !1), clearTimeout(this._handle), (this._handle = void 0))
        }),
        (t.prototype.enableCollectors = function (e) {
          this._collectors.forEach(function (r) {
            r.enable(e)
          })
        }),
        (t.prototype._addMetric = function (e) {
          var r = e.value,
            n = e.count || 1,
            i = IBe.PerformanceToQuickPulseCounter[e.name]
          i &&
            (this._metrics[i]
              ? ((this._metrics[i].Value =
                  (this._metrics[i].Value * this._metrics[i].Weight + r * n) / (this._metrics[i].Weight + n)),
                (this._metrics[i].Weight += n))
              : ((this._metrics[i] = mU.createQuickPulseMetric(e)),
                (this._metrics[i].Name = i),
                (this._metrics[i].Weight = 1)))
        }),
        (t.prototype._resetQuickPulseBuffer = function () {
          delete this._metrics, (this._metrics = {}), (this._documents.length = 0)
        }),
        (t.prototype._goQuickPulse = function () {
          return Spe(this, void 0, void 0, function () {
            var e,
              r,
              n,
              i,
              o = this
            return Cpe(this, function (s) {
              switch (s.label) {
                case 0:
                  return (
                    (e = Object.keys(this._metrics).map(function (a) {
                      return o._metrics[a]
                    })),
                    (r = mU.createQuickPulseEnvelope(e, this._documents.slice(), this.config, this.context)),
                    this._resetQuickPulseBuffer(),
                    this._isCollectingData ? [4, this._post(r)] : [3, 2]
                  )
                case 1:
                  return s.sent(), [3, 3]
                case 2:
                  this._ping(r), (s.label = 3)
                case 3:
                  return (
                    (n = this._pollingIntervalHint > 0 ? this._pollingIntervalHint : t.PING_INTERVAL),
                    (i = this._isCollectingData ? t.POST_INTERVAL : n),
                    this._isCollectingData &&
                    Date.now() - this._lastSuccessTime >= t.MAX_POST_WAIT_TIME &&
                    !this._lastSendSucceeded
                      ? ((this._isCollectingData = !1), (i = t.FALLBACK_INTERVAL))
                      : !this._isCollectingData &&
                        Date.now() - this._lastSuccessTime >= t.MAX_PING_WAIT_TIME &&
                        !this._lastSendSucceeded &&
                        (i = t.FALLBACK_INTERVAL),
                    (this._lastSendSucceeded = null),
                    (this._handle = setTimeout(this._goQuickPulse.bind(this), i)),
                    this._handle.unref(),
                    [2]
                  )
              }
            })
          })
        }),
        (t.prototype._ping = function (e) {
          this._sender.ping(e, this._redirectedHost, this._quickPulseDone.bind(this))
        }),
        (t.prototype._post = function (e) {
          return Spe(this, void 0, void 0, function () {
            return Cpe(this, function (r) {
              switch (r.label) {
                case 0:
                  return [4, this._sender.post(e, this._redirectedHost, this._quickPulseDone.bind(this))]
                case 1:
                  return r.sent(), [2]
              }
            })
          })
        }),
        (t.prototype._quickPulseDone = function (e, r, n, i) {
          e != null
            ? (this._isCollectingData !== e && (Ipe.info('Live Metrics sending data', e), this.enableCollectors(e)),
              (this._isCollectingData = e),
              n && n.length > 0 && ((this._redirectedHost = n), Ipe.info('Redirecting endpoint to: ', n)),
              i && i > 0 && (this._pollingIntervalHint = i),
              r && r.statusCode < 300 && r.statusCode >= 200
                ? ((this._lastSuccessTime = Date.now()), (this._lastSendSucceeded = !0))
                : (this._lastSendSucceeded = !1))
            : (this._lastSendSucceeded = !1)
        }),
        (t.MAX_POST_WAIT_TIME = 2e4),
        (t.MAX_PING_WAIT_TIME = 6e4),
        (t.FALLBACK_INTERVAL = 6e4),
        (t.PING_INTERVAL = 5e3),
        (t.POST_INTERVAL = 1e3),
        t
      )
    })()
  wpe.exports = ABe
})
var Rpe = handleExports(Dy => {
  'use strict'
  var yD =
    (Dy && Dy.__assign) ||
    function () {
      return (
        (yD =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        yD.apply(this, arguments)
      )
    }
  Object.defineProperty(Dy, '__esModule', { value: !0 })
  Dy.AutoCollectNativePerformance = void 0
  var cT = Ey(),
    RBe = on(),
    DBe = (function () {
      function t(e) {
        ;(this._disabledMetrics = {}), t.INSTANCE && t.INSTANCE.dispose(), (t.INSTANCE = this), (this._client = e)
      }
      return (
        (t.prototype.enable = function (e, r, n) {
          var i = this
          if (
            (r === void 0 && (r = {}),
            n === void 0 && (n = 6e4),
            t._metricsAvailable == null && e && !this._isInitialized)
          )
            try {
              var o = require('applicationinsights-native-metrics')
              ;(t._emitter = new o()),
                (t._metricsAvailable = !0),
                RBe.info('Native metrics module successfully loaded!')
            } catch {
              t._metricsAvailable = !1
              return
            }
          ;(this._isEnabled = e),
            (this._disabledMetrics = r),
            this._isEnabled && !this._isInitialized && (this._isInitialized = !0),
            this._isEnabled && t._emitter
              ? (t._emitter.enable(!0, n),
                this._handle ||
                  ((this._handle = setInterval(function () {
                    return i._trackNativeMetrics()
                  }, n)),
                  this._handle.unref()))
              : t._emitter &&
                (t._emitter.enable(!1), this._handle && (clearInterval(this._handle), (this._handle = void 0)))
        }),
        (t.prototype.dispose = function () {
          this.enable(!1)
        }),
        (t.parseEnabled = function (e, r) {
          var n = r.disableAllExtendedMetrics,
            i = r.extendedMetricDisablers
          if (n) return { isEnabled: !1, disabledMetrics: {} }
          if (i) {
            var o = i.split(','),
              s = {}
            if (o.length > 0)
              for (var a = 0, l = o; a < l.length; a++) {
                var c = l[a]
                s[c] = !0
              }
            return typeof e == 'object'
              ? { isEnabled: !0, disabledMetrics: yD(yD({}, e), s) }
              : { isEnabled: e, disabledMetrics: s }
          }
          return typeof e == 'boolean' ? { isEnabled: e, disabledMetrics: {} } : { isEnabled: !0, disabledMetrics: e }
        }),
        (t.prototype._trackNativeMetrics = function () {
          var e = !0
          typeof this._isEnabled != 'object' && (e = this._isEnabled),
            e && (this._trackGarbageCollection(), this._trackEventLoop(), this._trackHeapUsage())
        }),
        (t.prototype._trackGarbageCollection = function () {
          var e
          if (!this._disabledMetrics.gc) {
            var r = t._emitter.getGCData()
            for (var n in r) {
              var i = r[n].metrics,
                o = n + ' Garbage Collection Duration',
                s = Math.sqrt(i.sumSquares / i.count - Math.pow(i.total / i.count, 2)) || 0
              this._client.trackMetric({
                name: o,
                value: i.total,
                count: i.count,
                max: i.max,
                min: i.min,
                stdDev: s,
                tagOverrides:
                  ((e = {}), (e[this._client.context.keys.internalSdkVersion] = 'node-nativeperf:' + cT.sdkVersion), e),
              })
            }
          }
        }),
        (t.prototype._trackEventLoop = function () {
          var e
          if (!this._disabledMetrics.loop) {
            var r = t._emitter.getLoopData(),
              n = r.loopUsage
            if (n.count != 0) {
              var i = 'Event Loop CPU Time',
                o = Math.sqrt(n.sumSquares / n.count - Math.pow(n.total / n.count, 2)) || 0
              this._client.trackMetric({
                name: i,
                value: n.total,
                count: n.count,
                min: n.min,
                max: n.max,
                stdDev: o,
                tagOverrides:
                  ((e = {}), (e[this._client.context.keys.internalSdkVersion] = 'node-nativeperf:' + cT.sdkVersion), e),
              })
            }
          }
        }),
        (t.prototype._trackHeapUsage = function () {
          var e, r, n
          if (!this._disabledMetrics.heap) {
            var i = process.memoryUsage(),
              o = i.heapUsed,
              s = i.heapTotal,
              a = i.rss
            this._client.trackMetric({
              name: 'Memory Usage (Heap)',
              value: o,
              count: 1,
              tagOverrides:
                ((e = {}), (e[this._client.context.keys.internalSdkVersion] = 'node-nativeperf:' + cT.sdkVersion), e),
            }),
              this._client.trackMetric({
                name: 'Memory Total (Heap)',
                value: s,
                count: 1,
                tagOverrides:
                  ((r = {}), (r[this._client.context.keys.internalSdkVersion] = 'node-nativeperf:' + cT.sdkVersion), r),
              }),
              this._client.trackMetric({
                name: 'Memory Usage (Non-Heap)',
                value: a - s,
                count: 1,
                tagOverrides:
                  ((n = {}), (n[this._client.context.keys.internalSdkVersion] = 'node-nativeperf:' + cT.sdkVersion), n),
              })
          }
        }),
        t
      )
    })()
  Dy.AutoCollectNativePerformance = DBe
})
var Npe = handleExports(om => {
  'use strict'
  var Dpe =
      (om && om.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    Ppe =
      (om && om.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }
  Object.defineProperty(om, '__esModule', { value: !0 })
  om.AzureFunctionsHook = void 0
  var xD = on(),
    hU = Wf(),
    PBe = (function () {
      function t(e) {
        ;(this._client = e), (this._autoGenerateIncomingRequests = !1)
        try {
          ;(this._functionsCoreModule = require('@azure/functions-core')),
            this._addPreInvocationHook(),
            this._addPostInvocationHook()
        } catch {
          xD.info('AzureFunctionsHook failed to load, not running in Azure Functions')
        }
      }
      return (
        (t.prototype._getFuncModelHelper = function () {
          if (this._cachedModelHelper === void 0) {
            var e = this._functionsCoreModule.getProgrammingModel()
            e.name === '@azure/functions' &&
              (e.version.startsWith('3.')
                ? (this._cachedModelHelper = new NBe())
                : e.version.startsWith('4.') && (this._cachedModelHelper = new kBe())),
              this._cachedModelHelper ||
                ((this._cachedModelHelper = null),
                xD.warn('AzureFunctionsHook does not support model "' + e.name + '" version "' + e.version + '"'))
          }
          return this._cachedModelHelper
        }),
        (t.prototype.enable = function (e) {
          this._autoGenerateIncomingRequests = e
        }),
        (t.prototype.dispose = function () {
          this.enable(!1), this._removeInvocationHooks(), (this._functionsCoreModule = void 0)
        }),
        (t.prototype._addPreInvocationHook = function () {
          var e = this
          this._preInvocationHook ||
            (this._preInvocationHook = this._functionsCoreModule.registerHook('preInvocation', function (r) {
              return Dpe(e, void 0, void 0, function () {
                var n, i, o, s
                return Ppe(this, function (a) {
                  try {
                    ;(n = this._getFuncModelHelper()),
                      n &&
                        ((i = r.invocationContext),
                        (o = hU.CorrelationContextManager.startOperation(i)),
                        o &&
                          (o.customProperties.setProperty('InvocationId', i.invocationId),
                          (s = i.traceContext),
                          s.attributes &&
                            (o.customProperties.setProperty('ProcessId', s.attributes.ProcessId),
                            o.customProperties.setProperty('LogLevel', s.attributes.LogLevel),
                            o.customProperties.setProperty('Category', s.attributes.Category),
                            o.customProperties.setProperty('HostInstanceId', s.attributes.HostInstanceId),
                            o.customProperties.setProperty(
                              'AzFuncLiveLogsSessionId',
                              s.attributes['#AzFuncLiveLogsSessionId']
                            )),
                          (r.functionCallback = hU.CorrelationContextManager.wrapCallback(r.functionCallback, o)),
                          n.isHttpTrigger(r) &&
                            this._autoGenerateIncomingRequests &&
                            ((r.hookData.appInsightsExtractedContext = o),
                            (r.hookData.appInsightsStartTime = Date.now()))))
                  } catch (l) {
                    return xD.warn('Failed to propagate context in Azure Functions', l), [2]
                  }
                  return [2]
                })
              })
            }))
        }),
        (t.prototype._addPostInvocationHook = function () {
          var e = this
          this._postInvocationHook ||
            (this._postInvocationHook = this._functionsCoreModule.registerHook('postInvocation', function (r) {
              return Dpe(e, void 0, void 0, function () {
                var n,
                  i,
                  o,
                  s,
                  a = this
                return Ppe(this, function (l) {
                  try {
                    ;(n = this._getFuncModelHelper()),
                      n &&
                        this._autoGenerateIncomingRequests &&
                        n.isHttpTrigger(r) &&
                        ((i = r.inputs[0]),
                        i &&
                          ((o = r.hookData.appInsightsStartTime || Date.now()),
                          (s = r.hookData.appInsightsExtractedContext),
                          s
                            ? hU.CorrelationContextManager.runWithContext(s, function () {
                                a._createIncomingRequestTelemetry(i, r, o, s.operation.parentId)
                              })
                            : this._createIncomingRequestTelemetry(i, r, o, null)))
                  } catch (c) {
                    xD.warn('Error creating automatic incoming request in Azure Functions', c)
                  }
                  return [2]
                })
              })
            }))
        }),
        (t.prototype._createIncomingRequestTelemetry = function (e, r, n, i) {
          var o = this._getFuncModelHelper().getStatusCodes(r),
            s = 200
          if (o)
            for (var a = 0, l = o; a < l.length; a++) {
              var c = l[a]
              if (typeof c == 'number' && Number.isInteger(c)) {
                s = c
                break
              } else if (typeof c == 'string') {
                var u = parseInt(c)
                if (!isNaN(u)) {
                  s = u
                  break
                }
              }
            }
          else s = void 0
          this._client.trackRequest({
            name: e.method + ' ' + e.url,
            resultCode: s,
            success: typeof s == 'number' ? 0 < s && s < 400 : void 0,
            url: e.url,
            time: new Date(n),
            duration: Date.now() - n,
            id: i,
          }),
            this._client.flush()
        }),
        (t.prototype._removeInvocationHooks = function () {
          this._preInvocationHook && (this._preInvocationHook.dispose(), (this._preInvocationHook = void 0)),
            this._postInvocationHook && (this._postInvocationHook.dispose(), (this._postInvocationHook = void 0))
        }),
        t
      )
    })()
  om.AzureFunctionsHook = PBe
  var NBe = (function () {
      function t() {}
      return (
        (t.prototype._getInvocationContext = function (e) {
          return e.invocationContext
        }),
        (t.prototype.getStatusCodes = function (e) {
          var r = this._getInvocationContext(e),
            n,
            i = r.bindingDefinitions.find(function (o) {
              return o.direction === 'out' && o.type.toLowerCase() === 'http'
            })
          return (
            i?.name === '$return'
              ? (n = e.result)
              : i && r.bindings && r.bindings[i.name] !== void 0
              ? (n = r.bindings[i.name])
              : (n = r.res),
            n ? [n.statusCode, n.status] : void 0
          )
        }),
        (t.prototype.isHttpTrigger = function (e) {
          var r = this._getInvocationContext(e)
          return !!r.bindingDefinitions.find(function (n) {
            var i
            return ((i = n.type) === null || i === void 0 ? void 0 : i.toLowerCase()) === 'httptrigger'
          })
        }),
        t
      )
    })(),
    kBe = (function () {
      function t() {}
      return (
        (t.prototype._getInvocationContext = function (e) {
          return e.invocationContext
        }),
        (t.prototype.getStatusCodes = function (e) {
          var r = e.result
          return r ? [r.status] : void 0
        }),
        (t.prototype.isHttpTrigger = function (e) {
          var r = this._getInvocationContext(e)
          return r.options.trigger.type.toLowerCase() === 'httptrigger'
        }),
        t
      )
    })()
})
var gU = handleExports((MIt, Lpe) => {
  'use strict'
  var OBe = Gg(),
    kpe = Q7(),
    LBe = on(),
    Ope = xn(),
    MBe = require('url'),
    FBe = d2(),
    UBe = (function () {
      function t(e) {
        ;(this._endpointBase = Ope.DEFAULT_BREEZE_ENDPOINT), this._mergeConfig()
        var r = this._connectionString,
          n = kpe.parse(e),
          i = kpe.parse(r),
          o = !n.instrumentationkey && Object.keys(n).length > 0 ? null : e,
          s = this._instrumentationKey
        this.instrumentationKey = n.instrumentationkey || o || i.instrumentationkey || s
        var a = '' + (this.endpointUrl || n.ingestionendpoint || i.ingestionendpoint || this._endpointBase)
        a.endsWith('/') && (a = a.slice(0, -1)),
          (this.endpointUrl = a + '/v2.1/track'),
          (this.maxBatchSize = this.maxBatchSize || 250),
          (this.maxBatchIntervalMs = this.maxBatchIntervalMs || 15e3),
          (this.disableAppInsights = this.disableAppInsights || !1),
          (this.samplingPercentage = this.samplingPercentage || 100),
          (this.correlationIdRetryIntervalMs = this.correlationIdRetryIntervalMs || 30 * 1e3),
          (this.enableWebInstrumentation = this.enableWebInstrumentation || this.enableAutoWebSnippetInjection || !1),
          (this.webInstrumentationConfig = this.webInstrumentationConfig || null),
          (this.enableAutoWebSnippetInjection = this.enableWebInstrumentation),
          (this.correlationHeaderExcludedDomains = this.correlationHeaderExcludedDomains || [
            '*.core.windows.net',
            '*.core.chinacloudapi.cn',
            '*.core.cloudapi.de',
            '*.core.usgovcloudapi.net',
            '*.core.microsoft.scloud',
            '*.core.eaglex.ic.gov',
          ]),
          (this.ignoreLegacyHeaders = this.ignoreLegacyHeaders || !1),
          (this.profileQueryEndpoint =
            n.ingestionendpoint ||
            i.ingestionendpoint ||
            process.env[t.ENV_profileQueryEndpoint] ||
            this._endpointBase),
          (this.quickPulseHost =
            this.quickPulseHost ||
            n.liveendpoint ||
            i.liveendpoint ||
            process.env[t.ENV_quickPulseHost] ||
            Ope.DEFAULT_LIVEMETRICS_HOST),
          (this.webInstrumentationConnectionString =
            this.webInstrumentationConnectionString || this._webInstrumentationConnectionString || ''),
          (this.webSnippetConnectionString = this.webInstrumentationConnectionString),
          this.quickPulseHost.match(/^https?:\/\//) && (this.quickPulseHost = new MBe.URL(this.quickPulseHost).host),
          (this.aadAudience = n.aadaudience || i.aadaudience)
      }
      return (
        Object.defineProperty(t.prototype, 'profileQueryEndpoint', {
          get: function () {
            return this._profileQueryEndpoint
          },
          set: function (e) {
            ;(this._profileQueryEndpoint = e), (this.correlationId = OBe.correlationIdPrefix)
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, 'instrumentationKey', {
          get: function () {
            return this._instrumentationKey
          },
          set: function (e) {
            t._validateInstrumentationKey(e) ||
              LBe.warn(
                'An invalid instrumentation key was provided. There may be resulting telemetry loss',
                this.instrumentationKey
              ),
              (this._instrumentationKey = e)
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, 'webSnippetConnectionString', {
          get: function () {
            return this._webInstrumentationConnectionString
          },
          set: function (e) {
            this._webInstrumentationConnectionString = e
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(t.prototype, 'webInstrumentationConnectionString', {
          get: function () {
            return this._webInstrumentationConnectionString
          },
          set: function (e) {
            this._webInstrumentationConnectionString = e
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._mergeConfig = function () {
          var e = FBe.JsonConfig.getInstance()
          ;(this._connectionString = e.connectionString),
            (this._instrumentationKey = e.instrumentationKey),
            (this.correlationHeaderExcludedDomains = e.correlationHeaderExcludedDomains),
            (this.correlationIdRetryIntervalMs = e.correlationIdRetryIntervalMs),
            (this.disableAllExtendedMetrics = e.disableAllExtendedMetrics),
            (this.disableAppInsights = e.disableAppInsights),
            (this.disableStatsbeat = e.disableStatsbeat),
            (this.distributedTracingMode = e.distributedTracingMode),
            (this.enableAutoCollectConsole = e.enableAutoCollectConsole),
            (this.enableLoggerErrorToTrace = e.enableLoggerErrorToTrace),
            (this.enableAutoCollectDependencies = e.enableAutoCollectDependencies),
            (this.enableAutoCollectIncomingRequestAzureFunctions = e.enableAutoCollectIncomingRequestAzureFunctions),
            (this.enableAutoCollectExceptions = e.enableAutoCollectExceptions),
            (this.enableAutoCollectExtendedMetrics = e.enableAutoCollectExtendedMetrics),
            (this.enableAutoCollectExternalLoggers = e.enableAutoCollectExternalLoggers),
            (this.enableAutoCollectHeartbeat = e.enableAutoCollectHeartbeat),
            (this.enableAutoCollectPerformance = e.enableAutoCollectPerformance),
            (this.enableAutoCollectPreAggregatedMetrics = e.enableAutoCollectPreAggregatedMetrics),
            (this.enableAutoCollectRequests = e.enableAutoCollectRequests),
            (this.enableAutoDependencyCorrelation = e.enableAutoDependencyCorrelation),
            (this.enableInternalDebugLogging = e.enableInternalDebugLogging),
            (this.enableInternalWarningLogging = e.enableInternalWarningLogging),
            (this.enableResendInterval = e.enableResendInterval),
            (this.enableMaxBytesOnDisk = e.enableMaxBytesOnDisk),
            (this.enableSendLiveMetrics = e.enableSendLiveMetrics),
            (this.enableUseAsyncHooks = e.enableUseAsyncHooks),
            (this.enableUseDiskRetryCaching = e.enableUseDiskRetryCaching),
            (this.endpointUrl = e.endpointUrl),
            (this.extendedMetricDisablers = e.extendedMetricDisablers),
            (this.ignoreLegacyHeaders = e.ignoreLegacyHeaders),
            (this.maxBatchIntervalMs = e.maxBatchIntervalMs),
            (this.maxBatchSize = e.maxBatchSize),
            (this.proxyHttpUrl = e.proxyHttpUrl),
            (this.proxyHttpsUrl = e.proxyHttpsUrl),
            (this.quickPulseHost = e.quickPulseHost),
            (this.samplingPercentage = e.samplingPercentage),
            (this.enableWebInstrumentation = e.enableWebInstrumentation),
            (this._webInstrumentationConnectionString = e.webInstrumentationConnectionString),
            (this.webInstrumentationConfig = e.webInstrumentationConfig),
            (this.webInstrumentationSrc = e.webInstrumentationSrc)
        }),
        (t._validateInstrumentationKey = function (e) {
          var r = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
            n = new RegExp(r)
          return n.test(e)
        }),
        (t.ENV_azurePrefix = 'APPSETTING_'),
        (t.ENV_iKey = 'APPINSIGHTS_INSTRUMENTATIONKEY'),
        (t.legacy_ENV_iKey = 'APPINSIGHTS_INSTRUMENTATION_KEY'),
        (t.ENV_profileQueryEndpoint = 'APPINSIGHTS_PROFILE_QUERY_ENDPOINT'),
        (t.ENV_quickPulseHost = 'APPINSIGHTS_QUICKPULSE_HOST'),
        t
      )
    })()
  Lpe.exports = UBe
})
function bD() {
  return vU.create()
}
var Mpe,
  vU,
  _U = createGetter(() => {
    ;(Mpe = new Set(['Deserialize', 'Serialize', 'Retry', 'Sign'])),
      (vU = class t {
        constructor(e) {
          var r
          ;(this._policies = []),
            (this._policies = (r = e?.slice(0)) !== null && r !== void 0 ? r : []),
            (this._orderedPolicies = void 0)
        }
        addPolicy(e, r = {}) {
          if (r.phase && r.afterPhase) throw new Error('Policies inside a phase cannot specify afterPhase.')
          if (r.phase && !Mpe.has(r.phase)) throw new Error(`Invalid phase name: ${r.phase}`)
          if (r.afterPhase && !Mpe.has(r.afterPhase)) throw new Error(`Invalid afterPhase name: ${r.afterPhase}`)
          this._policies.push({ policy: e, options: r }), (this._orderedPolicies = void 0)
        }
        removePolicy(e) {
          let r = []
          return (
            (this._policies = this._policies.filter(n =>
              (e.name && n.policy.name === e.name) || (e.phase && n.options.phase === e.phase)
                ? (r.push(n.policy), !1)
                : !0
            )),
            (this._orderedPolicies = void 0),
            r
          )
        }
        sendRequest(e, r) {
          return this.getOrderedPolicies().reduceRight(
            (o, s) => a => s.sendRequest(a, o),
            o => e.sendRequest(o)
          )(r)
        }
        getOrderedPolicies() {
          return this._orderedPolicies || (this._orderedPolicies = this.orderPolicies()), this._orderedPolicies
        }
        clone() {
          return new t(this._policies)
        }
        static create() {
          return new t()
        }
        orderPolicies() {
          let e = [],
            r = new Map()
          function n(m) {
            return { name: m, policies: new Set(), hasRun: !1, hasAfterPolicies: !1 }
          }
          let i = n('Serialize'),
            o = n('None'),
            s = n('Deserialize'),
            a = n('Retry'),
            l = n('Sign'),
            c = [i, o, s, a, l]
          function u(m) {
            return m === 'Retry' ? a : m === 'Serialize' ? i : m === 'Deserialize' ? s : m === 'Sign' ? l : o
          }
          for (let m of this._policies) {
            let h = m.policy,
              g = m.options,
              v = h.name
            if (r.has(v)) throw new Error('Duplicate policy names not allowed in pipeline')
            let _ = { policy: h, dependsOn: new Set(), dependants: new Set() }
            g.afterPhase && ((_.afterPhase = u(g.afterPhase)), (_.afterPhase.hasAfterPolicies = !0)),
              r.set(v, _),
              u(g.phase).policies.add(_)
          }
          for (let m of this._policies) {
            let { policy: h, options: g } = m,
              v = h.name,
              _ = r.get(v)
            if (!_) throw new Error(`Missing node for policy ${v}`)
            if (g.afterPolicies)
              for (let y of g.afterPolicies) {
                let b = r.get(y)
                b && (_.dependsOn.add(b), b.dependants.add(_))
              }
            if (g.beforePolicies)
              for (let y of g.beforePolicies) {
                let b = r.get(y)
                b && (b.dependsOn.add(_), _.dependants.add(b))
              }
          }
          function p(m) {
            m.hasRun = !0
            for (let h of m.policies)
              if (!(h.afterPhase && (!h.afterPhase.hasRun || h.afterPhase.policies.size)) && h.dependsOn.size === 0) {
                e.push(h.policy)
                for (let g of h.dependants) g.dependsOn.delete(h)
                r.delete(h.policy.name), m.policies.delete(h)
              }
          }
          function d() {
            for (let m of c) {
              if ((p(m), m.policies.size > 0 && m !== o)) {
                o.hasRun || p(o)
                return
              }
              m.hasAfterPolicies && p(o)
            }
          }
          let f = 0
          for (; r.size > 0; ) {
            f++
            let m = e.length
            if ((d(), e.length <= m && f > 1))
              throw new Error('Cannot satisfy policy dependencies due to requirements cycle.')
          }
          return e
        }
      })
  })
function Bpe(t, ...e) {
  process.stderr.write(`${Upe.default.format(t, ...e)}${Fpe.EOL}`)
}
var Fpe,
  Upe,
  qpe = createGetter(() => {
    ;(Fpe = require('os')), (Upe = handleDefaultExports(require('util')))
  })
function bU(t) {
  ;(jpe = t), (yU = []), (xU = [])
  let e = /\*/g,
    r = t.split(',').map(n => n.trim().replace(e, '.*?'))
  for (let n of r) n.startsWith('-') ? xU.push(new RegExp(`^${n.substr(1)}$`)) : yU.push(new RegExp(`^${n}$`))
  for (let n of ED) n.enabled = EU(n.namespace)
}
function EU(t) {
  if (t.endsWith('*')) return !0
  for (let e of xU) if (e.test(t)) return !1
  for (let e of yU) if (e.test(t)) return !0
  return !1
}
function BBe() {
  let t = jpe || ''
  return bU(''), t
}
function Vpe(t) {
  let e = Object.assign(r, { enabled: EU(t), destroy: qBe, log: Gpe.log, namespace: t, extend: HBe })
  function r(...n) {
    e.enabled && (n.length > 0 && (n[0] = `${t} ${n[0]}`), e.log(...n))
  }
  return ED.push(e), e
}
function qBe() {
  let t = ED.indexOf(this)
  return t >= 0 ? (ED.splice(t, 1), !0) : !1
}
function HBe(t) {
  let e = Vpe(`${this.namespace}:${t}`)
  return (e.log = this.log), e
}
var Hpe,
  jpe,
  yU,
  xU,
  ED,
  Gpe,
  Py,
  zpe = createGetter(() => {
    qpe()
    ;(Hpe = (typeof process < 'u' && process.env && process.env.DEBUG) || void 0), (yU = []), (xU = []), (ED = [])
    Hpe && bU(Hpe)
    Gpe = Object.assign(t => Vpe(t), { enable: bU, enabled: EU, disable: BBe, log: Bpe })
    Py = Gpe
  })
function jBe(t) {
  if (t && !Qpe(t)) throw new Error(`Unknown log level '${t}'. Acceptable values: ${CU.join(',')}`)
  TU = t
  let e = []
  for (let r of Wpe) Ype(r) && e.push(r.namespace)
  Py.enable(e.join(','))
}
function CD(t) {
  let e = SU.extend(t)
  return (
    Kpe(SU, e), { error: SD(e, 'error'), warning: SD(e, 'warning'), info: SD(e, 'info'), verbose: SD(e, 'verbose') }
  )
}
function Kpe(t, e) {
  e.log = (...r) => {
    t.log(...r)
  }
}
function SD(t, e) {
  let r = Object.assign(t.extend(e), { level: e })
  if ((Kpe(t, r), Ype(r))) {
    let n = Py.disable()
    Py.enable(n + ',' + r.namespace)
  }
  return Wpe.add(r), r
}
function Ype(t) {
  return !!(TU && $pe[t.level] <= $pe[TU])
}
function Qpe(t) {
  return CU.includes(t)
}
var Wpe,
  TD,
  TU,
  SU,
  CU,
  $pe,
  IU = createGetter(() => {
    zpe()
    ;(Wpe = new Set()),
      (TD = (typeof process < 'u' && process.env && process.env.AZURE_LOG_LEVEL) || void 0),
      (SU = Py('azure'))
    SU.log = (...t) => {
      Py.log(...t)
    }
    CU = ['verbose', 'info', 'warning', 'error']
    TD &&
      (Qpe(TD)
        ? jBe(TD)
        : console.error(
            `AZURE_LOG_LEVEL set to unknown log level '${TD}'; logging is not enabled. Acceptable values: ${CU.join(
              ', '
            )}.`
          ))
    $pe = { verbose: 400, info: 300, warning: 200, error: 100 }
  })
var lo,
  Ny = createGetter(() => {
    IU()
    lo = CD('core-rest-pipeline')
  })
var wU,
  ID,
  Xpe = createGetter(() => {
    ID =
      typeof process < 'u' && !!process.version && !!(!((wU = process.versions) === null || wU === void 0) && wU.node)
  })
function AU(t) {
  if (t.aborted) return
  t.onabort && t.onabort.call(t)
  let e = ky.get(t)
  e &&
    e.slice().forEach(r => {
      r.call(t, { type: 'abort' })
    }),
    wD.set(t, !0)
}
var ky,
  wD,
  lT,
  Jpe = createGetter(() => {
    ;(ky = new WeakMap()),
      (wD = new WeakMap()),
      (lT = class t {
        constructor() {
          ;(this.onabort = null), ky.set(this, []), wD.set(this, !1)
        }
        get aborted() {
          if (!wD.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.')
          return wD.get(this)
        }
        static get none() {
          return new t()
        }
        addEventListener(e, r) {
          if (!ky.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.')
          ky.get(this).push(r)
        }
        removeEventListener(e, r) {
          if (!ky.has(this)) throw new TypeError('Expected `this` to be an instance of AbortSignal.')
          let n = ky.get(this),
            i = n.indexOf(r)
          i > -1 && n.splice(i, 1)
        }
        dispatchEvent(e) {
          throw new Error(
            'This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.'
          )
        }
      })
  })
var ou,
  uT,
  Zpe = createGetter(() => {
    Jpe()
    ;(ou = class extends Error {
      constructor(e) {
        super(e), (this.name = 'AbortError')
      }
    }),
      (uT = class {
        constructor(e) {
          if (((this._signal = new lT()), !!e)) {
            Array.isArray(e) || (e = arguments)
            for (let r of e)
              r.aborted
                ? this.abort()
                : r.addEventListener('abort', () => {
                    this.abort()
                  })
          }
        }
        get signal() {
          return this._signal
        }
        abort() {
          AU(this._signal)
        }
        static timeout(e) {
          let r = new lT(),
            n = setTimeout(AU, e, r)
          return typeof n.unref == 'function' && n.unref(), r
        }
      })
  })
var AD = createGetter(() => {
  Zpe()
})
function RU(t, e) {
  return (t = Math.ceil(t)), (e = Math.floor(e)), Math.floor(Math.random() * (e - t + 1)) + t
}
var ede = createGetter(() => {})
function pT(t) {
  return typeof t == 'object' && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date)
}
var DU = createGetter(() => {})
function Oy(t) {
  if (pT(t)) {
    let e = typeof t.name == 'string',
      r = typeof t.message == 'string'
    return e && r
  }
  return !1
}
function Ly(t) {
  if (Oy(t)) return t.message
  {
    let e
    try {
      typeof t == 'object' && t ? (e = JSON.stringify(t)) : (e = String(t))
    } catch {
      e = '[unable to stringify input]'
    }
    return `Unknown error ${e}`
  }
}
var tde = createGetter(() => {
  DU()
})
var My = createGetter(() => {
  Xpe()
  ede()
  DU()
  tde()
})
var PU,
  GBe,
  VBe,
  Fy,
  NU = createGetter(() => {
    My()
    ;(PU = 'REDACTED'),
      (GBe = [
        'x-ms-client-request-id',
        'x-ms-return-client-request-id',
        'x-ms-useragent',
        'x-ms-correlation-request-id',
        'x-ms-request-id',
        'client-request-id',
        'ms-cv',
        'return-client-request-id',
        'traceparent',
        'Access-Control-Allow-Credentials',
        'Access-Control-Allow-Headers',
        'Access-Control-Allow-Methods',
        'Access-Control-Allow-Origin',
        'Access-Control-Expose-Headers',
        'Access-Control-Max-Age',
        'Access-Control-Request-Headers',
        'Access-Control-Request-Method',
        'Origin',
        'Accept',
        'Accept-Encoding',
        'Cache-Control',
        'Connection',
        'Content-Length',
        'Content-Type',
        'Date',
        'ETag',
        'Expires',
        'If-Match',
        'If-Modified-Since',
        'If-None-Match',
        'If-Unmodified-Since',
        'Last-Modified',
        'Pragma',
        'Request-Id',
        'Retry-After',
        'Server',
        'Transfer-Encoding',
        'User-Agent',
        'WWW-Authenticate',
      ]),
      (VBe = ['api-version']),
      (Fy = class {
        constructor({ additionalAllowedHeaderNames: e = [], additionalAllowedQueryParameters: r = [] } = {}) {
          ;(e = GBe.concat(e)),
            (r = VBe.concat(r)),
            (this.allowedHeaderNames = new Set(e.map(n => n.toLowerCase()))),
            (this.allowedQueryParameters = new Set(r.map(n => n.toLowerCase())))
        }
        sanitize(e) {
          let r = new Set()
          return JSON.stringify(
            e,
            (n, i) => {
              if (i instanceof Error) return Object.assign(Object.assign({}, i), { name: i.name, message: i.message })
              if (n === 'headers') return this.sanitizeHeaders(i)
              if (n === 'url') return this.sanitizeUrl(i)
              if (n === 'query') return this.sanitizeQuery(i)
              if (n === 'body') return
              if (n === 'response') return
              if (n === 'operationSpec') return
              if (Array.isArray(i) || pT(i)) {
                if (r.has(i)) return '[Circular]'
                r.add(i)
              }
              return i
            },
            2
          )
        }
        sanitizeHeaders(e) {
          let r = {}
          for (let n of Object.keys(e)) this.allowedHeaderNames.has(n.toLowerCase()) ? (r[n] = e[n]) : (r[n] = PU)
          return r
        }
        sanitizeQuery(e) {
          if (typeof e != 'object' || e === null) return e
          let r = {}
          for (let n of Object.keys(e)) this.allowedQueryParameters.has(n.toLowerCase()) ? (r[n] = e[n]) : (r[n] = PU)
          return r
        }
        sanitizeUrl(e) {
          if (typeof e != 'string' || e === null) return e
          let r = new URL(e)
          if (!r.search) return e
          for (let [n] of r.searchParams) this.allowedQueryParameters.has(n.toLowerCase()) || r.searchParams.set(n, PU)
          return r.toString()
        }
      })
  })
function RD(t = {}) {
  var e
  let r = (e = t.logger) !== null && e !== void 0 ? e : lo.info,
    n = new Fy({
      additionalAllowedHeaderNames: t.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: t.additionalAllowedQueryParameters,
    })
  return {
    name: kU,
    async sendRequest(i, o) {
      if (!r.enabled) return o(i)
      r(`Request: ${n.sanitize(i)}`)
      let s = await o(i)
      return r(`Response status code: ${s.status}`), r(`Headers: ${n.sanitize(s.headers)}`), s
    },
  }
}
var kU,
  OU = createGetter(() => {
    Ny()
    NU()
    kU = 'logPolicy'
  })
function DD(t = {}) {
  let { maxRetries: e = 20 } = t
  return {
    name: LU,
    async sendRequest(r, n) {
      let i = await n(r)
      return nde(n, i, e)
    },
  }
}
async function nde(t, e, r, n = 0) {
  let { request: i, status: o, headers: s } = e,
    a = s.get('location')
  if (
    a &&
    (o === 300 ||
      (o === 301 && rde.includes(i.method)) ||
      (o === 302 && rde.includes(i.method)) ||
      (o === 303 && i.method === 'POST') ||
      o === 307) &&
    n < r
  ) {
    let l = new URL(a, i.url)
    ;(i.url = l.toString()),
      o === 303 && ((i.method = 'GET'), i.headers.delete('Content-Length'), delete i.body),
      i.headers.delete('Authorization')
    let c = await t(i)
    return nde(t, c, r, n + 1)
  }
  return e
}
var LU,
  rde,
  MU = createGetter(() => {
    ;(LU = 'redirectPolicy'), (rde = ['GET', 'HEAD'])
  })
function ide() {
  return 'User-Agent'
}
function ode(t) {
  t.set('Node', process.version), t.set('OS', `(${Uy.arch()}-${Uy.type()}-${Uy.release()})`)
}
var Uy,
  sde = createGetter(() => {
    Uy = handleDefaultExports(require('os'))
  })
var PD,
  FU = createGetter(() => {
    PD = '1.10.1'
  })
function zBe(t) {
  let e = []
  for (let [r, n] of t) {
    let i = n ? `${r}/${n}` : r
    e.push(i)
  }
  return e.join(' ')
}
function ade() {
  return ide()
}
function ND(t) {
  let e = new Map()
  e.set('core-rest-pipeline', PD), ode(e)
  let r = zBe(e)
  return t ? `${t} ${r}` : r
}
var UU = createGetter(() => {
  sde()
  FU()
})
function kD(t = {}) {
  let e = ND(t.userAgentPrefix)
  return {
    name: BU,
    async sendRequest(r, n) {
      return r.headers.has(cde) || r.headers.set(cde, e), n(r)
    },
  }
}
var cde,
  BU,
  qU = createGetter(() => {
    UU()
    ;(cde = ade()), (BU = 'userAgentPolicy')
  })
function OD() {
  return {
    name: HU,
    async sendRequest(t, e) {
      return t.method !== 'HEAD' && t.headers.set('Accept-Encoding', 'gzip,deflate'), e(t)
    },
  }
}
var HU,
  jU = createGetter(() => {
    HU = 'decompressResponsePolicy'
  })
function LD(t, e, r) {
  return new Promise((n, i) => {
    let o,
      s,
      a = () => i(new ou(r?.abortErrorMsg ? r?.abortErrorMsg : $Be)),
      l = () => {
        r?.abortSignal && s && r.abortSignal.removeEventListener('abort', s)
      }
    if (((s = () => (o && clearTimeout(o), l(), a())), r?.abortSignal && r.abortSignal.aborted)) return a()
    ;(o = setTimeout(() => {
      l(), n(e)
    }, t)),
      r?.abortSignal && r.abortSignal.addEventListener('abort', s)
  })
}
function lde(t, e) {
  let r = t.headers.get(e)
  if (!r) return
  let n = Number(r)
  if (!Number.isNaN(n)) return n
}
var $Be,
  MD = createGetter(() => {
    AD()
    $Be = 'The operation was aborted.'
  })
function ude(t) {
  if (t && [429, 503].includes(t.status))
    try {
      for (let i of WBe) {
        let o = lde(t, i)
        if (o === 0 || o) return o * (i === GU ? 1e3 : 1)
      }
      let e = t.headers.get(GU)
      if (!e) return
      let n = Date.parse(e) - Date.now()
      return Number.isFinite(n) ? Math.max(0, n) : void 0
    } catch {
      return
    }
}
function pde(t) {
  return Number.isFinite(ude(t))
}
function FD() {
  return {
    name: 'throttlingRetryStrategy',
    retry({ response: t }) {
      let e = ude(t)
      return Number.isFinite(e) ? { retryAfterInMs: e } : { skipStrategy: !0 }
    },
  }
}
var GU,
  WBe,
  UD = createGetter(() => {
    MD()
    ;(GU = 'Retry-After'), (WBe = ['retry-after-ms', 'x-ms-retry-after-ms', GU])
  })
function By(t = {}) {
  var e, r
  let n = (e = t.retryDelayInMs) !== null && e !== void 0 ? e : KBe,
    i = (r = t.maxRetryDelayInMs) !== null && r !== void 0 ? r : YBe,
    o = n
  return {
    name: 'exponentialRetryStrategy',
    retry({ retryCount: s, response: a, responseError: l }) {
      let c = XBe(l),
        u = c && t.ignoreSystemErrors,
        p = QBe(a),
        d = p && t.ignoreHttpStatusCodes
      if ((a && (pde(a) || !p)) || d || u) return { skipStrategy: !0 }
      if (l && !c && !p) return { errorToThrow: l }
      let m = o * Math.pow(2, s),
        h = Math.min(i, m)
      return (o = h / 2 + RU(0, h / 2)), { retryAfterInMs: o }
    },
  }
}
function QBe(t) {
  return !!(t && t.status !== void 0 && (t.status >= 500 || t.status === 408) && t.status !== 501 && t.status !== 505)
}
function XBe(t) {
  return t
    ? t.code === 'ETIMEDOUT' ||
        t.code === 'ESOCKETTIMEDOUT' ||
        t.code === 'ECONNREFUSED' ||
        t.code === 'ECONNRESET' ||
        t.code === 'ENOENT'
    : !1
}
var KBe,
  YBe,
  BD = createGetter(() => {
    My()
    UD()
    ;(KBe = 1e3), (YBe = 1e3 * 64)
  })
function su(t, e = { maxRetries: 3 }) {
  let r = e.logger || dde
  return {
    name: JBe,
    async sendRequest(n, i) {
      var o, s
      let a,
        l,
        c = -1
      e: for (;;) {
        ;(c += 1), (a = void 0), (l = void 0)
        try {
          r.info(`Retry ${c}: Attempting to send request`, n.requestId),
            (a = await i(n)),
            r.info(`Retry ${c}: Received a response from request`, n.requestId)
        } catch (u) {
          if (
            (r.error(`Retry ${c}: Received an error from request`, n.requestId), (l = u), !u || l.name !== 'RestError')
          )
            throw u
          a = l.response
        }
        if (!((o = n.abortSignal) === null || o === void 0) && o.aborted)
          throw (r.error(`Retry ${c}: Request aborted.`), new ou())
        if (c >= ((s = e.maxRetries) !== null && s !== void 0 ? s : 3)) {
          if (
            (r.info(
              `Retry ${c}: Maximum retries reached. Returning the last received response, or throwing the last received error.`
            ),
            l)
          )
            throw l
          if (a) return a
          throw new Error('Maximum retries reached with no response or error to throw')
        }
        r.info(`Retry ${c}: Processing ${t.length} retry strategies.`)
        t: for (let u of t) {
          let p = u.logger || dde
          p.info(`Retry ${c}: Processing retry strategy ${u.name}.`)
          let d = u.retry({ retryCount: c, response: a, responseError: l })
          if (d.skipStrategy) {
            p.info(`Retry ${c}: Skipped.`)
            continue t
          }
          let { errorToThrow: f, retryAfterInMs: m, redirectTo: h } = d
          if (f) throw (p.error(`Retry ${c}: Retry strategy ${u.name} throws error:`, f), f)
          if (m || m === 0) {
            p.info(`Retry ${c}: Retry strategy ${u.name} retries after ${m}`),
              await LD(m, void 0, { abortSignal: n.abortSignal })
            continue e
          }
          if (h) {
            p.info(`Retry ${c}: Retry strategy ${u.name} redirects to ${h}`), (n.url = h)
            continue e
          }
        }
        if (l) throw (r.info('None of the retry strategies could work with the received error. Throwing it.'), l)
        if (a) return r.info('None of the retry strategies could work with the received response. Returning it.'), a
      }
    },
  }
}
var dde,
  JBe,
  qy = createGetter(() => {
    MD()
    IU()
    AD()
    ;(dde = CD('core-rest-pipeline retryPolicy')), (JBe = 'retryPolicy')
  })
function qD(t = {}) {
  var e
  return {
    name: ZBe,
    sendRequest: su([FD(), By(t)], { maxRetries: (e = t.maxRetries) !== null && e !== void 0 ? e : 3 }).sendRequest,
  }
}
var ZBe,
  VU = createGetter(() => {
    BD()
    UD()
    qy()
    ZBe = 'defaultRetryPolicy'
  })
var hde = handleExports((Lwt, mde) => {
  var fde = require('stream').Stream,
    eqe = require('util')
  mde.exports = Wc
  function Wc() {
    ;(this.source = null),
      (this.dataSize = 0),
      (this.maxDataSize = 1024 * 1024),
      (this.pauseStream = !0),
      (this._maxDataSizeExceeded = !1),
      (this._released = !1),
      (this._bufferedEvents = [])
  }
  eqe.inherits(Wc, fde)
  Wc.create = function (t, e) {
    var r = new this()
    e = e || {}
    for (var n in e) r[n] = e[n]
    r.source = t
    var i = t.emit
    return (
      (t.emit = function () {
        return r._handleEmit(arguments), i.apply(t, arguments)
      }),
      t.on('error', function () {}),
      r.pauseStream && t.pause(),
      r
    )
  }
  Object.defineProperty(Wc.prototype, 'readable', {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.source.readable
    },
  })
  Wc.prototype.setEncoding = function () {
    return this.source.setEncoding.apply(this.source, arguments)
  }
  Wc.prototype.resume = function () {
    this._released || this.release(), this.source.resume()
  }
  Wc.prototype.pause = function () {
    this.source.pause()
  }
  Wc.prototype.release = function () {
    ;(this._released = !0),
      this._bufferedEvents.forEach(
        function (t) {
          this.emit.apply(this, t)
        }.bind(this)
      ),
      (this._bufferedEvents = [])
  }
  Wc.prototype.pipe = function () {
    var t = fde.prototype.pipe.apply(this, arguments)
    return this.resume(), t
  }
  Wc.prototype._handleEmit = function (t) {
    if (this._released) {
      this.emit.apply(this, t)
      return
    }
    t[0] === 'data' && ((this.dataSize += t[1].length), this._checkIfMaxDataSizeExceeded()),
      this._bufferedEvents.push(t)
  }
  Wc.prototype._checkIfMaxDataSizeExceeded = function () {
    if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
      this._maxDataSizeExceeded = !0
      var t = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this.emit('error', new Error(t))
    }
  }
})
var yde = handleExports((Mwt, _de) => {
  var tqe = require('util'),
    vde = require('stream').Stream,
    gde = hde()
  _de.exports = Mn
  function Mn() {
    ;(this.writable = !1),
      (this.readable = !0),
      (this.dataSize = 0),
      (this.maxDataSize = 2 * 1024 * 1024),
      (this.pauseStreams = !0),
      (this._released = !1),
      (this._streams = []),
      (this._currentStream = null),
      (this._insideLoop = !1),
      (this._pendingNext = !1)
  }
  tqe.inherits(Mn, vde)
  Mn.create = function (t) {
    var e = new this()
    t = t || {}
    for (var r in t) e[r] = t[r]
    return e
  }
  Mn.isStreamLike = function (t) {
    return (
      typeof t != 'function' &&
      typeof t != 'string' &&
      typeof t != 'boolean' &&
      typeof t != 'number' &&
      !Buffer.isBuffer(t)
    )
  }
  Mn.prototype.append = function (t) {
    var e = Mn.isStreamLike(t)
    if (e) {
      if (!(t instanceof gde)) {
        var r = gde.create(t, { maxDataSize: 1 / 0, pauseStream: this.pauseStreams })
        t.on('data', this._checkDataSize.bind(this)), (t = r)
      }
      this._handleErrors(t), this.pauseStreams && t.pause()
    }
    return this._streams.push(t), this
  }
  Mn.prototype.pipe = function (t, e) {
    return vde.prototype.pipe.call(this, t, e), this.resume(), t
  }
  Mn.prototype._getNext = function () {
    if (((this._currentStream = null), this._insideLoop)) {
      this._pendingNext = !0
      return
    }
    this._insideLoop = !0
    try {
      do (this._pendingNext = !1), this._realGetNext()
      while (this._pendingNext)
    } finally {
      this._insideLoop = !1
    }
  }
  Mn.prototype._realGetNext = function () {
    var t = this._streams.shift()
    if (typeof t > 'u') {
      this.end()
      return
    }
    if (typeof t != 'function') {
      this._pipeNext(t)
      return
    }
    var e = t
    e(
      function (r) {
        var n = Mn.isStreamLike(r)
        n && (r.on('data', this._checkDataSize.bind(this)), this._handleErrors(r)), this._pipeNext(r)
      }.bind(this)
    )
  }
  Mn.prototype._pipeNext = function (t) {
    this._currentStream = t
    var e = Mn.isStreamLike(t)
    if (e) {
      t.on('end', this._getNext.bind(this)), t.pipe(this, { end: !1 })
      return
    }
    var r = t
    this.write(r), this._getNext()
  }
  Mn.prototype._handleErrors = function (t) {
    var e = this
    t.on('error', function (r) {
      e._emitError(r)
    })
  }
  Mn.prototype.write = function (t) {
    this.emit('data', t)
  }
  Mn.prototype.pause = function () {
    this.pauseStreams &&
      (this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.pause == 'function' &&
        this._currentStream.pause(),
      this.emit('pause'))
  }
  Mn.prototype.resume = function () {
    this._released || ((this._released = !0), (this.writable = !0), this._getNext()),
      this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.resume == 'function' &&
        this._currentStream.resume(),
      this.emit('resume')
  }
  Mn.prototype.end = function () {
    this._reset(), this.emit('end')
  }
  Mn.prototype.destroy = function () {
    this._reset(), this.emit('close')
  }
  Mn.prototype._reset = function () {
    ;(this.writable = !1), (this._streams = []), (this._currentStream = null)
  }
  Mn.prototype._checkDataSize = function () {
    if ((this._updateDataSize(), !(this.dataSize <= this.maxDataSize))) {
      var t = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this._emitError(new Error(t))
    }
  }
  Mn.prototype._updateDataSize = function () {
    this.dataSize = 0
    var t = this
    this._streams.forEach(function (e) {
      e.dataSize && (t.dataSize += e.dataSize)
    }),
      this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize)
  }
  Mn.prototype._emitError = function (t) {
    this._reset(), this.emit('error', t)
  }
})
var xde = handleExports((Fwt, rqe) => {
  rqe.exports = {
    'application/1d-interleaved-parityfec': { source: 'iana' },
    'application/3gpdash-qoe-report+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/3gpp-ims+xml': { source: 'iana', compressible: !0 },
    'application/3gpphal+json': { source: 'iana', compressible: !0 },
    'application/3gpphalforms+json': { source: 'iana', compressible: !0 },
    'application/a2l': { source: 'iana' },
    'application/ace+cbor': { source: 'iana' },
    'application/activemessage': { source: 'iana' },
    'application/activity+json': { source: 'iana', compressible: !0 },
    'application/alto-costmap+json': { source: 'iana', compressible: !0 },
    'application/alto-costmapfilter+json': { source: 'iana', compressible: !0 },
    'application/alto-directory+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointcost+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointcostparams+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointprop+json': { source: 'iana', compressible: !0 },
    'application/alto-endpointpropparams+json': { source: 'iana', compressible: !0 },
    'application/alto-error+json': { source: 'iana', compressible: !0 },
    'application/alto-networkmap+json': { source: 'iana', compressible: !0 },
    'application/alto-networkmapfilter+json': { source: 'iana', compressible: !0 },
    'application/alto-updatestreamcontrol+json': { source: 'iana', compressible: !0 },
    'application/alto-updatestreamparams+json': { source: 'iana', compressible: !0 },
    'application/aml': { source: 'iana' },
    'application/andrew-inset': { source: 'iana', extensions: ['ez'] },
    'application/applefile': { source: 'iana' },
    'application/applixware': { source: 'apache', extensions: ['aw'] },
    'application/at+jwt': { source: 'iana' },
    'application/atf': { source: 'iana' },
    'application/atfx': { source: 'iana' },
    'application/atom+xml': { source: 'iana', compressible: !0, extensions: ['atom'] },
    'application/atomcat+xml': { source: 'iana', compressible: !0, extensions: ['atomcat'] },
    'application/atomdeleted+xml': { source: 'iana', compressible: !0, extensions: ['atomdeleted'] },
    'application/atomicmail': { source: 'iana' },
    'application/atomsvc+xml': { source: 'iana', compressible: !0, extensions: ['atomsvc'] },
    'application/atsc-dwd+xml': { source: 'iana', compressible: !0, extensions: ['dwd'] },
    'application/atsc-dynamic-event-message': { source: 'iana' },
    'application/atsc-held+xml': { source: 'iana', compressible: !0, extensions: ['held'] },
    'application/atsc-rdt+json': { source: 'iana', compressible: !0 },
    'application/atsc-rsat+xml': { source: 'iana', compressible: !0, extensions: ['rsat'] },
    'application/atxml': { source: 'iana' },
    'application/auth-policy+xml': { source: 'iana', compressible: !0 },
    'application/bacnet-xdd+zip': { source: 'iana', compressible: !1 },
    'application/batch-smtp': { source: 'iana' },
    'application/bdoc': { compressible: !1, extensions: ['bdoc'] },
    'application/beep+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/calendar+json': { source: 'iana', compressible: !0 },
    'application/calendar+xml': { source: 'iana', compressible: !0, extensions: ['xcs'] },
    'application/call-completion': { source: 'iana' },
    'application/cals-1840': { source: 'iana' },
    'application/captive+json': { source: 'iana', compressible: !0 },
    'application/cbor': { source: 'iana' },
    'application/cbor-seq': { source: 'iana' },
    'application/cccex': { source: 'iana' },
    'application/ccmp+xml': { source: 'iana', compressible: !0 },
    'application/ccxml+xml': { source: 'iana', compressible: !0, extensions: ['ccxml'] },
    'application/cdfx+xml': { source: 'iana', compressible: !0, extensions: ['cdfx'] },
    'application/cdmi-capability': { source: 'iana', extensions: ['cdmia'] },
    'application/cdmi-container': { source: 'iana', extensions: ['cdmic'] },
    'application/cdmi-domain': { source: 'iana', extensions: ['cdmid'] },
    'application/cdmi-object': { source: 'iana', extensions: ['cdmio'] },
    'application/cdmi-queue': { source: 'iana', extensions: ['cdmiq'] },
    'application/cdni': { source: 'iana' },
    'application/cea': { source: 'iana' },
    'application/cea-2018+xml': { source: 'iana', compressible: !0 },
    'application/cellml+xml': { source: 'iana', compressible: !0 },
    'application/cfw': { source: 'iana' },
    'application/city+json': { source: 'iana', compressible: !0 },
    'application/clr': { source: 'iana' },
    'application/clue+xml': { source: 'iana', compressible: !0 },
    'application/clue_info+xml': { source: 'iana', compressible: !0 },
    'application/cms': { source: 'iana' },
    'application/cnrp+xml': { source: 'iana', compressible: !0 },
    'application/coap-group+json': { source: 'iana', compressible: !0 },
    'application/coap-payload': { source: 'iana' },
    'application/commonground': { source: 'iana' },
    'application/conference-info+xml': { source: 'iana', compressible: !0 },
    'application/cose': { source: 'iana' },
    'application/cose-key': { source: 'iana' },
    'application/cose-key-set': { source: 'iana' },
    'application/cpl+xml': { source: 'iana', compressible: !0, extensions: ['cpl'] },
    'application/csrattrs': { source: 'iana' },
    'application/csta+xml': { source: 'iana', compressible: !0 },
    'application/cstadata+xml': { source: 'iana', compressible: !0 },
    'application/csvm+json': { source: 'iana', compressible: !0 },
    'application/cu-seeme': { source: 'apache', extensions: ['cu'] },
    'application/cwt': { source: 'iana' },
    'application/cybercash': { source: 'iana' },
    'application/dart': { compressible: !0 },
    'application/dash+xml': { source: 'iana', compressible: !0, extensions: ['mpd'] },
    'application/dash-patch+xml': { source: 'iana', compressible: !0, extensions: ['mpp'] },
    'application/dashdelta': { source: 'iana' },
    'application/davmount+xml': { source: 'iana', compressible: !0, extensions: ['davmount'] },
    'application/dca-rft': { source: 'iana' },
    'application/dcd': { source: 'iana' },
    'application/dec-dx': { source: 'iana' },
    'application/dialog-info+xml': { source: 'iana', compressible: !0 },
    'application/dicom': { source: 'iana' },
    'application/dicom+json': { source: 'iana', compressible: !0 },
    'application/dicom+xml': { source: 'iana', compressible: !0 },
    'application/dii': { source: 'iana' },
    'application/dit': { source: 'iana' },
    'application/dns': { source: 'iana' },
    'application/dns+json': { source: 'iana', compressible: !0 },
    'application/dns-message': { source: 'iana' },
    'application/docbook+xml': { source: 'apache', compressible: !0, extensions: ['dbk'] },
    'application/dots+cbor': { source: 'iana' },
    'application/dskpp+xml': { source: 'iana', compressible: !0 },
    'application/dssc+der': { source: 'iana', extensions: ['dssc'] },
    'application/dssc+xml': { source: 'iana', compressible: !0, extensions: ['xdssc'] },
    'application/dvcs': { source: 'iana' },
    'application/ecmascript': { source: 'iana', compressible: !0, extensions: ['es', 'ecma'] },
    'application/edi-consent': { source: 'iana' },
    'application/edi-x12': { source: 'iana', compressible: !1 },
    'application/edifact': { source: 'iana', compressible: !1 },
    'application/efi': { source: 'iana' },
    'application/elm+json': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/elm+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.cap+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/emergencycalldata.comment+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.control+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.deviceinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.ecall.msd': { source: 'iana' },
    'application/emergencycalldata.providerinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.serviceinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.subscriberinfo+xml': { source: 'iana', compressible: !0 },
    'application/emergencycalldata.veds+xml': { source: 'iana', compressible: !0 },
    'application/emma+xml': { source: 'iana', compressible: !0, extensions: ['emma'] },
    'application/emotionml+xml': { source: 'iana', compressible: !0, extensions: ['emotionml'] },
    'application/encaprtp': { source: 'iana' },
    'application/epp+xml': { source: 'iana', compressible: !0 },
    'application/epub+zip': { source: 'iana', compressible: !1, extensions: ['epub'] },
    'application/eshop': { source: 'iana' },
    'application/exi': { source: 'iana', extensions: ['exi'] },
    'application/expect-ct-report+json': { source: 'iana', compressible: !0 },
    'application/express': { source: 'iana', extensions: ['exp'] },
    'application/fastinfoset': { source: 'iana' },
    'application/fastsoap': { source: 'iana' },
    'application/fdt+xml': { source: 'iana', compressible: !0, extensions: ['fdt'] },
    'application/fhir+json': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/fhir+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/fido.trusted-apps+json': { compressible: !0 },
    'application/fits': { source: 'iana' },
    'application/flexfec': { source: 'iana' },
    'application/font-sfnt': { source: 'iana' },
    'application/font-tdpfr': { source: 'iana', extensions: ['pfr'] },
    'application/font-woff': { source: 'iana', compressible: !1 },
    'application/framework-attributes+xml': { source: 'iana', compressible: !0 },
    'application/geo+json': { source: 'iana', compressible: !0, extensions: ['geojson'] },
    'application/geo+json-seq': { source: 'iana' },
    'application/geopackage+sqlite3': { source: 'iana' },
    'application/geoxacml+xml': { source: 'iana', compressible: !0 },
    'application/gltf-buffer': { source: 'iana' },
    'application/gml+xml': { source: 'iana', compressible: !0, extensions: ['gml'] },
    'application/gpx+xml': { source: 'apache', compressible: !0, extensions: ['gpx'] },
    'application/gxf': { source: 'apache', extensions: ['gxf'] },
    'application/gzip': { source: 'iana', compressible: !1, extensions: ['gz'] },
    'application/h224': { source: 'iana' },
    'application/held+xml': { source: 'iana', compressible: !0 },
    'application/hjson': { extensions: ['hjson'] },
    'application/http': { source: 'iana' },
    'application/hyperstudio': { source: 'iana', extensions: ['stk'] },
    'application/ibe-key-request+xml': { source: 'iana', compressible: !0 },
    'application/ibe-pkg-reply+xml': { source: 'iana', compressible: !0 },
    'application/ibe-pp-data': { source: 'iana' },
    'application/iges': { source: 'iana' },
    'application/im-iscomposing+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/index': { source: 'iana' },
    'application/index.cmd': { source: 'iana' },
    'application/index.obj': { source: 'iana' },
    'application/index.response': { source: 'iana' },
    'application/index.vnd': { source: 'iana' },
    'application/inkml+xml': { source: 'iana', compressible: !0, extensions: ['ink', 'inkml'] },
    'application/iotp': { source: 'iana' },
    'application/ipfix': { source: 'iana', extensions: ['ipfix'] },
    'application/ipp': { source: 'iana' },
    'application/isup': { source: 'iana' },
    'application/its+xml': { source: 'iana', compressible: !0, extensions: ['its'] },
    'application/java-archive': { source: 'apache', compressible: !1, extensions: ['jar', 'war', 'ear'] },
    'application/java-serialized-object': { source: 'apache', compressible: !1, extensions: ['ser'] },
    'application/java-vm': { source: 'apache', compressible: !1, extensions: ['class'] },
    'application/javascript': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['js', 'mjs'] },
    'application/jf2feed+json': { source: 'iana', compressible: !0 },
    'application/jose': { source: 'iana' },
    'application/jose+json': { source: 'iana', compressible: !0 },
    'application/jrd+json': { source: 'iana', compressible: !0 },
    'application/jscalendar+json': { source: 'iana', compressible: !0 },
    'application/json': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['json', 'map'] },
    'application/json-patch+json': { source: 'iana', compressible: !0 },
    'application/json-seq': { source: 'iana' },
    'application/json5': { extensions: ['json5'] },
    'application/jsonml+json': { source: 'apache', compressible: !0, extensions: ['jsonml'] },
    'application/jwk+json': { source: 'iana', compressible: !0 },
    'application/jwk-set+json': { source: 'iana', compressible: !0 },
    'application/jwt': { source: 'iana' },
    'application/kpml-request+xml': { source: 'iana', compressible: !0 },
    'application/kpml-response+xml': { source: 'iana', compressible: !0 },
    'application/ld+json': { source: 'iana', compressible: !0, extensions: ['jsonld'] },
    'application/lgr+xml': { source: 'iana', compressible: !0, extensions: ['lgr'] },
    'application/link-format': { source: 'iana' },
    'application/load-control+xml': { source: 'iana', compressible: !0 },
    'application/lost+xml': { source: 'iana', compressible: !0, extensions: ['lostxml'] },
    'application/lostsync+xml': { source: 'iana', compressible: !0 },
    'application/lpf+zip': { source: 'iana', compressible: !1 },
    'application/lxf': { source: 'iana' },
    'application/mac-binhex40': { source: 'iana', extensions: ['hqx'] },
    'application/mac-compactpro': { source: 'apache', extensions: ['cpt'] },
    'application/macwriteii': { source: 'iana' },
    'application/mads+xml': { source: 'iana', compressible: !0, extensions: ['mads'] },
    'application/manifest+json': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['webmanifest'] },
    'application/marc': { source: 'iana', extensions: ['mrc'] },
    'application/marcxml+xml': { source: 'iana', compressible: !0, extensions: ['mrcx'] },
    'application/mathematica': { source: 'iana', extensions: ['ma', 'nb', 'mb'] },
    'application/mathml+xml': { source: 'iana', compressible: !0, extensions: ['mathml'] },
    'application/mathml-content+xml': { source: 'iana', compressible: !0 },
    'application/mathml-presentation+xml': { source: 'iana', compressible: !0 },
    'application/mbms-associated-procedure-description+xml': { source: 'iana', compressible: !0 },
    'application/mbms-deregister+xml': { source: 'iana', compressible: !0 },
    'application/mbms-envelope+xml': { source: 'iana', compressible: !0 },
    'application/mbms-msk+xml': { source: 'iana', compressible: !0 },
    'application/mbms-msk-response+xml': { source: 'iana', compressible: !0 },
    'application/mbms-protection-description+xml': { source: 'iana', compressible: !0 },
    'application/mbms-reception-report+xml': { source: 'iana', compressible: !0 },
    'application/mbms-register+xml': { source: 'iana', compressible: !0 },
    'application/mbms-register-response+xml': { source: 'iana', compressible: !0 },
    'application/mbms-schedule+xml': { source: 'iana', compressible: !0 },
    'application/mbms-user-service-description+xml': { source: 'iana', compressible: !0 },
    'application/mbox': { source: 'iana', extensions: ['mbox'] },
    'application/media-policy-dataset+xml': { source: 'iana', compressible: !0, extensions: ['mpf'] },
    'application/media_control+xml': { source: 'iana', compressible: !0 },
    'application/mediaservercontrol+xml': { source: 'iana', compressible: !0, extensions: ['mscml'] },
    'application/merge-patch+json': { source: 'iana', compressible: !0 },
    'application/metalink+xml': { source: 'apache', compressible: !0, extensions: ['metalink'] },
    'application/metalink4+xml': { source: 'iana', compressible: !0, extensions: ['meta4'] },
    'application/mets+xml': { source: 'iana', compressible: !0, extensions: ['mets'] },
    'application/mf4': { source: 'iana' },
    'application/mikey': { source: 'iana' },
    'application/mipc': { source: 'iana' },
    'application/missing-blocks+cbor-seq': { source: 'iana' },
    'application/mmt-aei+xml': { source: 'iana', compressible: !0, extensions: ['maei'] },
    'application/mmt-usd+xml': { source: 'iana', compressible: !0, extensions: ['musd'] },
    'application/mods+xml': { source: 'iana', compressible: !0, extensions: ['mods'] },
    'application/moss-keys': { source: 'iana' },
    'application/moss-signature': { source: 'iana' },
    'application/mosskey-data': { source: 'iana' },
    'application/mosskey-request': { source: 'iana' },
    'application/mp21': { source: 'iana', extensions: ['m21', 'mp21'] },
    'application/mp4': { source: 'iana', extensions: ['mp4s', 'm4p'] },
    'application/mpeg4-generic': { source: 'iana' },
    'application/mpeg4-iod': { source: 'iana' },
    'application/mpeg4-iod-xmt': { source: 'iana' },
    'application/mrb-consumer+xml': { source: 'iana', compressible: !0 },
    'application/mrb-publish+xml': { source: 'iana', compressible: !0 },
    'application/msc-ivr+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/msc-mixer+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/msword': { source: 'iana', compressible: !1, extensions: ['doc', 'dot'] },
    'application/mud+json': { source: 'iana', compressible: !0 },
    'application/multipart-core': { source: 'iana' },
    'application/mxf': { source: 'iana', extensions: ['mxf'] },
    'application/n-quads': { source: 'iana', extensions: ['nq'] },
    'application/n-triples': { source: 'iana', extensions: ['nt'] },
    'application/nasdata': { source: 'iana' },
    'application/news-checkgroups': { source: 'iana', charset: 'US-ASCII' },
    'application/news-groupinfo': { source: 'iana', charset: 'US-ASCII' },
    'application/news-transmission': { source: 'iana' },
    'application/nlsml+xml': { source: 'iana', compressible: !0 },
    'application/node': { source: 'iana', extensions: ['cjs'] },
    'application/nss': { source: 'iana' },
    'application/oauth-authz-req+jwt': { source: 'iana' },
    'application/oblivious-dns-message': { source: 'iana' },
    'application/ocsp-request': { source: 'iana' },
    'application/ocsp-response': { source: 'iana' },
    'application/octet-stream': {
      source: 'iana',
      compressible: !1,
      extensions: [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer',
      ],
    },
    'application/oda': { source: 'iana', extensions: ['oda'] },
    'application/odm+xml': { source: 'iana', compressible: !0 },
    'application/odx': { source: 'iana' },
    'application/oebps-package+xml': { source: 'iana', compressible: !0, extensions: ['opf'] },
    'application/ogg': { source: 'iana', compressible: !1, extensions: ['ogx'] },
    'application/omdoc+xml': { source: 'apache', compressible: !0, extensions: ['omdoc'] },
    'application/onenote': { source: 'apache', extensions: ['onetoc', 'onetoc2', 'onetmp', 'onepkg'] },
    'application/opc-nodeset+xml': { source: 'iana', compressible: !0 },
    'application/oscore': { source: 'iana' },
    'application/oxps': { source: 'iana', extensions: ['oxps'] },
    'application/p21': { source: 'iana' },
    'application/p21+zip': { source: 'iana', compressible: !1 },
    'application/p2p-overlay+xml': { source: 'iana', compressible: !0, extensions: ['relo'] },
    'application/parityfec': { source: 'iana' },
    'application/passport': { source: 'iana' },
    'application/patch-ops-error+xml': { source: 'iana', compressible: !0, extensions: ['xer'] },
    'application/pdf': { source: 'iana', compressible: !1, extensions: ['pdf'] },
    'application/pdx': { source: 'iana' },
    'application/pem-certificate-chain': { source: 'iana' },
    'application/pgp-encrypted': { source: 'iana', compressible: !1, extensions: ['pgp'] },
    'application/pgp-keys': { source: 'iana', extensions: ['asc'] },
    'application/pgp-signature': { source: 'iana', extensions: ['asc', 'sig'] },
    'application/pics-rules': { source: 'apache', extensions: ['prf'] },
    'application/pidf+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/pidf-diff+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/pkcs10': { source: 'iana', extensions: ['p10'] },
    'application/pkcs12': { source: 'iana' },
    'application/pkcs7-mime': { source: 'iana', extensions: ['p7m', 'p7c'] },
    'application/pkcs7-signature': { source: 'iana', extensions: ['p7s'] },
    'application/pkcs8': { source: 'iana', extensions: ['p8'] },
    'application/pkcs8-encrypted': { source: 'iana' },
    'application/pkix-attr-cert': { source: 'iana', extensions: ['ac'] },
    'application/pkix-cert': { source: 'iana', extensions: ['cer'] },
    'application/pkix-crl': { source: 'iana', extensions: ['crl'] },
    'application/pkix-pkipath': { source: 'iana', extensions: ['pkipath'] },
    'application/pkixcmp': { source: 'iana', extensions: ['pki'] },
    'application/pls+xml': { source: 'iana', compressible: !0, extensions: ['pls'] },
    'application/poc-settings+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/postscript': { source: 'iana', compressible: !0, extensions: ['ai', 'eps', 'ps'] },
    'application/ppsp-tracker+json': { source: 'iana', compressible: !0 },
    'application/problem+json': { source: 'iana', compressible: !0 },
    'application/problem+xml': { source: 'iana', compressible: !0 },
    'application/provenance+xml': { source: 'iana', compressible: !0, extensions: ['provx'] },
    'application/prs.alvestrand.titrax-sheet': { source: 'iana' },
    'application/prs.cww': { source: 'iana', extensions: ['cww'] },
    'application/prs.cyn': { source: 'iana', charset: '7-BIT' },
    'application/prs.hpub+zip': { source: 'iana', compressible: !1 },
    'application/prs.nprend': { source: 'iana' },
    'application/prs.plucker': { source: 'iana' },
    'application/prs.rdf-xml-crypt': { source: 'iana' },
    'application/prs.xsf+xml': { source: 'iana', compressible: !0 },
    'application/pskc+xml': { source: 'iana', compressible: !0, extensions: ['pskcxml'] },
    'application/pvd+json': { source: 'iana', compressible: !0 },
    'application/qsig': { source: 'iana' },
    'application/raml+yaml': { compressible: !0, extensions: ['raml'] },
    'application/raptorfec': { source: 'iana' },
    'application/rdap+json': { source: 'iana', compressible: !0 },
    'application/rdf+xml': { source: 'iana', compressible: !0, extensions: ['rdf', 'owl'] },
    'application/reginfo+xml': { source: 'iana', compressible: !0, extensions: ['rif'] },
    'application/relax-ng-compact-syntax': { source: 'iana', extensions: ['rnc'] },
    'application/remote-printing': { source: 'iana' },
    'application/reputon+json': { source: 'iana', compressible: !0 },
    'application/resource-lists+xml': { source: 'iana', compressible: !0, extensions: ['rl'] },
    'application/resource-lists-diff+xml': { source: 'iana', compressible: !0, extensions: ['rld'] },
    'application/rfc+xml': { source: 'iana', compressible: !0 },
    'application/riscos': { source: 'iana' },
    'application/rlmi+xml': { source: 'iana', compressible: !0 },
    'application/rls-services+xml': { source: 'iana', compressible: !0, extensions: ['rs'] },
    'application/route-apd+xml': { source: 'iana', compressible: !0, extensions: ['rapd'] },
    'application/route-s-tsid+xml': { source: 'iana', compressible: !0, extensions: ['sls'] },
    'application/route-usd+xml': { source: 'iana', compressible: !0, extensions: ['rusd'] },
    'application/rpki-ghostbusters': { source: 'iana', extensions: ['gbr'] },
    'application/rpki-manifest': { source: 'iana', extensions: ['mft'] },
    'application/rpki-publication': { source: 'iana' },
    'application/rpki-roa': { source: 'iana', extensions: ['roa'] },
    'application/rpki-updown': { source: 'iana' },
    'application/rsd+xml': { source: 'apache', compressible: !0, extensions: ['rsd'] },
    'application/rss+xml': { source: 'apache', compressible: !0, extensions: ['rss'] },
    'application/rtf': { source: 'iana', compressible: !0, extensions: ['rtf'] },
    'application/rtploopback': { source: 'iana' },
    'application/rtx': { source: 'iana' },
    'application/samlassertion+xml': { source: 'iana', compressible: !0 },
    'application/samlmetadata+xml': { source: 'iana', compressible: !0 },
    'application/sarif+json': { source: 'iana', compressible: !0 },
    'application/sarif-external-properties+json': { source: 'iana', compressible: !0 },
    'application/sbe': { source: 'iana' },
    'application/sbml+xml': { source: 'iana', compressible: !0, extensions: ['sbml'] },
    'application/scaip+xml': { source: 'iana', compressible: !0 },
    'application/scim+json': { source: 'iana', compressible: !0 },
    'application/scvp-cv-request': { source: 'iana', extensions: ['scq'] },
    'application/scvp-cv-response': { source: 'iana', extensions: ['scs'] },
    'application/scvp-vp-request': { source: 'iana', extensions: ['spq'] },
    'application/scvp-vp-response': { source: 'iana', extensions: ['spp'] },
    'application/sdp': { source: 'iana', extensions: ['sdp'] },
    'application/secevent+jwt': { source: 'iana' },
    'application/senml+cbor': { source: 'iana' },
    'application/senml+json': { source: 'iana', compressible: !0 },
    'application/senml+xml': { source: 'iana', compressible: !0, extensions: ['senmlx'] },
    'application/senml-etch+cbor': { source: 'iana' },
    'application/senml-etch+json': { source: 'iana', compressible: !0 },
    'application/senml-exi': { source: 'iana' },
    'application/sensml+cbor': { source: 'iana' },
    'application/sensml+json': { source: 'iana', compressible: !0 },
    'application/sensml+xml': { source: 'iana', compressible: !0, extensions: ['sensmlx'] },
    'application/sensml-exi': { source: 'iana' },
    'application/sep+xml': { source: 'iana', compressible: !0 },
    'application/sep-exi': { source: 'iana' },
    'application/session-info': { source: 'iana' },
    'application/set-payment': { source: 'iana' },
    'application/set-payment-initiation': { source: 'iana', extensions: ['setpay'] },
    'application/set-registration': { source: 'iana' },
    'application/set-registration-initiation': { source: 'iana', extensions: ['setreg'] },
    'application/sgml': { source: 'iana' },
    'application/sgml-open-catalog': { source: 'iana' },
    'application/shf+xml': { source: 'iana', compressible: !0, extensions: ['shf'] },
    'application/sieve': { source: 'iana', extensions: ['siv', 'sieve'] },
    'application/simple-filter+xml': { source: 'iana', compressible: !0 },
    'application/simple-message-summary': { source: 'iana' },
    'application/simplesymbolcontainer': { source: 'iana' },
    'application/sipc': { source: 'iana' },
    'application/slate': { source: 'iana' },
    'application/smil': { source: 'iana' },
    'application/smil+xml': { source: 'iana', compressible: !0, extensions: ['smi', 'smil'] },
    'application/smpte336m': { source: 'iana' },
    'application/soap+fastinfoset': { source: 'iana' },
    'application/soap+xml': { source: 'iana', compressible: !0 },
    'application/sparql-query': { source: 'iana', extensions: ['rq'] },
    'application/sparql-results+xml': { source: 'iana', compressible: !0, extensions: ['srx'] },
    'application/spdx+json': { source: 'iana', compressible: !0 },
    'application/spirits-event+xml': { source: 'iana', compressible: !0 },
    'application/sql': { source: 'iana' },
    'application/srgs': { source: 'iana', extensions: ['gram'] },
    'application/srgs+xml': { source: 'iana', compressible: !0, extensions: ['grxml'] },
    'application/sru+xml': { source: 'iana', compressible: !0, extensions: ['sru'] },
    'application/ssdl+xml': { source: 'apache', compressible: !0, extensions: ['ssdl'] },
    'application/ssml+xml': { source: 'iana', compressible: !0, extensions: ['ssml'] },
    'application/stix+json': { source: 'iana', compressible: !0 },
    'application/swid+xml': { source: 'iana', compressible: !0, extensions: ['swidtag'] },
    'application/tamp-apex-update': { source: 'iana' },
    'application/tamp-apex-update-confirm': { source: 'iana' },
    'application/tamp-community-update': { source: 'iana' },
    'application/tamp-community-update-confirm': { source: 'iana' },
    'application/tamp-error': { source: 'iana' },
    'application/tamp-sequence-adjust': { source: 'iana' },
    'application/tamp-sequence-adjust-confirm': { source: 'iana' },
    'application/tamp-status-query': { source: 'iana' },
    'application/tamp-status-response': { source: 'iana' },
    'application/tamp-update': { source: 'iana' },
    'application/tamp-update-confirm': { source: 'iana' },
    'application/tar': { compressible: !0 },
    'application/taxii+json': { source: 'iana', compressible: !0 },
    'application/td+json': { source: 'iana', compressible: !0 },
    'application/tei+xml': { source: 'iana', compressible: !0, extensions: ['tei', 'teicorpus'] },
    'application/tetra_isi': { source: 'iana' },
    'application/thraud+xml': { source: 'iana', compressible: !0, extensions: ['tfi'] },
    'application/timestamp-query': { source: 'iana' },
    'application/timestamp-reply': { source: 'iana' },
    'application/timestamped-data': { source: 'iana', extensions: ['tsd'] },
    'application/tlsrpt+gzip': { source: 'iana' },
    'application/tlsrpt+json': { source: 'iana', compressible: !0 },
    'application/tnauthlist': { source: 'iana' },
    'application/token-introspection+jwt': { source: 'iana' },
    'application/toml': { compressible: !0, extensions: ['toml'] },
    'application/trickle-ice-sdpfrag': { source: 'iana' },
    'application/trig': { source: 'iana', extensions: ['trig'] },
    'application/ttml+xml': { source: 'iana', compressible: !0, extensions: ['ttml'] },
    'application/tve-trigger': { source: 'iana' },
    'application/tzif': { source: 'iana' },
    'application/tzif-leap': { source: 'iana' },
    'application/ubjson': { compressible: !1, extensions: ['ubj'] },
    'application/ulpfec': { source: 'iana' },
    'application/urc-grpsheet+xml': { source: 'iana', compressible: !0 },
    'application/urc-ressheet+xml': { source: 'iana', compressible: !0, extensions: ['rsheet'] },
    'application/urc-targetdesc+xml': { source: 'iana', compressible: !0, extensions: ['td'] },
    'application/urc-uisocketdesc+xml': { source: 'iana', compressible: !0 },
    'application/vcard+json': { source: 'iana', compressible: !0 },
    'application/vcard+xml': { source: 'iana', compressible: !0 },
    'application/vemmi': { source: 'iana' },
    'application/vividence.scriptfile': { source: 'apache' },
    'application/vnd.1000minds.decision-model+xml': { source: 'iana', compressible: !0, extensions: ['1km'] },
    'application/vnd.3gpp-prose+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp-prose-pc3ch+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp-v2x-local-service-information': { source: 'iana' },
    'application/vnd.3gpp.5gnas': { source: 'iana' },
    'application/vnd.3gpp.access-transfer-events+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.bsf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.gmop+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.gtpc': { source: 'iana' },
    'application/vnd.3gpp.interworking-data': { source: 'iana' },
    'application/vnd.3gpp.lpp': { source: 'iana' },
    'application/vnd.3gpp.mc-signalling-ear': { source: 'iana' },
    'application/vnd.3gpp.mcdata-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-payload': { source: 'iana' },
    'application/vnd.3gpp.mcdata-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-signalling': { source: 'iana' },
    'application/vnd.3gpp.mcdata-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcdata-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-floor-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-location-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-mbms-usage-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-signed+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-ue-init-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcptt-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-affiliation-command+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-affiliation-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-location-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-mbms-usage-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-service-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-transmission-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-ue-config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mcvideo-user-profile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.mid-call+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.ngap': { source: 'iana' },
    'application/vnd.3gpp.pfcp': { source: 'iana' },
    'application/vnd.3gpp.pic-bw-large': { source: 'iana', extensions: ['plb'] },
    'application/vnd.3gpp.pic-bw-small': { source: 'iana', extensions: ['psb'] },
    'application/vnd.3gpp.pic-bw-var': { source: 'iana', extensions: ['pvb'] },
    'application/vnd.3gpp.s1ap': { source: 'iana' },
    'application/vnd.3gpp.sms': { source: 'iana' },
    'application/vnd.3gpp.sms+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.srvcc-ext+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.srvcc-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.state-and-event-info+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp.ussd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp2.bcmcsinfo+xml': { source: 'iana', compressible: !0 },
    'application/vnd.3gpp2.sms': { source: 'iana' },
    'application/vnd.3gpp2.tcap': { source: 'iana', extensions: ['tcap'] },
    'application/vnd.3lightssoftware.imagescal': { source: 'iana' },
    'application/vnd.3m.post-it-notes': { source: 'iana', extensions: ['pwn'] },
    'application/vnd.accpac.simply.aso': { source: 'iana', extensions: ['aso'] },
    'application/vnd.accpac.simply.imp': { source: 'iana', extensions: ['imp'] },
    'application/vnd.acucobol': { source: 'iana', extensions: ['acu'] },
    'application/vnd.acucorp': { source: 'iana', extensions: ['atc', 'acutc'] },
    'application/vnd.adobe.air-application-installer-package+zip': {
      source: 'apache',
      compressible: !1,
      extensions: ['air'],
    },
    'application/vnd.adobe.flash.movie': { source: 'iana' },
    'application/vnd.adobe.formscentral.fcdt': { source: 'iana', extensions: ['fcdt'] },
    'application/vnd.adobe.fxp': { source: 'iana', extensions: ['fxp', 'fxpl'] },
    'application/vnd.adobe.partial-upload': { source: 'iana' },
    'application/vnd.adobe.xdp+xml': { source: 'iana', compressible: !0, extensions: ['xdp'] },
    'application/vnd.adobe.xfdf': { source: 'iana', extensions: ['xfdf'] },
    'application/vnd.aether.imp': { source: 'iana' },
    'application/vnd.afpc.afplinedata': { source: 'iana' },
    'application/vnd.afpc.afplinedata-pagedef': { source: 'iana' },
    'application/vnd.afpc.cmoca-cmresource': { source: 'iana' },
    'application/vnd.afpc.foca-charset': { source: 'iana' },
    'application/vnd.afpc.foca-codedfont': { source: 'iana' },
    'application/vnd.afpc.foca-codepage': { source: 'iana' },
    'application/vnd.afpc.modca': { source: 'iana' },
    'application/vnd.afpc.modca-cmtable': { source: 'iana' },
    'application/vnd.afpc.modca-formdef': { source: 'iana' },
    'application/vnd.afpc.modca-mediummap': { source: 'iana' },
    'application/vnd.afpc.modca-objectcontainer': { source: 'iana' },
    'application/vnd.afpc.modca-overlay': { source: 'iana' },
    'application/vnd.afpc.modca-pagesegment': { source: 'iana' },
    'application/vnd.age': { source: 'iana', extensions: ['age'] },
    'application/vnd.ah-barcode': { source: 'iana' },
    'application/vnd.ahead.space': { source: 'iana', extensions: ['ahead'] },
    'application/vnd.airzip.filesecure.azf': { source: 'iana', extensions: ['azf'] },
    'application/vnd.airzip.filesecure.azs': { source: 'iana', extensions: ['azs'] },
    'application/vnd.amadeus+json': { source: 'iana', compressible: !0 },
    'application/vnd.amazon.ebook': { source: 'apache', extensions: ['azw'] },
    'application/vnd.amazon.mobi8-ebook': { source: 'iana' },
    'application/vnd.americandynamics.acc': { source: 'iana', extensions: ['acc'] },
    'application/vnd.amiga.ami': { source: 'iana', extensions: ['ami'] },
    'application/vnd.amundsen.maze+xml': { source: 'iana', compressible: !0 },
    'application/vnd.android.ota': { source: 'iana' },
    'application/vnd.android.package-archive': { source: 'apache', compressible: !1, extensions: ['apk'] },
    'application/vnd.anki': { source: 'iana' },
    'application/vnd.anser-web-certificate-issue-initiation': { source: 'iana', extensions: ['cii'] },
    'application/vnd.anser-web-funds-transfer-initiation': { source: 'apache', extensions: ['fti'] },
    'application/vnd.antix.game-component': { source: 'iana', extensions: ['atx'] },
    'application/vnd.apache.arrow.file': { source: 'iana' },
    'application/vnd.apache.arrow.stream': { source: 'iana' },
    'application/vnd.apache.thrift.binary': { source: 'iana' },
    'application/vnd.apache.thrift.compact': { source: 'iana' },
    'application/vnd.apache.thrift.json': { source: 'iana' },
    'application/vnd.api+json': { source: 'iana', compressible: !0 },
    'application/vnd.aplextor.warrp+json': { source: 'iana', compressible: !0 },
    'application/vnd.apothekende.reservation+json': { source: 'iana', compressible: !0 },
    'application/vnd.apple.installer+xml': { source: 'iana', compressible: !0, extensions: ['mpkg'] },
    'application/vnd.apple.keynote': { source: 'iana', extensions: ['key'] },
    'application/vnd.apple.mpegurl': { source: 'iana', extensions: ['m3u8'] },
    'application/vnd.apple.numbers': { source: 'iana', extensions: ['numbers'] },
    'application/vnd.apple.pages': { source: 'iana', extensions: ['pages'] },
    'application/vnd.apple.pkpass': { compressible: !1, extensions: ['pkpass'] },
    'application/vnd.arastra.swi': { source: 'iana' },
    'application/vnd.aristanetworks.swi': { source: 'iana', extensions: ['swi'] },
    'application/vnd.artisan+json': { source: 'iana', compressible: !0 },
    'application/vnd.artsquare': { source: 'iana' },
    'application/vnd.astraea-software.iota': { source: 'iana', extensions: ['iota'] },
    'application/vnd.audiograph': { source: 'iana', extensions: ['aep'] },
    'application/vnd.autopackage': { source: 'iana' },
    'application/vnd.avalon+json': { source: 'iana', compressible: !0 },
    'application/vnd.avistar+xml': { source: 'iana', compressible: !0 },
    'application/vnd.balsamiq.bmml+xml': { source: 'iana', compressible: !0, extensions: ['bmml'] },
    'application/vnd.balsamiq.bmpr': { source: 'iana' },
    'application/vnd.banana-accounting': { source: 'iana' },
    'application/vnd.bbf.usp.error': { source: 'iana' },
    'application/vnd.bbf.usp.msg': { source: 'iana' },
    'application/vnd.bbf.usp.msg+json': { source: 'iana', compressible: !0 },
    'application/vnd.bekitzur-stech+json': { source: 'iana', compressible: !0 },
    'application/vnd.bint.med-content': { source: 'iana' },
    'application/vnd.biopax.rdf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.blink-idb-value-wrapper': { source: 'iana' },
    'application/vnd.blueice.multipass': { source: 'iana', extensions: ['mpm'] },
    'application/vnd.bluetooth.ep.oob': { source: 'iana' },
    'application/vnd.bluetooth.le.oob': { source: 'iana' },
    'application/vnd.bmi': { source: 'iana', extensions: ['bmi'] },
    'application/vnd.bpf': { source: 'iana' },
    'application/vnd.bpf3': { source: 'iana' },
    'application/vnd.businessobjects': { source: 'iana', extensions: ['rep'] },
    'application/vnd.byu.uapi+json': { source: 'iana', compressible: !0 },
    'application/vnd.cab-jscript': { source: 'iana' },
    'application/vnd.canon-cpdl': { source: 'iana' },
    'application/vnd.canon-lips': { source: 'iana' },
    'application/vnd.capasystems-pg+json': { source: 'iana', compressible: !0 },
    'application/vnd.cendio.thinlinc.clientconf': { source: 'iana' },
    'application/vnd.century-systems.tcp_stream': { source: 'iana' },
    'application/vnd.chemdraw+xml': { source: 'iana', compressible: !0, extensions: ['cdxml'] },
    'application/vnd.chess-pgn': { source: 'iana' },
    'application/vnd.chipnuts.karaoke-mmd': { source: 'iana', extensions: ['mmd'] },
    'application/vnd.ciedi': { source: 'iana' },
    'application/vnd.cinderella': { source: 'iana', extensions: ['cdy'] },
    'application/vnd.cirpack.isdn-ext': { source: 'iana' },
    'application/vnd.citationstyles.style+xml': { source: 'iana', compressible: !0, extensions: ['csl'] },
    'application/vnd.claymore': { source: 'iana', extensions: ['cla'] },
    'application/vnd.cloanto.rp9': { source: 'iana', extensions: ['rp9'] },
    'application/vnd.clonk.c4group': { source: 'iana', extensions: ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'] },
    'application/vnd.cluetrust.cartomobile-config': { source: 'iana', extensions: ['c11amc'] },
    'application/vnd.cluetrust.cartomobile-config-pkg': { source: 'iana', extensions: ['c11amz'] },
    'application/vnd.coffeescript': { source: 'iana' },
    'application/vnd.collabio.xodocuments.document': { source: 'iana' },
    'application/vnd.collabio.xodocuments.document-template': { source: 'iana' },
    'application/vnd.collabio.xodocuments.presentation': { source: 'iana' },
    'application/vnd.collabio.xodocuments.presentation-template': { source: 'iana' },
    'application/vnd.collabio.xodocuments.spreadsheet': { source: 'iana' },
    'application/vnd.collabio.xodocuments.spreadsheet-template': { source: 'iana' },
    'application/vnd.collection+json': { source: 'iana', compressible: !0 },
    'application/vnd.collection.doc+json': { source: 'iana', compressible: !0 },
    'application/vnd.collection.next+json': { source: 'iana', compressible: !0 },
    'application/vnd.comicbook+zip': { source: 'iana', compressible: !1 },
    'application/vnd.comicbook-rar': { source: 'iana' },
    'application/vnd.commerce-battelle': { source: 'iana' },
    'application/vnd.commonspace': { source: 'iana', extensions: ['csp'] },
    'application/vnd.contact.cmsg': { source: 'iana', extensions: ['cdbcmsg'] },
    'application/vnd.coreos.ignition+json': { source: 'iana', compressible: !0 },
    'application/vnd.cosmocaller': { source: 'iana', extensions: ['cmc'] },
    'application/vnd.crick.clicker': { source: 'iana', extensions: ['clkx'] },
    'application/vnd.crick.clicker.keyboard': { source: 'iana', extensions: ['clkk'] },
    'application/vnd.crick.clicker.palette': { source: 'iana', extensions: ['clkp'] },
    'application/vnd.crick.clicker.template': { source: 'iana', extensions: ['clkt'] },
    'application/vnd.crick.clicker.wordbank': { source: 'iana', extensions: ['clkw'] },
    'application/vnd.criticaltools.wbs+xml': { source: 'iana', compressible: !0, extensions: ['wbs'] },
    'application/vnd.cryptii.pipe+json': { source: 'iana', compressible: !0 },
    'application/vnd.crypto-shade-file': { source: 'iana' },
    'application/vnd.cryptomator.encrypted': { source: 'iana' },
    'application/vnd.cryptomator.vault': { source: 'iana' },
    'application/vnd.ctc-posml': { source: 'iana', extensions: ['pml'] },
    'application/vnd.ctct.ws+xml': { source: 'iana', compressible: !0 },
    'application/vnd.cups-pdf': { source: 'iana' },
    'application/vnd.cups-postscript': { source: 'iana' },
    'application/vnd.cups-ppd': { source: 'iana', extensions: ['ppd'] },
    'application/vnd.cups-raster': { source: 'iana' },
    'application/vnd.cups-raw': { source: 'iana' },
    'application/vnd.curl': { source: 'iana' },
    'application/vnd.curl.car': { source: 'apache', extensions: ['car'] },
    'application/vnd.curl.pcurl': { source: 'apache', extensions: ['pcurl'] },
    'application/vnd.cyan.dean.root+xml': { source: 'iana', compressible: !0 },
    'application/vnd.cybank': { source: 'iana' },
    'application/vnd.cyclonedx+json': { source: 'iana', compressible: !0 },
    'application/vnd.cyclonedx+xml': { source: 'iana', compressible: !0 },
    'application/vnd.d2l.coursepackage1p0+zip': { source: 'iana', compressible: !1 },
    'application/vnd.d3m-dataset': { source: 'iana' },
    'application/vnd.d3m-problem': { source: 'iana' },
    'application/vnd.dart': { source: 'iana', compressible: !0, extensions: ['dart'] },
    'application/vnd.data-vision.rdz': { source: 'iana', extensions: ['rdz'] },
    'application/vnd.datapackage+json': { source: 'iana', compressible: !0 },
    'application/vnd.dataresource+json': { source: 'iana', compressible: !0 },
    'application/vnd.dbf': { source: 'iana', extensions: ['dbf'] },
    'application/vnd.debian.binary-package': { source: 'iana' },
    'application/vnd.dece.data': { source: 'iana', extensions: ['uvf', 'uvvf', 'uvd', 'uvvd'] },
    'application/vnd.dece.ttml+xml': { source: 'iana', compressible: !0, extensions: ['uvt', 'uvvt'] },
    'application/vnd.dece.unspecified': { source: 'iana', extensions: ['uvx', 'uvvx'] },
    'application/vnd.dece.zip': { source: 'iana', extensions: ['uvz', 'uvvz'] },
    'application/vnd.denovo.fcselayout-link': { source: 'iana', extensions: ['fe_launch'] },
    'application/vnd.desmume.movie': { source: 'iana' },
    'application/vnd.dir-bi.plate-dl-nosuffix': { source: 'iana' },
    'application/vnd.dm.delegation+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dna': { source: 'iana', extensions: ['dna'] },
    'application/vnd.document+json': { source: 'iana', compressible: !0 },
    'application/vnd.dolby.mlp': { source: 'apache', extensions: ['mlp'] },
    'application/vnd.dolby.mobile.1': { source: 'iana' },
    'application/vnd.dolby.mobile.2': { source: 'iana' },
    'application/vnd.doremir.scorecloud-binary-document': { source: 'iana' },
    'application/vnd.dpgraph': { source: 'iana', extensions: ['dpg'] },
    'application/vnd.dreamfactory': { source: 'iana', extensions: ['dfac'] },
    'application/vnd.drive+json': { source: 'iana', compressible: !0 },
    'application/vnd.ds-keypoint': { source: 'apache', extensions: ['kpxx'] },
    'application/vnd.dtg.local': { source: 'iana' },
    'application/vnd.dtg.local.flash': { source: 'iana' },
    'application/vnd.dtg.local.html': { source: 'iana' },
    'application/vnd.dvb.ait': { source: 'iana', extensions: ['ait'] },
    'application/vnd.dvb.dvbisl+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.dvbj': { source: 'iana' },
    'application/vnd.dvb.esgcontainer': { source: 'iana' },
    'application/vnd.dvb.ipdcdftnotifaccess': { source: 'iana' },
    'application/vnd.dvb.ipdcesgaccess': { source: 'iana' },
    'application/vnd.dvb.ipdcesgaccess2': { source: 'iana' },
    'application/vnd.dvb.ipdcesgpdd': { source: 'iana' },
    'application/vnd.dvb.ipdcroaming': { source: 'iana' },
    'application/vnd.dvb.iptv.alfec-base': { source: 'iana' },
    'application/vnd.dvb.iptv.alfec-enhancement': { source: 'iana' },
    'application/vnd.dvb.notif-aggregate-root+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-container+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-generic+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-msglist+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-registration-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-ia-registration-response+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.notif-init+xml': { source: 'iana', compressible: !0 },
    'application/vnd.dvb.pfr': { source: 'iana' },
    'application/vnd.dvb.service': { source: 'iana', extensions: ['svc'] },
    'application/vnd.dxr': { source: 'iana' },
    'application/vnd.dynageo': { source: 'iana', extensions: ['geo'] },
    'application/vnd.dzr': { source: 'iana' },
    'application/vnd.easykaraoke.cdgdownload': { source: 'iana' },
    'application/vnd.ecdis-update': { source: 'iana' },
    'application/vnd.ecip.rlp': { source: 'iana' },
    'application/vnd.eclipse.ditto+json': { source: 'iana', compressible: !0 },
    'application/vnd.ecowin.chart': { source: 'iana', extensions: ['mag'] },
    'application/vnd.ecowin.filerequest': { source: 'iana' },
    'application/vnd.ecowin.fileupdate': { source: 'iana' },
    'application/vnd.ecowin.series': { source: 'iana' },
    'application/vnd.ecowin.seriesrequest': { source: 'iana' },
    'application/vnd.ecowin.seriesupdate': { source: 'iana' },
    'application/vnd.efi.img': { source: 'iana' },
    'application/vnd.efi.iso': { source: 'iana' },
    'application/vnd.emclient.accessrequest+xml': { source: 'iana', compressible: !0 },
    'application/vnd.enliven': { source: 'iana', extensions: ['nml'] },
    'application/vnd.enphase.envoy': { source: 'iana' },
    'application/vnd.eprints.data+xml': { source: 'iana', compressible: !0 },
    'application/vnd.epson.esf': { source: 'iana', extensions: ['esf'] },
    'application/vnd.epson.msf': { source: 'iana', extensions: ['msf'] },
    'application/vnd.epson.quickanime': { source: 'iana', extensions: ['qam'] },
    'application/vnd.epson.salt': { source: 'iana', extensions: ['slt'] },
    'application/vnd.epson.ssf': { source: 'iana', extensions: ['ssf'] },
    'application/vnd.ericsson.quickcall': { source: 'iana' },
    'application/vnd.espass-espass+zip': { source: 'iana', compressible: !1 },
    'application/vnd.eszigno3+xml': { source: 'iana', compressible: !0, extensions: ['es3', 'et3'] },
    'application/vnd.etsi.aoc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.asic-e+zip': { source: 'iana', compressible: !1 },
    'application/vnd.etsi.asic-s+zip': { source: 'iana', compressible: !1 },
    'application/vnd.etsi.cug+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvcommand+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvdiscovery+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-bc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-cod+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsad-npvr+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvservice+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvsync+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.iptvueprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.mcid+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.mheg5': { source: 'iana' },
    'application/vnd.etsi.overload-control-policy-dataset+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.pstn+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.sci+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.simservs+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.timestamp-token': { source: 'iana' },
    'application/vnd.etsi.tsl+xml': { source: 'iana', compressible: !0 },
    'application/vnd.etsi.tsl.der': { source: 'iana' },
    'application/vnd.eu.kasparian.car+json': { source: 'iana', compressible: !0 },
    'application/vnd.eudora.data': { source: 'iana' },
    'application/vnd.evolv.ecig.profile': { source: 'iana' },
    'application/vnd.evolv.ecig.settings': { source: 'iana' },
    'application/vnd.evolv.ecig.theme': { source: 'iana' },
    'application/vnd.exstream-empower+zip': { source: 'iana', compressible: !1 },
    'application/vnd.exstream-package': { source: 'iana' },
    'application/vnd.ezpix-album': { source: 'iana', extensions: ['ez2'] },
    'application/vnd.ezpix-package': { source: 'iana', extensions: ['ez3'] },
    'application/vnd.f-secure.mobile': { source: 'iana' },
    'application/vnd.familysearch.gedcom+zip': { source: 'iana', compressible: !1 },
    'application/vnd.fastcopy-disk-image': { source: 'iana' },
    'application/vnd.fdf': { source: 'iana', extensions: ['fdf'] },
    'application/vnd.fdsn.mseed': { source: 'iana', extensions: ['mseed'] },
    'application/vnd.fdsn.seed': { source: 'iana', extensions: ['seed', 'dataless'] },
    'application/vnd.ffsns': { source: 'iana' },
    'application/vnd.ficlab.flb+zip': { source: 'iana', compressible: !1 },
    'application/vnd.filmit.zfc': { source: 'iana' },
    'application/vnd.fints': { source: 'iana' },
    'application/vnd.firemonkeys.cloudcell': { source: 'iana' },
    'application/vnd.flographit': { source: 'iana', extensions: ['gph'] },
    'application/vnd.fluxtime.clip': { source: 'iana', extensions: ['ftc'] },
    'application/vnd.font-fontforge-sfd': { source: 'iana' },
    'application/vnd.framemaker': { source: 'iana', extensions: ['fm', 'frame', 'maker', 'book'] },
    'application/vnd.frogans.fnc': { source: 'iana', extensions: ['fnc'] },
    'application/vnd.frogans.ltf': { source: 'iana', extensions: ['ltf'] },
    'application/vnd.fsc.weblaunch': { source: 'iana', extensions: ['fsc'] },
    'application/vnd.fujifilm.fb.docuworks': { source: 'iana' },
    'application/vnd.fujifilm.fb.docuworks.binder': { source: 'iana' },
    'application/vnd.fujifilm.fb.docuworks.container': { source: 'iana' },
    'application/vnd.fujifilm.fb.jfi+xml': { source: 'iana', compressible: !0 },
    'application/vnd.fujitsu.oasys': { source: 'iana', extensions: ['oas'] },
    'application/vnd.fujitsu.oasys2': { source: 'iana', extensions: ['oa2'] },
    'application/vnd.fujitsu.oasys3': { source: 'iana', extensions: ['oa3'] },
    'application/vnd.fujitsu.oasysgp': { source: 'iana', extensions: ['fg5'] },
    'application/vnd.fujitsu.oasysprs': { source: 'iana', extensions: ['bh2'] },
    'application/vnd.fujixerox.art-ex': { source: 'iana' },
    'application/vnd.fujixerox.art4': { source: 'iana' },
    'application/vnd.fujixerox.ddd': { source: 'iana', extensions: ['ddd'] },
    'application/vnd.fujixerox.docuworks': { source: 'iana', extensions: ['xdw'] },
    'application/vnd.fujixerox.docuworks.binder': { source: 'iana', extensions: ['xbd'] },
    'application/vnd.fujixerox.docuworks.container': { source: 'iana' },
    'application/vnd.fujixerox.hbpl': { source: 'iana' },
    'application/vnd.fut-misnet': { source: 'iana' },
    'application/vnd.futoin+cbor': { source: 'iana' },
    'application/vnd.futoin+json': { source: 'iana', compressible: !0 },
    'application/vnd.fuzzysheet': { source: 'iana', extensions: ['fzs'] },
    'application/vnd.genomatix.tuxedo': { source: 'iana', extensions: ['txd'] },
    'application/vnd.gentics.grd+json': { source: 'iana', compressible: !0 },
    'application/vnd.geo+json': { source: 'iana', compressible: !0 },
    'application/vnd.geocube+xml': { source: 'iana', compressible: !0 },
    'application/vnd.geogebra.file': { source: 'iana', extensions: ['ggb'] },
    'application/vnd.geogebra.slides': { source: 'iana' },
    'application/vnd.geogebra.tool': { source: 'iana', extensions: ['ggt'] },
    'application/vnd.geometry-explorer': { source: 'iana', extensions: ['gex', 'gre'] },
    'application/vnd.geonext': { source: 'iana', extensions: ['gxt'] },
    'application/vnd.geoplan': { source: 'iana', extensions: ['g2w'] },
    'application/vnd.geospace': { source: 'iana', extensions: ['g3w'] },
    'application/vnd.gerber': { source: 'iana' },
    'application/vnd.globalplatform.card-content-mgt': { source: 'iana' },
    'application/vnd.globalplatform.card-content-mgt-response': { source: 'iana' },
    'application/vnd.gmx': { source: 'iana', extensions: ['gmx'] },
    'application/vnd.google-apps.document': { compressible: !1, extensions: ['gdoc'] },
    'application/vnd.google-apps.presentation': { compressible: !1, extensions: ['gslides'] },
    'application/vnd.google-apps.spreadsheet': { compressible: !1, extensions: ['gsheet'] },
    'application/vnd.google-earth.kml+xml': { source: 'iana', compressible: !0, extensions: ['kml'] },
    'application/vnd.google-earth.kmz': { source: 'iana', compressible: !1, extensions: ['kmz'] },
    'application/vnd.gov.sk.e-form+xml': { source: 'iana', compressible: !0 },
    'application/vnd.gov.sk.e-form+zip': { source: 'iana', compressible: !1 },
    'application/vnd.gov.sk.xmldatacontainer+xml': { source: 'iana', compressible: !0 },
    'application/vnd.grafeq': { source: 'iana', extensions: ['gqf', 'gqs'] },
    'application/vnd.gridmp': { source: 'iana' },
    'application/vnd.groove-account': { source: 'iana', extensions: ['gac'] },
    'application/vnd.groove-help': { source: 'iana', extensions: ['ghf'] },
    'application/vnd.groove-identity-message': { source: 'iana', extensions: ['gim'] },
    'application/vnd.groove-injector': { source: 'iana', extensions: ['grv'] },
    'application/vnd.groove-tool-message': { source: 'iana', extensions: ['gtm'] },
    'application/vnd.groove-tool-template': { source: 'iana', extensions: ['tpl'] },
    'application/vnd.groove-vcard': { source: 'iana', extensions: ['vcg'] },
    'application/vnd.hal+json': { source: 'iana', compressible: !0 },
    'application/vnd.hal+xml': { source: 'iana', compressible: !0, extensions: ['hal'] },
    'application/vnd.handheld-entertainment+xml': { source: 'iana', compressible: !0, extensions: ['zmm'] },
    'application/vnd.hbci': { source: 'iana', extensions: ['hbci'] },
    'application/vnd.hc+json': { source: 'iana', compressible: !0 },
    'application/vnd.hcl-bireports': { source: 'iana' },
    'application/vnd.hdt': { source: 'iana' },
    'application/vnd.heroku+json': { source: 'iana', compressible: !0 },
    'application/vnd.hhe.lesson-player': { source: 'iana', extensions: ['les'] },
    'application/vnd.hl7cda+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.hl7v2+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.hp-hpgl': { source: 'iana', extensions: ['hpgl'] },
    'application/vnd.hp-hpid': { source: 'iana', extensions: ['hpid'] },
    'application/vnd.hp-hps': { source: 'iana', extensions: ['hps'] },
    'application/vnd.hp-jlyt': { source: 'iana', extensions: ['jlt'] },
    'application/vnd.hp-pcl': { source: 'iana', extensions: ['pcl'] },
    'application/vnd.hp-pclxl': { source: 'iana', extensions: ['pclxl'] },
    'application/vnd.httphone': { source: 'iana' },
    'application/vnd.hydrostatix.sof-data': { source: 'iana', extensions: ['sfd-hdstx'] },
    'application/vnd.hyper+json': { source: 'iana', compressible: !0 },
    'application/vnd.hyper-item+json': { source: 'iana', compressible: !0 },
    'application/vnd.hyperdrive+json': { source: 'iana', compressible: !0 },
    'application/vnd.hzn-3d-crossword': { source: 'iana' },
    'application/vnd.ibm.afplinedata': { source: 'iana' },
    'application/vnd.ibm.electronic-media': { source: 'iana' },
    'application/vnd.ibm.minipay': { source: 'iana', extensions: ['mpy'] },
    'application/vnd.ibm.modcap': { source: 'iana', extensions: ['afp', 'listafp', 'list3820'] },
    'application/vnd.ibm.rights-management': { source: 'iana', extensions: ['irm'] },
    'application/vnd.ibm.secure-container': { source: 'iana', extensions: ['sc'] },
    'application/vnd.iccprofile': { source: 'iana', extensions: ['icc', 'icm'] },
    'application/vnd.ieee.1905': { source: 'iana' },
    'application/vnd.igloader': { source: 'iana', extensions: ['igl'] },
    'application/vnd.imagemeter.folder+zip': { source: 'iana', compressible: !1 },
    'application/vnd.imagemeter.image+zip': { source: 'iana', compressible: !1 },
    'application/vnd.immervision-ivp': { source: 'iana', extensions: ['ivp'] },
    'application/vnd.immervision-ivu': { source: 'iana', extensions: ['ivu'] },
    'application/vnd.ims.imsccv1p1': { source: 'iana' },
    'application/vnd.ims.imsccv1p2': { source: 'iana' },
    'application/vnd.ims.imsccv1p3': { source: 'iana' },
    'application/vnd.ims.lis.v2.result+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolconsumerprofile+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolproxy+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolproxy.id+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolsettings+json': { source: 'iana', compressible: !0 },
    'application/vnd.ims.lti.v2.toolsettings.simple+json': { source: 'iana', compressible: !0 },
    'application/vnd.informedcontrol.rms+xml': { source: 'iana', compressible: !0 },
    'application/vnd.informix-visionary': { source: 'iana' },
    'application/vnd.infotech.project': { source: 'iana' },
    'application/vnd.infotech.project+xml': { source: 'iana', compressible: !0 },
    'application/vnd.innopath.wamp.notification': { source: 'iana' },
    'application/vnd.insors.igm': { source: 'iana', extensions: ['igm'] },
    'application/vnd.intercon.formnet': { source: 'iana', extensions: ['xpw', 'xpx'] },
    'application/vnd.intergeo': { source: 'iana', extensions: ['i2g'] },
    'application/vnd.intertrust.digibox': { source: 'iana' },
    'application/vnd.intertrust.nncp': { source: 'iana' },
    'application/vnd.intu.qbo': { source: 'iana', extensions: ['qbo'] },
    'application/vnd.intu.qfx': { source: 'iana', extensions: ['qfx'] },
    'application/vnd.iptc.g2.catalogitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.conceptitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.knowledgeitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.newsitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.newsmessage+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.packageitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.iptc.g2.planningitem+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ipunplugged.rcprofile': { source: 'iana', extensions: ['rcprofile'] },
    'application/vnd.irepository.package+xml': { source: 'iana', compressible: !0, extensions: ['irp'] },
    'application/vnd.is-xpr': { source: 'iana', extensions: ['xpr'] },
    'application/vnd.isac.fcs': { source: 'iana', extensions: ['fcs'] },
    'application/vnd.iso11783-10+zip': { source: 'iana', compressible: !1 },
    'application/vnd.jam': { source: 'iana', extensions: ['jam'] },
    'application/vnd.japannet-directory-service': { source: 'iana' },
    'application/vnd.japannet-jpnstore-wakeup': { source: 'iana' },
    'application/vnd.japannet-payment-wakeup': { source: 'iana' },
    'application/vnd.japannet-registration': { source: 'iana' },
    'application/vnd.japannet-registration-wakeup': { source: 'iana' },
    'application/vnd.japannet-setstore-wakeup': { source: 'iana' },
    'application/vnd.japannet-verification': { source: 'iana' },
    'application/vnd.japannet-verification-wakeup': { source: 'iana' },
    'application/vnd.jcp.javame.midlet-rms': { source: 'iana', extensions: ['rms'] },
    'application/vnd.jisp': { source: 'iana', extensions: ['jisp'] },
    'application/vnd.joost.joda-archive': { source: 'iana', extensions: ['joda'] },
    'application/vnd.jsk.isdn-ngn': { source: 'iana' },
    'application/vnd.kahootz': { source: 'iana', extensions: ['ktz', 'ktr'] },
    'application/vnd.kde.karbon': { source: 'iana', extensions: ['karbon'] },
    'application/vnd.kde.kchart': { source: 'iana', extensions: ['chrt'] },
    'application/vnd.kde.kformula': { source: 'iana', extensions: ['kfo'] },
    'application/vnd.kde.kivio': { source: 'iana', extensions: ['flw'] },
    'application/vnd.kde.kontour': { source: 'iana', extensions: ['kon'] },
    'application/vnd.kde.kpresenter': { source: 'iana', extensions: ['kpr', 'kpt'] },
    'application/vnd.kde.kspread': { source: 'iana', extensions: ['ksp'] },
    'application/vnd.kde.kword': { source: 'iana', extensions: ['kwd', 'kwt'] },
    'application/vnd.kenameaapp': { source: 'iana', extensions: ['htke'] },
    'application/vnd.kidspiration': { source: 'iana', extensions: ['kia'] },
    'application/vnd.kinar': { source: 'iana', extensions: ['kne', 'knp'] },
    'application/vnd.koan': { source: 'iana', extensions: ['skp', 'skd', 'skt', 'skm'] },
    'application/vnd.kodak-descriptor': { source: 'iana', extensions: ['sse'] },
    'application/vnd.las': { source: 'iana' },
    'application/vnd.las.las+json': { source: 'iana', compressible: !0 },
    'application/vnd.las.las+xml': { source: 'iana', compressible: !0, extensions: ['lasxml'] },
    'application/vnd.laszip': { source: 'iana' },
    'application/vnd.leap+json': { source: 'iana', compressible: !0 },
    'application/vnd.liberty-request+xml': { source: 'iana', compressible: !0 },
    'application/vnd.llamagraphics.life-balance.desktop': { source: 'iana', extensions: ['lbd'] },
    'application/vnd.llamagraphics.life-balance.exchange+xml': {
      source: 'iana',
      compressible: !0,
      extensions: ['lbe'],
    },
    'application/vnd.logipipe.circuit+zip': { source: 'iana', compressible: !1 },
    'application/vnd.loom': { source: 'iana' },
    'application/vnd.lotus-1-2-3': { source: 'iana', extensions: ['123'] },
    'application/vnd.lotus-approach': { source: 'iana', extensions: ['apr'] },
    'application/vnd.lotus-freelance': { source: 'iana', extensions: ['pre'] },
    'application/vnd.lotus-notes': { source: 'iana', extensions: ['nsf'] },
    'application/vnd.lotus-organizer': { source: 'iana', extensions: ['org'] },
    'application/vnd.lotus-screencam': { source: 'iana', extensions: ['scm'] },
    'application/vnd.lotus-wordpro': { source: 'iana', extensions: ['lwp'] },
    'application/vnd.macports.portpkg': { source: 'iana', extensions: ['portpkg'] },
    'application/vnd.mapbox-vector-tile': { source: 'iana', extensions: ['mvt'] },
    'application/vnd.marlin.drm.actiontoken+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.conftoken+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.license+xml': { source: 'iana', compressible: !0 },
    'application/vnd.marlin.drm.mdcf': { source: 'iana' },
    'application/vnd.mason+json': { source: 'iana', compressible: !0 },
    'application/vnd.maxar.archive.3tz+zip': { source: 'iana', compressible: !1 },
    'application/vnd.maxmind.maxmind-db': { source: 'iana' },
    'application/vnd.mcd': { source: 'iana', extensions: ['mcd'] },
    'application/vnd.medcalcdata': { source: 'iana', extensions: ['mc1'] },
    'application/vnd.mediastation.cdkey': { source: 'iana', extensions: ['cdkey'] },
    'application/vnd.meridian-slingshot': { source: 'iana' },
    'application/vnd.mfer': { source: 'iana', extensions: ['mwf'] },
    'application/vnd.mfmp': { source: 'iana', extensions: ['mfm'] },
    'application/vnd.micro+json': { source: 'iana', compressible: !0 },
    'application/vnd.micrografx.flo': { source: 'iana', extensions: ['flo'] },
    'application/vnd.micrografx.igx': { source: 'iana', extensions: ['igx'] },
    'application/vnd.microsoft.portable-executable': { source: 'iana' },
    'application/vnd.microsoft.windows.thumbnail-cache': { source: 'iana' },
    'application/vnd.miele+json': { source: 'iana', compressible: !0 },
    'application/vnd.mif': { source: 'iana', extensions: ['mif'] },
    'application/vnd.minisoft-hp3000-save': { source: 'iana' },
    'application/vnd.mitsubishi.misty-guard.trustweb': { source: 'iana' },
    'application/vnd.mobius.daf': { source: 'iana', extensions: ['daf'] },
    'application/vnd.mobius.dis': { source: 'iana', extensions: ['dis'] },
    'application/vnd.mobius.mbk': { source: 'iana', extensions: ['mbk'] },
    'application/vnd.mobius.mqy': { source: 'iana', extensions: ['mqy'] },
    'application/vnd.mobius.msl': { source: 'iana', extensions: ['msl'] },
    'application/vnd.mobius.plc': { source: 'iana', extensions: ['plc'] },
    'application/vnd.mobius.txf': { source: 'iana', extensions: ['txf'] },
    'application/vnd.mophun.application': { source: 'iana', extensions: ['mpn'] },
    'application/vnd.mophun.certificate': { source: 'iana', extensions: ['mpc'] },
    'application/vnd.motorola.flexsuite': { source: 'iana' },
    'application/vnd.motorola.flexsuite.adsi': { source: 'iana' },
    'application/vnd.motorola.flexsuite.fis': { source: 'iana' },
    'application/vnd.motorola.flexsuite.gotap': { source: 'iana' },
    'application/vnd.motorola.flexsuite.kmr': { source: 'iana' },
    'application/vnd.motorola.flexsuite.ttc': { source: 'iana' },
    'application/vnd.motorola.flexsuite.wem': { source: 'iana' },
    'application/vnd.motorola.iprm': { source: 'iana' },
    'application/vnd.mozilla.xul+xml': { source: 'iana', compressible: !0, extensions: ['xul'] },
    'application/vnd.ms-3mfdocument': { source: 'iana' },
    'application/vnd.ms-artgalry': { source: 'iana', extensions: ['cil'] },
    'application/vnd.ms-asf': { source: 'iana' },
    'application/vnd.ms-cab-compressed': { source: 'iana', extensions: ['cab'] },
    'application/vnd.ms-color.iccprofile': { source: 'apache' },
    'application/vnd.ms-excel': {
      source: 'iana',
      compressible: !1,
      extensions: ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
    },
    'application/vnd.ms-excel.addin.macroenabled.12': { source: 'iana', extensions: ['xlam'] },
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': { source: 'iana', extensions: ['xlsb'] },
    'application/vnd.ms-excel.sheet.macroenabled.12': { source: 'iana', extensions: ['xlsm'] },
    'application/vnd.ms-excel.template.macroenabled.12': { source: 'iana', extensions: ['xltm'] },
    'application/vnd.ms-fontobject': { source: 'iana', compressible: !0, extensions: ['eot'] },
    'application/vnd.ms-htmlhelp': { source: 'iana', extensions: ['chm'] },
    'application/vnd.ms-ims': { source: 'iana', extensions: ['ims'] },
    'application/vnd.ms-lrm': { source: 'iana', extensions: ['lrm'] },
    'application/vnd.ms-office.activex+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-officetheme': { source: 'iana', extensions: ['thmx'] },
    'application/vnd.ms-opentype': { source: 'apache', compressible: !0 },
    'application/vnd.ms-outlook': { compressible: !1, extensions: ['msg'] },
    'application/vnd.ms-package.obfuscated-opentype': { source: 'apache' },
    'application/vnd.ms-pki.seccat': { source: 'apache', extensions: ['cat'] },
    'application/vnd.ms-pki.stl': { source: 'apache', extensions: ['stl'] },
    'application/vnd.ms-playready.initiator+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-powerpoint': { source: 'iana', compressible: !1, extensions: ['ppt', 'pps', 'pot'] },
    'application/vnd.ms-powerpoint.addin.macroenabled.12': { source: 'iana', extensions: ['ppam'] },
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': { source: 'iana', extensions: ['pptm'] },
    'application/vnd.ms-powerpoint.slide.macroenabled.12': { source: 'iana', extensions: ['sldm'] },
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': { source: 'iana', extensions: ['ppsm'] },
    'application/vnd.ms-powerpoint.template.macroenabled.12': { source: 'iana', extensions: ['potm'] },
    'application/vnd.ms-printdevicecapabilities+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-printing.printticket+xml': { source: 'apache', compressible: !0 },
    'application/vnd.ms-printschematicket+xml': { source: 'iana', compressible: !0 },
    'application/vnd.ms-project': { source: 'iana', extensions: ['mpp', 'mpt'] },
    'application/vnd.ms-tnef': { source: 'iana' },
    'application/vnd.ms-windows.devicepairing': { source: 'iana' },
    'application/vnd.ms-windows.nwprinting.oob': { source: 'iana' },
    'application/vnd.ms-windows.printerpairing': { source: 'iana' },
    'application/vnd.ms-windows.wsd.oob': { source: 'iana' },
    'application/vnd.ms-wmdrm.lic-chlg-req': { source: 'iana' },
    'application/vnd.ms-wmdrm.lic-resp': { source: 'iana' },
    'application/vnd.ms-wmdrm.meter-chlg-req': { source: 'iana' },
    'application/vnd.ms-wmdrm.meter-resp': { source: 'iana' },
    'application/vnd.ms-word.document.macroenabled.12': { source: 'iana', extensions: ['docm'] },
    'application/vnd.ms-word.template.macroenabled.12': { source: 'iana', extensions: ['dotm'] },
    'application/vnd.ms-works': { source: 'iana', extensions: ['wps', 'wks', 'wcm', 'wdb'] },
    'application/vnd.ms-wpl': { source: 'iana', extensions: ['wpl'] },
    'application/vnd.ms-xpsdocument': { source: 'iana', compressible: !1, extensions: ['xps'] },
    'application/vnd.msa-disk-image': { source: 'iana' },
    'application/vnd.mseq': { source: 'iana', extensions: ['mseq'] },
    'application/vnd.msign': { source: 'iana' },
    'application/vnd.multiad.creator': { source: 'iana' },
    'application/vnd.multiad.creator.cif': { source: 'iana' },
    'application/vnd.music-niff': { source: 'iana' },
    'application/vnd.musician': { source: 'iana', extensions: ['mus'] },
    'application/vnd.muvee.style': { source: 'iana', extensions: ['msty'] },
    'application/vnd.mynfc': { source: 'iana', extensions: ['taglet'] },
    'application/vnd.nacamar.ybrid+json': { source: 'iana', compressible: !0 },
    'application/vnd.ncd.control': { source: 'iana' },
    'application/vnd.ncd.reference': { source: 'iana' },
    'application/vnd.nearst.inv+json': { source: 'iana', compressible: !0 },
    'application/vnd.nebumind.line': { source: 'iana' },
    'application/vnd.nervana': { source: 'iana' },
    'application/vnd.netfpx': { source: 'iana' },
    'application/vnd.neurolanguage.nlu': { source: 'iana', extensions: ['nlu'] },
    'application/vnd.nimn': { source: 'iana' },
    'application/vnd.nintendo.nitro.rom': { source: 'iana' },
    'application/vnd.nintendo.snes.rom': { source: 'iana' },
    'application/vnd.nitf': { source: 'iana', extensions: ['ntf', 'nitf'] },
    'application/vnd.noblenet-directory': { source: 'iana', extensions: ['nnd'] },
    'application/vnd.noblenet-sealer': { source: 'iana', extensions: ['nns'] },
    'application/vnd.noblenet-web': { source: 'iana', extensions: ['nnw'] },
    'application/vnd.nokia.catalogs': { source: 'iana' },
    'application/vnd.nokia.conml+wbxml': { source: 'iana' },
    'application/vnd.nokia.conml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.iptv.config+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.isds-radio-presets': { source: 'iana' },
    'application/vnd.nokia.landmark+wbxml': { source: 'iana' },
    'application/vnd.nokia.landmark+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.landmarkcollection+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.n-gage.ac+xml': { source: 'iana', compressible: !0, extensions: ['ac'] },
    'application/vnd.nokia.n-gage.data': { source: 'iana', extensions: ['ngdat'] },
    'application/vnd.nokia.n-gage.symbian.install': { source: 'iana', extensions: ['n-gage'] },
    'application/vnd.nokia.ncd': { source: 'iana' },
    'application/vnd.nokia.pcd+wbxml': { source: 'iana' },
    'application/vnd.nokia.pcd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.nokia.radio-preset': { source: 'iana', extensions: ['rpst'] },
    'application/vnd.nokia.radio-presets': { source: 'iana', extensions: ['rpss'] },
    'application/vnd.novadigm.edm': { source: 'iana', extensions: ['edm'] },
    'application/vnd.novadigm.edx': { source: 'iana', extensions: ['edx'] },
    'application/vnd.novadigm.ext': { source: 'iana', extensions: ['ext'] },
    'application/vnd.ntt-local.content-share': { source: 'iana' },
    'application/vnd.ntt-local.file-transfer': { source: 'iana' },
    'application/vnd.ntt-local.ogw_remote-access': { source: 'iana' },
    'application/vnd.ntt-local.sip-ta_remote': { source: 'iana' },
    'application/vnd.ntt-local.sip-ta_tcp_stream': { source: 'iana' },
    'application/vnd.oasis.opendocument.chart': { source: 'iana', extensions: ['odc'] },
    'application/vnd.oasis.opendocument.chart-template': { source: 'iana', extensions: ['otc'] },
    'application/vnd.oasis.opendocument.database': { source: 'iana', extensions: ['odb'] },
    'application/vnd.oasis.opendocument.formula': { source: 'iana', extensions: ['odf'] },
    'application/vnd.oasis.opendocument.formula-template': { source: 'iana', extensions: ['odft'] },
    'application/vnd.oasis.opendocument.graphics': { source: 'iana', compressible: !1, extensions: ['odg'] },
    'application/vnd.oasis.opendocument.graphics-template': { source: 'iana', extensions: ['otg'] },
    'application/vnd.oasis.opendocument.image': { source: 'iana', extensions: ['odi'] },
    'application/vnd.oasis.opendocument.image-template': { source: 'iana', extensions: ['oti'] },
    'application/vnd.oasis.opendocument.presentation': { source: 'iana', compressible: !1, extensions: ['odp'] },
    'application/vnd.oasis.opendocument.presentation-template': { source: 'iana', extensions: ['otp'] },
    'application/vnd.oasis.opendocument.spreadsheet': { source: 'iana', compressible: !1, extensions: ['ods'] },
    'application/vnd.oasis.opendocument.spreadsheet-template': { source: 'iana', extensions: ['ots'] },
    'application/vnd.oasis.opendocument.text': { source: 'iana', compressible: !1, extensions: ['odt'] },
    'application/vnd.oasis.opendocument.text-master': { source: 'iana', extensions: ['odm'] },
    'application/vnd.oasis.opendocument.text-template': { source: 'iana', extensions: ['ott'] },
    'application/vnd.oasis.opendocument.text-web': { source: 'iana', extensions: ['oth'] },
    'application/vnd.obn': { source: 'iana' },
    'application/vnd.ocf+cbor': { source: 'iana' },
    'application/vnd.oci.image.manifest.v1+json': { source: 'iana', compressible: !0 },
    'application/vnd.oftn.l10n+json': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.contentaccessdownload+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.contentaccessstreaming+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.cspg-hexbinary': { source: 'iana' },
    'application/vnd.oipf.dae.svg+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.dae.xhtml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.mippvcontrolmessage+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.pae.gem': { source: 'iana' },
    'application/vnd.oipf.spdiscovery+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.spdlist+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.ueprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oipf.userprofile+xml': { source: 'iana', compressible: !0 },
    'application/vnd.olpc-sugar': { source: 'iana', extensions: ['xo'] },
    'application/vnd.oma-scws-config': { source: 'iana' },
    'application/vnd.oma-scws-http-request': { source: 'iana' },
    'application/vnd.oma-scws-http-response': { source: 'iana' },
    'application/vnd.oma.bcast.associated-procedure-parameter+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.drm-trigger+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.imd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.ltkm': { source: 'iana' },
    'application/vnd.oma.bcast.notification+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.provisioningtrigger': { source: 'iana' },
    'application/vnd.oma.bcast.sgboot': { source: 'iana' },
    'application/vnd.oma.bcast.sgdd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.sgdu': { source: 'iana' },
    'application/vnd.oma.bcast.simple-symbol-container': { source: 'iana' },
    'application/vnd.oma.bcast.smartcard-trigger+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.sprov+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.bcast.stkm': { source: 'iana' },
    'application/vnd.oma.cab-address-book+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-feature-handler+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-pcc+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-subs-invite+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.cab-user-prefs+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.dcd': { source: 'iana' },
    'application/vnd.oma.dcdc': { source: 'iana' },
    'application/vnd.oma.dd2+xml': { source: 'iana', compressible: !0, extensions: ['dd2'] },
    'application/vnd.oma.drm.risd+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.group-usage-list+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.lwm2m+cbor': { source: 'iana' },
    'application/vnd.oma.lwm2m+json': { source: 'iana', compressible: !0 },
    'application/vnd.oma.lwm2m+tlv': { source: 'iana' },
    'application/vnd.oma.pal+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.detailed-progress-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.final-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.groups+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.invocation-descriptor+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.poc.optimized-progress-report+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.push': { source: 'iana' },
    'application/vnd.oma.scidm.messages+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oma.xcap-directory+xml': { source: 'iana', compressible: !0 },
    'application/vnd.omads-email+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omads-file+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omads-folder+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.omaloc-supl-init': { source: 'iana' },
    'application/vnd.onepager': { source: 'iana' },
    'application/vnd.onepagertamp': { source: 'iana' },
    'application/vnd.onepagertamx': { source: 'iana' },
    'application/vnd.onepagertat': { source: 'iana' },
    'application/vnd.onepagertatp': { source: 'iana' },
    'application/vnd.onepagertatx': { source: 'iana' },
    'application/vnd.openblox.game+xml': { source: 'iana', compressible: !0, extensions: ['obgx'] },
    'application/vnd.openblox.game-binary': { source: 'iana' },
    'application/vnd.openeye.oeb': { source: 'iana' },
    'application/vnd.openofficeorg.extension': { source: 'apache', extensions: ['oxt'] },
    'application/vnd.openstreetmap.data+xml': { source: 'iana', compressible: !0, extensions: ['osm'] },
    'application/vnd.opentimestamps.ots': { source: 'iana' },
    'application/vnd.openxmlformats-officedocument.custom-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawing+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.extended-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
      source: 'iana',
      compressible: !1,
      extensions: ['pptx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.slide': { source: 'iana', extensions: ['sldx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': { source: 'iana', extensions: ['ppsx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.presentationml.template': { source: 'iana', extensions: ['potx'] },
    'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
      source: 'iana',
      compressible: !1,
      extensions: ['xlsx'],
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': { source: 'iana', extensions: ['xltx'] },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.theme+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.themeoverride+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.vmldrawing': { source: 'iana' },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
      source: 'iana',
      compressible: !1,
      extensions: ['docx'],
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': { source: 'iana', extensions: ['dotx'] },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
      source: 'iana',
      compressible: !0,
    },
    'application/vnd.openxmlformats-package.core-properties+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': { source: 'iana', compressible: !0 },
    'application/vnd.openxmlformats-package.relationships+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oracle.resource+json': { source: 'iana', compressible: !0 },
    'application/vnd.orange.indata': { source: 'iana' },
    'application/vnd.osa.netdeploy': { source: 'iana' },
    'application/vnd.osgeo.mapguide.package': { source: 'iana', extensions: ['mgp'] },
    'application/vnd.osgi.bundle': { source: 'iana' },
    'application/vnd.osgi.dp': { source: 'iana', extensions: ['dp'] },
    'application/vnd.osgi.subsystem': { source: 'iana', extensions: ['esa'] },
    'application/vnd.otps.ct-kip+xml': { source: 'iana', compressible: !0 },
    'application/vnd.oxli.countgraph': { source: 'iana' },
    'application/vnd.pagerduty+json': { source: 'iana', compressible: !0 },
    'application/vnd.palm': { source: 'iana', extensions: ['pdb', 'pqa', 'oprc'] },
    'application/vnd.panoply': { source: 'iana' },
    'application/vnd.paos.xml': { source: 'iana' },
    'application/vnd.patentdive': { source: 'iana' },
    'application/vnd.patientecommsdoc': { source: 'iana' },
    'application/vnd.pawaafile': { source: 'iana', extensions: ['paw'] },
    'application/vnd.pcos': { source: 'iana' },
    'application/vnd.pg.format': { source: 'iana', extensions: ['str'] },
    'application/vnd.pg.osasli': { source: 'iana', extensions: ['ei6'] },
    'application/vnd.piaccess.application-licence': { source: 'iana' },
    'application/vnd.picsel': { source: 'iana', extensions: ['efif'] },
    'application/vnd.pmi.widget': { source: 'iana', extensions: ['wg'] },
    'application/vnd.poc.group-advertisement+xml': { source: 'iana', compressible: !0 },
    'application/vnd.pocketlearn': { source: 'iana', extensions: ['plf'] },
    'application/vnd.powerbuilder6': { source: 'iana', extensions: ['pbd'] },
    'application/vnd.powerbuilder6-s': { source: 'iana' },
    'application/vnd.powerbuilder7': { source: 'iana' },
    'application/vnd.powerbuilder7-s': { source: 'iana' },
    'application/vnd.powerbuilder75': { source: 'iana' },
    'application/vnd.powerbuilder75-s': { source: 'iana' },
    'application/vnd.preminet': { source: 'iana' },
    'application/vnd.previewsystems.box': { source: 'iana', extensions: ['box'] },
    'application/vnd.proteus.magazine': { source: 'iana', extensions: ['mgz'] },
    'application/vnd.psfs': { source: 'iana' },
    'application/vnd.publishare-delta-tree': { source: 'iana', extensions: ['qps'] },
    'application/vnd.pvi.ptid1': { source: 'iana', extensions: ['ptid'] },
    'application/vnd.pwg-multiplexed': { source: 'iana' },
    'application/vnd.pwg-xhtml-print+xml': { source: 'iana', compressible: !0 },
    'application/vnd.qualcomm.brew-app-res': { source: 'iana' },
    'application/vnd.quarantainenet': { source: 'iana' },
    'application/vnd.quark.quarkxpress': { source: 'iana', extensions: ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'] },
    'application/vnd.quobject-quoxdocument': { source: 'iana' },
    'application/vnd.radisys.moml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-conf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-conn+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-dialog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-audit-stream+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-conf+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-base+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-fax-detect+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-group+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-speech+xml': { source: 'iana', compressible: !0 },
    'application/vnd.radisys.msml-dialog-transform+xml': { source: 'iana', compressible: !0 },
    'application/vnd.rainstor.data': { source: 'iana' },
    'application/vnd.rapid': { source: 'iana' },
    'application/vnd.rar': { source: 'iana', extensions: ['rar'] },
    'application/vnd.realvnc.bed': { source: 'iana', extensions: ['bed'] },
    'application/vnd.recordare.musicxml': { source: 'iana', extensions: ['mxl'] },
    'application/vnd.recordare.musicxml+xml': { source: 'iana', compressible: !0, extensions: ['musicxml'] },
    'application/vnd.renlearn.rlprint': { source: 'iana' },
    'application/vnd.resilient.logic': { source: 'iana' },
    'application/vnd.restful+json': { source: 'iana', compressible: !0 },
    'application/vnd.rig.cryptonote': { source: 'iana', extensions: ['cryptonote'] },
    'application/vnd.rim.cod': { source: 'apache', extensions: ['cod'] },
    'application/vnd.rn-realmedia': { source: 'apache', extensions: ['rm'] },
    'application/vnd.rn-realmedia-vbr': { source: 'apache', extensions: ['rmvb'] },
    'application/vnd.route66.link66+xml': { source: 'iana', compressible: !0, extensions: ['link66'] },
    'application/vnd.rs-274x': { source: 'iana' },
    'application/vnd.ruckus.download': { source: 'iana' },
    'application/vnd.s3sms': { source: 'iana' },
    'application/vnd.sailingtracker.track': { source: 'iana', extensions: ['st'] },
    'application/vnd.sar': { source: 'iana' },
    'application/vnd.sbm.cid': { source: 'iana' },
    'application/vnd.sbm.mid2': { source: 'iana' },
    'application/vnd.scribus': { source: 'iana' },
    'application/vnd.sealed.3df': { source: 'iana' },
    'application/vnd.sealed.csf': { source: 'iana' },
    'application/vnd.sealed.doc': { source: 'iana' },
    'application/vnd.sealed.eml': { source: 'iana' },
    'application/vnd.sealed.mht': { source: 'iana' },
    'application/vnd.sealed.net': { source: 'iana' },
    'application/vnd.sealed.ppt': { source: 'iana' },
    'application/vnd.sealed.tiff': { source: 'iana' },
    'application/vnd.sealed.xls': { source: 'iana' },
    'application/vnd.sealedmedia.softseal.html': { source: 'iana' },
    'application/vnd.sealedmedia.softseal.pdf': { source: 'iana' },
    'application/vnd.seemail': { source: 'iana', extensions: ['see'] },
    'application/vnd.seis+json': { source: 'iana', compressible: !0 },
    'application/vnd.sema': { source: 'iana', extensions: ['sema'] },
    'application/vnd.semd': { source: 'iana', extensions: ['semd'] },
    'application/vnd.semf': { source: 'iana', extensions: ['semf'] },
    'application/vnd.shade-save-file': { source: 'iana' },
    'application/vnd.shana.informed.formdata': { source: 'iana', extensions: ['ifm'] },
    'application/vnd.shana.informed.formtemplate': { source: 'iana', extensions: ['itp'] },
    'application/vnd.shana.informed.interchange': { source: 'iana', extensions: ['iif'] },
    'application/vnd.shana.informed.package': { source: 'iana', extensions: ['ipk'] },
    'application/vnd.shootproof+json': { source: 'iana', compressible: !0 },
    'application/vnd.shopkick+json': { source: 'iana', compressible: !0 },
    'application/vnd.shp': { source: 'iana' },
    'application/vnd.shx': { source: 'iana' },
    'application/vnd.sigrok.session': { source: 'iana' },
    'application/vnd.simtech-mindmapper': { source: 'iana', extensions: ['twd', 'twds'] },
    'application/vnd.siren+json': { source: 'iana', compressible: !0 },
    'application/vnd.smaf': { source: 'iana', extensions: ['mmf'] },
    'application/vnd.smart.notebook': { source: 'iana' },
    'application/vnd.smart.teacher': { source: 'iana', extensions: ['teacher'] },
    'application/vnd.snesdev-page-table': { source: 'iana' },
    'application/vnd.software602.filler.form+xml': { source: 'iana', compressible: !0, extensions: ['fo'] },
    'application/vnd.software602.filler.form-xml-zip': { source: 'iana' },
    'application/vnd.solent.sdkm+xml': { source: 'iana', compressible: !0, extensions: ['sdkm', 'sdkd'] },
    'application/vnd.spotfire.dxp': { source: 'iana', extensions: ['dxp'] },
    'application/vnd.spotfire.sfs': { source: 'iana', extensions: ['sfs'] },
    'application/vnd.sqlite3': { source: 'iana' },
    'application/vnd.sss-cod': { source: 'iana' },
    'application/vnd.sss-dtf': { source: 'iana' },
    'application/vnd.sss-ntf': { source: 'iana' },
    'application/vnd.stardivision.calc': { source: 'apache', extensions: ['sdc'] },
    'application/vnd.stardivision.draw': { source: 'apache', extensions: ['sda'] },
    'application/vnd.stardivision.impress': { source: 'apache', extensions: ['sdd'] },
    'application/vnd.stardivision.math': { source: 'apache', extensions: ['smf'] },
    'application/vnd.stardivision.writer': { source: 'apache', extensions: ['sdw', 'vor'] },
    'application/vnd.stardivision.writer-global': { source: 'apache', extensions: ['sgl'] },
    'application/vnd.stepmania.package': { source: 'iana', extensions: ['smzip'] },
    'application/vnd.stepmania.stepchart': { source: 'iana', extensions: ['sm'] },
    'application/vnd.street-stream': { source: 'iana' },
    'application/vnd.sun.wadl+xml': { source: 'iana', compressible: !0, extensions: ['wadl'] },
    'application/vnd.sun.xml.calc': { source: 'apache', extensions: ['sxc'] },
    'application/vnd.sun.xml.calc.template': { source: 'apache', extensions: ['stc'] },
    'application/vnd.sun.xml.draw': { source: 'apache', extensions: ['sxd'] },
    'application/vnd.sun.xml.draw.template': { source: 'apache', extensions: ['std'] },
    'application/vnd.sun.xml.impress': { source: 'apache', extensions: ['sxi'] },
    'application/vnd.sun.xml.impress.template': { source: 'apache', extensions: ['sti'] },
    'application/vnd.sun.xml.math': { source: 'apache', extensions: ['sxm'] },
    'application/vnd.sun.xml.writer': { source: 'apache', extensions: ['sxw'] },
    'application/vnd.sun.xml.writer.global': { source: 'apache', extensions: ['sxg'] },
    'application/vnd.sun.xml.writer.template': { source: 'apache', extensions: ['stw'] },
    'application/vnd.sus-calendar': { source: 'iana', extensions: ['sus', 'susp'] },
    'application/vnd.svd': { source: 'iana', extensions: ['svd'] },
    'application/vnd.swiftview-ics': { source: 'iana' },
    'application/vnd.sycle+xml': { source: 'iana', compressible: !0 },
    'application/vnd.syft+json': { source: 'iana', compressible: !0 },
    'application/vnd.symbian.install': { source: 'apache', extensions: ['sis', 'sisx'] },
    'application/vnd.syncml+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['xsm'] },
    'application/vnd.syncml.dm+wbxml': { source: 'iana', charset: 'UTF-8', extensions: ['bdm'] },
    'application/vnd.syncml.dm+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['xdm'] },
    'application/vnd.syncml.dm.notification': { source: 'iana' },
    'application/vnd.syncml.dmddf+wbxml': { source: 'iana' },
    'application/vnd.syncml.dmddf+xml': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['ddf'] },
    'application/vnd.syncml.dmtnds+wbxml': { source: 'iana' },
    'application/vnd.syncml.dmtnds+xml': { source: 'iana', charset: 'UTF-8', compressible: !0 },
    'application/vnd.syncml.ds.notification': { source: 'iana' },
    'application/vnd.tableschema+json': { source: 'iana', compressible: !0 },
    'application/vnd.tao.intent-module-archive': { source: 'iana', extensions: ['tao'] },
    'application/vnd.tcpdump.pcap': { source: 'iana', extensions: ['pcap', 'cap', 'dmp'] },
    'application/vnd.think-cell.ppttc+json': { source: 'iana', compressible: !0 },
    'application/vnd.tmd.mediaflex.api+xml': { source: 'iana', compressible: !0 },
    'application/vnd.tml': { source: 'iana' },
    'application/vnd.tmobile-livetv': { source: 'iana', extensions: ['tmo'] },
    'application/vnd.tri.onesource': { source: 'iana' },
    'application/vnd.trid.tpt': { source: 'iana', extensions: ['tpt'] },
    'application/vnd.triscape.mxs': { source: 'iana', extensions: ['mxs'] },
    'application/vnd.trueapp': { source: 'iana', extensions: ['tra'] },
    'application/vnd.truedoc': { source: 'iana' },
    'application/vnd.ubisoft.webplayer': { source: 'iana' },
    'application/vnd.ufdl': { source: 'iana', extensions: ['ufd', 'ufdl'] },
    'application/vnd.uiq.theme': { source: 'iana', extensions: ['utz'] },
    'application/vnd.umajin': { source: 'iana', extensions: ['umj'] },
    'application/vnd.unity': { source: 'iana', extensions: ['unityweb'] },
    'application/vnd.uoml+xml': { source: 'iana', compressible: !0, extensions: ['uoml'] },
    'application/vnd.uplanet.alert': { source: 'iana' },
    'application/vnd.uplanet.alert-wbxml': { source: 'iana' },
    'application/vnd.uplanet.bearer-choice': { source: 'iana' },
    'application/vnd.uplanet.bearer-choice-wbxml': { source: 'iana' },
    'application/vnd.uplanet.cacheop': { source: 'iana' },
    'application/vnd.uplanet.cacheop-wbxml': { source: 'iana' },
    'application/vnd.uplanet.channel': { source: 'iana' },
    'application/vnd.uplanet.channel-wbxml': { source: 'iana' },
    'application/vnd.uplanet.list': { source: 'iana' },
    'application/vnd.uplanet.list-wbxml': { source: 'iana' },
    'application/vnd.uplanet.listcmd': { source: 'iana' },
    'application/vnd.uplanet.listcmd-wbxml': { source: 'iana' },
    'application/vnd.uplanet.signal': { source: 'iana' },
    'application/vnd.uri-map': { source: 'iana' },
    'application/vnd.valve.source.material': { source: 'iana' },
    'application/vnd.vcx': { source: 'iana', extensions: ['vcx'] },
    'application/vnd.vd-study': { source: 'iana' },
    'application/vnd.vectorworks': { source: 'iana' },
    'application/vnd.vel+json': { source: 'iana', compressible: !0 },
    'application/vnd.verimatrix.vcas': { source: 'iana' },
    'application/vnd.veritone.aion+json': { source: 'iana', compressible: !0 },
    'application/vnd.veryant.thin': { source: 'iana' },
    'application/vnd.ves.encrypted': { source: 'iana' },
    'application/vnd.vidsoft.vidconference': { source: 'iana' },
    'application/vnd.visio': { source: 'iana', extensions: ['vsd', 'vst', 'vss', 'vsw'] },
    'application/vnd.visionary': { source: 'iana', extensions: ['vis'] },
    'application/vnd.vividence.scriptfile': { source: 'iana' },
    'application/vnd.vsf': { source: 'iana', extensions: ['vsf'] },
    'application/vnd.wap.sic': { source: 'iana' },
    'application/vnd.wap.slc': { source: 'iana' },
    'application/vnd.wap.wbxml': { source: 'iana', charset: 'UTF-8', extensions: ['wbxml'] },
    'application/vnd.wap.wmlc': { source: 'iana', extensions: ['wmlc'] },
    'application/vnd.wap.wmlscriptc': { source: 'iana', extensions: ['wmlsc'] },
    'application/vnd.webturbo': { source: 'iana', extensions: ['wtb'] },
    'application/vnd.wfa.dpp': { source: 'iana' },
    'application/vnd.wfa.p2p': { source: 'iana' },
    'application/vnd.wfa.wsc': { source: 'iana' },
    'application/vnd.windows.devicepairing': { source: 'iana' },
    'application/vnd.wmc': { source: 'iana' },
    'application/vnd.wmf.bootstrap': { source: 'iana' },
    'application/vnd.wolfram.mathematica': { source: 'iana' },
    'application/vnd.wolfram.mathematica.package': { source: 'iana' },
    'application/vnd.wolfram.player': { source: 'iana', extensions: ['nbp'] },
    'application/vnd.wordperfect': { source: 'iana', extensions: ['wpd'] },
    'application/vnd.wqd': { source: 'iana', extensions: ['wqd'] },
    'application/vnd.wrq-hp3000-labelled': { source: 'iana' },
    'application/vnd.Uri.stf': { source: 'iana', extensions: ['stf'] },
    'application/vnd.wv.csp+wbxml': { source: 'iana' },
    'application/vnd.wv.csp+xml': { source: 'iana', compressible: !0 },
    'application/vnd.wv.ssp+xml': { source: 'iana', compressible: !0 },
    'application/vnd.xacml+json': { source: 'iana', compressible: !0 },
    'application/vnd.xara': { source: 'iana', extensions: ['xar'] },
    'application/vnd.xfdl': { source: 'iana', extensions: ['xfdl'] },
    'application/vnd.xfdl.webform': { source: 'iana' },
    'application/vnd.xmi+xml': { source: 'iana', compressible: !0 },
    'application/vnd.xmpie.cpkg': { source: 'iana' },
    'application/vnd.xmpie.dpkg': { source: 'iana' },
    'application/vnd.xmpie.plan': { source: 'iana' },
    'application/vnd.xmpie.ppkg': { source: 'iana' },
    'application/vnd.xmpie.xlim': { source: 'iana' },
    'application/vnd.yamaha.hv-dic': { source: 'iana', extensions: ['hvd'] },
    'application/vnd.yamaha.hv-script': { source: 'iana', extensions: ['hvs'] },
    'application/vnd.yamaha.hv-voice': { source: 'iana', extensions: ['hvp'] },
    'application/vnd.yamaha.openscoreformat': { source: 'iana', extensions: ['osf'] },
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': { source: 'iana', compressible: !0, extensions: ['osfpvg'] },
    'application/vnd.yamaha.remote-setup': { source: 'iana' },
    'application/vnd.yamaha.smaf-audio': { source: 'iana', extensions: ['saf'] },
    'application/vnd.yamaha.smaf-phrase': { source: 'iana', extensions: ['spf'] },
    'application/vnd.yamaha.through-ngn': { source: 'iana' },
    'application/vnd.yamaha.tunnel-udpencap': { source: 'iana' },
    'application/vnd.yaoweme': { source: 'iana' },
    'application/vnd.yellowriver-custom-menu': { source: 'iana', extensions: ['cmp'] },
    'application/vnd.youtube.yt': { source: 'iana' },
    'application/vnd.zul': { source: 'iana', extensions: ['zir', 'zirz'] },
    'application/vnd.zzazz.deck+xml': { source: 'iana', compressible: !0, extensions: ['zaz'] },
    'application/voicexml+xml': { source: 'iana', compressible: !0, extensions: ['vxml'] },
    'application/voucher-cms+json': { source: 'iana', compressible: !0 },
    'application/vq-rtcpxr': { source: 'iana' },
    'application/wasm': { source: 'iana', compressible: !0, extensions: ['wasm'] },
    'application/watcherinfo+xml': { source: 'iana', compressible: !0, extensions: ['wif'] },
    'application/webpush-options+json': { source: 'iana', compressible: !0 },
    'application/whoispp-query': { source: 'iana' },
    'application/whoispp-response': { source: 'iana' },
    'application/widget': { source: 'iana', extensions: ['wgt'] },
    'application/winhlp': { source: 'apache', extensions: ['hlp'] },
    'application/wita': { source: 'iana' },
    'application/wordperfect5.1': { source: 'iana' },
    'application/wsdl+xml': { source: 'iana', compressible: !0, extensions: ['wsdl'] },
    'application/wspolicy+xml': { source: 'iana', compressible: !0, extensions: ['wspolicy'] },
    'application/x-7z-compressed': { source: 'apache', compressible: !1, extensions: ['7z'] },
    'application/x-abiword': { source: 'apache', extensions: ['abw'] },
    'application/x-ace-compressed': { source: 'apache', extensions: ['ace'] },
    'application/x-amf': { source: 'apache' },
    'application/x-apple-diskimage': { source: 'apache', extensions: ['dmg'] },
    'application/x-arj': { compressible: !1, extensions: ['arj'] },
    'application/x-authorware-bin': { source: 'apache', extensions: ['aab', 'x32', 'u32', 'vox'] },
    'application/x-authorware-map': { source: 'apache', extensions: ['aam'] },
    'application/x-authorware-seg': { source: 'apache', extensions: ['aas'] },
    'application/x-bcpio': { source: 'apache', extensions: ['bcpio'] },
    'application/x-bdoc': { compressible: !1, extensions: ['bdoc'] },
    'application/x-bittorrent': { source: 'apache', extensions: ['torrent'] },
    'application/x-blorb': { source: 'apache', extensions: ['blb', 'blorb'] },
    'application/x-bzip': { source: 'apache', compressible: !1, extensions: ['bz'] },
    'application/x-bzip2': { source: 'apache', compressible: !1, extensions: ['bz2', 'boz'] },
    'application/x-cbr': { source: 'apache', extensions: ['cbr', 'cba', 'cbt', 'cbz', 'cb7'] },
    'application/x-cdlink': { source: 'apache', extensions: ['vcd'] },
    'application/x-cfs-compressed': { source: 'apache', extensions: ['cfs'] },
    'application/x-chat': { source: 'apache', extensions: ['chat'] },
    'application/x-chess-pgn': { source: 'apache', extensions: ['pgn'] },
    'application/x-chrome-extension': { extensions: ['crx'] },
    'application/x-cocoa': { source: 'nginx', extensions: ['cco'] },
    'application/x-compress': { source: 'apache' },
    'application/x-conference': { source: 'apache', extensions: ['nsc'] },
    'application/x-cpio': { source: 'apache', extensions: ['cpio'] },
    'application/x-csh': { source: 'apache', extensions: ['csh'] },
    'application/x-deb': { compressible: !1 },
    'application/x-debian-package': { source: 'apache', extensions: ['deb', 'udeb'] },
    'application/x-dgc-compressed': { source: 'apache', extensions: ['dgc'] },
    'application/x-director': {
      source: 'apache',
      extensions: ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa'],
    },
    'application/x-doom': { source: 'apache', extensions: ['wad'] },
    'application/x-dtbncx+xml': { source: 'apache', compressible: !0, extensions: ['ncx'] },
    'application/x-dtbook+xml': { source: 'apache', compressible: !0, extensions: ['dtb'] },
    'application/x-dtbresource+xml': { source: 'apache', compressible: !0, extensions: ['res'] },
    'application/x-dvi': { source: 'apache', compressible: !1, extensions: ['dvi'] },
    'application/x-envoy': { source: 'apache', extensions: ['evy'] },
    'application/x-eva': { source: 'apache', extensions: ['eva'] },
    'application/x-font-bdf': { source: 'apache', extensions: ['bdf'] },
    'application/x-font-dos': { source: 'apache' },
    'application/x-font-framemaker': { source: 'apache' },
    'application/x-font-ghostscript': { source: 'apache', extensions: ['gsf'] },
    'application/x-font-libgrx': { source: 'apache' },
    'application/x-font-linux-psf': { source: 'apache', extensions: ['psf'] },
    'application/x-font-pcf': { source: 'apache', extensions: ['pcf'] },
    'application/x-font-snf': { source: 'apache', extensions: ['snf'] },
    'application/x-font-speedo': { source: 'apache' },
    'application/x-font-sunos-news': { source: 'apache' },
    'application/x-font-type1': { source: 'apache', extensions: ['pfa', 'pfb', 'pfm', 'afm'] },
    'application/x-font-vfont': { source: 'apache' },
    'application/x-freearc': { source: 'apache', extensions: ['arc'] },
    'application/x-futuresplash': { source: 'apache', extensions: ['spl'] },
    'application/x-gca-compressed': { source: 'apache', extensions: ['gca'] },
    'application/x-glulx': { source: 'apache', extensions: ['ulx'] },
    'application/x-gnumeric': { source: 'apache', extensions: ['gnumeric'] },
    'application/x-gramps-xml': { source: 'apache', extensions: ['gramps'] },
    'application/x-gtar': { source: 'apache', extensions: ['gtar'] },
    'application/x-gzip': { source: 'apache' },
    'application/x-hdf': { source: 'apache', extensions: ['hdf'] },
    'application/x-httpd-php': { compressible: !0, extensions: ['php'] },
    'application/x-install-instructions': { source: 'apache', extensions: ['install'] },
    'application/x-iso9660-image': { source: 'apache', extensions: ['iso'] },
    'application/x-iwork-keynote-sffkey': { extensions: ['key'] },
    'application/x-iwork-numbers-sffnumbers': { extensions: ['numbers'] },
    'application/x-iwork-pages-sffpages': { extensions: ['pages'] },
    'application/x-java-archive-diff': { source: 'nginx', extensions: ['jardiff'] },
    'application/x-java-jnlp-file': { source: 'apache', compressible: !1, extensions: ['jnlp'] },
    'application/x-javascript': { compressible: !0 },
    'application/x-keepass2': { extensions: ['kdbx'] },
    'application/x-latex': { source: 'apache', compressible: !1, extensions: ['latex'] },
    'application/x-lua-bytecode': { extensions: ['luac'] },
    'application/x-lzh-compressed': { source: 'apache', extensions: ['lzh', 'lha'] },
    'application/x-makeself': { source: 'nginx', extensions: ['run'] },
    'application/x-mie': { source: 'apache', extensions: ['mie'] },
    'application/x-mobipocket-ebook': { source: 'apache', extensions: ['prc', 'mobi'] },
    'application/x-mpegurl': { compressible: !1 },
    'application/x-ms-application': { source: 'apache', extensions: ['application'] },
    'application/x-ms-shortcut': { source: 'apache', extensions: ['lnk'] },
    'application/x-ms-wmd': { source: 'apache', extensions: ['wmd'] },
    'application/x-ms-wmz': { source: 'apache', extensions: ['wmz'] },
    'application/x-ms-xbap': { source: 'apache', extensions: ['xbap'] },
    'application/x-msaccess': { source: 'apache', extensions: ['mdb'] },
    'application/x-msbinder': { source: 'apache', extensions: ['obd'] },
    'application/x-mscardfile': { source: 'apache', extensions: ['crd'] },
    'application/x-msclip': { source: 'apache', extensions: ['clp'] },
    'application/x-msdos-program': { extensions: ['exe'] },
    'application/x-msdownload': { source: 'apache', extensions: ['exe', 'dll', 'com', 'bat', 'msi'] },
    'application/x-msmediaview': { source: 'apache', extensions: ['mvb', 'm13', 'm14'] },
    'application/x-msmetafile': { source: 'apache', extensions: ['wmf', 'wmz', 'emf', 'emz'] },
    'application/x-msmoney': { source: 'apache', extensions: ['mny'] },
    'application/x-mspublisher': { source: 'apache', extensions: ['pub'] },
    'application/x-msschedule': { source: 'apache', extensions: ['scd'] },
    'application/x-msterminal': { source: 'apache', extensions: ['trm'] },
    'application/x-mswrite': { source: 'apache', extensions: ['wri'] },
    'application/x-netcdf': { source: 'apache', extensions: ['nc', 'cdf'] },
    'application/x-ns-proxy-autoconfig': { compressible: !0, extensions: ['pac'] },
    'application/x-nzb': { source: 'apache', extensions: ['nzb'] },
    'application/x-perl': { source: 'nginx', extensions: ['pl', 'pm'] },
    'application/x-pilot': { source: 'nginx', extensions: ['prc', 'pdb'] },
    'application/x-pkcs12': { source: 'apache', compressible: !1, extensions: ['p12', 'pfx'] },
    'application/x-pkcs7-certificates': { source: 'apache', extensions: ['p7b', 'spc'] },
    'application/x-pkcs7-certreqresp': { source: 'apache', extensions: ['p7r'] },
    'application/x-pki-message': { source: 'iana' },
    'application/x-rar-compressed': { source: 'apache', compressible: !1, extensions: ['rar'] },
    'application/x-redhat-package-manager': { source: 'nginx', extensions: ['rpm'] },
    'application/x-research-info-systems': { source: 'apache', extensions: ['ris'] },
    'application/x-sea': { source: 'nginx', extensions: ['sea'] },
    'application/x-sh': { source: 'apache', compressible: !0, extensions: ['sh'] },
    'application/x-shar': { source: 'apache', extensions: ['shar'] },
    'application/x-shockwave-flash': { source: 'apache', compressible: !1, extensions: ['swf'] },
    'application/x-silverlight-app': { source: 'apache', extensions: ['xap'] },
    'application/x-sql': { source: 'apache', extensions: ['sql'] },
    'application/x-stuffit': { source: 'apache', compressible: !1, extensions: ['sit'] },
    'application/x-stuffitx': { source: 'apache', extensions: ['sitx'] },
    'application/x-subrip': { source: 'apache', extensions: ['srt'] },
    'application/x-sv4cpio': { source: 'apache', extensions: ['sv4cpio'] },
    'application/x-sv4crc': { source: 'apache', extensions: ['sv4crc'] },
    'application/x-t3vm-image': { source: 'apache', extensions: ['t3'] },
    'application/x-tads': { source: 'apache', extensions: ['gam'] },
    'application/x-tar': { source: 'apache', compressible: !0, extensions: ['tar'] },
    'application/x-tcl': { source: 'apache', extensions: ['tcl', 'tk'] },
    'application/x-tex': { source: 'apache', extensions: ['tex'] },
    'application/x-tex-tfm': { source: 'apache', extensions: ['tfm'] },
    'application/x-texinfo': { source: 'apache', extensions: ['texinfo', 'texi'] },
    'application/x-tgif': { source: 'apache', extensions: ['obj'] },
    'application/x-ustar': { source: 'apache', extensions: ['ustar'] },
    'application/x-virtualbox-hdd': { compressible: !0, extensions: ['hdd'] },
    'application/x-virtualbox-ova': { compressible: !0, extensions: ['ova'] },
    'application/x-virtualbox-ovf': { compressible: !0, extensions: ['ovf'] },
    'application/x-virtualbox-vbox': { compressible: !0, extensions: ['vbox'] },
    'application/x-virtualbox-vbox-extpack': { compressible: !1, extensions: ['vbox-extpack'] },
    'application/x-virtualbox-vdi': { compressible: !0, extensions: ['vdi'] },
    'application/x-virtualbox-vhd': { compressible: !0, extensions: ['vhd'] },
    'application/x-virtualbox-vmdk': { compressible: !0, extensions: ['vmdk'] },
    'application/x-wais-source': { source: 'apache', extensions: ['src'] },
    'application/x-web-app-manifest+json': { compressible: !0, extensions: ['webapp'] },
    'application/x-www-form-urlencoded': { source: 'iana', compressible: !0 },
    'application/x-x509-ca-cert': { source: 'iana', extensions: ['der', 'crt', 'pem'] },
    'application/x-x509-ca-ra-cert': { source: 'iana' },
    'application/x-x509-next-ca-cert': { source: 'iana' },
    'application/x-xfig': { source: 'apache', extensions: ['fig'] },
    'application/x-xliff+xml': { source: 'apache', compressible: !0, extensions: ['xlf'] },
    'application/x-xpinstall': { source: 'apache', compressible: !1, extensions: ['xpi'] },
    'application/x-xz': { source: 'apache', extensions: ['xz'] },
    'application/x-zmachine': { source: 'apache', extensions: ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'] },
    'application/x400-bp': { source: 'iana' },
    'application/xacml+xml': { source: 'iana', compressible: !0 },
    'application/xaml+xml': { source: 'apache', compressible: !0, extensions: ['xaml'] },
    'application/xcap-att+xml': { source: 'iana', compressible: !0, extensions: ['xav'] },
    'application/xcap-caps+xml': { source: 'iana', compressible: !0, extensions: ['xca'] },
    'application/xcap-diff+xml': { source: 'iana', compressible: !0, extensions: ['xdf'] },
    'application/xcap-el+xml': { source: 'iana', compressible: !0, extensions: ['xel'] },
    'application/xcap-error+xml': { source: 'iana', compressible: !0 },
    'application/xcap-ns+xml': { source: 'iana', compressible: !0, extensions: ['xns'] },
    'application/xcon-conference-info+xml': { source: 'iana', compressible: !0 },
    'application/xcon-conference-info-diff+xml': { source: 'iana', compressible: !0 },
    'application/xenc+xml': { source: 'iana', compressible: !0, extensions: ['xenc'] },
    'application/xhtml+xml': { source: 'iana', compressible: !0, extensions: ['xhtml', 'xht'] },
    'application/xhtml-voice+xml': { source: 'apache', compressible: !0 },
    'application/xliff+xml': { source: 'iana', compressible: !0, extensions: ['xlf'] },
    'application/xml': { source: 'iana', compressible: !0, extensions: ['xml', 'xsl', 'xsd', 'rng'] },
    'application/xml-dtd': { source: 'iana', compressible: !0, extensions: ['dtd'] },
    'application/xml-external-parsed-entity': { source: 'iana' },
    'application/xml-patch+xml': { source: 'iana', compressible: !0 },
    'application/xmpp+xml': { source: 'iana', compressible: !0 },
    'application/xop+xml': { source: 'iana', compressible: !0, extensions: ['xop'] },
    'application/xproc+xml': { source: 'apache', compressible: !0, extensions: ['xpl'] },
    'application/xslt+xml': { source: 'iana', compressible: !0, extensions: ['xsl', 'xslt'] },
    'application/xspf+xml': { source: 'apache', compressible: !0, extensions: ['xspf'] },
    'application/xv+xml': { source: 'iana', compressible: !0, extensions: ['mxml', 'xhvml', 'xvml', 'xvm'] },
    'application/yang': { source: 'iana', extensions: ['yang'] },
    'application/yang-data+json': { source: 'iana', compressible: !0 },
    'application/yang-data+xml': { source: 'iana', compressible: !0 },
    'application/yang-patch+json': { source: 'iana', compressible: !0 },
    'application/yang-patch+xml': { source: 'iana', compressible: !0 },
    'application/yin+xml': { source: 'iana', compressible: !0, extensions: ['yin'] },
    'application/zip': { source: 'iana', compressible: !1, extensions: ['zip'] },
    'application/zlib': { source: 'iana' },
    'application/zstd': { source: 'iana' },
    'audio/1d-interleaved-parityfec': { source: 'iana' },
    'audio/32kadpcm': { source: 'iana' },
    'audio/3gpp': { source: 'iana', compressible: !1, extensions: ['3gpp'] },
    'audio/3gpp2': { source: 'iana' },
    'audio/aac': { source: 'iana' },
    'audio/ac3': { source: 'iana' },
    'audio/adpcm': { source: 'apache', extensions: ['adp'] },
    'audio/amr': { source: 'iana', extensions: ['amr'] },
    'audio/amr-wb': { source: 'iana' },
    'audio/amr-wb+': { source: 'iana' },
    'audio/aptx': { source: 'iana' },
    'audio/asc': { source: 'iana' },
    'audio/atrac-advanced-lossless': { source: 'iana' },
    'audio/atrac-x': { source: 'iana' },
    'audio/atrac3': { source: 'iana' },
    'audio/basic': { source: 'iana', compressible: !1, extensions: ['au', 'snd'] },
    'audio/bv16': { source: 'iana' },
    'audio/bv32': { source: 'iana' },
    'audio/clearmode': { source: 'iana' },
    'audio/cn': { source: 'iana' },
    'audio/dat12': { source: 'iana' },
    'audio/dls': { source: 'iana' },
    'audio/dsr-es201108': { source: 'iana' },
    'audio/dsr-es202050': { source: 'iana' },
    'audio/dsr-es202211': { source: 'iana' },
    'audio/dsr-es202212': { source: 'iana' },
    'audio/dv': { source: 'iana' },
    'audio/dvi4': { source: 'iana' },
    'audio/eac3': { source: 'iana' },
    'audio/encaprtp': { source: 'iana' },
    'audio/evrc': { source: 'iana' },
    'audio/evrc-qcp': { source: 'iana' },
    'audio/evrc0': { source: 'iana' },
    'audio/evrc1': { source: 'iana' },
    'audio/evrcb': { source: 'iana' },
    'audio/evrcb0': { source: 'iana' },
    'audio/evrcb1': { source: 'iana' },
    'audio/evrcnw': { source: 'iana' },
    'audio/evrcnw0': { source: 'iana' },
    'audio/evrcnw1': { source: 'iana' },
    'audio/evrcwb': { source: 'iana' },
    'audio/evrcwb0': { source: 'iana' },
    'audio/evrcwb1': { source: 'iana' },
    'audio/evs': { source: 'iana' },
    'audio/flexfec': { source: 'iana' },
    'audio/fwdred': { source: 'iana' },
    'audio/g711-0': { source: 'iana' },
    'audio/g719': { source: 'iana' },
    'audio/g722': { source: 'iana' },
    'audio/g7221': { source: 'iana' },
    'audio/g723': { source: 'iana' },
    'audio/g726-16': { source: 'iana' },
    'audio/g726-24': { source: 'iana' },
    'audio/g726-32': { source: 'iana' },
    'audio/g726-40': { source: 'iana' },
    'audio/g728': { source: 'iana' },
    'audio/g729': { source: 'iana' },
    'audio/g7291': { source: 'iana' },
    'audio/g729d': { source: 'iana' },
    'audio/g729e': { source: 'iana' },
    'audio/gsm': { source: 'iana' },
    'audio/gsm-efr': { source: 'iana' },
    'audio/gsm-hr-08': { source: 'iana' },
    'audio/ilbc': { source: 'iana' },
    'audio/ip-mr_v2.5': { source: 'iana' },
    'audio/isac': { source: 'apache' },
    'audio/l16': { source: 'iana' },
    'audio/l20': { source: 'iana' },
    'audio/l24': { source: 'iana', compressible: !1 },
    'audio/l8': { source: 'iana' },
    'audio/lpc': { source: 'iana' },
    'audio/melp': { source: 'iana' },
    'audio/melp1200': { source: 'iana' },
    'audio/melp2400': { source: 'iana' },
    'audio/melp600': { source: 'iana' },
    'audio/mhas': { source: 'iana' },
    'audio/midi': { source: 'apache', extensions: ['mid', 'midi', 'kar', 'rmi'] },
    'audio/mobile-xmf': { source: 'iana', extensions: ['mxmf'] },
    'audio/mp3': { compressible: !1, extensions: ['mp3'] },
    'audio/mp4': { source: 'iana', compressible: !1, extensions: ['m4a', 'mp4a'] },
    'audio/mp4a-latm': { source: 'iana' },
    'audio/mpa': { source: 'iana' },
    'audio/mpa-robust': { source: 'iana' },
    'audio/mpeg': { source: 'iana', compressible: !1, extensions: ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'] },
    'audio/mpeg4-generic': { source: 'iana' },
    'audio/musepack': { source: 'apache' },
    'audio/ogg': { source: 'iana', compressible: !1, extensions: ['oga', 'ogg', 'spx', 'opus'] },
    'audio/opus': { source: 'iana' },
    'audio/parityfec': { source: 'iana' },
    'audio/pcma': { source: 'iana' },
    'audio/pcma-wb': { source: 'iana' },
    'audio/pcmu': { source: 'iana' },
    'audio/pcmu-wb': { source: 'iana' },
    'audio/prs.sid': { source: 'iana' },
    'audio/qcelp': { source: 'iana' },
    'audio/raptorfec': { source: 'iana' },
    'audio/red': { source: 'iana' },
    'audio/rtp-enc-aescm128': { source: 'iana' },
    'audio/rtp-midi': { source: 'iana' },
    'audio/rtploopback': { source: 'iana' },
    'audio/rtx': { source: 'iana' },
    'audio/s3m': { source: 'apache', extensions: ['s3m'] },
    'audio/scip': { source: 'iana' },
    'audio/silk': { source: 'apache', extensions: ['sil'] },
    'audio/smv': { source: 'iana' },
    'audio/smv-qcp': { source: 'iana' },
    'audio/smv0': { source: 'iana' },
    'audio/sofa': { source: 'iana' },
    'audio/sp-midi': { source: 'iana' },
    'audio/speex': { source: 'iana' },
    'audio/t140c': { source: 'iana' },
    'audio/t38': { source: 'iana' },
    'audio/telephone-event': { source: 'iana' },
    'audio/tetra_acelp': { source: 'iana' },
    'audio/tetra_acelp_bb': { source: 'iana' },
    'audio/tone': { source: 'iana' },
    'audio/tsvcis': { source: 'iana' },
    'audio/uemclip': { source: 'iana' },
    'audio/ulpfec': { source: 'iana' },
    'audio/usac': { source: 'iana' },
    'audio/vdvi': { source: 'iana' },
    'audio/vmr-wb': { source: 'iana' },
    'audio/vnd.3gpp.iufp': { source: 'iana' },
    'audio/vnd.4sb': { source: 'iana' },
    'audio/vnd.audiokoz': { source: 'iana' },
    'audio/vnd.celp': { source: 'iana' },
    'audio/vnd.cisco.nse': { source: 'iana' },
    'audio/vnd.cmles.radio-events': { source: 'iana' },
    'audio/vnd.cns.anp1': { source: 'iana' },
    'audio/vnd.cns.inf1': { source: 'iana' },
    'audio/vnd.dece.audio': { source: 'iana', extensions: ['uva', 'uvva'] },
    'audio/vnd.digital-winds': { source: 'iana', extensions: ['eol'] },
    'audio/vnd.dlna.adts': { source: 'iana' },
    'audio/vnd.dolby.heaac.1': { source: 'iana' },
    'audio/vnd.dolby.heaac.2': { source: 'iana' },
    'audio/vnd.dolby.mlp': { source: 'iana' },
    'audio/vnd.dolby.mps': { source: 'iana' },
    'audio/vnd.dolby.pl2': { source: 'iana' },
    'audio/vnd.dolby.pl2x': { source: 'iana' },
    'audio/vnd.dolby.pl2z': { source: 'iana' },
    'audio/vnd.dolby.pulse.1': { source: 'iana' },
    'audio/vnd.dra': { source: 'iana', extensions: ['dra'] },
    'audio/vnd.dts': { source: 'iana', extensions: ['dts'] },
    'audio/vnd.dts.hd': { source: 'iana', extensions: ['dtshd'] },
    'audio/vnd.dts.uhd': { source: 'iana' },
    'audio/vnd.dvb.file': { source: 'iana' },
    'audio/vnd.everad.plj': { source: 'iana' },
    'audio/vnd.hns.audio': { source: 'iana' },
    'audio/vnd.lucent.voice': { source: 'iana', extensions: ['lvp'] },
    'audio/vnd.ms-playready.media.pya': { source: 'iana', extensions: ['pya'] },
    'audio/vnd.nokia.mobile-xmf': { source: 'iana' },
    'audio/vnd.nortel.vbk': { source: 'iana' },
    'audio/vnd.nuera.ecelp4800': { source: 'iana', extensions: ['ecelp4800'] },
    'audio/vnd.nuera.ecelp7470': { source: 'iana', extensions: ['ecelp7470'] },
    'audio/vnd.nuera.ecelp9600': { source: 'iana', extensions: ['ecelp9600'] },
    'audio/vnd.octel.sbc': { source: 'iana' },
    'audio/vnd.presonus.multitrack': { source: 'iana' },
    'audio/vnd.qcelp': { source: 'iana' },
    'audio/vnd.rhetorex.32kadpcm': { source: 'iana' },
    'audio/vnd.rip': { source: 'iana', extensions: ['rip'] },
    'audio/vnd.rn-realaudio': { compressible: !1 },
    'audio/vnd.sealedmedia.softseal.mpeg': { source: 'iana' },
    'audio/vnd.vmx.cvsd': { source: 'iana' },
    'audio/vnd.wave': { compressible: !1 },
    'audio/vorbis': { source: 'iana', compressible: !1 },
    'audio/vorbis-config': { source: 'iana' },
    'audio/wav': { compressible: !1, extensions: ['wav'] },
    'audio/wave': { compressible: !1, extensions: ['wav'] },
    'audio/webm': { source: 'apache', compressible: !1, extensions: ['weba'] },
    'audio/x-aac': { source: 'apache', compressible: !1, extensions: ['aac'] },
    'audio/x-aiff': { source: 'apache', extensions: ['aif', 'aiff', 'aifc'] },
    'audio/x-caf': { source: 'apache', compressible: !1, extensions: ['caf'] },
    'audio/x-flac': { source: 'apache', extensions: ['flac'] },
    'audio/x-m4a': { source: 'nginx', extensions: ['m4a'] },
    'audio/x-matroska': { source: 'apache', extensions: ['mka'] },
    'audio/x-mpegurl': { source: 'apache', extensions: ['m3u'] },
    'audio/x-ms-wax': { source: 'apache', extensions: ['wax'] },
    'audio/x-ms-wma': { source: 'apache', extensions: ['wma'] },
    'audio/x-pn-realaudio': { source: 'apache', extensions: ['ram', 'ra'] },
    'audio/x-pn-realaudio-plugin': { source: 'apache', extensions: ['rmp'] },
    'audio/x-realaudio': { source: 'nginx', extensions: ['ra'] },
    'audio/x-tta': { source: 'apache' },
    'audio/x-wav': { source: 'apache', extensions: ['wav'] },
    'audio/xm': { source: 'apache', extensions: ['xm'] },
    'chemical/x-cdx': { source: 'apache', extensions: ['cdx'] },
    'chemical/x-cif': { source: 'apache', extensions: ['cif'] },
    'chemical/x-cmdf': { source: 'apache', extensions: ['cmdf'] },
    'chemical/x-cml': { source: 'apache', extensions: ['cml'] },
    'chemical/x-csml': { source: 'apache', extensions: ['csml'] },
    'chemical/x-pdb': { source: 'apache' },
    'chemical/x-xyz': { source: 'apache', extensions: ['xyz'] },
    'font/collection': { source: 'iana', extensions: ['ttc'] },
    'font/otf': { source: 'iana', compressible: !0, extensions: ['otf'] },
    'font/sfnt': { source: 'iana' },
    'font/ttf': { source: 'iana', compressible: !0, extensions: ['ttf'] },
    'font/woff': { source: 'iana', extensions: ['woff'] },
    'font/woff2': { source: 'iana', extensions: ['woff2'] },
    'image/aces': { source: 'iana', extensions: ['exr'] },
    'image/apng': { compressible: !1, extensions: ['apng'] },
    'image/avci': { source: 'iana', extensions: ['avci'] },
    'image/avcs': { source: 'iana', extensions: ['avcs'] },
    'image/avif': { source: 'iana', compressible: !1, extensions: ['avif'] },
    'image/bmp': { source: 'iana', compressible: !0, extensions: ['bmp'] },
    'image/cgm': { source: 'iana', extensions: ['cgm'] },
    'image/dicom-rle': { source: 'iana', extensions: ['drle'] },
    'image/emf': { source: 'iana', extensions: ['emf'] },
    'image/fits': { source: 'iana', extensions: ['fits'] },
    'image/g3fax': { source: 'iana', extensions: ['g3'] },
    'image/gif': { source: 'iana', compressible: !1, extensions: ['gif'] },
    'image/heic': { source: 'iana', extensions: ['heic'] },
    'image/heic-sequence': { source: 'iana', extensions: ['heics'] },
    'image/heif': { source: 'iana', extensions: ['heif'] },
    'image/heif-sequence': { source: 'iana', extensions: ['heifs'] },
    'image/hej2k': { source: 'iana', extensions: ['hej2'] },
    'image/hsj2': { source: 'iana', extensions: ['hsj2'] },
    'image/ief': { source: 'iana', extensions: ['ief'] },
    'image/jls': { source: 'iana', extensions: ['jls'] },
    'image/jp2': { source: 'iana', compressible: !1, extensions: ['jp2', 'jpg2'] },
    'image/jpeg': { source: 'iana', compressible: !1, extensions: ['jpeg', 'jpg', 'jpe'] },
    'image/jph': { source: 'iana', extensions: ['jph'] },
    'image/jphc': { source: 'iana', extensions: ['jhc'] },
    'image/jpm': { source: 'iana', compressible: !1, extensions: ['jpm'] },
    'image/jpx': { source: 'iana', compressible: !1, extensions: ['jpx', 'jpf'] },
    'image/jxr': { source: 'iana', extensions: ['jxr'] },
    'image/jxra': { source: 'iana', extensions: ['jxra'] },
    'image/jxrs': { source: 'iana', extensions: ['jxrs'] },
    'image/jxs': { source: 'iana', extensions: ['jxs'] },
    'image/jxsc': { source: 'iana', extensions: ['jxsc'] },
    'image/jxsi': { source: 'iana', extensions: ['jxsi'] },
    'image/jxss': { source: 'iana', extensions: ['jxss'] },
    'image/ktx': { source: 'iana', extensions: ['ktx'] },
    'image/ktx2': { source: 'iana', extensions: ['ktx2'] },
    'image/naplps': { source: 'iana' },
    'image/pjpeg': { compressible: !1 },
    'image/png': { source: 'iana', compressible: !1, extensions: ['png'] },
    'image/prs.btif': { source: 'iana', extensions: ['btif'] },
    'image/prs.pti': { source: 'iana', extensions: ['pti'] },
    'image/pwg-raster': { source: 'iana' },
    'image/sgi': { source: 'apache', extensions: ['sgi'] },
    'image/svg+xml': { source: 'iana', compressible: !0, extensions: ['svg', 'svgz'] },
    'image/t38': { source: 'iana', extensions: ['t38'] },
    'image/tiff': { source: 'iana', compressible: !1, extensions: ['tif', 'tiff'] },
    'image/tiff-fx': { source: 'iana', extensions: ['tfx'] },
    'image/vnd.adobe.photoshop': { source: 'iana', compressible: !0, extensions: ['psd'] },
    'image/vnd.airzip.accelerator.azv': { source: 'iana', extensions: ['azv'] },
    'image/vnd.cns.inf2': { source: 'iana' },
    'image/vnd.dece.graphic': { source: 'iana', extensions: ['uvi', 'uvvi', 'uvg', 'uvvg'] },
    'image/vnd.djvu': { source: 'iana', extensions: ['djvu', 'djv'] },
    'image/vnd.dvb.subtitle': { source: 'iana', extensions: ['sub'] },
    'image/vnd.dwg': { source: 'iana', extensions: ['dwg'] },
    'image/vnd.dxf': { source: 'iana', extensions: ['dxf'] },
    'image/vnd.fastbidsheet': { source: 'iana', extensions: ['fbs'] },
    'image/vnd.fpx': { source: 'iana', extensions: ['fpx'] },
    'image/vnd.fst': { source: 'iana', extensions: ['fst'] },
    'image/vnd.fujixerox.edmics-mmr': { source: 'iana', extensions: ['mmr'] },
    'image/vnd.fujixerox.edmics-rlc': { source: 'iana', extensions: ['rlc'] },
    'image/vnd.globalgraphics.pgb': { source: 'iana' },
    'image/vnd.microsoft.icon': { source: 'iana', compressible: !0, extensions: ['ico'] },
    'image/vnd.mix': { source: 'iana' },
    'image/vnd.mozilla.apng': { source: 'iana' },
    'image/vnd.ms-dds': { compressible: !0, extensions: ['dds'] },
    'image/vnd.ms-modi': { source: 'iana', extensions: ['mdi'] },
    'image/vnd.ms-photo': { source: 'apache', extensions: ['wdp'] },
    'image/vnd.net-fpx': { source: 'iana', extensions: ['npx'] },
    'image/vnd.pco.b16': { source: 'iana', extensions: ['b16'] },
    'image/vnd.radiance': { source: 'iana' },
    'image/vnd.sealed.png': { source: 'iana' },
    'image/vnd.sealedmedia.softseal.gif': { source: 'iana' },
    'image/vnd.sealedmedia.softseal.jpg': { source: 'iana' },
    'image/vnd.svf': { source: 'iana' },
    'image/vnd.tencent.tap': { source: 'iana', extensions: ['tap'] },
    'image/vnd.valve.source.texture': { source: 'iana', extensions: ['vtf'] },
    'image/vnd.wap.wbmp': { source: 'iana', extensions: ['wbmp'] },
    'image/vnd.xiff': { source: 'iana', extensions: ['xif'] },
    'image/vnd.zbrush.pcx': { source: 'iana', extensions: ['pcx'] },
    'image/webp': { source: 'apache', extensions: ['webp'] },
    'image/wmf': { source: 'iana', extensions: ['wmf'] },
    'image/x-3ds': { source: 'apache', extensions: ['3ds'] },
    'image/x-cmu-raster': { source: 'apache', extensions: ['ras'] },
    'image/x-cmx': { source: 'apache', extensions: ['cmx'] },
    'image/x-freehand': { source: 'apache', extensions: ['fh', 'fhc', 'fh4', 'fh5', 'fh7'] },
    'image/x-icon': { source: 'apache', compressible: !0, extensions: ['ico'] },
    'image/x-jng': { source: 'nginx', extensions: ['jng'] },
    'image/x-mrsid-image': { source: 'apache', extensions: ['sid'] },
    'image/x-ms-bmp': { source: 'nginx', compressible: !0, extensions: ['bmp'] },
    'image/x-pcx': { source: 'apache', extensions: ['pcx'] },
    'image/x-pict': { source: 'apache', extensions: ['pic', 'pct'] },
    'image/x-portable-anymap': { source: 'apache', extensions: ['pnm'] },
    'image/x-portable-bitmap': { source: 'apache', extensions: ['pbm'] },
    'image/x-portable-graymap': { source: 'apache', extensions: ['pgm'] },
    'image/x-portable-pixmap': { source: 'apache', extensions: ['ppm'] },
    'image/x-rgb': { source: 'apache', extensions: ['rgb'] },
    'image/x-tga': { source: 'apache', extensions: ['tga'] },
    'image/x-xbitmap': { source: 'apache', extensions: ['xbm'] },
    'image/x-xcf': { compressible: !1 },
    'image/x-xpixmap': { source: 'apache', extensions: ['xpm'] },
    'image/x-xwindowdump': { source: 'apache', extensions: ['xwd'] },
    'message/cpim': { source: 'iana' },
    'message/delivery-status': { source: 'iana' },
    'message/disposition-notification': { source: 'iana', extensions: ['disposition-notification'] },
    'message/external-body': { source: 'iana' },
    'message/feedback-report': { source: 'iana' },
    'message/global': { source: 'iana', extensions: ['u8msg'] },
    'message/global-delivery-status': { source: 'iana', extensions: ['u8dsn'] },
    'message/global-disposition-notification': { source: 'iana', extensions: ['u8mdn'] },
    'message/global-headers': { source: 'iana', extensions: ['u8hdr'] },
    'message/http': { source: 'iana', compressible: !1 },
    'message/imdn+xml': { source: 'iana', compressible: !0 },
    'message/news': { source: 'iana' },
    'message/partial': { source: 'iana', compressible: !1 },
    'message/rfc822': { source: 'iana', compressible: !0, extensions: ['eml', 'mime'] },
    'message/s-http': { source: 'iana' },
    'message/sip': { source: 'iana' },
    'message/sipfrag': { source: 'iana' },
    'message/tracking-status': { source: 'iana' },
    'message/vnd.si.simp': { source: 'iana' },
    'message/vnd.wfa.wsc': { source: 'iana', extensions: ['wsc'] },
    'model/3mf': { source: 'iana', extensions: ['3mf'] },
    'model/e57': { source: 'iana' },
    'model/gltf+json': { source: 'iana', compressible: !0, extensions: ['gltf'] },
    'model/gltf-binary': { source: 'iana', compressible: !0, extensions: ['glb'] },
    'model/iges': { source: 'iana', compressible: !1, extensions: ['igs', 'iges'] },
    'model/mesh': { source: 'iana', compressible: !1, extensions: ['msh', 'mesh', 'silo'] },
    'model/mtl': { source: 'iana', extensions: ['mtl'] },
    'model/obj': { source: 'iana', extensions: ['obj'] },
    'model/step': { source: 'iana' },
    'model/step+xml': { source: 'iana', compressible: !0, extensions: ['stpx'] },
    'model/step+zip': { source: 'iana', compressible: !1, extensions: ['stpz'] },
    'model/step-xml+zip': { source: 'iana', compressible: !1, extensions: ['stpxz'] },
    'model/stl': { source: 'iana', extensions: ['stl'] },
    'model/vnd.collada+xml': { source: 'iana', compressible: !0, extensions: ['dae'] },
    'model/vnd.dwf': { source: 'iana', extensions: ['dwf'] },
    'model/vnd.flatland.3dml': { source: 'iana' },
    'model/vnd.gdl': { source: 'iana', extensions: ['gdl'] },
    'model/vnd.gs-gdl': { source: 'apache' },
    'model/vnd.gs.gdl': { source: 'iana' },
    'model/vnd.gtw': { source: 'iana', extensions: ['gtw'] },
    'model/vnd.moml+xml': { source: 'iana', compressible: !0 },
    'model/vnd.mts': { source: 'iana', extensions: ['mts'] },
    'model/vnd.opengex': { source: 'iana', extensions: ['ogex'] },
    'model/vnd.parasolid.transmit.binary': { source: 'iana', extensions: ['x_b'] },
    'model/vnd.parasolid.transmit.text': { source: 'iana', extensions: ['x_t'] },
    'model/vnd.pytha.pyox': { source: 'iana' },
    'model/vnd.rosette.annotated-data-model': { source: 'iana' },
    'model/vnd.sap.vds': { source: 'iana', extensions: ['vds'] },
    'model/vnd.usdz+zip': { source: 'iana', compressible: !1, extensions: ['usdz'] },
    'model/vnd.valve.source.compiled-map': { source: 'iana', extensions: ['bsp'] },
    'model/vnd.vtu': { source: 'iana', extensions: ['vtu'] },
    'model/vrml': { source: 'iana', compressible: !1, extensions: ['wrl', 'vrml'] },
    'model/x3d+binary': { source: 'apache', compressible: !1, extensions: ['x3db', 'x3dbz'] },
    'model/x3d+fastinfoset': { source: 'iana', extensions: ['x3db'] },
    'model/x3d+vrml': { source: 'apache', compressible: !1, extensions: ['x3dv', 'x3dvz'] },
    'model/x3d+xml': { source: 'iana', compressible: !0, extensions: ['x3d', 'x3dz'] },
    'model/x3d-vrml': { source: 'iana', extensions: ['x3dv'] },
    'multipart/alternative': { source: 'iana', compressible: !1 },
    'multipart/appledouble': { source: 'iana' },
    'multipart/byteranges': { source: 'iana' },
    'multipart/digest': { source: 'iana' },
    'multipart/encrypted': { source: 'iana', compressible: !1 },
    'multipart/form-data': { source: 'iana', compressible: !1 },
    'multipart/header-set': { source: 'iana' },
    'multipart/mixed': { source: 'iana' },
    'multipart/multilingual': { source: 'iana' },
    'multipart/parallel': { source: 'iana' },
    'multipart/related': { source: 'iana', compressible: !1 },
    'multipart/report': { source: 'iana' },
    'multipart/signed': { source: 'iana', compressible: !1 },
    'multipart/vnd.bint.med-plus': { source: 'iana' },
    'multipart/voice-message': { source: 'iana' },
    'multipart/x-mixed-replace': { source: 'iana' },
    'text/1d-interleaved-parityfec': { source: 'iana' },
    'text/cache-manifest': { source: 'iana', compressible: !0, extensions: ['appcache', 'manifest'] },
    'text/calendar': { source: 'iana', extensions: ['ics', 'ifb'] },
    'text/calender': { compressible: !0 },
    'text/cmd': { compressible: !0 },
    'text/coffeescript': { extensions: ['coffee', 'litcoffee'] },
    'text/cql': { source: 'iana' },
    'text/cql-expression': { source: 'iana' },
    'text/cql-identifier': { source: 'iana' },
    'text/css': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['css'] },
    'text/csv': { source: 'iana', compressible: !0, extensions: ['csv'] },
    'text/csv-schema': { source: 'iana' },
    'text/directory': { source: 'iana' },
    'text/dns': { source: 'iana' },
    'text/ecmascript': { source: 'iana' },
    'text/encaprtp': { source: 'iana' },
    'text/enriched': { source: 'iana' },
    'text/fhirpath': { source: 'iana' },
    'text/flexfec': { source: 'iana' },
    'text/fwdred': { source: 'iana' },
    'text/gff3': { source: 'iana' },
    'text/grammar-ref-list': { source: 'iana' },
    'text/html': { source: 'iana', compressible: !0, extensions: ['html', 'htm', 'shtml'] },
    'text/jade': { extensions: ['jade'] },
    'text/javascript': { source: 'iana', compressible: !0 },
    'text/jcr-cnd': { source: 'iana' },
    'text/jsx': { compressible: !0, extensions: ['jsx'] },
    'text/less': { compressible: !0, extensions: ['less'] },
    'text/markdown': { source: 'iana', compressible: !0, extensions: ['markdown', 'md'] },
    'text/mathml': { source: 'nginx', extensions: ['mml'] },
    'text/mdx': { compressible: !0, extensions: ['mdx'] },
    'text/mizar': { source: 'iana' },
    'text/n3': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['n3'] },
    'text/parameters': { source: 'iana', charset: 'UTF-8' },
    'text/parityfec': { source: 'iana' },
    'text/plain': {
      source: 'iana',
      compressible: !0,
      extensions: ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    },
    'text/provenance-notation': { source: 'iana', charset: 'UTF-8' },
    'text/prs.fallenstein.rst': { source: 'iana' },
    'text/prs.lines.tag': { source: 'iana', extensions: ['dsc'] },
    'text/prs.prop.logic': { source: 'iana' },
    'text/raptorfec': { source: 'iana' },
    'text/red': { source: 'iana' },
    'text/rfc822-headers': { source: 'iana' },
    'text/richtext': { source: 'iana', compressible: !0, extensions: ['rtx'] },
    'text/rtf': { source: 'iana', compressible: !0, extensions: ['rtf'] },
    'text/rtp-enc-aescm128': { source: 'iana' },
    'text/rtploopback': { source: 'iana' },
    'text/rtx': { source: 'iana' },
    'text/sgml': { source: 'iana', extensions: ['sgml', 'sgm'] },
    'text/shaclc': { source: 'iana' },
    'text/shex': { source: 'iana', extensions: ['shex'] },
    'text/slim': { extensions: ['slim', 'slm'] },
    'text/spdx': { source: 'iana', extensions: ['spdx'] },
    'text/strings': { source: 'iana' },
    'text/stylus': { extensions: ['stylus', 'styl'] },
    'text/t140': { source: 'iana' },
    'text/tab-separated-values': { source: 'iana', compressible: !0, extensions: ['tsv'] },
    'text/troff': { source: 'iana', extensions: ['t', 'tr', 'roff', 'man', 'me', 'ms'] },
    'text/turtle': { source: 'iana', charset: 'UTF-8', extensions: ['ttl'] },
    'text/ulpfec': { source: 'iana' },
    'text/uri-list': { source: 'iana', compressible: !0, extensions: ['uri', 'uris', 'urls'] },
    'text/vcard': { source: 'iana', compressible: !0, extensions: ['vcard'] },
    'text/vnd.a': { source: 'iana' },
    'text/vnd.abc': { source: 'iana' },
    'text/vnd.ascii-art': { source: 'iana' },
    'text/vnd.curl': { source: 'iana', extensions: ['curl'] },
    'text/vnd.curl.dcurl': { source: 'apache', extensions: ['dcurl'] },
    'text/vnd.curl.mcurl': { source: 'apache', extensions: ['mcurl'] },
    'text/vnd.curl.scurl': { source: 'apache', extensions: ['scurl'] },
    'text/vnd.debian.copyright': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.dmclientscript': { source: 'iana' },
    'text/vnd.dvb.subtitle': { source: 'iana', extensions: ['sub'] },
    'text/vnd.esmertec.theme-descriptor': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.familysearch.gedcom': { source: 'iana', extensions: ['ged'] },
    'text/vnd.ficlab.flt': { source: 'iana' },
    'text/vnd.fly': { source: 'iana', extensions: ['fly'] },
    'text/vnd.fmi.flexstor': { source: 'iana', extensions: ['flx'] },
    'text/vnd.gml': { source: 'iana' },
    'text/vnd.graphviz': { source: 'iana', extensions: ['gv'] },
    'text/vnd.hans': { source: 'iana' },
    'text/vnd.hgl': { source: 'iana' },
    'text/vnd.in3d.3dml': { source: 'iana', extensions: ['3dml'] },
    'text/vnd.in3d.spot': { source: 'iana', extensions: ['spot'] },
    'text/vnd.iptc.newsml': { source: 'iana' },
    'text/vnd.iptc.nitf': { source: 'iana' },
    'text/vnd.latex-z': { source: 'iana' },
    'text/vnd.motorola.reflex': { source: 'iana' },
    'text/vnd.ms-mediapackage': { source: 'iana' },
    'text/vnd.net2phone.commcenter.command': { source: 'iana' },
    'text/vnd.radisys.msml-basic-layout': { source: 'iana' },
    'text/vnd.senx.warpscript': { source: 'iana' },
    'text/vnd.si.uricatalogue': { source: 'iana' },
    'text/vnd.sosi': { source: 'iana' },
    'text/vnd.sun.j2me.app-descriptor': { source: 'iana', charset: 'UTF-8', extensions: ['jad'] },
    'text/vnd.trolltech.linguist': { source: 'iana', charset: 'UTF-8' },
    'text/vnd.wap.si': { source: 'iana' },
    'text/vnd.wap.sl': { source: 'iana' },
    'text/vnd.wap.wml': { source: 'iana', extensions: ['wml'] },
    'text/vnd.wap.wmlscript': { source: 'iana', extensions: ['wmls'] },
    'text/vtt': { source: 'iana', charset: 'UTF-8', compressible: !0, extensions: ['vtt'] },
    'text/x-asm': { source: 'apache', extensions: ['s', 'asm'] },
    'text/x-c': { source: 'apache', extensions: ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'] },
    'text/x-component': { source: 'nginx', extensions: ['htc'] },
    'text/x-fortran': { source: 'apache', extensions: ['f', 'for', 'f77', 'f90'] },
    'text/x-gwt-rpc': { compressible: !0 },
    'text/x-handlebars-template': { extensions: ['hbs'] },
    'text/x-java-source': { source: 'apache', extensions: ['java'] },
    'text/x-jquery-tmpl': { compressible: !0 },
    'text/x-lua': { extensions: ['lua'] },
    'text/x-markdown': { compressible: !0, extensions: ['mkd'] },
    'text/x-nfo': { source: 'apache', extensions: ['nfo'] },
    'text/x-opml': { source: 'apache', extensions: ['opml'] },
    'text/x-org': { compressible: !0, extensions: ['org'] },
    'text/x-pascal': { source: 'apache', extensions: ['p', 'pas'] },
    'text/x-processing': { compressible: !0, extensions: ['pde'] },
    'text/x-sass': { extensions: ['sass'] },
    'text/x-scss': { extensions: ['scss'] },
    'text/x-setext': { source: 'apache', extensions: ['etx'] },
    'text/x-sfv': { source: 'apache', extensions: ['sfv'] },
    'text/x-suse-ymp': { compressible: !0, extensions: ['ymp'] },
    'text/x-uuencode': { source: 'apache', extensions: ['uu'] },
    'text/x-vcalendar': { source: 'apache', extensions: ['vcs'] },
    'text/x-vcard': { source: 'apache', extensions: ['vcf'] },
    'text/xml': { source: 'iana', compressible: !0, extensions: ['xml'] },
    'text/xml-external-parsed-entity': { source: 'iana' },
    'text/yaml': { compressible: !0, extensions: ['yaml', 'yml'] },
    'video/1d-interleaved-parityfec': { source: 'iana' },
    'video/3gpp': { source: 'iana', extensions: ['3gp', '3gpp'] },
    'video/3gpp-tt': { source: 'iana' },
    'video/3gpp2': { source: 'iana', extensions: ['3g2'] },
    'video/av1': { source: 'iana' },
    'video/bmpeg': { source: 'iana' },
    'video/bt656': { source: 'iana' },
    'video/celb': { source: 'iana' },
    'video/dv': { source: 'iana' },
    'video/encaprtp': { source: 'iana' },
    'video/ffv1': { source: 'iana' },
    'video/flexfec': { source: 'iana' },
    'video/h261': { source: 'iana', extensions: ['h261'] },
    'video/h263': { source: 'iana', extensions: ['h263'] },
    'video/h263-1998': { source: 'iana' },
    'video/h263-2000': { source: 'iana' },
    'video/h264': { source: 'iana', extensions: ['h264'] },
    'video/h264-rcdo': { source: 'iana' },
    'video/h264-svc': { source: 'iana' },
    'video/h265': { source: 'iana' },
    'video/iso.segment': { source: 'iana', extensions: ['m4s'] },
    'video/jpeg': { source: 'iana', extensions: ['jpgv'] },
    'video/jpeg2000': { source: 'iana' },
    'video/jpm': { source: 'apache', extensions: ['jpm', 'jpgm'] },
    'video/jxsv': { source: 'iana' },
    'video/mj2': { source: 'iana', extensions: ['mj2', 'mjp2'] },
    'video/mp1s': { source: 'iana' },
    'video/mp2p': { source: 'iana' },
    'video/mp2t': { source: 'iana', extensions: ['ts'] },
    'video/mp4': { source: 'iana', compressible: !1, extensions: ['mp4', 'mp4v', 'mpg4'] },
    'video/mp4v-es': { source: 'iana' },
    'video/mpeg': { source: 'iana', compressible: !1, extensions: ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'] },
    'video/mpeg4-generic': { source: 'iana' },
    'video/mpv': { source: 'iana' },
    'video/nv': { source: 'iana' },
    'video/ogg': { source: 'iana', compressible: !1, extensions: ['ogv'] },
    'video/parityfec': { source: 'iana' },
    'video/pointer': { source: 'iana' },
    'video/quicktime': { source: 'iana', compressible: !1, extensions: ['qt', 'mov'] },
    'video/raptorfec': { source: 'iana' },
    'video/raw': { source: 'iana' },
    'video/rtp-enc-aescm128': { source: 'iana' },
    'video/rtploopback': { source: 'iana' },
    'video/rtx': { source: 'iana' },
    'video/scip': { source: 'iana' },
    'video/smpte291': { source: 'iana' },
    'video/smpte292m': { source: 'iana' },
    'video/ulpfec': { source: 'iana' },
    'video/vc1': { source: 'iana' },
    'video/vc2': { source: 'iana' },
    'video/vnd.cctv': { source: 'iana' },
    'video/vnd.dece.hd': { source: 'iana', extensions: ['uvh', 'uvvh'] },
    'video/vnd.dece.mobile': { source: 'iana', extensions: ['uvm', 'uvvm'] },
    'video/vnd.dece.mp4': { source: 'iana' },
    'video/vnd.dece.pd': { source: 'iana', extensions: ['uvp', 'uvvp'] },
    'video/vnd.dece.sd': { source: 'iana', extensions: ['uvs', 'uvvs'] },
    'video/vnd.dece.video': { source: 'iana', extensions: ['uvv', 'uvvv'] },
    'video/vnd.directv.mpeg': { source: 'iana' },
    'video/vnd.directv.mpeg-tts': { source: 'iana' },
    'video/vnd.dlna.mpeg-tts': { source: 'iana' },
    'video/vnd.dvb.file': { source: 'iana', extensions: ['dvb'] },
    'video/vnd.fvt': { source: 'iana', extensions: ['fvt'] },
    'video/vnd.hns.video': { source: 'iana' },
    'video/vnd.iptvforum.1dparityfec-1010': { source: 'iana' },
    'video/vnd.iptvforum.1dparityfec-2005': { source: 'iana' },
    'video/vnd.iptvforum.2dparityfec-1010': { source: 'iana' },
    'video/vnd.iptvforum.2dparityfec-2005': { source: 'iana' },
    'video/vnd.iptvforum.ttsavc': { source: 'iana' },
    'video/vnd.iptvforum.ttsmpeg2': { source: 'iana' },
    'video/vnd.motorola.video': { source: 'iana' },
    'video/vnd.motorola.videop': { source: 'iana' },
    'video/vnd.mpegurl': { source: 'iana', extensions: ['mxu', 'm4u'] },
    'video/vnd.ms-playready.media.pyv': { source: 'iana', extensions: ['pyv'] },
    'video/vnd.nokia.interleaved-multimedia': { source: 'iana' },
    'video/vnd.nokia.mp4vr': { source: 'iana' },
    'video/vnd.nokia.videovoip': { source: 'iana' },
    'video/vnd.objectvideo': { source: 'iana' },
    'video/vnd.radgamettools.bink': { source: 'iana' },
    'video/vnd.radgamettools.smacker': { source: 'iana' },
    'video/vnd.sealed.mpeg1': { source: 'iana' },
    'video/vnd.sealed.mpeg4': { source: 'iana' },
    'video/vnd.sealed.swf': { source: 'iana' },
    'video/vnd.sealedmedia.softseal.mov': { source: 'iana' },
    'video/vnd.uvvu.mp4': { source: 'iana', extensions: ['uvu', 'uvvu'] },
    'video/vnd.vivo': { source: 'iana', extensions: ['viv'] },
    'video/vnd.youtube.yt': { source: 'iana' },
    'video/vp8': { source: 'iana' },
    'video/vp9': { source: 'iana' },
    'video/webm': { source: 'apache', compressible: !1, extensions: ['webm'] },
    'video/x-f4v': { source: 'apache', extensions: ['f4v'] },
    'video/x-fli': { source: 'apache', extensions: ['fli'] },
    'video/x-flv': { source: 'apache', compressible: !1, extensions: ['flv'] },
    'video/x-m4v': { source: 'apache', extensions: ['m4v'] },
    'video/x-matroska': { source: 'apache', compressible: !1, extensions: ['mkv', 'mk3d', 'mks'] },
    'video/x-mng': { source: 'apache', extensions: ['mng'] },
    'video/x-ms-asf': { source: 'apache', extensions: ['asf', 'asx'] },
    'video/x-ms-vob': { source: 'apache', extensions: ['vob'] },
    'video/x-ms-wm': { source: 'apache', extensions: ['wm'] },
    'video/x-ms-wmv': { source: 'apache', compressible: !1, extensions: ['wmv'] },
    'video/x-ms-wmx': { source: 'apache', extensions: ['wmx'] },
    'video/x-ms-wvx': { source: 'apache', extensions: ['wvx'] },
    'video/x-msvideo': { source: 'apache', extensions: ['avi'] },
    'video/x-sgi-movie': { source: 'apache', extensions: ['movie'] },
    'video/x-smv': { source: 'apache', extensions: ['smv'] },
    'x-conference/x-cooltalk': { source: 'apache', extensions: ['ice'] },
    'x-shader/x-fragment': { compressible: !0 },
    'x-shader/x-vertex': { compressible: !0 },
  }
})
var Ede = handleExports((Uwt, bde) => {
  bde.exports = xde()
})
var Cde = handleExports(Ds => {
  'use strict'
  var HD = Ede(),
    nqe = require('path').extname,
    Tde = /^\s*([^;\s]*)(?:;|\s|$)/,
    iqe = /^text\//i
  Ds.charset = Sde
  Ds.charsets = { lookup: Sde }
  Ds.contentType = oqe
  Ds.extension = sqe
  Ds.extensions = Object.create(null)
  Ds.lookup = aqe
  Ds.types = Object.create(null)
  cqe(Ds.extensions, Ds.types)
  function Sde(t) {
    if (!t || typeof t != 'string') return !1
    var e = Tde.exec(t),
      r = e && HD[e[1].toLowerCase()]
    return r && r.charset ? r.charset : e && iqe.test(e[1]) ? 'UTF-8' : !1
  }
  function oqe(t) {
    if (!t || typeof t != 'string') return !1
    var e = t.indexOf('/') === -1 ? Ds.lookup(t) : t
    if (!e) return !1
    if (e.indexOf('charset') === -1) {
      var r = Ds.charset(e)
      r && (e += '; charset=' + r.toLowerCase())
    }
    return e
  }
  function sqe(t) {
    if (!t || typeof t != 'string') return !1
    var e = Tde.exec(t),
      r = e && Ds.extensions[e[1].toLowerCase()]
    return !r || !r.length ? !1 : r[0]
  }
  function aqe(t) {
    if (!t || typeof t != 'string') return !1
    var e = nqe('x.' + t)
      .toLowerCase()
      .substr(1)
    return (e && Ds.types[e]) || !1
  }
  function cqe(t, e) {
    var r = ['nginx', 'apache', void 0, 'iana']
    Object.keys(HD).forEach(function (i) {
      var o = HD[i],
        s = o.extensions
      if (!(!s || !s.length)) {
        t[i] = s
        for (var a = 0; a < s.length; a++) {
          var l = s[a]
          if (e[l]) {
            var c = r.indexOf(HD[e[l]].source),
              u = r.indexOf(o.source)
            if (e[l] !== 'application/octet-stream' && (c > u || (c === u && e[l].substr(0, 12) === 'application/')))
              continue
          }
          e[l] = i
        }
      }
    })
  }
})
var wde = handleExports((qwt, Ide) => {
  Ide.exports = lqe
  function lqe(t) {
    var e =
      typeof setImmediate == 'function'
        ? setImmediate
        : typeof process == 'object' && typeof process.nextTick == 'function'
        ? process.nextTick
        : null
    e ? e(t) : setTimeout(t, 0)
  }
})
var zU = handleExports((Hwt, Rde) => {
  var Ade = wde()
  Rde.exports = uqe
  function uqe(t) {
    var e = !1
    return (
      Ade(function () {
        e = !0
      }),
      function (n, i) {
        e
          ? t(n, i)
          : Ade(function () {
              t(n, i)
            })
      }
    )
  }
})
var $U = handleExports((jwt, Dde) => {
  Dde.exports = pqe
  function pqe(t) {
    Object.keys(t.jobs).forEach(dqe.bind(t)), (t.jobs = {})
  }
  function dqe(t) {
    typeof this.jobs[t] == 'function' && this.jobs[t]()
  }
})
var WU = handleExports((Gwt, Nde) => {
  var Pde = zU(),
    fqe = $U()
  Nde.exports = mqe
  function mqe(t, e, r, n) {
    var i = r.keyedList ? r.keyedList[r.index] : r.index
    r.jobs[i] = hqe(e, i, t[i], function (o, s) {
      i in r.jobs && (delete r.jobs[i], o ? fqe(r) : (r.results[i] = s), n(o, r.results))
    })
  }
  function hqe(t, e, r, n) {
    var i
    return t.length == 2 ? (i = t(r, Pde(n))) : (i = t(r, e, Pde(n))), i
  }
})
var KU = handleExports((Vwt, kde) => {
  kde.exports = gqe
  function gqe(t, e) {
    var r = !Array.isArray(t),
      n = {
        index: 0,
        keyedList: r || e ? Object.keys(t) : null,
        jobs: {},
        results: r ? {} : [],
        size: r ? Object.keys(t).length : t.length,
      }
    return (
      e &&
        n.keyedList.sort(
          r
            ? e
            : function (i, o) {
                return e(t[i], t[o])
              }
        ),
      n
    )
  }
})
var YU = handleExports((zwt, Ode) => {
  var vqe = $U(),
    _qe = zU()
  Ode.exports = yqe
  function yqe(t) {
    Object.keys(this.jobs).length && ((this.index = this.size), vqe(this), _qe(t)(null, this.results))
  }
})
var Mde = handleExports(($wt, Lde) => {
  var xqe = WU(),
    bqe = KU(),
    Eqe = YU()
  Lde.exports = Tqe
  function Tqe(t, e, r) {
    for (var n = bqe(t); n.index < (n.keyedList || t).length; )
      xqe(t, e, n, function (i, o) {
        if (i) {
          r(i, o)
          return
        }
        if (Object.keys(n.jobs).length === 0) {
          r(null, n.results)
          return
        }
      }),
        n.index++
    return Eqe.bind(n, r)
  }
})
var QU = handleExports((Wwt, jD) => {
  var Fde = WU(),
    Sqe = KU(),
    Cqe = YU()
  jD.exports = Iqe
  jD.exports.ascending = Ude
  jD.exports.descending = wqe
  function Iqe(t, e, r, n) {
    var i = Sqe(t, r)
    return (
      Fde(t, e, i, function o(s, a) {
        if (s) {
          n(s, a)
          return
        }
        if ((i.index++, i.index < (i.keyedList || t).length)) {
          Fde(t, e, i, o)
          return
        }
        n(null, i.results)
      }),
      Cqe.bind(i, n)
    )
  }
  function Ude(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
  }
  function wqe(t, e) {
    return -1 * Ude(t, e)
  }
})
var qde = handleExports((Kwt, Bde) => {
  var Aqe = QU()
  Bde.exports = Rqe
  function Rqe(t, e, r) {
    return Aqe(t, e, null, r)
  }
})
var jde = handleExports((Ywt, Hde) => {
  Hde.exports = { parallel: Mde(), serial: qde(), serialOrdered: QU() }
})
var Vde = handleExports((Qwt, Gde) => {
  Gde.exports = function (t, e) {
    return (
      Object.keys(e).forEach(function (r) {
        t[r] = t[r] || e[r]
      }),
      t
    )
  }
})
var tB = handleExports((Xwt, $de) => {
  var eB = yde(),
    zde = require('util'),
    XU = require('path'),
    Dqe = require('http'),
    Pqe = require('https'),
    Nqe = require('url').parse,
    kqe = require('fs'),
    Oqe = require('stream').Stream,
    JU = Cde(),
    Lqe = jde(),
    ZU = Vde()
  $de.exports = ur
  zde.inherits(ur, eB)
  function ur(t) {
    if (!(this instanceof ur)) return new ur(t)
    ;(this._overheadLength = 0), (this._valueLength = 0), (this._valuesToMeasure = []), eB.call(this), (t = t || {})
    for (var e in t) this[e] = t[e]
  }
  ur.LINE_BREAK = `\r
`
  ur.DEFAULT_CONTENT_TYPE = 'application/octet-stream'
  ur.prototype.append = function (t, e, r) {
    ;(r = r || {}), typeof r == 'string' && (r = { filename: r })
    var n = eB.prototype.append.bind(this)
    if ((typeof e == 'number' && (e = '' + e), zde.isArray(e))) {
      this._error(new Error('Arrays are not supported.'))
      return
    }
    var i = this._multiPartHeader(t, e, r),
      o = this._multiPartFooter()
    n(i), n(e), n(o), this._trackLength(i, e, r)
  }
  ur.prototype._trackLength = function (t, e, r) {
    var n = 0
    r.knownLength != null
      ? (n += +r.knownLength)
      : Buffer.isBuffer(e)
      ? (n = e.length)
      : typeof e == 'string' && (n = Buffer.byteLength(e)),
      (this._valueLength += n),
      (this._overheadLength += Buffer.byteLength(t) + ur.LINE_BREAK.length),
      !(!e || (!e.path && !(e.readable && e.hasOwnProperty('httpVersion')) && !(e instanceof Oqe))) &&
        (r.knownLength || this._valuesToMeasure.push(e))
  }
  ur.prototype._lengthRetriever = function (t, e) {
    t.hasOwnProperty('fd')
      ? t.end != null && t.end != 1 / 0 && t.start != null
        ? e(null, t.end + 1 - (t.start ? t.start : 0))
        : kqe.stat(t.path, function (r, n) {
            var i
            if (r) {
              e(r)
              return
            }
            ;(i = n.size - (t.start ? t.start : 0)), e(null, i)
          })
      : t.hasOwnProperty('httpVersion')
      ? e(null, +t.headers['content-length'])
      : t.hasOwnProperty('httpModule')
      ? (t.on('response', function (r) {
          t.pause(), e(null, +r.headers['content-length'])
        }),
        t.resume())
      : e('Unknown stream')
  }
  ur.prototype._multiPartHeader = function (t, e, r) {
    if (typeof r.header == 'string') return r.header
    var n = this._getContentDisposition(e, r),
      i = this._getContentType(e, r),
      o = '',
      s = {
        'Content-Disposition': ['form-data', 'name="' + t + '"'].concat(n || []),
        'Content-Type': [].concat(i || []),
      }
    typeof r.header == 'object' && ZU(s, r.header)
    var a
    for (var l in s)
      s.hasOwnProperty(l) &&
        ((a = s[l]),
        a != null && (Array.isArray(a) || (a = [a]), a.length && (o += l + ': ' + a.join('; ') + ur.LINE_BREAK)))
    return '--' + this.getBoundary() + ur.LINE_BREAK + o + ur.LINE_BREAK
  }
  ur.prototype._getContentDisposition = function (t, e) {
    var r, n
    return (
      typeof e.filepath == 'string'
        ? (r = XU.normalize(e.filepath).replace(/\\/g, '/'))
        : e.filename || t.name || t.path
        ? (r = XU.basename(e.filename || t.name || t.path))
        : t.readable && t.hasOwnProperty('httpVersion') && (r = XU.basename(t.client._httpMessage.path || '')),
      r && (n = 'filename="' + r + '"'),
      n
    )
  }
  ur.prototype._getContentType = function (t, e) {
    var r = e.contentType
    return (
      !r && t.name && (r = JU.lookup(t.name)),
      !r && t.path && (r = JU.lookup(t.path)),
      !r && t.readable && t.hasOwnProperty('httpVersion') && (r = t.headers['content-type']),
      !r && (e.filepath || e.filename) && (r = JU.lookup(e.filepath || e.filename)),
      !r && typeof t == 'object' && (r = ur.DEFAULT_CONTENT_TYPE),
      r
    )
  }
  ur.prototype._multiPartFooter = function () {
    return function (t) {
      var e = ur.LINE_BREAK,
        r = this._streams.length === 0
      r && (e += this._lastBoundary()), t(e)
    }.bind(this)
  }
  ur.prototype._lastBoundary = function () {
    return '--' + this.getBoundary() + '--' + ur.LINE_BREAK
  }
  ur.prototype.getHeaders = function (t) {
    var e,
      r = { 'content-type': 'multipart/form-data; boundary=' + this.getBoundary() }
    for (e in t) t.hasOwnProperty(e) && (r[e.toLowerCase()] = t[e])
    return r
  }
  ur.prototype.setBoundary = function (t) {
    this._boundary = t
  }
  ur.prototype.getBoundary = function () {
    return this._boundary || this._generateBoundary(), this._boundary
  }
  ur.prototype.getBuffer = function () {
    for (var t = new Buffer.alloc(0), e = this.getBoundary(), r = 0, n = this._streams.length; r < n; r++)
      typeof this._streams[r] != 'function' &&
        (Buffer.isBuffer(this._streams[r])
          ? (t = Buffer.concat([t, this._streams[r]]))
          : (t = Buffer.concat([t, Buffer.from(this._streams[r])])),
        (typeof this._streams[r] != 'string' || this._streams[r].substring(2, e.length + 2) !== e) &&
          (t = Buffer.concat([t, Buffer.from(ur.LINE_BREAK)])))
    return Buffer.concat([t, Buffer.from(this._lastBoundary())])
  }
  ur.prototype._generateBoundary = function () {
    for (var t = '--------------------------', e = 0; e < 24; e++) t += Math.floor(Math.random() * 10).toString(16)
    this._boundary = t
  }
  ur.prototype.getLengthSync = function () {
    var t = this._overheadLength + this._valueLength
    return (
      this._streams.length && (t += this._lastBoundary().length),
      this.hasKnownLength() || this._error(new Error('Cannot calculate proper length in synchronous way.')),
      t
    )
  }
  ur.prototype.hasKnownLength = function () {
    var t = !0
    return this._valuesToMeasure.length && (t = !1), t
  }
  ur.prototype.getLength = function (t) {
    var e = this._overheadLength + this._valueLength
    if ((this._streams.length && (e += this._lastBoundary().length), !this._valuesToMeasure.length)) {
      process.nextTick(t.bind(this, null, e))
      return
    }
    Lqe.parallel(this._valuesToMeasure, this._lengthRetriever, function (r, n) {
      if (r) {
        t(r)
        return
      }
      n.forEach(function (i) {
        e += i
      }),
        t(null, e)
    })
  }
  ur.prototype.submit = function (t, e) {
    var r,
      n,
      i = { method: 'post' }
    return (
      typeof t == 'string'
        ? ((t = Nqe(t)), (n = ZU({ port: t.port, path: t.pathname, host: t.hostname, protocol: t.protocol }, i)))
        : ((n = ZU(t, i)), n.port || (n.port = n.protocol == 'https:' ? 443 : 80)),
      (n.headers = this.getHeaders(t.headers)),
      n.protocol == 'https:' ? (r = Pqe.request(n)) : (r = Dqe.request(n)),
      this.getLength(
        function (o, s) {
          if (o && o !== 'Unknown stream') {
            this._error(o)
            return
          }
          if ((s && r.setHeader('Content-Length', s), this.pipe(r), e)) {
            var a,
              l = function (c, u) {
                return r.removeListener('error', l), r.removeListener('response', a), e.call(this, c, u)
              }
            ;(a = l.bind(this, null)), r.on('error', l), r.on('response', a)
          }
        }.bind(this)
      ),
      r
    )
  }
  ur.prototype._error = function (t) {
    this.error || ((this.error = t), this.pause(), this.emit('error', t))
  }
  ur.prototype.toString = function () {
    return '[object FormData]'
  }
})
function GD() {
  return {
    name: rB,
    async sendRequest(t, e) {
      if (t.formData) {
        let r = t.headers.get('Content-Type')
        r && r.indexOf('application/x-www-form-urlencoded') !== -1
          ? ((t.body = Mqe(t.formData)), (t.formData = void 0))
          : await Fqe(t.formData, t)
      }
      return e(t)
    },
  }
}
function Mqe(t) {
  let e = new URLSearchParams()
  for (let [r, n] of Object.entries(t))
    if (Array.isArray(n)) for (let i of n) e.append(r, i.toString())
    else e.append(r, n.toString())
  return e.toString()
}
async function Fqe(t, e) {
  let r = new Wde.default()
  for (let i of Object.keys(t)) {
    let o = t[i]
    if (Array.isArray(o)) for (let s of o) r.append(i, s)
    else r.append(i, o)
  }
  ;(e.body = r), (e.formData = void 0)
  let n = e.headers.get('Content-Type')
  n &&
    n.indexOf('multipart/form-data') !== -1 &&
    e.headers.set('Content-Type', `multipart/form-data; boundary=${r.getBoundary()}`)
  try {
    let i = await new Promise((o, s) => {
      r.getLength((a, l) => {
        a ? s(a) : o(l)
      })
    })
    e.headers.set('Content-Length', i)
  } catch {}
}
var Wde,
  rB,
  nB = createGetter(() => {
    ;(Wde = handleDefaultExports(tB())), (rB = 'formDataPolicy')
  })
var Kde = handleExports(iB => {
  'use strict'
  Object.defineProperty(iB, '__esModule', { value: !0 })
  function Uqe(t) {
    return function (e, r) {
      return new Promise((n, i) => {
        t.call(this, e, r, (o, s) => {
          o ? i(o) : n(s)
        })
      })
    }
  }
  iB.default = Uqe
})
var aB = handleExports((sB, Qde) => {
  'use strict'
  var Yde =
      (sB && sB.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t }
      },
    Bqe = require('events'),
    qqe = Yde(La()),
    Hqe = Yde(Kde()),
    fT = qqe.default('agent-base')
  function jqe(t) {
    return !!t && typeof t.addRequest == 'function'
  }
  function oB() {
    let { stack: t } = new Error()
    return typeof t != 'string'
      ? !1
      : t
          .split(
            `
`
          )
          .some(e => e.indexOf('(https.js:') !== -1 || e.indexOf('node:https:') !== -1)
  }
  function VD(t, e) {
    return new VD.Agent(t, e)
  }
  ;(function (t) {
    class e extends Bqe.EventEmitter {
      constructor(n, i) {
        super()
        let o = i
        typeof n == 'function' ? (this.callback = n) : n && (o = n),
          (this.timeout = null),
          o && typeof o.timeout == 'number' && (this.timeout = o.timeout),
          (this.maxFreeSockets = 1),
          (this.maxSockets = 1),
          (this.maxTotalSockets = 1 / 0),
          (this.sockets = {}),
          (this.freeSockets = {}),
          (this.requests = {}),
          (this.options = {})
      }
      get defaultPort() {
        return typeof this.explicitDefaultPort == 'number' ? this.explicitDefaultPort : oB() ? 443 : 80
      }
      set defaultPort(n) {
        this.explicitDefaultPort = n
      }
      get protocol() {
        return typeof this.explicitProtocol == 'string' ? this.explicitProtocol : oB() ? 'https:' : 'http:'
      }
      set protocol(n) {
        this.explicitProtocol = n
      }
      callback(n, i, o) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`')
      }
      addRequest(n, i) {
        let o = Object.assign({}, i)
        typeof o.secureEndpoint != 'boolean' && (o.secureEndpoint = oB()),
          o.host == null && (o.host = 'localhost'),
          o.port == null && (o.port = o.secureEndpoint ? 443 : 80),
          o.protocol == null && (o.protocol = o.secureEndpoint ? 'https:' : 'http:'),
          o.host && o.path && delete o.path,
          delete o.agent,
          delete o.hostname,
          delete o._defaultAgent,
          delete o.defaultPort,
          delete o.createConnection,
          (n._last = !0),
          (n.shouldKeepAlive = !1)
        let s = !1,
          a = null,
          l = o.timeout || this.timeout,
          c = f => {
            n._hadError || (n.emit('error', f), (n._hadError = !0))
          },
          u = () => {
            ;(a = null), (s = !0)
            let f = new Error(`A "socket" was not created for HTTP request before ${l}ms`)
            ;(f.code = 'ETIMEOUT'), c(f)
          },
          p = f => {
            s || (a !== null && (clearTimeout(a), (a = null)), c(f))
          },
          d = f => {
            if (s) return
            if ((a != null && (clearTimeout(a), (a = null)), jqe(f))) {
              fT('Callback returned another Agent instance %o', f.constructor.name), f.addRequest(n, o)
              return
            }
            if (f) {
              f.once('free', () => {
                this.freeSocket(f, o)
              }),
                n.onSocket(f)
              return
            }
            let m = new Error(`no Duplex stream was returned to agent-base for \`${n.method} ${n.path}\``)
            c(m)
          }
        if (typeof this.callback != 'function') {
          c(new Error('`callback` is not defined'))
          return
        }
        this.promisifiedCallback ||
          (this.callback.length >= 3
            ? (fT('Converting legacy callback function to promise'),
              (this.promisifiedCallback = Hqe.default(this.callback)))
            : (this.promisifiedCallback = this.callback)),
          typeof l == 'number' && l > 0 && (a = setTimeout(u, l)),
          'port' in o && typeof o.port != 'number' && (o.port = Number(o.port))
        try {
          fT('Resolving socket for %o request: %o', o.protocol, `${n.method} ${n.path}`),
            Promise.resolve(this.promisifiedCallback(n, o)).then(d, p)
        } catch (f) {
          Promise.reject(f).catch(p)
        }
      }
      freeSocket(n, i) {
        fT('Freeing socket %o %o', n.constructor.name, i), n.destroy()
      }
      destroy() {
        fT('Destroying agent %o', this.constructor.name)
      }
    }
    ;(t.Agent = e), (t.prototype = t.Agent.prototype)
  })(VD || (VD = {}))
  Qde.exports = VD
})
var Xde = handleExports(hT => {
  'use strict'
  var Gqe =
    (hT && hT.__importDefault) ||
    function (t) {
      return t && t.__esModule ? t : { default: t }
    }
  Object.defineProperty(hT, '__esModule', { value: !0 })
  var Vqe = Gqe(La()),
    mT = Vqe.default('https-proxy-agent:parse-proxy-response')
  function zqe(t) {
    return new Promise((e, r) => {
      let n = 0,
        i = []
      function o() {
        let p = t.read()
        p ? u(p) : t.once('readable', o)
      }
      function s() {
        t.removeListener('end', l),
          t.removeListener('error', c),
          t.removeListener('close', a),
          t.removeListener('readable', o)
      }
      function a(p) {
        mT('onclose had error %o', p)
      }
      function l() {
        mT('onend')
      }
      function c(p) {
        s(), mT('onerror %o', p), r(p)
      }
      function u(p) {
        i.push(p), (n += p.length)
        let d = Buffer.concat(i, n)
        if (
          d.indexOf(`\r
\r
`) === -1
        ) {
          mT('have not received end of HTTP headers yet...'), o()
          return
        }
        let m = d.toString(
            'ascii',
            0,
            d.indexOf(`\r
`)
          ),
          h = +m.split(' ')[1]
        mT('got proxy server response: %o', m), e({ statusCode: h, buffered: d })
      }
      t.on('error', c), t.on('close', a), t.on('end', l), o()
    })
  }
  hT.default = zqe
})
var efe = handleExports(sv => {
  'use strict'
  var $qe =
      (sv && sv.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    Hy =
      (sv && sv.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t }
      }
  Object.defineProperty(sv, '__esModule', { value: !0 })
  var Jde = Hy(require('net')),
    Zde = Hy(require('tls')),
    Wqe = Hy(require('url')),
    Kqe = Hy(require('assert')),
    Yqe = Hy(La()),
    Qqe = aB(),
    Xqe = Hy(Xde()),
    gT = Yqe.default('https-proxy-agent:agent'),
    cB = class extends Qqe.Agent {
      constructor(e) {
        let r
        if ((typeof e == 'string' ? (r = Wqe.default.parse(e)) : (r = e), !r))
          throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!')
        gT('creating new HttpsProxyAgent instance: %o', r), super(r)
        let n = Object.assign({}, r)
        ;(this.secureProxy = r.secureProxy || eHe(n.protocol)),
          (n.host = n.hostname || n.host),
          typeof n.port == 'string' && (n.port = parseInt(n.port, 10)),
          !n.port && n.host && (n.port = this.secureProxy ? 443 : 80),
          this.secureProxy && !('ALPNProtocols' in n) && (n.ALPNProtocols = ['http 1.1']),
          n.host && n.path && (delete n.path, delete n.pathname),
          (this.proxy = n)
      }
      callback(e, r) {
        return $qe(this, void 0, void 0, function* () {
          let { proxy: n, secureProxy: i } = this,
            o
          i
            ? (gT('Creating `tls.Socket`: %o', n), (o = Zde.default.connect(n)))
            : (gT('Creating `net.Socket`: %o', n), (o = Jde.default.connect(n)))
          let s = Object.assign({}, n.headers),
            l = `CONNECT ${`${r.host}:${r.port}`} HTTP/1.1\r
`
          n.auth && (s['Proxy-Authorization'] = `Basic ${Buffer.from(n.auth).toString('base64')}`)
          let { host: c, port: u, secureEndpoint: p } = r
          Zqe(u, p) || (c += `:${u}`), (s.Host = c), (s.Connection = 'close')
          for (let g of Object.keys(s))
            l += `${g}: ${s[g]}\r
`
          let d = Xqe.default(o)
          o.write(`${l}\r
`)
          let { statusCode: f, buffered: m } = yield d
          if (f === 200) {
            if ((e.once('socket', Jqe), r.secureEndpoint)) {
              gT('Upgrading socket connection to TLS')
              let g = r.servername || r.host
              return Zde.default.connect(
                Object.assign(Object.assign({}, tHe(r, 'host', 'hostname', 'path', 'port')), {
                  socket: o,
                  servername: g,
                })
              )
            }
            return o
          }
          o.destroy()
          let h = new Jde.default.Socket({ writable: !1 })
          return (
            (h.readable = !0),
            e.once('socket', g => {
              gT('replaying proxy buffer for failed request'),
                Kqe.default(g.listenerCount('data') > 0),
                g.push(m),
                g.push(null)
            }),
            h
          )
        })
      }
    }
  sv.default = cB
  function Jqe(t) {
    t.resume()
  }
  function Zqe(t, e) {
    return !!((!e && t === 80) || (e && t === 443))
  }
  function eHe(t) {
    return typeof t == 'string' ? /^https:?$/i.test(t) : !1
  }
  function tHe(t, ...e) {
    let r = {},
      n
    for (n in t) e.includes(n) || (r[n] = t[n])
    return r
  }
})
var rfe = handleExports((pB, tfe) => {
  'use strict'
  var rHe =
      (pB && pB.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t }
      },
    lB = rHe(efe())
  function uB(t) {
    return new lB.default(t)
  }
  ;(function (t) {
    ;(t.HttpsProxyAgent = lB.default), (t.prototype = lB.default.prototype)
  })(uB || (uB = {}))
  tfe.exports = uB
})
var nfe = handleExports(dB => {
  'use strict'
  Object.defineProperty(dB, '__esModule', { value: !0 })
  function nHe(t, e, { signal: r } = {}) {
    return new Promise((n, i) => {
      function o() {
        r?.removeEventListener('abort', o), t.removeListener(e, s), t.removeListener('error', a)
      }
      function s(...l) {
        o(), n(l)
      }
      function a(l) {
        o(), i(l)
      }
      r?.addEventListener('abort', o), t.on(e, s), t.on('error', a)
    })
  }
  dB.default = nHe
})
var ife = handleExports(av => {
  'use strict'
  var iHe =
      (av && av.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    vT =
      (av && av.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t }
      }
  Object.defineProperty(av, '__esModule', { value: !0 })
  var oHe = vT(require('net')),
    sHe = vT(require('tls')),
    fB = vT(require('url')),
    aHe = vT(La()),
    cHe = vT(nfe()),
    lHe = aB(),
    sm = (0, aHe.default)('http-proxy-agent')
  function uHe(t) {
    return typeof t == 'string' ? /^https:?$/i.test(t) : !1
  }
  var mB = class extends lHe.Agent {
    constructor(e) {
      let r
      if ((typeof e == 'string' ? (r = fB.default.parse(e)) : (r = e), !r))
        throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!')
      sm('Creating new HttpProxyAgent instance: %o', r), super(r)
      let n = Object.assign({}, r)
      ;(this.secureProxy = r.secureProxy || uHe(n.protocol)),
        (n.host = n.hostname || n.host),
        typeof n.port == 'string' && (n.port = parseInt(n.port, 10)),
        !n.port && n.host && (n.port = this.secureProxy ? 443 : 80),
        n.host && n.path && (delete n.path, delete n.pathname),
        (this.proxy = n)
    }
    callback(e, r) {
      return iHe(this, void 0, void 0, function* () {
        let { proxy: n, secureProxy: i } = this,
          o = fB.default.parse(e.path)
        o.protocol || (o.protocol = 'http:'),
          o.hostname || (o.hostname = r.hostname || r.host || null),
          o.port == null && typeof r.port && (o.port = String(r.port)),
          o.port === '80' && (o.port = ''),
          (e.path = fB.default.format(o)),
          n.auth && e.setHeader('Proxy-Authorization', `Basic ${Buffer.from(n.auth).toString('base64')}`)
        let s
        if (
          (i
            ? (sm('Creating `tls.Socket`: %o', n), (s = sHe.default.connect(n)))
            : (sm('Creating `net.Socket`: %o', n), (s = oHe.default.connect(n))),
          e._header)
        ) {
          let a, l
          sm('Regenerating stored HTTP header string for request'),
            (e._header = null),
            e._implicitHeader(),
            e.output && e.output.length > 0
              ? (sm('Patching connection write() output buffer with updated header'),
                (a = e.output[0]),
                (l =
                  a.indexOf(`\r
\r
`) + 4),
                (e.output[0] = e._header + a.substring(l)),
                sm('Output buffer: %o', e.output))
              : e.outputData &&
                e.outputData.length > 0 &&
                (sm('Patching connection write() output buffer with updated header'),
                (a = e.outputData[0].data),
                (l =
                  a.indexOf(`\r
\r
`) + 4),
                (e.outputData[0].data = e._header + a.substring(l)),
                sm('Output buffer: %o', e.outputData[0].data))
        }
        return yield (0, cHe.default)(s, 'connect'), s
      })
    }
  }
  av.default = mB
})
var sfe = handleExports((vB, ofe) => {
  'use strict'
  var pHe =
      (vB && vB.__importDefault) ||
      function (t) {
        return t && t.__esModule ? t : { default: t }
      },
    hB = pHe(ife())
  function gB(t) {
    return new hB.default(t)
  }
  ;(function (t) {
    ;(t.HttpProxyAgent = hB.default), (t.prototype = hB.default.prototype)
  })(gB || (gB = {}))
  ofe.exports = gB
})
function zD(t) {
  if (process.env[t]) return process.env[t]
  if (process.env[t.toLowerCase()]) return process.env[t.toLowerCase()]
}
function vHe() {
  if (!process) return
  let t = zD(dHe),
    e = zD(mHe),
    r = zD(fHe)
  return t || e || r
}
function _He(t, e, r) {
  if (e.length === 0) return !1
  let n = new URL(t).hostname
  if (r?.has(n)) return r.get(n)
  let i = !1
  for (let o of e)
    o[0] === '.' ? (n.endsWith(o) || (n.length === o.length - 1 && n === o.slice(1))) && (i = !0) : n === o && (i = !0)
  return r?.set(n, i), i
}
function yHe() {
  let t = zD(hHe)
  return (
    (pfe = !0),
    t
      ? t
          .split(',')
          .map(e => e.trim())
          .filter(e => e.length)
      : []
  )
}
function yB(t) {
  if (!t && ((t = vHe()), !t)) return
  let e = new URL(t)
  return {
    host: (e.protocol ? e.protocol + '//' : '') + e.hostname,
    port: Number.parseInt(e.port || '80'),
    username: e.username,
    password: e.password,
  }
}
function cfe(t, { headers: e, tlsSettings: r }) {
  let n
  try {
    n = new URL(t.host)
  } catch {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${t.host}".`)
  }
  r &&
    lo.warning(
      'TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.'
    )
  let i = { hostname: n.hostname, port: t.port, protocol: n.protocol, headers: e.toJSON() }
  return (
    t.username && t.password ? (i.auth = `${t.username}:${t.password}`) : t.username && (i.auth = `${t.username}`), i
  )
}
function xHe(t, e) {
  if (t.agent) return
  let n = new URL(t.url).protocol !== 'https:',
    i = t.proxySettings
  if (i)
    if (n) {
      if (!e.httpProxyAgent) {
        let o = cfe(i, t)
        e.httpProxyAgent = new ufe.HttpProxyAgent(o)
      }
      t.agent = e.httpProxyAgent
    } else {
      if (!e.httpsProxyAgent) {
        let o = cfe(i, t)
        e.httpsProxyAgent = new lfe.HttpsProxyAgent(o)
      }
      t.agent = e.httpsProxyAgent
    }
}
function $D(t = yB(), e) {
  pfe || afe.push(...yHe())
  let r = {}
  return {
    name: _B,
    async sendRequest(n, i) {
      var o
      return (
        !n.proxySettings &&
          !_He(
            n.url,
            (o = e?.customNoProxyList) !== null && o !== void 0 ? o : afe,
            e?.customNoProxyList ? void 0 : gHe
          ) &&
          (n.proxySettings = t),
        n.proxySettings && xHe(n, r),
        i(n)
      )
    },
  }
}
var lfe,
  ufe,
  dHe,
  fHe,
  mHe,
  hHe,
  _B,
  afe,
  pfe,
  gHe,
  xB = createGetter(() => {
    ;(lfe = handleDefaultExports(rfe())), (ufe = handleDefaultExports(sfe()))
    Ny()
    ;(dHe = 'HTTPS_PROXY'),
      (fHe = 'HTTP_PROXY'),
      (mHe = 'ALL_PROXY'),
      (hHe = 'NO_PROXY'),
      (_B = 'proxyPolicy'),
      (afe = []),
      (pfe = !1),
      (gHe = new Map())
  })
function WD(t = 'x-ms-client-request-id') {
  return {
    name: bB,
    async sendRequest(e, r) {
      return e.headers.has(t) || e.headers.set(t, e.requestId), r(e)
    },
  }
}
var bB,
  EB = createGetter(() => {
    bB = 'setClientRequestIdPolicy'
  })
function KD(t) {
  return { name: TB, sendRequest: async (e, r) => (e.tlsSettings || (e.tlsSettings = t), r(e)) }
}
var TB,
  SB = createGetter(() => {
    TB = 'tlsPolicy'
  })
function dfe(t = {}) {
  let e = new CB(t.parentContext)
  return t.span && (e = e.setValue(jy.span, t.span)), t.namespace && (e = e.setValue(jy.namespace, t.namespace)), e
}
var jy,
  CB,
  IB = createGetter(() => {
    jy = { span: Symbol.for('@azure/core-tracing span'), namespace: Symbol.for('@azure/core-tracing namespace') }
    CB = class t {
      constructor(e) {
        this._contextMap = e instanceof t ? new Map(e._contextMap) : new Map()
      }
      setValue(e, r) {
        let n = new t(this)
        return n._contextMap.set(e, r), n
      }
      getValue(e) {
        return this._contextMap.get(e)
      }
      deleteValue(e) {
        let r = new t(this)
        return r._contextMap.delete(e), r
      }
    }
  })
function bHe() {
  return {
    end: () => {},
    isRecording: () => !1,
    recordException: () => {},
    setAttribute: () => {},
    setStatus: () => {},
  }
}
function EHe() {
  return {
    createRequestHeaders: () => ({}),
    parseTraceparentHeader: () => {},
    startSpan: (t, e) => ({ span: bHe(), tracingContext: dfe({ parentContext: e.tracingContext }) }),
    withContext(t, e, ...r) {
      return e(...r)
    },
  }
}
function _T() {
  return wB || (wB = EHe()), wB
}
var wB,
  ffe = createGetter(() => {
    IB()
  })
function AB(t) {
  let { namespace: e, packageName: r, packageVersion: n } = t
  function i(c, u, p) {
    var d
    let f = _T().startSpan(
        c,
        Object.assign(Object.assign({}, p), {
          packageName: r,
          packageVersion: n,
          tracingContext: (d = u?.tracingOptions) === null || d === void 0 ? void 0 : d.tracingContext,
        })
      ),
      m = f.tracingContext,
      h = f.span
    m.getValue(jy.namespace) || (m = m.setValue(jy.namespace, e)),
      h.setAttribute('az.namespace', m.getValue(jy.namespace))
    let g = Object.assign({}, u, {
      tracingOptions: Object.assign(Object.assign({}, u?.tracingOptions), { tracingContext: m }),
    })
    return { span: h, updatedOptions: g }
  }
  async function o(c, u, p, d) {
    let { span: f, updatedOptions: m } = i(c, u, d)
    try {
      let h = await s(m.tracingOptions.tracingContext, () => Promise.resolve(p(m, f)))
      return f.setStatus({ status: 'success' }), h
    } catch (h) {
      throw (f.setStatus({ status: 'error', error: h }), h)
    } finally {
      f.end()
    }
  }
  function s(c, u, ...p) {
    return _T().withContext(c, u, ...p)
  }
  function a(c) {
    return _T().parseTraceparentHeader(c)
  }
  function l(c) {
    return _T().createRequestHeaders(c)
  }
  return { startSpan: i, withSpan: o, withContext: s, parseTraceparentHeader: a, createRequestHeaders: l }
}
var mfe = createGetter(() => {
  ffe()
  IB()
})
var hfe = createGetter(() => {
  mfe()
})
var gfe,
  vfe,
  _fe = createGetter(() => {
    ;(gfe = require('util')), (vfe = gfe.inspect.custom)
  })
function YD(t) {
  return t instanceof ga ? !0 : Oy(t) && t.name === 'RestError'
}
var THe,
  ga,
  QD = createGetter(() => {
    My()
    _fe()
    NU()
    ;(THe = new Fy()),
      (ga = class t extends Error {
        constructor(e, r = {}) {
          super(e),
            (this.name = 'RestError'),
            (this.code = r.code),
            (this.statusCode = r.statusCode),
            (this.request = r.request),
            (this.response = r.response),
            Object.setPrototypeOf(this, t.prototype)
        }
        [vfe]() {
          return `RestError: ${this.message}
 ${THe.sanitize(this)}`
        }
      })
    ga.REQUEST_SEND_ERROR = 'REQUEST_SEND_ERROR'
    ga.PARSE_ERROR = 'PARSE_ERROR'
  })
function XD(t = {}) {
  let e = ND(t.userAgentPrefix),
    r = SHe()
  return {
    name: RB,
    async sendRequest(n, i) {
      var o, s
      if (!r || !(!((o = n.tracingOptions) === null || o === void 0) && o.tracingContext)) return i(n)
      let { span: a, tracingContext: l } = (s = CHe(r, n, e)) !== null && s !== void 0 ? s : {}
      if (!a || !l) return i(n)
      try {
        let c = await r.withContext(l, i, n)
        return wHe(a, c), c
      } catch (c) {
        throw (IHe(a, c), c)
      }
    },
  }
}
function SHe() {
  try {
    return AB({ namespace: '', packageName: '@azure/core-rest-pipeline', packageVersion: PD })
  } catch (t) {
    lo.warning(`Error when creating the TracingClient: ${Ly(t)}`)
    return
  }
}
function CHe(t, e, r) {
  try {
    let { span: n, updatedOptions: i } = t.startSpan(
      `HTTP ${e.method}`,
      { tracingOptions: e.tracingOptions },
      { spanKind: 'client', spanAttributes: { 'http.method': e.method, 'http.url': e.url, requestId: e.requestId } }
    )
    if (!n.isRecording()) {
      n.end()
      return
    }
    r && n.setAttribute('http.user_agent', r)
    let o = t.createRequestHeaders(i.tracingOptions.tracingContext)
    for (let [s, a] of Object.entries(o)) e.headers.set(s, a)
    return { span: n, tracingContext: i.tracingOptions.tracingContext }
  } catch (n) {
    lo.warning(`Skipping creating a tracing span due to an error: ${Ly(n)}`)
    return
  }
}
function IHe(t, e) {
  try {
    t.setStatus({ status: 'error', error: Oy(e) ? e : void 0 }),
      YD(e) && e.statusCode && t.setAttribute('http.status_code', e.statusCode),
      t.end()
  } catch (r) {
    lo.warning(`Skipping tracing span processing due to an error: ${Ly(r)}`)
  }
}
function wHe(t, e) {
  try {
    t.setAttribute('http.status_code', e.status)
    let r = e.headers.get('x-ms-request-id')
    r && t.setAttribute('serviceRequestId', r), t.setStatus({ status: 'success' }), t.end()
  } catch (r) {
    lo.warning(`Skipping tracing span processing due to an error: ${Ly(r)}`)
  }
}
var RB,
  DB = createGetter(() => {
    hfe()
    FU()
    UU()
    Ny()
    My()
    QD()
    RB = 'tracingPolicy'
  })
function yfe(t) {
  let e = bD()
  return (
    ID && (t.tlsOptions && e.addPolicy(KD(t.tlsOptions)), e.addPolicy($D(t.proxyOptions)), e.addPolicy(OD())),
    e.addPolicy(GD()),
    e.addPolicy(kD(t.userAgentOptions)),
    e.addPolicy(WD()),
    e.addPolicy(qD(t.retryOptions), { phase: 'Retry' }),
    e.addPolicy(XD(t.userAgentOptions), { afterPhase: 'Retry' }),
    ID && e.addPolicy(DD(t.redirectOptions), { afterPhase: 'Retry' }),
    e.addPolicy(RD(t.loggingOptions), { afterPhase: 'Sign' }),
    e
  )
}
var xfe = createGetter(() => {
  OU()
  _U()
  MU()
  qU()
  jU()
  VU()
  nB()
  My()
  xB()
  EB()
  SB()
  DB()
})
function JD(t) {
  return t.toLowerCase()
}
function* AHe(t) {
  for (let e of t.values()) yield [e.name, e.value]
}
function Gy(t) {
  return new PB(t)
}
var PB,
  ZD = createGetter(() => {
    PB = class {
      constructor(e) {
        if (((this._headersMap = new Map()), e)) for (let r of Object.keys(e)) this.set(r, e[r])
      }
      set(e, r) {
        this._headersMap.set(JD(e), { name: e, value: String(r) })
      }
      get(e) {
        var r
        return (r = this._headersMap.get(JD(e))) === null || r === void 0 ? void 0 : r.value
      }
      has(e) {
        return this._headersMap.has(JD(e))
      }
      delete(e) {
        this._headersMap.delete(JD(e))
      }
      toJSON(e = {}) {
        let r = {}
        if (e.preserveCase) for (let n of this._headersMap.values()) r[n.name] = n.value
        else for (let [n, i] of this._headersMap) r[n] = i.value
        return r
      }
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: !0 }))
      }
      [Symbol.iterator]() {
        return AHe(this._headersMap)
      }
    }
  })
function yT(t) {
  return t && typeof t.pipe == 'function'
}
function bfe(t) {
  return new Promise(e => {
    t.on('close', e), t.on('end', e), t.on('error', e)
  })
}
function Tfe(t) {
  return t && typeof t.byteLength == 'number'
}
function DHe(t) {
  let e = Gy()
  for (let r of Object.keys(t.headers)) {
    let n = t.headers[r]
    Array.isArray(n) ? n.length > 0 && e.set(r, n[0]) : n && e.set(r, n)
  }
  return e
}
function PHe(t, e) {
  let r = e.get('Content-Encoding')
  if (r === 'gzip') {
    let n = tP.createGunzip()
    return t.pipe(n), n
  } else if (r === 'deflate') {
    let n = tP.createInflate()
    return t.pipe(n), n
  }
  return t
}
function NHe(t) {
  return new Promise((e, r) => {
    let n = []
    t.on('data', i => {
      Buffer.isBuffer(i) ? n.push(i) : n.push(Buffer.from(i))
    }),
      t.on('end', () => {
        e(Buffer.concat(n).toString('utf8'))
      }),
      t.on('error', i => {
        i && i?.name === 'AbortError'
          ? r(i)
          : r(new ga(`Error reading response as text: ${i.message}`, { code: ga.PARSE_ERROR }))
      })
  })
}
function kHe(t) {
  return t
    ? Buffer.isBuffer(t)
      ? t.length
      : yT(t)
      ? null
      : Tfe(t)
      ? t.byteLength
      : typeof t == 'string'
      ? Buffer.from(t).length
      : null
    : 0
}
function Sfe() {
  return new NB()
}
var Vy,
  zy,
  tP,
  Efe,
  RHe,
  eP,
  NB,
  Cfe = createGetter(() => {
    ;(Vy = handleDefaultExports(require('http'))), (zy = handleDefaultExports(require('https'))), (tP = handleDefaultExports(require('zlib'))), (Efe = require('stream'))
    AD()
    ZD()
    QD()
    Ny()
    RHe = {}
    ;(eP = class extends Efe.Transform {
      constructor(e) {
        super(), (this.loadedBytes = 0), (this.progressCallback = e)
      }
      _transform(e, r, n) {
        this.push(e), (this.loadedBytes += e.length)
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes }), n()
        } catch (i) {
          n(i)
        }
      }
    }),
      (NB = class {
        constructor() {
          this.cachedHttpsAgents = new WeakMap()
        }
        async sendRequest(e) {
          var r, n, i
          let o = new uT(),
            s
          if (e.abortSignal) {
            if (e.abortSignal.aborted) throw new ou('The operation was aborted.')
            ;(s = p => {
              p.type === 'abort' && o.abort()
            }),
              e.abortSignal.addEventListener('abort', s)
          }
          e.timeout > 0 &&
            setTimeout(() => {
              o.abort()
            }, e.timeout)
          let a = e.headers.get('Accept-Encoding'),
            l = a?.includes('gzip') || a?.includes('deflate'),
            c = typeof e.body == 'function' ? e.body() : e.body
          if (c && !e.headers.has('Content-Length')) {
            let p = kHe(c)
            p !== null && e.headers.set('Content-Length', p)
          }
          let u
          try {
            if (c && e.onUploadProgress) {
              let g = e.onUploadProgress,
                v = new eP(g)
              v.on('error', _ => {
                lo.error('Error in upload progress', _)
              }),
                yT(c) ? c.pipe(v) : v.end(c),
                (c = v)
            }
            let p = await this.makeRequest(e, o, c),
              d = DHe(p),
              m = { status: (r = p.statusCode) !== null && r !== void 0 ? r : 0, headers: d, request: e }
            if (e.method === 'HEAD') return p.resume(), m
            u = l ? PHe(p, d) : p
            let h = e.onDownloadProgress
            if (h) {
              let g = new eP(h)
              g.on('error', v => {
                lo.error('Error in download progress', v)
              }),
                u.pipe(g),
                (u = g)
            }
            return (
              (!((n = e.streamResponseStatusCodes) === null || n === void 0) && n.has(Number.POSITIVE_INFINITY)) ||
              (!((i = e.streamResponseStatusCodes) === null || i === void 0) && i.has(m.status))
                ? (m.readableStreamBody = u)
                : (m.bodyAsText = await NHe(u)),
              m
            )
          } finally {
            if (e.abortSignal && s) {
              let p = Promise.resolve()
              yT(c) && (p = bfe(c))
              let d = Promise.resolve()
              yT(u) && (d = bfe(u)),
                Promise.all([p, d])
                  .then(() => {
                    var f
                    s && ((f = e.abortSignal) === null || f === void 0 || f.removeEventListener('abort', s))
                  })
                  .catch(f => {
                    lo.warning('Error when cleaning up abortListener on httpRequest', f)
                  })
            }
          }
        }
        makeRequest(e, r, n) {
          var i
          let o = new URL(e.url),
            s = o.protocol !== 'https:'
          if (s && !e.allowInsecureConnection)
            throw new Error(`Cannot connect to ${e.url} while allowInsecureConnection is false.`)
          let l = {
            agent: (i = e.agent) !== null && i !== void 0 ? i : this.getOrCreateAgent(e, s),
            hostname: o.hostname,
            path: `${o.pathname}${o.search}`,
            port: o.port,
            method: e.method,
            headers: e.headers.toJSON({ preserveCase: !0 }),
          }
          return new Promise((c, u) => {
            let p = s ? Vy.request(l, c) : zy.request(l, c)
            p.once('error', d => {
              var f
              u(
                new ga(d.message, {
                  code: (f = d.code) !== null && f !== void 0 ? f : ga.REQUEST_SEND_ERROR,
                  request: e,
                })
              )
            }),
              r.signal.addEventListener('abort', () => {
                let d = new ou('The operation was aborted.')
                p.destroy(d), u(d)
              }),
              n && yT(n)
                ? n.pipe(p)
                : n
                ? typeof n == 'string' || Buffer.isBuffer(n)
                  ? p.end(n)
                  : Tfe(n)
                  ? p.end(ArrayBuffer.isView(n) ? Buffer.from(n.buffer) : Buffer.from(n))
                  : (lo.error('Unrecognized body type', n), u(new ga('Unrecognized body type')))
                : p.end()
          })
        }
        getOrCreateAgent(e, r) {
          var n
          let i = e.disableKeepAlive
          if (r)
            return i
              ? Vy.globalAgent
              : (this.cachedHttpAgent || (this.cachedHttpAgent = new Vy.Agent({ keepAlive: !0 })), this.cachedHttpAgent)
          {
            if (i && !e.tlsSettings) return zy.globalAgent
            let o = (n = e.tlsSettings) !== null && n !== void 0 ? n : RHe,
              s = this.cachedHttpsAgents.get(o)
            return (
              (s && s.options.keepAlive === !i) ||
                (lo.info('No cached TLS Agent exist, creating a new Agent'),
                (s = new zy.Agent(Object.assign({ keepAlive: !i }, o))),
                this.cachedHttpsAgents.set(o, s)),
              s
            )
          }
        }
      })
  })
function Ife() {
  return Sfe()
}
var wfe = createGetter(() => {
  Cfe()
})
function kB() {
  return rP > nP.length - 16 && (Afe.default.randomFillSync(nP), (rP = 0)), nP.slice(rP, (rP += 16))
}
var Afe,
  nP,
  rP,
  Rfe = createGetter(() => {
    ;(Afe = handleDefaultExports(require('crypto'))), (nP = new Uint8Array(256)), (rP = nP.length)
  })
var Dfe,
  Pfe = createGetter(() => {
    Dfe =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  })
function OHe(t) {
  return typeof t == 'string' && Dfe.test(t)
}
var Nfe,
  kfe = createGetter(() => {
    Pfe()
    Nfe = OHe
  })
function LHe(t, e = 0) {
  let r = (
    uo[t[e + 0]] +
    uo[t[e + 1]] +
    uo[t[e + 2]] +
    uo[t[e + 3]] +
    '-' +
    uo[t[e + 4]] +
    uo[t[e + 5]] +
    '-' +
    uo[t[e + 6]] +
    uo[t[e + 7]] +
    '-' +
    uo[t[e + 8]] +
    uo[t[e + 9]] +
    '-' +
    uo[t[e + 10]] +
    uo[t[e + 11]] +
    uo[t[e + 12]] +
    uo[t[e + 13]] +
    uo[t[e + 14]] +
    uo[t[e + 15]]
  ).toLowerCase()
  if (!Nfe(r)) throw TypeError('Stringified UUID is invalid')
  return r
}
var uo,
  Ofe,
  Lfe = createGetter(() => {
    kfe()
    uo = []
    for (let t = 0; t < 256; ++t) uo.push((t + 256).toString(16).substr(1))
    Ofe = LHe
  })
function MHe(t, e, r) {
  t = t || {}
  let n = t.random || (t.rng || kB)()
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), e)) {
    r = r || 0
    for (let i = 0; i < 16; ++i) e[r + i] = n[i]
    return e
  }
  return Ofe(n)
}
var OB,
  Mfe = createGetter(() => {
    Rfe()
    Lfe()
    OB = MHe
  })
var Ffe = createGetter(() => {
  Mfe()
})
function Ufe() {
  return OB()
}
var Bfe = createGetter(() => {
  Ffe()
})
function qfe(t) {
  return new LB(t)
}
var LB,
  Hfe = createGetter(() => {
    ZD()
    Bfe()
    LB = class {
      constructor(e) {
        var r, n, i, o, s, a, l
        ;(this.url = e.url),
          (this.body = e.body),
          (this.headers = (r = e.headers) !== null && r !== void 0 ? r : Gy()),
          (this.method = (n = e.method) !== null && n !== void 0 ? n : 'GET'),
          (this.timeout = (i = e.timeout) !== null && i !== void 0 ? i : 0),
          (this.formData = e.formData),
          (this.disableKeepAlive = (o = e.disableKeepAlive) !== null && o !== void 0 ? o : !1),
          (this.proxySettings = e.proxySettings),
          (this.streamResponseStatusCodes = e.streamResponseStatusCodes),
          (this.withCredentials = (s = e.withCredentials) !== null && s !== void 0 ? s : !1),
          (this.abortSignal = e.abortSignal),
          (this.tracingOptions = e.tracingOptions),
          (this.onUploadProgress = e.onUploadProgress),
          (this.onDownloadProgress = e.onDownloadProgress),
          (this.requestId = e.requestId || Ufe()),
          (this.allowInsecureConnection = (a = e.allowInsecureConnection) !== null && a !== void 0 ? a : !1),
          (this.enableBrowserStreams = (l = e.enableBrowserStreams) !== null && l !== void 0 ? l : !1)
      }
    }
  })
function Gfe(t = {}) {
  var e
  return su([By(Object.assign(Object.assign({}, t), { ignoreSystemErrors: !0 }))], {
    maxRetries: (e = t.maxRetries) !== null && e !== void 0 ? e : 3,
  })
}
var jfe,
  Vfe = createGetter(() => {
    BD()
    qy()
    jfe = 'exponentialRetryPolicy'
  })
function zfe(t = {}) {
  var e
  return {
    name: MB,
    sendRequest: su([By(Object.assign(Object.assign({}, t), { ignoreHttpStatusCodes: !0 }))], {
      maxRetries: (e = t.maxRetries) !== null && e !== void 0 ? e : 3,
    }).sendRequest,
  }
}
var MB,
  $fe = createGetter(() => {
    BD()
    qy()
    MB = 'systemErrorRetryPolicy'
  })
function Wfe(t = {}) {
  var e
  return {
    name: FB,
    sendRequest: su([FD()], { maxRetries: (e = t.maxRetries) !== null && e !== void 0 ? e : 3 }).sendRequest,
  }
}
var FB,
  Kfe = createGetter(() => {
    UD()
    qy()
    FB = 'throttlingRetryPolicy'
  })
async function UHe(t, e, r) {
  async function n() {
    if (Date.now() < r)
      try {
        return await t()
      } catch {
        return null
      }
    else {
      let o = await t()
      if (o === null) throw new Error('Failed to refresh access token.')
      return o
    }
  }
  let i = await n()
  for (; i === null; ) await LD(e), (i = await n())
  return i
}
function Yfe(t, e) {
  let r = null,
    n = null,
    i,
    o = Object.assign(Object.assign({}, FHe), e),
    s = {
      get isRefreshing() {
        return r !== null
      },
      get shouldRefresh() {
        var l
        return (
          !s.isRefreshing &&
          ((l = n?.expiresOnTimestamp) !== null && l !== void 0 ? l : 0) - o.refreshWindowInMs < Date.now()
        )
      },
      get mustRefresh() {
        return n === null || n.expiresOnTimestamp - o.forcedRefreshWindowInMs < Date.now()
      },
    }
  function a(l, c) {
    var u
    return (
      s.isRefreshing ||
        (r = UHe(
          () => t.getToken(l, c),
          o.retryIntervalInMs,
          (u = n?.expiresOnTimestamp) !== null && u !== void 0 ? u : Date.now()
        )
          .then(d => ((r = null), (n = d), (i = c.tenantId), n))
          .catch(d => {
            throw ((r = null), (n = null), (i = void 0), d)
          })),
      r
    )
  }
  return async (l, c) => (i !== c.tenantId || !!c.claims || s.mustRefresh ? a(l, c) : (s.shouldRefresh && a(l, c), n))
}
var FHe,
  Qfe = createGetter(() => {
    MD()
    FHe = { forcedRefreshWindowInMs: 1e3, retryIntervalInMs: 3e3, refreshWindowInMs: 1e3 * 60 * 2 }
  })
async function BHe(t) {
  let { scopes: e, getAccessToken: r, request: n } = t,
    i = { abortSignal: n.abortSignal, tracingOptions: n.tracingOptions },
    o = await r(e, i)
  o && t.request.headers.set('Authorization', `Bearer ${o.token}`)
}
function qHe(t) {
  let e = t.headers.get('WWW-Authenticate')
  if (t.status === 401 && e) return e
}
function Xfe(t) {
  var e
  let { credential: r, scopes: n, challengeCallbacks: i } = t,
    o = t.logger || lo,
    s = Object.assign(
      {
        authorizeRequest: (e = i?.authorizeRequest) !== null && e !== void 0 ? e : BHe,
        authorizeRequestOnChallenge: i?.authorizeRequestOnChallenge,
      },
      i
    ),
    a = r ? Yfe(r) : () => Promise.resolve(null)
  return {
    name: UB,
    async sendRequest(l, c) {
      if (!l.url.toLowerCase().startsWith('https://'))
        throw new Error('Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.')
      await s.authorizeRequest({ scopes: Array.isArray(n) ? n : [n], request: l, getAccessToken: a, logger: o })
      let u, p
      try {
        u = await c(l)
      } catch (d) {
        ;(p = d), (u = d.response)
      }
      if (
        s.authorizeRequestOnChallenge &&
        u?.status === 401 &&
        qHe(u) &&
        (await s.authorizeRequestOnChallenge({
          scopes: Array.isArray(n) ? n : [n],
          request: l,
          response: u,
          getAccessToken: a,
          logger: o,
        }))
      )
        return c(l)
      if (p) throw p
      return u
    },
  }
}
var UB,
  Jfe = createGetter(() => {
    Qfe()
    Ny()
    UB = 'bearerTokenAuthenticationPolicy'
  })
function Zfe() {
  return {
    name: BB,
    async sendRequest(t, e) {
      if (typeof t.body == 'string' && t.body.startsWith('[')) {
        let r = JSON.parse(t.body)
        Array.isArray(r) &&
          (t.body = r
            .map(
              n =>
                JSON.stringify(n) +
                `
`
            )
            .join(''))
      }
      return e(t)
    },
  }
}
var BB,
  eme = createGetter(() => {
    BB = 'ndJsonPolicy'
  })
var tme = {}
defineProperties(tme, {
  RestError: () => ga,
  bearerTokenAuthenticationPolicy: () => Xfe,
  bearerTokenAuthenticationPolicyName: () => UB,
  createDefaultHttpClient: () => Ife,
  createEmptyPipeline: () => bD,
  createHttpHeaders: () => Gy,
  createPipelineFromOptions: () => yfe,
  createPipelineRequest: () => qfe,
  decompressResponsePolicy: () => OD,
  decompressResponsePolicyName: () => HU,
  defaultRetryPolicy: () => qD,
  exponentialRetryPolicy: () => Gfe,
  exponentialRetryPolicyName: () => jfe,
  formDataPolicy: () => GD,
  formDataPolicyName: () => rB,
  getDefaultProxySettings: () => yB,
  isRestError: () => YD,
  logPolicy: () => RD,
  logPolicyName: () => kU,
  ndJsonPolicy: () => Zfe,
  ndJsonPolicyName: () => BB,
  proxyPolicy: () => $D,
  proxyPolicyName: () => _B,
  redirectPolicy: () => DD,
  redirectPolicyName: () => LU,
  retryPolicy: () => su,
  setClientRequestIdPolicy: () => WD,
  setClientRequestIdPolicyName: () => bB,
  systemErrorRetryPolicy: () => zfe,
  systemErrorRetryPolicyName: () => MB,
  throttlingRetryPolicy: () => Wfe,
  throttlingRetryPolicyName: () => FB,
  tlsPolicy: () => KD,
  tlsPolicyName: () => TB,
  tracingPolicy: () => XD,
  tracingPolicyName: () => RB,
  userAgentPolicy: () => kD,
  userAgentPolicyName: () => BU,
})
var rme = createGetter(() => {
  _U()
  xfe()
  wfe()
  ZD()
  Hfe()
  QD()
  jU()
  Vfe()
  EB()
  OU()
  xB()
  MU()
  $fe()
  Kfe()
  qy()
  DB()
  VU()
  qU()
  SB()
  nB()
  Jfe()
  eme()
})
var ome = handleExports((xT, ime) => {
  'use strict'
  var HHe =
      (xT && xT.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    jHe =
      (xT && xT.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    nme = (rme(), handleEsModuleExports(tme)),
    GHe = 'https://monitor.azure.com//.default'
  function VHe(t) {
    return null
  }
  var zHe = (function () {
    function t(e, r) {
      var n = r ? [r] : [GHe]
      this._azureTokenPolicy = nme.bearerTokenAuthenticationPolicy({ credential: e, scopes: n })
    }
    return (
      (t.prototype.addAuthorizationHeader = function (e) {
        return HHe(this, void 0, void 0, function () {
          var r, n
          return jHe(this, function (i) {
            switch (i.label) {
              case 0:
                return (
                  (r = 'authorization'),
                  (n = nme.createPipelineRequest({ url: 'https://' })),
                  [4, this._azureTokenPolicy.sendRequest(n, VHe)]
                )
              case 1:
                return i.sent(), (e.headers[r] = n.headers.get(r)), [2]
            }
          })
        })
      }),
      t
    )
  })()
  ime.exports = zHe
})
var ame = handleExports((K2t, sme) => {
  'use strict'
  var $He = on(),
    WHe = oo(),
    KHe = (function () {
      function t(e, r, n, i) {
        ;(this._buffer = []),
          (this._lastSend = 0),
          (this._isDisabled = e),
          (this._getBatchSize = r),
          (this._getBatchIntervalMs = n),
          (this._sender = i)
      }
      return (
        (t.prototype.setUseDiskRetryCaching = function (e, r, n) {
          this._sender.setDiskRetryMode(e, r, n)
        }),
        (t.prototype.send = function (e) {
          var r = this
          if (!this._isDisabled()) {
            if (!e) {
              $He.warn('Cannot send null/undefined telemetry')
              return
            }
            if ((this._buffer.push(e), this._buffer.length >= this._getBatchSize())) {
              this.triggerSend(!1)
              return
            }
            !this._timeoutHandle &&
              this._buffer.length > 0 &&
              (this._timeoutHandle = setTimeout(function () {
                ;(r._timeoutHandle = null), r.triggerSend(!1)
              }, this._getBatchIntervalMs()))
          }
        }),
        (t.prototype.triggerSend = function (e, r) {
          var n = this._buffer.length < 1
          n ||
            (e || WHe.isNodeExit
              ? (this._sender.saveOnCrash(this._buffer), typeof r == 'function' && r('data saved on crash'))
              : this._sender.send(this._buffer, r)),
            (this._lastSend = +new Date()),
            (this._buffer = []),
            clearTimeout(this._timeoutHandle),
            (this._timeoutHandle = null),
            n && typeof r == 'function' && r('no data to send')
        }),
        t
      )
    })()
  sme.exports = KHe
})
var cme = handleExports(iP => {
  'use strict'
  Object.defineProperty(iP, '__esModule', { value: !0 })
  iP.azureRoleEnvironmentTelemetryProcessor = void 0
  function YHe(t, e) {}
  iP.azureRoleEnvironmentTelemetryProcessor = YHe
})
var pme = handleExports($y => {
  'use strict'
  Object.defineProperty($y, '__esModule', { value: !0 })
  $y.getSamplingHashCode = $y.samplingTelemetryProcessor = void 0
  var lme = Ao()
  function QHe(t, e) {
    var r = t.sampleRate,
      n = !1
    return r == null ||
      r >= 100 ||
      (t.data && lme.TelemetryType.Metric === lme.baseTypeToTelemetryType(t.data.baseType))
      ? !0
      : (e.correlationContext && e.correlationContext.operation
          ? (n = ume(e.correlationContext.operation.id) < r)
          : (n = Math.random() * 100 < r),
        n)
  }
  $y.samplingTelemetryProcessor = QHe
  function ume(t) {
    var e = -2147483648,
      r = 2147483647,
      n = 5381
    if (!t) return 0
    for (; t.length < 8; ) t = t + t
    for (var i = 0; i < t.length; i++) n = ((((n << 5) + n) | 0) + t.charCodeAt(i)) | 0
    return (n = n <= e ? r : Math.abs(n)), (n / r) * 100
  }
  $y.getSamplingHashCode = ume
})
var dme = handleExports(oP => {
  'use strict'
  Object.defineProperty(oP, '__esModule', { value: !0 })
  oP.performanceMetricsTelemetryProcessor = void 0
  var qB = aD(),
    HB = Ao()
  function XHe(t, e) {
    switch ((e && e.addDocument(t), t.data.baseType)) {
      case HB.TelemetryTypeString.Exception:
        qB.countException()
        break
      case HB.TelemetryTypeString.Request:
        var r = t.data.baseData
        qB.countRequest(r.duration, r.success)
        break
      case HB.TelemetryTypeString.Dependency:
        var n = t.data.baseData
        qB.countDependency(n.duration, n.success)
        break
    }
    return !0
  }
  oP.performanceMetricsTelemetryProcessor = XHe
})
var fme = handleExports(Wy => {
  'use strict'
  var au =
    (Wy && Wy.__assign) ||
    function () {
      return (
        (au =
          Object.assign ||
          function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
              e = arguments[r]
              for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
          }),
        au.apply(this, arguments)
      )
    }
  Object.defineProperty(Wy, '__esModule', { value: !0 })
  Wy.preAggregatedMetricsTelemetryProcessor = void 0
  var JHe = Ao(),
    bT = Y7(),
    sP = Ao()
  function ZHe(t, e) {
    if (bT.isEnabled())
      switch (t.data.baseType) {
        case sP.TelemetryTypeString.Exception:
          var r = t.data.baseData
          r.properties = au(au({}, r.properties), {
            '_MS.ProcessedByMetricExtractors': "(Name:'Exceptions', Ver:'1.1')",
          })
          var n = { cloudRoleInstance: t.tags[e.keys.cloudRoleInstance], cloudRoleName: t.tags[e.keys.cloudRole] }
          bT.countException(n)
          break
        case sP.TelemetryTypeString.Trace:
          var i = t.data.baseData
          i.properties = au(au({}, i.properties), { '_MS.ProcessedByMetricExtractors': "(Name:'Traces', Ver:'1.1')" })
          var o = {
            cloudRoleInstance: t.tags[e.keys.cloudRoleInstance],
            cloudRoleName: t.tags[e.keys.cloudRole],
            traceSeverityLevel: JHe.SeverityLevel[i.severity],
          }
          bT.countTrace(o)
          break
        case sP.TelemetryTypeString.Request:
          var s = t.data.baseData
          s.properties = au(au({}, s.properties), { '_MS.ProcessedByMetricExtractors': "(Name:'Requests', Ver:'1.1')" })
          var a = {
            cloudRoleInstance: t.tags[e.keys.cloudRoleInstance],
            cloudRoleName: t.tags[e.keys.cloudRole],
            operationSynthetic: t.tags[e.keys.operationSyntheticSource],
            requestSuccess: s.success,
            requestResultCode: s.responseCode,
          }
          bT.countRequest(s.duration, a)
          break
        case sP.TelemetryTypeString.Dependency:
          var l = t.data.baseData
          l.properties = au(au({}, l.properties), {
            '_MS.ProcessedByMetricExtractors': "(Name:'Dependencies', Ver:'1.1')",
          })
          var c = {
            cloudRoleInstance: t.tags[e.keys.cloudRoleInstance],
            cloudRoleName: t.tags[e.keys.cloudRole],
            operationSynthetic: t.tags[e.keys.operationSyntheticSource],
            dependencySuccess: l.success,
            dependencyType: l.type,
            dependencyTarget: l.target,
            dependencyResultCode: l.resultCode,
          }
          bT.countDependency(l.duration, c)
          break
      }
    return !0
  }
  Wy.preAggregatedMetricsTelemetryProcessor = ZHe
})
var mme = handleExports(cu => {
  'use strict'
  var eje =
      (cu && cu.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r),
              Object.defineProperty(t, n, {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              })
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    aP =
      (cu && cu.__exportStar) ||
      function (t, e) {
        for (var r in t) r !== 'default' && !Object.prototype.hasOwnProperty.call(e, r) && eje(e, t, r)
      }
  Object.defineProperty(cu, '__esModule', { value: !0 })
  aP(cme(), cu)
  aP(pme(), cu)
  aP(dme(), cu)
  aP(fme(), cu)
})
var jB = handleExports((eRt, vme) => {
  'use strict'
  var xt = Ao(),
    Ps = oo(),
    hme = Wf(),
    tje = on(),
    rje = (function () {
      function t() {}
      return (
        (t.createEnvelope = function (e, r, n, i, o) {
          var s = null
          switch (r) {
            case xt.TelemetryType.Trace:
              s = t.createTraceData(e)
              break
            case xt.TelemetryType.Dependency:
              s = t.createDependencyData(e)
              break
            case xt.TelemetryType.Event:
              s = t.createEventData(e)
              break
            case xt.TelemetryType.Exception:
              s = t.createExceptionData(e)
              break
            case xt.TelemetryType.Request:
              s = t.createRequestData(e)
              break
            case xt.TelemetryType.Metric:
              s = t.createMetricData(e)
              break
            case xt.TelemetryType.Availability:
              s = t.createAvailabilityData(e)
              break
            case xt.TelemetryType.PageView:
              s = t.createPageViewData(e)
              break
          }
          if (s && s.baseData && xt.domainSupportsProperties(s.baseData)) {
            if (n)
              if (!s.baseData.properties) s.baseData.properties = n
              else for (var a in n) s.baseData.properties[a] || (s.baseData.properties[a] = n[a])
            t.addAzureFunctionsCorrelationProperties(s.baseData.properties),
              s.baseData.properties && (s.baseData.properties = Ps.validateStringMap(s.baseData.properties))
          }
          var l = (o && o.instrumentationKey) || '',
            c = new xt.Envelope()
          return (
            (c.data = s),
            (c.iKey = l),
            (c.name =
              'Microsoft.ApplicationInsights.' +
              l.replace(/-/g, '') +
              '.' +
              s.baseType.substr(0, s.baseType.length - 4)),
            (c.tags = this.getTags(i, e.tagOverrides)),
            (c.time = new Date().toISOString()),
            (c.ver = 1),
            (c.sampleRate = o ? o.samplingPercentage : 100),
            r === xt.TelemetryType.Metric && (c.sampleRate = 100),
            c
          )
        }),
        (t.addAzureFunctionsCorrelationProperties = function (e) {
          var r = hme.CorrelationContextManager.getCurrentContext()
          if (r && r.customProperties && r.customProperties.getProperty instanceof Function) {
            e = e || {}
            var n = r.customProperties.getProperty('InvocationId')
            n && (e.InvocationId = n),
              (n = r.customProperties.getProperty('ProcessId')),
              n && (e.ProcessId = n),
              (n = r.customProperties.getProperty('LogLevel')),
              n && (e.LogLevel = n),
              (n = r.customProperties.getProperty('Category')),
              n && (e.Category = n),
              (n = r.customProperties.getProperty('HostInstanceId')),
              n && (e.HostInstanceId = n),
              (n = r.customProperties.getProperty('AzFuncLiveLogsSessionId')),
              n && (e.AzFuncLiveLogsSessionId = n)
          }
        }),
        (t.truncateProperties = function (e) {
          if (e.properties)
            try {
              for (var r = {}, n = Object.keys(e.properties), i = Object.values(e.properties), o = 0; o < n.length; o++)
                n[o].length <= 150 &&
                  (Ps.isDate(i[o]) ||
                    (i[o] == null && (i[o] = ''),
                    typeof i[o] == 'object' && (i[o] = Ps.stringify(i[o])),
                    (r[n[o]] = String(i[o]).substring(0, 8192))),
                  (r[n[o]] = i[o]))
              return r
            } catch (s) {
              tje.warn('Failed to properly truncate telemetry properties: ', s)
            }
        }),
        (t.createTraceData = function (e) {
          var r,
            n = new xt.MessageData()
          ;(n.message = (r = e.message) === null || r === void 0 ? void 0 : r.substring(0, 32768)),
            (n.properties = this.truncateProperties(e)),
            isNaN(e.severity) ? (n.severityLevel = xt.SeverityLevel.Information) : (n.severityLevel = e.severity)
          var i = new xt.Data()
          return (i.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Trace)), (i.baseData = n), i
        }),
        (t.createDependencyData = function (e) {
          var r,
            n,
            i,
            o = new xt.RemoteDependencyData()
          ;(o.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 1024)),
            (o.data = (n = e.data) === null || n === void 0 ? void 0 : n.substring(0, 8192)),
            (o.target = (i = e.target) === null || i === void 0 ? void 0 : i.substring(0, 1024)),
            (o.duration = Ps.msToTimeSpan(e.duration)),
            (o.success = e.success),
            (o.type = e.dependencyTypeName),
            (o.properties = this.truncateProperties(e)),
            (o.resultCode = e.resultCode ? e.resultCode.toString() : '0'),
            e.id ? (o.id = e.id) : (o.id = Ps.w3cTraceId())
          var s = new xt.Data()
          return (s.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Dependency)), (s.baseData = o), s
        }),
        (t.createEventData = function (e) {
          var r,
            n = new xt.EventData()
          ;(n.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 512)),
            (n.properties = this.truncateProperties(e)),
            (n.measurements = e.measurements)
          var i = new xt.Data()
          return (i.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Event)), (i.baseData = n), i
        }),
        (t.createExceptionData = function (e) {
          var r,
            n,
            i = new xt.ExceptionData()
          ;(i.properties = this.truncateProperties(e)),
            isNaN(e.severity) ? (i.severityLevel = xt.SeverityLevel.Error) : (i.severityLevel = e.severity),
            (i.measurements = e.measurements),
            (i.exceptions = [])
          var o = e.exception.stack,
            s = new xt.ExceptionDetails()
          ;(s.message = (r = e.exception.message) === null || r === void 0 ? void 0 : r.substring(0, 32768)),
            (s.typeName = (n = e.exception.name) === null || n === void 0 ? void 0 : n.substring(0, 1024)),
            (s.parsedStack = this.parseStack(o)),
            (s.hasFullStack = Ps.isArray(s.parsedStack) && s.parsedStack.length > 0),
            i.exceptions.push(s)
          var a = new xt.Data()
          return (a.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Exception)), (a.baseData = i), a
        }),
        (t.createRequestData = function (e) {
          var r,
            n,
            i,
            o,
            s = new xt.RequestData()
          e.id ? (s.id = e.id) : (s.id = Ps.w3cTraceId()),
            (s.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 1024)),
            (s.url = (n = e.url) === null || n === void 0 ? void 0 : n.substring(0, 2048)),
            (s.source = (i = e.source) === null || i === void 0 ? void 0 : i.substring(0, 1024)),
            (s.duration = Ps.msToTimeSpan(e.duration)),
            (s.responseCode =
              (o = e.resultCode ? e.resultCode.toString() : '0') === null || o === void 0
                ? void 0
                : o.substring(0, 1024)),
            (s.success = e.success),
            (s.properties = this.truncateProperties(e)),
            (s.measurements = e.measurements)
          var a = new xt.Data()
          return (a.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Request)), (a.baseData = s), a
        }),
        (t.createMetricData = function (e) {
          var r,
            n = new xt.MetricData()
          n.metrics = []
          var i = new xt.DataPoint()
          ;(i.count = isNaN(e.count) ? 1 : e.count),
            (i.kind = xt.DataPointType.Aggregation),
            (i.max = isNaN(e.max) ? e.value : e.max),
            (i.min = isNaN(e.min) ? e.value : e.min),
            (i.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 1024)),
            (i.stdDev = isNaN(e.stdDev) ? 0 : e.stdDev),
            (i.value = e.value),
            (i.ns = e.namespace),
            n.metrics.push(i),
            (n.properties = this.truncateProperties(e))
          var o = new xt.Data()
          return (o.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Metric)), (o.baseData = n), o
        }),
        (t.createAvailabilityData = function (e) {
          var r,
            n,
            i = new xt.AvailabilityData()
          e.id ? (i.id = e.id) : (i.id = Ps.w3cTraceId()),
            (i.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 1024)),
            (i.duration = Ps.msToTimeSpan(e.duration)),
            (i.success = e.success),
            (i.runLocation = e.runLocation),
            (i.message = (n = e.message) === null || n === void 0 ? void 0 : n.substring(0, 8192)),
            (i.measurements = e.measurements),
            (i.properties = this.truncateProperties(e))
          var o = new xt.Data()
          return (o.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.Availability)), (o.baseData = i), o
        }),
        (t.createPageViewData = function (e) {
          var r,
            n,
            i = new xt.PageViewData()
          ;(i.name = (r = e.name) === null || r === void 0 ? void 0 : r.substring(0, 1024)),
            (i.duration = Ps.msToTimeSpan(e.duration)),
            (i.url = (n = e.url) === null || n === void 0 ? void 0 : n.substring(0, 2048)),
            (i.measurements = e.measurements),
            (i.properties = this.truncateProperties(e))
          var o = new xt.Data()
          return (o.baseType = xt.telemetryTypeToBaseType(xt.TelemetryType.PageView)), (o.baseData = i), o
        }),
        (t.getTags = function (e, r) {
          var n = hme.CorrelationContextManager.getCurrentContext(),
            i = {}
          if (e && e.tags) for (var o in e.tags) i[o] = e.tags[o]
          if (r) for (var o in r) i[o] = r[o]
          return (
            n &&
              ((i[e.keys.operationId] = i[e.keys.operationId] || n.operation.id),
              (i[e.keys.operationName] = i[e.keys.operationName] || n.operation.name),
              (i[e.keys.operationParentId] = i[e.keys.operationParentId] || n.operation.parentId)),
            i
          )
        }),
        (t.parseStack = function (e) {
          var r = void 0
          if (typeof e == 'string') {
            var n = e.split(`
`)
            r = []
            for (var i = 0, o = 0, s = 0; s <= n.length; s++) {
              var a = n[s]
              if (gme.regex.test(a)) {
                var l = new gme(n[s], i++)
                ;(o += l.sizeInBytes), r.push(l)
              }
            }
            var c = 32 * 1024
            if (o > c)
              for (var u = 0, p = r.length - 1, d = 0, f = u, m = p; u < p; ) {
                var h = r[u].sizeInBytes,
                  g = r[p].sizeInBytes
                if (((d += h + g), d > c)) {
                  var v = m - f + 1
                  r.splice(f, v)
                  break
                }
                ;(f = u), (m = p), u++, p--
              }
          }
          return r
        }),
        t
      )
    })(),
    gme = (function () {
      function t(e, r) {
        ;(this.sizeInBytes = 0), (this.level = r), (this.method = '<no_method>'), (this.assembly = Ps.trim(e))
        var n = e.match(t.regex)
        n &&
          n.length >= 5 &&
          ((this.method = Ps.trim(n[2]) || this.method),
          (this.fileName = Ps.trim(n[4]) || '<no_filename>'),
          (this.line = parseInt(n[5]) || 0)),
          (this.sizeInBytes += this.method.length),
          (this.sizeInBytes += this.fileName.length),
          (this.sizeInBytes += this.assembly.length),
          (this.sizeInBytes += t.baseSize),
          (this.sizeInBytes += this.level.toString().length),
          (this.sizeInBytes += this.line.toString().length)
      }
      return (t.regex = /^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/), (t.baseSize = 58), t
    })()
  vme.exports = rje
})
var _me = handleExports(am => {
  'use strict'
  var nje =
      (am && am.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    ije =
      (am && am.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      }
  Object.defineProperty(am, '__esModule', { value: !0 })
  am.FileAccessControl = void 0
  var oje = require('fs'),
    sje = require('os'),
    Ky = require('child_process'),
    aje = on(),
    cje = (function () {
      function t() {}
      return (
        (t.checkFileProtection = function () {
          if (!t.OS_PROVIDES_FILE_PROTECTION && !t.OS_FILE_PROTECTION_CHECKED)
            if (((t.OS_FILE_PROTECTION_CHECKED = !0), t.USE_ICACLS)) {
              try {
                t.OS_PROVIDES_FILE_PROTECTION = oje.existsSync(t.ICACLS_PATH)
              } catch {}
              t.OS_PROVIDES_FILE_PROTECTION ||
                aje.warn(
                  t.TAG,
                  'Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.'
                )
            } else t.OS_PROVIDES_FILE_PROTECTION = !0
        }),
        (t.applyACLRules = function (e) {
          return nje(this, void 0, void 0, function () {
            var r, n
            return ije(this, function (i) {
              switch (i.label) {
                case 0:
                  if (!t.USE_ICACLS) return [3, 7]
                  if (t.ACLED_DIRECTORIES[e] !== void 0) return [3, 6]
                  ;(t.ACLED_DIRECTORIES[e] = !1), (i.label = 1)
                case 1:
                  return i.trys.push([1, 4, , 5]), [4, this._getACLIdentity()]
                case 2:
                  return (r = i.sent()), [4, this._runICACLS(this._getACLArguments(e, r))]
                case 3:
                  return i.sent(), (t.ACLED_DIRECTORIES[e] = !0), [3, 5]
                case 4:
                  throw ((n = i.sent()), (t.ACLED_DIRECTORIES[e] = !1), n)
                case 5:
                  return [3, 7]
                case 6:
                  if (!t.ACLED_DIRECTORIES[e])
                    throw new Error('Setting ACL restrictions did not succeed (cached result)')
                  i.label = 7
                case 7:
                  return [2]
              }
            })
          })
        }),
        (t.applyACLRulesSync = function (e) {
          if (t.USE_ICACLS) {
            if (t.ACLED_DIRECTORIES[e] === void 0) {
              this._runICACLSSync(this._getACLArguments(e, this._getACLIdentitySync())), (t.ACLED_DIRECTORIES[e] = !0)
              return
            } else if (!t.ACLED_DIRECTORIES[e])
              throw new Error('Setting ACL restrictions did not succeed (cached result)')
          }
        }),
        (t._runICACLS = function (e) {
          return new Promise(function (r, n) {
            var i = Ky.spawn(t.ICACLS_PATH, e, { windowsHide: !0 })
            i.on('error', function (o) {
              return n(o)
            }),
              i.on('close', function (o, s) {
                o === 0
                  ? r()
                  : n(new Error('Setting ACL restrictions did not succeed (ICACLS returned code ' + o + ')'))
              })
          })
        }),
        (t._runICACLSSync = function (e) {
          if (Ky.spawnSync) {
            var r = Ky.spawnSync(t.ICACLS_PATH, e, { windowsHide: !0 })
            if (r.error) throw r.error
            if (r.status !== 0)
              throw new Error('Setting ACL restrictions did not succeed (ICACLS returned code ' + r.status + ')')
          } else throw new Error('Could not synchronously call ICACLS under current version of Node.js')
        }),
        (t._getACLIdentity = function () {
          return new Promise(function (e, r) {
            t.ACL_IDENTITY && e(t.ACL_IDENTITY)
            var n = Ky.spawn(
                t.POWERSHELL_PATH,
                ['-Command', '[System.Security.Principal.WindowsIdentity]::GetCurrent().Name'],
                { windowsHide: !0, stdio: ['ignore', 'pipe', 'pipe'] }
              ),
              i = ''
            n.stdout.on('data', function (o) {
              return (i += o)
            }),
              n.on('error', function (o) {
                return r(o)
              }),
              n.on('close', function (o, s) {
                ;(t.ACL_IDENTITY = i && i.trim()),
                  o === 0
                    ? e(t.ACL_IDENTITY)
                    : r(new Error('Getting ACL identity did not succeed (PS returned code ' + o + ')'))
              })
          })
        }),
        (t._getACLIdentitySync = function () {
          if (t.ACL_IDENTITY) return t.ACL_IDENTITY
          if (Ky.spawnSync) {
            var e = Ky.spawnSync(
              t.POWERSHELL_PATH,
              ['-Command', '[System.Security.Principal.WindowsIdentity]::GetCurrent().Name'],
              { windowsHide: !0, stdio: ['ignore', 'pipe', 'pipe'] }
            )
            if (e.error) throw e.error
            if (e.status !== 0)
              throw new Error('Getting ACL identity did not succeed (PS returned code ' + e.status + ')')
            return (t.ACL_IDENTITY = e.stdout && e.stdout.toString().trim()), t.ACL_IDENTITY
          } else throw new Error('Could not synchronously get ACL identity under current version of Node.js')
        }),
        (t._getACLArguments = function (e, r) {
          return [e, '/grant', '*S-1-5-32-544:(OI)(CI)F', '/grant', r + ':(OI)(CI)F', '/inheritance:r']
        }),
        (t.TAG = 'FileAccessControl'),
        (t.ICACLS_PATH = process.env.systemdrive + '/windows/system32/icacls.exe'),
        (t.POWERSHELL_PATH = process.env.systemdrive + '/windows/system32/windowspowershell/v1.0/powershell.exe'),
        (t.ACLED_DIRECTORIES = {}),
        (t.ACL_IDENTITY = null),
        (t.OS_FILE_PROTECTION_CHECKED = !1),
        (t.OS_PROVIDES_FILE_PROTECTION = !1),
        (t.USE_ICACLS = sje.type() === 'Windows_NT'),
        t
      )
    })()
  am.FileAccessControl = cje
})
var VB = handleExports((TT, xme) => {
  'use strict'
  var cP =
      (TT && TT.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    lP =
      (TT && TT.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    GB = require('fs'),
    lje = require('os'),
    cv = require('path'),
    uje = require('zlib'),
    cm = xn(),
    pje = Ry(),
    Hp = o6(),
    Ns = oo(),
    dje = require('url'),
    yme = on(),
    ET = _me(),
    fje = 439,
    mje = 402,
    hje = [200, 206, 402, 408, 429, 439, 500],
    gje = (function () {
      function t(e, r, n, i, o, s, a) {
        ;(this._redirectedHost = null),
          (this._config = e),
          (this._onSuccess = n),
          (this._onError = i),
          (this._statsbeat = o),
          (this._enableDiskRetryMode = !1),
          (this._resendInterval = t.WAIT_BETWEEN_RESEND),
          (this._maxBytesOnDisk = t.MAX_BYTES_ON_DISK),
          (this._numConsecutiveFailures = 0),
          (this._numConsecutiveRedirects = 0),
          (this._resendTimer = null),
          (this._getAuthorizationHandler = r),
          (this._fileCleanupTimer = null),
          (this._tempDir = cv.join(lje.tmpdir(), t.TEMPDIR_PREFIX + this._config.instrumentationKey)),
          (this._isStatsbeatSender = s || !1),
          (this._shutdownStatsbeat = a),
          (this._failedToIngestCounter = 0),
          (this._statsbeatHasReachedIngestionAtLeastOnce = !1)
      }
      return (
        (t.prototype.setDiskRetryMode = function (e, r, n) {
          var i = this
          e && ET.FileAccessControl.checkFileProtection(),
            (this._enableDiskRetryMode = ET.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && e),
            typeof r == 'number' && r >= 0 && (this._resendInterval = Math.floor(r)),
            typeof n == 'number' && n >= 0 && (this._maxBytesOnDisk = Math.floor(n)),
            e &&
              !ET.FileAccessControl.OS_PROVIDES_FILE_PROTECTION &&
              ((this._enableDiskRetryMode = !1),
              this._logWarn(
                'Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.'
              )),
            this._enableDiskRetryMode
              ? (this._statsbeat && this._statsbeat.addFeature(cm.StatsbeatFeature.DISK_RETRY),
                this._fileCleanupTimer ||
                  ((this._fileCleanupTimer = setTimeout(function () {
                    i._fileCleanupTask()
                  }, t.CLEANUP_TIMEOUT)),
                  this._fileCleanupTimer.unref()))
              : (this._statsbeat && this._statsbeat.removeFeature(cm.StatsbeatFeature.DISK_RETRY),
                this._fileCleanupTimer && clearTimeout(this._fileCleanupTimer))
        }),
        (t.prototype.send = function (e, r) {
          return cP(this, void 0, void 0, function () {
            var n,
              i,
              o,
              s,
              a,
              l,
              c,
              u,
              p = this
            return lP(this, function (d) {
              switch (d.label) {
                case 0:
                  if (!e) return [3, 5]
                  if (
                    ((n = this._redirectedHost || this._config.endpointUrl),
                    (i = new dje.URL(n).hostname),
                    (o = {
                      method: 'POST',
                      withCredentials: !1,
                      headers: { 'Content-Type': 'application/x-json-stream' },
                    }),
                    (s = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null),
                    !s)
                  )
                    return [3, 4]
                  this._statsbeat && this._statsbeat.addFeature(cm.StatsbeatFeature.AAD_HANDLING), (d.label = 1)
                case 1:
                  return d.trys.push([1, 3, , 4]), [4, s.addAuthorizationHeader(o)]
                case 2:
                  return d.sent(), [3, 4]
                case 3:
                  return (
                    (a = d.sent()),
                    (l = 'Failed to get AAD bearer token for the Application.'),
                    this._enableDiskRetryMode &&
                      ((l += 'This batch of telemetry items will be retried. '), this._storeToDisk(e)),
                    (l += 'Error:' + a.toString()),
                    this._logWarn(l),
                    typeof r == 'function' && r(l),
                    [2]
                  )
                case 4:
                  ;(c = ''),
                    e.forEach(function (f) {
                      var m = Ns.stringify(f)
                      typeof m == 'string' &&
                        (c +=
                          m +
                          `
`)
                    }),
                    c.length > 0 && (c = c.substring(0, c.length - 1)),
                    (u = Buffer.from ? Buffer.from(c) : new Buffer(c)),
                    uje.gzip(u, function (f, m) {
                      var h = m
                      f
                        ? (p._logWarn(Ns.dumpObj(f)), (h = u), (o.headers['Content-Length'] = u.length.toString()))
                        : ((o.headers['Content-Encoding'] = 'gzip'),
                          (o.headers['Content-Length'] = m.length.toString())),
                        p._logInfo(Ns.dumpObj(o)),
                        (o[pje.disableCollectionRequestOption] = !0)
                      var g = +new Date(),
                        v = function (y) {
                          y.setEncoding('utf-8')
                          var b = ''
                          y.on('data', function (x) {
                            b += x
                          }),
                            y.on('end', function () {
                              var x = +new Date(),
                                P = x - g
                              if (
                                ((p._numConsecutiveFailures = 0),
                                p._isStatsbeatSender &&
                                  !p._statsbeatHasReachedIngestionAtLeastOnce &&
                                  (hje.includes(y.statusCode)
                                    ? (p._statsbeatHasReachedIngestionAtLeastOnce = !0)
                                    : p._statsbeatFailedToIngest()),
                                p._statsbeat &&
                                  (y.statusCode == mje || y.statusCode == fje
                                    ? p._statsbeat.countThrottle(cm.StatsbeatNetworkCategory.Breeze, i, y.statusCode)
                                    : p._statsbeat.countRequest(
                                        cm.StatsbeatNetworkCategory.Breeze,
                                        i,
                                        P,
                                        y.statusCode === 200,
                                        y.statusCode
                                      )),
                                p._enableDiskRetryMode)
                              ) {
                                if (y.statusCode === 200)
                                  p._resendTimer ||
                                    ((p._resendTimer = setTimeout(function () {
                                      ;(p._resendTimer = null), p._sendFirstFileOnDisk()
                                    }, p._resendInterval)),
                                    p._resendTimer.unref())
                                else if (p._isRetriable(y.statusCode))
                                  try {
                                    p._statsbeat &&
                                      p._statsbeat.countRetry(cm.StatsbeatNetworkCategory.Breeze, i, y.statusCode)
                                    var U = JSON.parse(b),
                                      H = []
                                    U.errors &&
                                      (U.errors.forEach(function (F) {
                                        ;(F.statusCode == 429 || F.statusCode == 500 || F.statusCode == 503) &&
                                          H.push(e[F.index])
                                      }),
                                      H.length > 0 && p._storeToDisk(H))
                                  } catch {
                                    p._storeToDisk(e)
                                  }
                              }
                              if (y.statusCode === 307 || y.statusCode === 308)
                                if ((p._numConsecutiveRedirects++, p._numConsecutiveRedirects < 10)) {
                                  var j = y.headers.location ? y.headers.location.toString() : null
                                  j && ((p._redirectedHost = j), p.send(e, r))
                                } else {
                                  var M = {
                                    name: 'Circular Redirect',
                                    message: 'Error sending telemetry because of circular redirects.',
                                  }
                                  p._statsbeat && p._statsbeat.countException(cm.StatsbeatNetworkCategory.Breeze, i, M),
                                    typeof r == 'function' &&
                                      r('Error sending telemetry because of circular redirects.')
                                }
                              else
                                (p._numConsecutiveRedirects = 0),
                                  typeof r == 'function' && r(b),
                                  p._logInfo(b),
                                  typeof p._onSuccess == 'function' && p._onSuccess(b)
                            })
                        },
                        _ = Ns.makeRequest(p._config, n, o, v)
                      _.setTimeout(t.HTTP_TIMEOUT, function () {
                        ;(p._requestTimedOut = !0), _.abort()
                      }),
                        _.on('error', function (y) {
                          if (
                            (p._isStatsbeatSender &&
                              !p._statsbeatHasReachedIngestionAtLeastOnce &&
                              p._statsbeatFailedToIngest(),
                            p._numConsecutiveFailures++,
                            p._statsbeat && p._statsbeat.countException(cm.StatsbeatNetworkCategory.Breeze, i, y),
                            !p._enableDiskRetryMode ||
                              (p._numConsecutiveFailures > 0 &&
                                p._numConsecutiveFailures % t.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0))
                          ) {
                            var b =
                              'Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:'
                            p._enableDiskRetryMode &&
                              (b =
                                'Ingestion endpoint could not be reached ' +
                                p._numConsecutiveFailures +
                                ' consecutive times. There may be resulting telemetry loss. Most recent error:'),
                              p._logWarn(b, Ns.dumpObj(y))
                          } else {
                            var b =
                              'Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:'
                            p._logInfo(b, Ns.dumpObj(y))
                          }
                          p._onErrorHelper(y),
                            typeof r == 'function' &&
                              (y
                                ? (p._requestTimedOut &&
                                    ((y.name = 'telemetry timeout'), (y.message = 'telemetry request timed out')),
                                  r(Ns.dumpObj(y)))
                                : r('Error sending telemetry')),
                            p._enableDiskRetryMode && p._storeToDisk(e)
                        }),
                        _.write(h),
                        _.end()
                    }),
                    (d.label = 5)
                case 5:
                  return [2]
              }
            })
          })
        }),
        (t.prototype.saveOnCrash = function (e) {
          this._enableDiskRetryMode && this._storeToDiskSync(Ns.stringify(e))
        }),
        (t.prototype._isRetriable = function (e) {
          return (
            e === 206 ||
            e === 401 ||
            e === 403 ||
            e === 408 ||
            e === 429 ||
            e === 500 ||
            e === 502 ||
            e === 503 ||
            e === 504
          )
        }),
        (t.prototype._logInfo = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          this._isStatsbeatSender || yme.info(t.TAG, e, r)
        }),
        (t.prototype._logWarn = function (e) {
          for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n]
          this._isStatsbeatSender || yme.warn(t.TAG, e, r)
        }),
        (t.prototype._statsbeatFailedToIngest = function () {
          this._shutdownStatsbeat &&
            (this._failedToIngestCounter++, this._failedToIngestCounter >= 3 && this._shutdownStatsbeat())
        }),
        (t.prototype._storeToDisk = function (e) {
          return cP(this, void 0, void 0, function () {
            var r, n, i, o, s, a, l
            return lP(this, function (c) {
              switch (c.label) {
                case 0:
                  return (
                    c.trys.push([0, 2, , 3]),
                    this._logInfo('Checking existence of data storage directory: ' + this._tempDir),
                    [4, Hp.confirmDirExists(this._tempDir)]
                  )
                case 1:
                  return c.sent(), [3, 3]
                case 2:
                  return (
                    (r = c.sent()),
                    this._logWarn('Failed to create folder to put telemetry: ' + Ns.dumpObj(r)),
                    this._onErrorHelper(r),
                    [2]
                  )
                case 3:
                  return c.trys.push([3, 5, , 6]), [4, ET.FileAccessControl.applyACLRules(this._tempDir)]
                case 4:
                  return c.sent(), [3, 6]
                case 5:
                  return (
                    (n = c.sent()),
                    this._logWarn('Failed to apply file access control to folder: ' + Ns.dumpObj(n)),
                    this._onErrorHelper(n),
                    [2]
                  )
                case 6:
                  return c.trys.push([6, 8, , 9]), [4, Hp.getShallowDirectorySize(this._tempDir)]
                case 7:
                  return (
                    (i = c.sent()),
                    i > this._maxBytesOnDisk
                      ? (this._logWarn(
                          'Not saving data due to max size limit being met. Directory size in bytes is: ' + i
                        ),
                        [2])
                      : [3, 9]
                  )
                case 8:
                  return (
                    (o = c.sent()),
                    this._logWarn('Failed to read directory for retriable telemetry: ' + Ns.dumpObj(o)),
                    this._onErrorHelper(o),
                    [2]
                  )
                case 9:
                  return (
                    c.trys.push([9, 11, , 12]),
                    (s = new Date().getTime() + '.ai.json'),
                    (a = cv.join(this._tempDir, s)),
                    this._logInfo('saving data to disk at: ' + a),
                    [4, Hp.writeFileAsync(a, Ns.stringify(e), { mode: 384 })]
                  )
                case 10:
                  return c.sent(), [3, 12]
                case 11:
                  return (
                    (l = c.sent()),
                    this._logWarn('Failed to persist telemetry to disk: ' + Ns.dumpObj(l)),
                    this._onErrorHelper(l),
                    [2]
                  )
                case 12:
                  return [2]
              }
            })
          })
        }),
        (t.prototype._storeToDiskSync = function (e) {
          try {
            this._logInfo('Checking existence of data storage directory: ' + this._tempDir),
              GB.existsSync(this._tempDir) || GB.mkdirSync(this._tempDir),
              ET.FileAccessControl.applyACLRulesSync(this._tempDir)
            var r = Hp.getShallowDirectorySizeSync(this._tempDir)
            if (r > this._maxBytesOnDisk) {
              this._logInfo('Not saving data due to max size limit being met. Directory size in bytes is: ' + r)
              return
            }
            var n = new Date().getTime() + '.ai.json',
              i = cv.join(this._tempDir, n)
            this._logInfo('saving data before crash to disk at: ' + i), GB.writeFileSync(i, e, { mode: 384 })
          } catch (o) {
            this._logWarn('Error while saving data to disk: ' + Ns.dumpObj(o)), this._onErrorHelper(o)
          }
        }),
        (t.prototype._sendFirstFileOnDisk = function () {
          return cP(this, void 0, void 0, function () {
            var e, r, n, i, o, s
            return lP(this, function (a) {
              switch (a.label) {
                case 0:
                  return a.trys.push([0, 6, , 7]), [4, Hp.readdirAsync(this._tempDir)]
                case 1:
                  return (
                    (e = a.sent()),
                    (e = e.filter(function (l) {
                      return cv.basename(l).indexOf('.ai.json') > -1
                    })),
                    e.length > 0 ? ((r = e[0]), (n = cv.join(this._tempDir, r)), [4, Hp.readFileAsync(n)]) : [3, 5]
                  )
                case 2:
                  return (i = a.sent()), [4, Hp.unlinkAsync(n)]
                case 3:
                  return a.sent(), (o = JSON.parse(i.toString())), [4, this.send(o)]
                case 4:
                  a.sent(), (a.label = 5)
                case 5:
                  return [3, 7]
                case 6:
                  return (s = a.sent()), this._onErrorHelper(s), [3, 7]
                case 7:
                  return [2]
              }
            })
          })
        }),
        (t.prototype._onErrorHelper = function (e) {
          typeof this._onError == 'function' && this._onError(e)
        }),
        (t.prototype._fileCleanupTask = function () {
          return cP(this, void 0, void 0, function () {
            var e,
              r,
              n,
              i,
              o,
              s,
              a = this
            return lP(this, function (l) {
              switch (l.label) {
                case 0:
                  return l.trys.push([0, 6, , 7]), [4, Hp.readdirAsync(this._tempDir)]
                case 1:
                  if (
                    ((e = l.sent()),
                    (e = e.filter(function (c) {
                      return cv.basename(c).indexOf('.ai.json') > -1
                    })),
                    !(e.length > 0))
                  )
                    return [3, 5]
                  ;(r = 0), (l.label = 2)
                case 2:
                  return r < e.length
                    ? ((n = new Date(parseInt(e[r].split('.ai.json')[0]))),
                      (i = new Date(+new Date() - t.FILE_RETEMPTION_PERIOD) > n),
                      i
                        ? ((o = cv.join(this._tempDir, e[r])),
                          [
                            4,
                            Hp.unlinkAsync(o).catch(function (c) {
                              a._onErrorHelper(c)
                            }),
                          ])
                        : [3, 4])
                    : [3, 5]
                case 3:
                  l.sent(), (l.label = 4)
                case 4:
                  return r++, [3, 2]
                case 5:
                  return [3, 7]
                case 6:
                  return (s = l.sent()), s.code != 'ENOENT' && this._onErrorHelper(s), [3, 7]
                case 7:
                  return [2]
              }
            })
          })
        }),
        (t.TAG = 'Sender'),
        (t.WAIT_BETWEEN_RESEND = 60 * 1e3),
        (t.MAX_BYTES_ON_DISK = 50 * 1024 * 1024),
        (t.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5),
        (t.CLEANUP_TIMEOUT = 60 * 60 * 1e3),
        (t.FILE_RETEMPTION_PERIOD = 7 * 24 * 60 * 60 * 1e3),
        (t.TEMPDIR_PREFIX = 'appInsights-node'),
        (t.HTTP_TIMEOUT = 2e4),
        t
      )
    })()
  xme.exports = gje
})
var Eme = handleExports(uP => {
  'use strict'
  Object.defineProperty(uP, '__esModule', { value: !0 })
  uP.AzureVirtualMachine = void 0
  var bme = on(),
    vje = oo(),
    _je = Ry(),
    yje = 'http://169.254.169.254/metadata/instance/compute',
    xje = 'api-version=2017-12-01',
    bje = 'format=json',
    Eje = 'UNREACH',
    Tje = (function () {
      function t() {}
      return (
        (t.getAzureComputeMetadata = function (e, r) {
          var n,
            i = this,
            o = {},
            s = yje + '?' + xje + '&' + bje,
            a =
              ((n = { method: 'GET' }),
              (n[_je.disableCollectionRequestOption] = !0),
              (n.headers = { Metadata: 'True' }),
              n),
            l = vje.makeRequest(
              e,
              s,
              a,
              function (c) {
                if (c.statusCode === 200) {
                  o.isVM = !0
                  var u = ''
                  c.on('data', function (p) {
                    u += p
                  }),
                    c.on('end', function () {
                      try {
                        var p = JSON.parse(u)
                        ;(o.id = p.vmId || ''), (o.subscriptionId = p.subscriptionId || ''), (o.osType = p.osType || '')
                      } catch (d) {
                        bme.info(t.TAG, d)
                      }
                      r(o)
                    })
                } else r(o)
              },
              !1,
              !1
            )
          l &&
            (setTimeout(function () {
              ;(i._requestTimedOut = !0), l.abort()
            }, t.HTTP_TIMEOUT),
            l.on('error', function (c) {
              i._requestTimedOut && c && ((c.name = 'telemetry timeout'), (c.message = 'telemetry request timed out')),
                c && c.message && c.message.indexOf(Eje) > -1 ? (o.isVM = !1) : bme.info(t.TAG, c),
                r(o)
            }),
            l.end())
        }),
        (t.HTTP_TIMEOUT = 2500),
        (t.TAG = 'AzureVirtualMachine'),
        t
      )
    })()
  uP.AzureVirtualMachine = Tje
})
var Tme = handleExports(pP => {
  'use strict'
  Object.defineProperty(pP, '__esModule', { value: !0 })
  pP.NetworkStatsbeat = void 0
  var Sje = (function () {
    function t(e, r) {
      ;(this.endpoint = e),
        (this.host = r),
        (this.totalRequestCount = 0),
        (this.totalSuccesfulRequestCount = 0),
        (this.totalFailedRequestCount = []),
        (this.retryCount = []),
        (this.exceptionCount = []),
        (this.throttleCount = []),
        (this.intervalRequestExecutionTime = 0),
        (this.lastIntervalRequestExecutionTime = 0),
        (this.lastTime = +new Date()),
        (this.lastRequestCount = 0)
    }
    return t
  })()
  pP.NetworkStatsbeat = Sje
})
var Ame = handleExports((lv, wme) => {
  'use strict'
  var lu =
      (lv && lv.__assign) ||
      function () {
        return (
          (lu =
            Object.assign ||
            function (t) {
              for (var e, r = 1, n = arguments.length; r < n; r++) {
                e = arguments[r]
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
              }
              return t
            }),
          lu.apply(this, arguments)
        )
      },
    zB =
      (lv && lv.__awaiter) ||
      function (t, e, r, n) {
        function i(o) {
          return o instanceof r
            ? o
            : new r(function (s) {
                s(o)
              })
        }
        return new (r || (r = Promise))(function (o, s) {
          function a(u) {
            try {
              c(n.next(u))
            } catch (p) {
              s(p)
            }
          }
          function l(u) {
            try {
              c(n.throw(u))
            } catch (p) {
              s(p)
            }
          }
          function c(u) {
            u.done ? o(u.value) : i(u.value).then(a, l)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
    $B =
      (lv && lv.__generator) ||
      function (t, e) {
        var r = {
            label: 0,
            sent: function () {
              if (o[0] & 1) throw o[1]
              return o[1]
            },
            trys: [],
            ops: [],
          },
          n,
          i,
          o,
          s
        return (
          (s = { next: a(0), throw: a(1), return: a(2) }),
          typeof Symbol == 'function' &&
            (s[Symbol.iterator] = function () {
              return this
            }),
          s
        )
        function a(c) {
          return function (u) {
            return l([c, u])
          }
        }
        function l(c) {
          if (n) throw new TypeError('Generator is already executing.')
          for (; r; )
            try {
              if (
                ((n = 1),
                i &&
                  (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) &&
                  !(o = o.call(i, c[1])).done)
              )
                return o
              switch (((i = 0), o && (c = [c[0] & 2, o.value]), c[0])) {
                case 0:
                case 1:
                  o = c
                  break
                case 4:
                  return r.label++, { value: c[1], done: !1 }
                case 5:
                  r.label++, (i = c[1]), (c = [0])
                  continue
                case 7:
                  ;(c = r.ops.pop()), r.trys.pop()
                  continue
                default:
                  if (((o = r.trys), !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2))) {
                    r = 0
                    continue
                  }
                  if (c[0] === 3 && (!o || (c[1] > o[0] && c[1] < o[3]))) {
                    r.label = c[1]
                    break
                  }
                  if (c[0] === 6 && r.label < o[1]) {
                    ;(r.label = o[1]), (o = c)
                    break
                  }
                  if (o && r.label < o[2]) {
                    ;(r.label = o[2]), r.ops.push(c)
                    break
                  }
                  o[2] && r.ops.pop(), r.trys.pop()
                  continue
              }
              c = e.call(t, r)
            } catch (u) {
              ;(c = [6, u]), (i = 0)
            } finally {
              n = o = 0
            }
          if (c[0] & 5) throw c[1]
          return { value: c[0] ? c[1] : void 0, done: !0 }
        }
      },
    Cje = require('os'),
    Ije = jB(),
    Sme = on(),
    wje = VB(),
    dn = xn(),
    Aje = Ao(),
    Rje = Eme(),
    Dje = gU(),
    Cme = Ey(),
    Pje = Tme(),
    Ime = oo(),
    Nje = 'node',
    kje = (function () {
      function t(e, r) {
        ;(this._attach = dn.StatsbeatAttach.sdk),
          (this._feature = dn.StatsbeatFeature.NONE),
          (this._instrumentation = dn.StatsbeatInstrumentation.NONE),
          (this._isInitialized = !1),
          (this._statbeatMetrics = []),
          (this._networkStatsbeatCollection = []),
          (this._config = e),
          (this._context = r || new Cme())
        var n = this._getConnectionString(e)
        ;(this._statsbeatConfig = new Dje(n)),
          (this._statsbeatConfig.samplingPercentage = 100),
          (this._sender = new wje(
            this._statsbeatConfig,
            null,
            null,
            null,
            null,
            !0,
            this._shutdownStatsbeat.bind(this)
          ))
      }
      return (
        (t.prototype.enable = function (e) {
          var r = this
          ;(this._isEnabled = e),
            this._isEnabled && !this._isInitialized && (this._getCustomProperties(), (this._isInitialized = !0)),
            e
              ? (this._handle ||
                  ((this._handle = setInterval(function () {
                    r.trackShortIntervalStatsbeats()
                  }, t.STATS_COLLECTION_SHORT_INTERVAL)),
                  this._handle.unref()),
                this._longHandle ||
                  (this.trackLongIntervalStatsbeats(),
                  (this._longHandle = setInterval(function () {
                    r.trackLongIntervalStatsbeats()
                  }, t.STATS_COLLECTION_LONG_INTERVAL)),
                  this._longHandle.unref()))
              : (this._handle && (clearInterval(this._handle), (this._handle = null)),
                this._longHandle && (clearInterval(this._longHandle), (this._longHandle = null)))
        }),
        (t.prototype.isInitialized = function () {
          return this._isInitialized
        }),
        (t.prototype.isEnabled = function () {
          return this._isEnabled
        }),
        (t.prototype.setCodelessAttach = function () {
          this._attach = dn.StatsbeatAttach.codeless
        }),
        (t.prototype.addFeature = function (e) {
          this._feature |= e
        }),
        (t.prototype.removeFeature = function (e) {
          this._feature &= ~e
        }),
        (t.prototype.addInstrumentation = function (e) {
          this._instrumentation |= e
        }),
        (t.prototype.removeInstrumentation = function (e) {
          this._instrumentation &= ~e
        }),
        (t.prototype.countRequest = function (e, r, n, i, o) {
          if (this.isEnabled()) {
            var s = this._getNetworkStatsbeatCounter(e, r)
            if ((s.totalRequestCount++, (s.intervalRequestExecutionTime += n), i === !1)) {
              if (!o) return
              var a = s.totalFailedRequestCount.find(function (l) {
                return o === l.statusCode
              })
              a ? a.count++ : s.totalFailedRequestCount.push({ statusCode: o, count: 1 })
            } else s.totalSuccesfulRequestCount++
          }
        }),
        (t.prototype.countException = function (e, r, n) {
          if (this.isEnabled()) {
            var i = this._getNetworkStatsbeatCounter(e, r),
              o = i.exceptionCount.find(function (s) {
                return n.name === s.exceptionType
              })
            o ? o.count++ : i.exceptionCount.push({ exceptionType: n.name, count: 1 })
          }
        }),
        (t.prototype.countThrottle = function (e, r, n) {
          if (this.isEnabled()) {
            var i = this._getNetworkStatsbeatCounter(e, r),
              o = i.throttleCount.find(function (s) {
                return n === s.statusCode
              })
            o ? o.count++ : i.throttleCount.push({ statusCode: n, count: 1 })
          }
        }),
        (t.prototype.countRetry = function (e, r, n) {
          if (this.isEnabled()) {
            var i = this._getNetworkStatsbeatCounter(e, r),
              o = i.retryCount.find(function (s) {
                return n === s.statusCode
              })
            o ? o.count++ : i.retryCount.push({ statusCode: n, count: 1 })
          }
        }),
        (t.prototype.trackShortIntervalStatsbeats = function () {
          return zB(this, void 0, void 0, function () {
            var e, r
            return $B(this, function (n) {
              switch (n.label) {
                case 0:
                  return n.trys.push([0, 3, , 4]), [4, this._getResourceProvider()]
                case 1:
                  return (
                    n.sent(),
                    (e = {
                      os: this._os,
                      rp: this._resourceProvider,
                      cikey: this._cikey,
                      runtimeVersion: this._runtimeVersion,
                      language: this._language,
                      version: this._sdkVersion,
                      attach: this._attach,
                    }),
                    this._trackRequestDuration(e),
                    this._trackRequestsCount(e),
                    [4, this._sendStatsbeats()]
                  )
                case 2:
                  return n.sent(), [3, 4]
                case 3:
                  return (r = n.sent()), Sme.info(t.TAG, 'Failed to send Statsbeat metrics: ' + Ime.dumpObj(r)), [3, 4]
                case 4:
                  return [2]
              }
            })
          })
        }),
        (t.prototype.trackLongIntervalStatsbeats = function () {
          return zB(this, void 0, void 0, function () {
            var e, r, n, i, o
            return $B(this, function (s) {
              switch (s.label) {
                case 0:
                  return s.trys.push([0, 3, , 4]), [4, this._getResourceProvider()]
                case 1:
                  return (
                    s.sent(),
                    (e = {
                      os: this._os,
                      rp: this._resourceProvider,
                      cikey: this._cikey,
                      runtimeVersion: this._runtimeVersion,
                      language: this._language,
                      version: this._sdkVersion,
                      attach: this._attach,
                    }),
                    (r = Object.assign({ rpId: this._resourceIdentifier }, e)),
                    this._statbeatMetrics.push({ name: dn.StatsbeatCounter.ATTACH, value: 1, properties: r }),
                    this._instrumentation != dn.StatsbeatInstrumentation.NONE &&
                      ((n = Object.assign(
                        { feature: this._instrumentation, type: dn.StatsbeatFeatureType.Instrumentation },
                        e
                      )),
                      this._statbeatMetrics.push({ name: dn.StatsbeatCounter.FEATURE, value: 1, properties: n })),
                    this._feature != dn.StatsbeatFeature.NONE &&
                      ((i = Object.assign({ feature: this._feature, type: dn.StatsbeatFeatureType.Feature }, e)),
                      this._statbeatMetrics.push({ name: dn.StatsbeatCounter.FEATURE, value: 1, properties: i })),
                    [4, this._sendStatsbeats()]
                  )
                case 2:
                  return s.sent(), [3, 4]
                case 3:
                  return (o = s.sent()), Sme.info(t.TAG, 'Failed to send Statsbeat metrics: ' + Ime.dumpObj(o)), [3, 4]
                case 4:
                  return [2]
              }
            })
          })
        }),
        (t.prototype._getNetworkStatsbeatCounter = function (e, r) {
          for (var n = this._getShortHost(r), i = 0; i < this._networkStatsbeatCollection.length; i++)
            if (e === this._networkStatsbeatCollection[i].endpoint && n === this._networkStatsbeatCollection[i].host)
              return this._networkStatsbeatCollection[i]
          var o = new Pje.NetworkStatsbeat(e, n)
          return this._networkStatsbeatCollection.push(o), o
        }),
        (t.prototype._trackRequestDuration = function (e) {
          for (var r = 0; r < this._networkStatsbeatCollection.length; r++) {
            var n = this._networkStatsbeatCollection[r]
            n.time = +new Date()
            var i = n.totalRequestCount - n.lastRequestCount || 0,
              o = n.intervalRequestExecutionTime - n.lastIntervalRequestExecutionTime,
              s = (o > 0 && o / i) || 0
            if (((n.lastIntervalRequestExecutionTime = n.intervalRequestExecutionTime), i > 0)) {
              var a = Object.assign(
                {
                  endpoint: this._networkStatsbeatCollection[r].endpoint,
                  host: this._networkStatsbeatCollection[r].host,
                },
                e
              )
              this._statbeatMetrics.push({ name: dn.StatsbeatCounter.REQUEST_DURATION, value: s, properties: a })
            }
            ;(n.lastRequestCount = n.totalRequestCount), (n.lastTime = n.time)
          }
        }),
        (t.prototype._getShortHost = function (e) {
          var r = e
          try {
            var n = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/),
              i = n.exec(e)
            i != null && i.length > 1 && (r = i[1]), (r = r.replace('.in.applicationinsights.azure.com', ''))
          } catch {}
          return r
        }),
        (t.prototype._trackRequestsCount = function (e) {
          for (
            var r = this,
              n = function (a) {
                o = i._networkStatsbeatCollection[a]
                var l = Object.assign({ endpoint: o.endpoint, host: o.host }, e)
                o.totalSuccesfulRequestCount > 0 &&
                  (i._statbeatMetrics.push({
                    name: dn.StatsbeatCounter.REQUEST_SUCCESS,
                    value: o.totalSuccesfulRequestCount,
                    properties: l,
                  }),
                  (o.totalSuccesfulRequestCount = 0)),
                  o.totalFailedRequestCount.length > 0 &&
                    (o.totalFailedRequestCount.forEach(function (c) {
                      ;(l = Object.assign(lu(lu({}, l), { statusCode: c.statusCode }))),
                        r._statbeatMetrics.push({
                          name: dn.StatsbeatCounter.REQUEST_FAILURE,
                          value: c.count,
                          properties: l,
                        })
                    }),
                    (o.totalFailedRequestCount = [])),
                  o.retryCount.length > 0 &&
                    (o.retryCount.forEach(function (c) {
                      ;(l = Object.assign(lu(lu({}, l), { statusCode: c.statusCode }))),
                        r._statbeatMetrics.push({
                          name: dn.StatsbeatCounter.RETRY_COUNT,
                          value: c.count,
                          properties: l,
                        })
                    }),
                    (o.retryCount = [])),
                  o.throttleCount.length > 0 &&
                    (o.throttleCount.forEach(function (c) {
                      ;(l = Object.assign(lu(lu({}, l), { statusCode: c.statusCode }))),
                        r._statbeatMetrics.push({
                          name: dn.StatsbeatCounter.THROTTLE_COUNT,
                          value: c.count,
                          properties: l,
                        })
                    }),
                    (o.throttleCount = [])),
                  o.exceptionCount.length > 0 &&
                    (o.exceptionCount.forEach(function (c) {
                      ;(l = Object.assign(lu(lu({}, l), { exceptionType: c.exceptionType }))),
                        r._statbeatMetrics.push({
                          name: dn.StatsbeatCounter.EXCEPTION_COUNT,
                          value: c.count,
                          properties: l,
                        })
                    }),
                    (o.exceptionCount = []))
              },
              i = this,
              o,
              s = 0;
            s < this._networkStatsbeatCollection.length;
            s++
          )
            n(s)
        }),
        (t.prototype._sendStatsbeats = function () {
          return zB(this, void 0, void 0, function () {
            var e, r, n, i
            return $B(this, function (o) {
              switch (o.label) {
                case 0:
                  for (e = [], r = 0; r < this._statbeatMetrics.length; r++)
                    (n = {
                      name: this._statbeatMetrics[r].name,
                      value: this._statbeatMetrics[r].value,
                      properties: this._statbeatMetrics[r].properties,
                    }),
                      (i = Ije.createEnvelope(n, Aje.TelemetryType.Metric, null, this._context, this._statsbeatConfig)),
                      (i.name = dn.StatsbeatTelemetryName),
                      e.push(i)
                  return (this._statbeatMetrics = []), [4, this._sender.send(e)]
                case 1:
                  return o.sent(), [2]
              }
            })
          })
        }),
        (t.prototype._getCustomProperties = function () {
          ;(this._language = Nje),
            (this._cikey = this._config.instrumentationKey),
            (this._sdkVersion = Cme.sdkVersion),
            (this._os = Cje.type()),
            (this._runtimeVersion = process.version)
        }),
        (t.prototype._getResourceProvider = function () {
          var e = this
          return new Promise(function (r, n) {
            var i = !1
            ;(e._resourceProvider = dn.StatsbeatResourceProvider.unknown),
              (e._resourceIdentifier = dn.StatsbeatResourceProvider.unknown),
              process.env.WEBSITE_SITE_NAME
                ? ((e._resourceProvider = dn.StatsbeatResourceProvider.appsvc),
                  (e._resourceIdentifier = process.env.WEBSITE_SITE_NAME),
                  process.env.WEBSITE_HOME_STAMPNAME &&
                    (e._resourceIdentifier += '/' + process.env.WEBSITE_HOME_STAMPNAME))
                : process.env.FUNCTIONS_WORKER_RUNTIME
                ? ((e._resourceProvider = dn.StatsbeatResourceProvider.functions),
                  process.env.WEBSITE_HOSTNAME && (e._resourceIdentifier = process.env.WEBSITE_HOSTNAME))
                : e._config &&
                  (e._isVM === void 0 || e._isVM == !0
                    ? ((i = !0),
                      Rje.AzureVirtualMachine.getAzureComputeMetadata(e._config, function (o) {
                        ;(e._isVM = o.isVM),
                          e._isVM &&
                            ((e._resourceProvider = dn.StatsbeatResourceProvider.vm),
                            (e._resourceIdentifier = o.id + '/' + o.subscriptionId),
                            o.osType && (e._os = o.osType)),
                          r()
                      }))
                    : (e._resourceProvider = dn.StatsbeatResourceProvider.unknown)),
              i || r()
          })
        }),
        (t.prototype._shutdownStatsbeat = function () {
          this.enable(!1)
        }),
        (t.prototype._getConnectionString = function (e) {
          for (
            var r = e.endpointUrl,
              n = [
                'westeurope',
                'northeurope',
                'francecentral',
                'francesouth',
                'germanywestcentral',
                'norwayeast',
                'norwaywest',
                'swedencentral',
                'switzerlandnorth',
                'switzerlandwest',
                'uksouth',
                'ukwest',
              ],
              i = 0;
            i < n.length;
            i++
          )
            if (r.indexOf(n[i]) > -1) return t.EU_CONNECTION_STRING
          return t.NON_EU_CONNECTION_STRING
        }),
        (t.NON_EU_CONNECTION_STRING =
          'InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com'),
        (t.EU_CONNECTION_STRING =
          'InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com'),
        (t.STATS_COLLECTION_SHORT_INTERVAL = 9e5),
        (t.STATS_COLLECTION_LONG_INTERVAL = 864e5),
        (t.TAG = 'Statsbeat'),
        t
      )
    })()
  wme.exports = kje
})
var Pme = handleExports((iRt, Dme) => {
  'use strict'
  var Oje = require('url'),
    Lje = gU(),
    Mje = ome(),
    Fje = Ey(),
    jp = Ao(),
    Uje = ame(),
    WB = mme(),
    Rme = Wf(),
    Bje = Ame(),
    qje = VB(),
    KB = oo(),
    dP = on(),
    Hje = jB(),
    jje = (function () {
      function t(e) {
        this._telemetryProcessors = []
        var r = new Lje(e)
        if (((this.config = r), !this.config.instrumentationKey || this.config.instrumentationKey == ''))
          throw new Error(
            'Instrumentation key not found, please provide a connection string before starting Application Insights SDK.'
          )
        ;(this.context = new Fje()),
          (this.commonProperties = {}),
          (this.authorizationHandler = null),
          this.config.disableStatsbeat ||
            ((this._statsbeat = new Bje(this.config, this.context)), this._statsbeat.enable(!0))
        var n = new qje(this.config, this.getAuthorizationHandler, null, null, this._statsbeat)
        this.channel = new Uje(
          function () {
            return r.disableAppInsights
          },
          function () {
            return r.maxBatchSize
          },
          function () {
            return r.maxBatchIntervalMs
          },
          n
        )
      }
      return (
        (t.prototype.trackAvailability = function (e) {
          this.track(e, jp.TelemetryType.Availability)
        }),
        (t.prototype.trackPageView = function (e) {
          this.track(e, jp.TelemetryType.PageView)
        }),
        (t.prototype.trackTrace = function (e) {
          this.track(e, jp.TelemetryType.Trace)
        }),
        (t.prototype.trackMetric = function (e) {
          this.track(e, jp.TelemetryType.Metric)
        }),
        (t.prototype.trackException = function (e) {
          e && e.exception && !KB.isError(e.exception) && (e.exception = new Error(e.exception.toString())),
            this.track(e, jp.TelemetryType.Exception)
        }),
        (t.prototype.trackEvent = function (e) {
          this.track(e, jp.TelemetryType.Event)
        }),
        (t.prototype.trackRequest = function (e) {
          this.track(e, jp.TelemetryType.Request)
        }),
        (t.prototype.trackDependency = function (e) {
          if (e && !e.target && e.data)
            try {
              e.target = new Oje.URL(e.data).host
            } catch (r) {
              ;(e.target = null), dP.warn(t.TAG, 'The URL object is failed to create.', r)
            }
          this.track(e, jp.TelemetryType.Dependency)
        }),
        (t.prototype.flush = function (e) {
          this.channel.triggerSend(e ? !!e.isAppCrashing : !1, e ? e.callback : void 0)
        }),
        (t.prototype.track = function (e, r) {
          if (e && jp.telemetryTypeToBaseType(r)) {
            var n = Hje.createEnvelope(e, r, this.commonProperties, this.context, this.config)
            e.time && (n.time = e.time.toISOString())
            var i = this.runTelemetryProcessors(n, e.contextObjects)
            ;(i =
              i &&
              WB.samplingTelemetryProcessor(n, {
                correlationContext: Rme.CorrelationContextManager.getCurrentContext(),
              })),
              WB.preAggregatedMetricsTelemetryProcessor(n, this.context),
              i && (WB.performanceMetricsTelemetryProcessor(n, this.quickPulseClient), this.channel.send(n))
          } else dP.warn(t.TAG, 'track() requires telemetry object and telemetryType to be specified.')
        }),
        (t.prototype.setAutoPopulateAzureProperties = function (e) {}),
        (t.prototype.getAuthorizationHandler = function (e) {
          return e && e.aadTokenCredential
            ? (this.authorizationHandler ||
                (dP.info(t.TAG, 'Adding authorization handler'),
                (this.authorizationHandler = new Mje(e.aadTokenCredential, e.aadAudience))),
              this.authorizationHandler)
            : null
        }),
        (t.prototype.addTelemetryProcessor = function (e) {
          this._telemetryProcessors.push(e)
        }),
        (t.prototype.clearTelemetryProcessors = function () {
          this._telemetryProcessors = []
        }),
        (t.prototype.runTelemetryProcessors = function (e, r) {
          var n = !0,
            i = this._telemetryProcessors.length
          if (i === 0) return n
          ;(r = r || {}), (r.correlationContext = Rme.CorrelationContextManager.getCurrentContext())
          for (var o = 0; o < i; ++o)
            try {
              var s = this._telemetryProcessors[o]
              if (s && s.apply(null, [e, r]) === !1) {
                n = !1
                break
              }
            } catch (a) {
              ;(n = !0), dP.warn(t.TAG, 'One of telemetry processors failed, telemetry item will be sent.', a, e)
            }
          return (
            n &&
              (e && e.tags && (e.tags = KB.validateStringMap(e.tags)),
              e &&
                e.data &&
                e.data.baseData &&
                e.data.baseData.properties &&
                (e.data.baseData.properties = KB.validateStringMap(e.data.baseData.properties))),
            n
          )
        }),
        (t.prototype.getStatsbeat = function () {
          return this._statsbeat
        }),
        (t.TAG = 'TelemetryClient'),
        t
      )
    })()
  Dme.exports = jje
})
var Ome = handleExports((YB, kme) => {
  'use strict'
  var Gje =
      (YB && YB.__extends) ||
      (function () {
        var t = function (e, r) {
          return (
            (t =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (n, i) {
                  n.__proto__ = i
                }) ||
              function (n, i) {
                for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o])
              }),
            t(e, r)
          )
        }
        return function (e, r) {
          t(e, r)
          function n() {
            this.constructor = e
          }
          e.prototype = r === null ? Object.create(r) : ((n.prototype = r.prototype), new n())
        }
      })(),
    Vje = Pme(),
    Nme = lU(),
    zje = Ry(),
    fP = on(),
    $je = (function (t) {
      Gje(e, t)
      function e() {
        return (t !== null && t.apply(this, arguments)) || this
      }
      return (
        (e.prototype.trackNodeHttpRequestSync = function (r) {
          r && r.request && r.response && r.duration
            ? Nme.trackRequestSync(this, r)
            : fP.warn(
                'trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.'
              )
        }),
        (e.prototype.trackNodeHttpRequest = function (r) {
          ;(r.duration || r.error) &&
            fP.warn(
              'trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.'
            ),
            r && r.request && r.response
              ? Nme.trackRequest(this, r)
              : fP.warn(
                  'trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.'
                )
        }),
        (e.prototype.trackNodeHttpDependency = function (r) {
          r && r.request
            ? zje.trackRequest(this, r)
            : fP.warn('trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.')
        }),
        e
      )
    })(Vje)
  kme.exports = $je
})
var Mme = handleExports(Lme => {
  'use strict'
  Object.defineProperty(Lme, '__esModule', { value: !0 })
})
var Hme = handleExports(de => {
  'use strict'
  Object.defineProperty(de, '__esModule', { value: !0 })
  de.dispose =
    de.Configuration =
    de.wrapWithCorrelationContext =
    de.startOperation =
    de.getCorrelationContext =
    de.start =
    de.setup =
    de.liveMetricsClient =
    de.defaultClient =
    de.DistributedTracingModes =
      void 0
  var QB = Wf(),
    Wje = wue(),
    Kje = Rue(),
    XB = aD(),
    Yje = Y7(),
    Qje = Fue(),
    Xje = Yue(),
    Jje = Ry(),
    Zje = lU(),
    Fme = Gg(),
    ST = on(),
    Ume = Ape(),
    JB = Rpe(),
    eGe = Npe()
  de.TelemetryClient = Ome()
  de.Contracts = Ao()
  de.azureFunctionsTypes = Mme()
  var Bme
  ;(function (t) {
    ;(t[(t.AI = 0)] = 'AI'), (t[(t.AI_AND_W3C = 1)] = 'AI_AND_W3C')
  })((Bme = de.DistributedTracingModes || (de.DistributedTracingModes = {})))
  var CT,
    IT,
    wT,
    AT,
    RT,
    Yy,
    Qy,
    uv,
    DT,
    PT,
    va = !1,
    mP
  function tGe(t) {
    return (
      de.defaultClient
        ? ST.info('The default client is already setup')
        : ((de.defaultClient = new de.TelemetryClient(t)),
          (CT = new Wje(de.defaultClient)),
          (IT = new Kje(de.defaultClient)),
          (wT = new XB(de.defaultClient)),
          (AT = new Yje(de.defaultClient)),
          (RT = new Qje(de.defaultClient)),
          (Yy = new Xje(de.defaultClient)),
          (uv = new Zje(de.defaultClient)),
          (DT = new Jje(de.defaultClient)),
          Qy || (Qy = new JB.AutoCollectNativePerformance(de.defaultClient)),
          (PT = new eGe.AzureFunctionsHook(de.defaultClient))),
      ZB
    )
  }
  de.setup = tGe
  function rGe() {
    de.defaultClient &&
      (de.defaultClient.config.enableAutoCollectExternalLoggers == null &&
        (de.defaultClient.config.enableAutoCollectExternalLoggers = !0),
      de.defaultClient.config.enableAutoCollectConsole == null &&
        (de.defaultClient.config.enableAutoCollectConsole = !1),
      de.defaultClient.config.enableAutoCollectExceptions == null &&
        (de.defaultClient.config.enableAutoCollectExceptions = !0),
      de.defaultClient.config.enableAutoCollectPerformance == null &&
        (de.defaultClient.config.enableAutoCollectPerformance = !0),
      de.defaultClient.config.enableAutoCollectPreAggregatedMetrics == null &&
        (de.defaultClient.config.enableAutoCollectPreAggregatedMetrics = !0),
      de.defaultClient.config.enableAutoCollectHeartbeat == null &&
        (de.defaultClient.config.enableAutoCollectHeartbeat = !0),
      de.defaultClient.config.enableAutoCollectRequests == null &&
        (de.defaultClient.config.enableAutoCollectRequests = !0),
      de.defaultClient.config.enableAutoCollectDependencies == null &&
        (de.defaultClient.config.enableAutoCollectDependencies = !0),
      de.defaultClient.config.enableUseDiskRetryCaching == null &&
        (de.defaultClient.config.enableUseDiskRetryCaching = !0),
      de.defaultClient.config.enableAutoDependencyCorrelation == null &&
        (de.defaultClient.config.enableAutoDependencyCorrelation = !0),
      de.defaultClient.config.enableSendLiveMetrics == null && (de.defaultClient.config.enableSendLiveMetrics = !1),
      de.defaultClient.config.enableAutoCollectExtendedMetrics == null &&
        (de.defaultClient.config.enableAutoCollectExtendedMetrics = !0),
      de.defaultClient.config.enableWebInstrumentation == null &&
        (de.defaultClient.config.enableWebInstrumentation = !1),
      de.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions == null &&
        (de.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions = !1))
  }
  function qme() {
    if (de.defaultClient) {
      ;(va = !0),
        rGe(),
        CT.enable(
          de.defaultClient.config.enableAutoCollectExternalLoggers,
          de.defaultClient.config.enableAutoCollectConsole
        ),
        IT.enable(de.defaultClient.config.enableAutoCollectExceptions),
        wT.enable(de.defaultClient.config.enableAutoCollectPerformance),
        AT.enable(de.defaultClient.config.enableAutoCollectPreAggregatedMetrics),
        RT.enable(de.defaultClient.config.enableAutoCollectHeartbeat),
        uv.useAutoCorrelation(
          de.defaultClient.config.enableAutoDependencyCorrelation,
          de.defaultClient.config.enableUseAsyncHooks
        ),
        uv.enable(de.defaultClient.config.enableAutoCollectRequests),
        DT.enable(de.defaultClient.config.enableAutoCollectDependencies),
        Yy.enable(
          de.defaultClient.config.enableWebInstrumentation,
          de.defaultClient.config.webInstrumentationConnectionString
        ),
        de.defaultClient.config.enableSendLiveMetrics &&
          (de.liveMetricsClient ||
            ((de.liveMetricsClient = new Ume(
              de.defaultClient.config,
              de.defaultClient.context,
              de.defaultClient.getAuthorizationHandler
            )),
            (mP = new XB(de.liveMetricsClient, 1e3, !0)),
            de.liveMetricsClient.addCollector(mP),
            (de.defaultClient.quickPulseClient = de.liveMetricsClient))),
        PT.enable(de.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions)
      var t = JB.AutoCollectNativePerformance.parseEnabled(
        de.defaultClient.config.enableAutoCollectExtendedMetrics,
        de.defaultClient.config
      )
      Qy.enable(de.defaultClient.config.enableAutoCollectExtendedMetrics, t.disabledMetrics),
        de.defaultClient &&
          de.defaultClient.channel &&
          de.defaultClient.channel.setUseDiskRetryCaching(
            de.defaultClient.config.enableUseDiskRetryCaching,
            de.defaultClient.config.enableResendInterval,
            de.defaultClient.config.enableMaxBytesOnDisk
          )
    } else ST.warn('Start cannot be called before setup')
    return ZB
  }
  de.start = qme
  function nGe() {
    return QB.CorrelationContextManager.getCurrentContext()
  }
  de.getCorrelationContext = nGe
  function iGe(t, e) {
    return QB.CorrelationContextManager.startOperation(t, e)
  }
  de.startOperation = iGe
  function oGe(t, e) {
    return QB.CorrelationContextManager.wrapCallback(t, e)
  }
  de.wrapWithCorrelationContext = oGe
  var ZB = (function () {
    function t() {}
    return (
      (t.setDistributedTracingMode = function (e) {
        return (Fme.w3cEnabled = e === Bme.AI_AND_W3C), t
      }),
      (t.setAutoCollectConsole = function (e, r) {
        return (
          r === void 0 && (r = !1),
          de.defaultClient &&
            ((de.defaultClient.config.enableAutoCollectExternalLoggers = e),
            (de.defaultClient.config.enableAutoCollectConsole = r),
            va && CT.enable(e, r)),
          t
        )
      }),
      (t.setAutoCollectExceptions = function (e) {
        return de.defaultClient && ((de.defaultClient.config.enableAutoCollectExceptions = e), va && IT.enable(e)), t
      }),
      (t.setAutoCollectPerformance = function (e, r) {
        if ((r === void 0 && (r = !0), de.defaultClient)) {
          de.defaultClient.config.enableAutoCollectPerformance = e
          var n = JB.AutoCollectNativePerformance.parseEnabled(r, de.defaultClient.config)
          ;(de.defaultClient.config.enableAutoCollectExtendedMetrics = n.isEnabled),
            va && (wT.enable(e), Qy.enable(de.defaultClient.config.enableAutoCollectExtendedMetrics, n.disabledMetrics))
        }
        return t
      }),
      (t.setAutoCollectPreAggregatedMetrics = function (e) {
        return (
          de.defaultClient && ((de.defaultClient.config.enableAutoCollectPreAggregatedMetrics = e), va && AT.enable(e)),
          t
        )
      }),
      (t.setAutoCollectHeartbeat = function (e) {
        return de.defaultClient && ((de.defaultClient.config.enableAutoCollectHeartbeat = e), va && RT.enable(e)), t
      }),
      (t.enableAutoWebSnippetInjection = function (e, r) {
        return (
          de.defaultClient &&
            ((de.defaultClient.config.enableWebInstrumentation = e),
            (de.defaultClient.config.webInstrumentationConnectionString = r),
            va &&
              Yy.enable(
                de.defaultClient.config.enableAutoWebSnippetInjection,
                de.defaultClient.config.webSnippetConnectionString
              )),
          t
        )
      }),
      (t.enableWebInstrumentation = function (e, r) {
        return (
          de.defaultClient &&
            ((de.defaultClient.config.enableWebInstrumentation = e),
            (de.defaultClient.config.webInstrumentationConnectionString = r),
            va &&
              Yy.enable(
                de.defaultClient.config.enableWebInstrumentation,
                de.defaultClient.config.webInstrumentationConnectionString
              )),
          t
        )
      }),
      (t.setAutoCollectRequests = function (e) {
        return de.defaultClient && ((de.defaultClient.config.enableAutoCollectRequests = e), va && uv.enable(e)), t
      }),
      (t.setAutoCollectDependencies = function (e) {
        return de.defaultClient && ((de.defaultClient.config.enableAutoCollectDependencies = e), va && DT.enable(e)), t
      }),
      (t.setAutoDependencyCorrelation = function (e, r) {
        return (
          de.defaultClient &&
            ((de.defaultClient.config.enableAutoDependencyCorrelation = e),
            (de.defaultClient.config.enableUseAsyncHooks = r),
            va && uv.useAutoCorrelation(e, r)),
          t
        )
      }),
      (t.setUseDiskRetryCaching = function (e, r, n) {
        return (
          de.defaultClient &&
            ((de.defaultClient.config.enableUseDiskRetryCaching = e),
            (de.defaultClient.config.enableResendInterval = r),
            (de.defaultClient.config.enableMaxBytesOnDisk = n),
            de.defaultClient.channel &&
              de.defaultClient.channel.setUseDiskRetryCaching(
                de.defaultClient.config.enableUseDiskRetryCaching,
                de.defaultClient.config.enableResendInterval,
                de.defaultClient.config.enableMaxBytesOnDisk
              )),
          t
        )
      }),
      (t.setInternalLogging = function (e, r) {
        return e === void 0 && (e = !1), r === void 0 && (r = !0), (ST.enableDebug = e), (ST.disableWarnings = !r), t
      }),
      (t.setAutoCollectIncomingRequestAzureFunctions = function (e) {
        return (
          de.defaultClient &&
            ((de.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions = e), va && PT.enable(e)),
          t
        )
      }),
      (t.setSendLiveMetrics = function (e) {
        return (
          e === void 0 && (e = !1),
          de.defaultClient
            ? (!de.liveMetricsClient && e
                ? ((de.liveMetricsClient = new Ume(
                    de.defaultClient.config,
                    de.defaultClient.context,
                    de.defaultClient.getAuthorizationHandler
                  )),
                  (mP = new XB(de.liveMetricsClient, 1e3, !0)),
                  de.liveMetricsClient.addCollector(mP),
                  (de.defaultClient.quickPulseClient = de.liveMetricsClient))
                : de.liveMetricsClient && de.liveMetricsClient.enable(e),
              (de.defaultClient.config.enableSendLiveMetrics = e),
              t)
            : (ST.warn('Live metrics client cannot be setup without the default client'), t)
        )
      }),
      (t.start = qme),
      t
    )
  })()
  de.Configuration = ZB
  function sGe() {
    ;(Fme.w3cEnabled = !0),
      (de.defaultClient = null),
      (va = !1),
      CT && CT.dispose(),
      IT && IT.dispose(),
      wT && wT.dispose(),
      AT && AT.dispose(),
      RT && RT.dispose(),
      Yy && Yy.dispose(),
      Qy && Qy.dispose(),
      uv && uv.dispose(),
      DT && DT.dispose(),
      de.liveMetricsClient && (de.liveMetricsClient.enable(!1), (de.liveMetricsClient = void 0)),
      PT && PT.dispose()
  }
  de.dispose = sGe
})
var Oq = handleExports(mm => {
  'use strict'
  Object.defineProperty(mm, '__esModule', { value: !0 })
  mm.TargetPopulation = mm.Filters = mm.VSCodeFilterProvider = void 0
  var QP = require('vscode'),
    kq = class t {
      constructor(e, r, n) {
        ;(this.extensionName = e), (this.extensionVersion = r), (this.targetPopulation = n)
      }
      static trimVersionSuffix(e) {
        let r = /\-[a-zA-Z0-9]+$/
        return e.split(r)[0]
      }
      getFilterValue(e) {
        switch (e) {
          case uu.ApplicationVersion:
            return t.trimVersionSuffix(QP.version)
          case uu.Build:
            return QP.env.appName
          case uu.ClientId:
            return QP.env.machineId
          case uu.ExtensionName:
            return this.extensionName
          case uu.ExtensionVersion:
            return t.trimVersionSuffix(this.extensionVersion)
          case uu.Language:
            return QP.env.language
          case uu.TargetPopulation:
            return this.targetPopulation
          default:
            return ''
        }
      }
      getFilters() {
        let e = new Map(),
          r = Object.values(uu)
        for (let n of r) e.set(n, this.getFilterValue(n))
        return e
      }
    }
  mm.VSCodeFilterProvider = kq
  var uu
  ;(function (t) {
    ;(t.Market = 'X-MSEdge-Market'),
      (t.CorpNet = 'X-FD-Corpnet'),
      (t.ApplicationVersion = 'X-VSCode-AppVersion'),
      (t.Build = 'X-VSCode-Build'),
      (t.ClientId = 'X-MSEdge-ClientId'),
      (t.ExtensionName = 'X-VSCode-ExtensionName'),
      (t.ExtensionVersion = 'X-VSCode-ExtensionVersion'),
      (t.Language = 'X-VSCode-Language'),
      (t.TargetPopulation = 'X-VSCode-TargetPopulation')
  })(uu || (mm.Filters = uu = {}))
  var qhe
  ;(function (t) {
    ;(t.Team = 'team'), (t.Internal = 'internal'), (t.Insiders = 'insider'), (t.Public = 'public')
  })(qhe || (mm.TargetPopulation = qhe = {}))
})
var Hhe = handleExports(XP => {
  'use strict'
  Object.defineProperty(XP, '__esModule', { value: !0 })
  XP.BaseFeatureProvider = void 0
  var Lq = class {
    constructor(e) {
      ;(this.telemetry = e), (this.isFetching = !1)
    }
    async getFeatures() {
      if (this.isFetching && this.fetchPromise) return this.fetchPromise
      this.fetchPromise = this.fetch()
      let e = await this.fetchPromise
      return (this.isFetching = !1), (this.fetchPromise = void 0), e
    }
  }
  XP.BaseFeatureProvider = Lq
})
var jhe = handleExports(JP => {
  'use strict'
  Object.defineProperty(JP, '__esModule', { value: !0 })
  JP.FilteredFeatureProvider = void 0
  var rVe = Hhe(),
    Mq = class extends rVe.BaseFeatureProvider {
      constructor(e, r) {
        super(e), (this.telemetry = e), (this.filterProviders = r), (this.cachedTelemetryEvents = [])
      }
      getFilters() {
        let e = new Map()
        for (let r of this.filterProviders) {
          let n = r.getFilters()
          for (let i of n.keys()) {
            let o = n.get(i)
            e.set(i, o)
          }
        }
        return e
      }
      PostEventToTelemetry(e) {
        if (this.cachedTelemetryEvents.includes(e)) return
        let r = JSON.stringify(e)
        this.telemetry.postEvent('report-headers', new Map([['ABExp.headers', r]])), this.cachedTelemetryEvents.push(e)
      }
    }
  JP.FilteredFeatureProvider = Mq
})
var Ghe = handleExports(hm => {
  'use strict'
  Object.defineProperty(hm, '__esModule', { value: !0 })
  hm.TasApiFeatureProvider = hm.TASAPI_FETCHERROR_EVENTNAME = void 0
  var nVe = jhe()
  hm.TASAPI_FETCHERROR_EVENTNAME = 'call-tas-error'
  var Fq = 'ErrorType',
    Uq = class extends nVe.FilteredFeatureProvider {
      constructor(e, r, n) {
        super(r, n), (this.httpClient = e), (this.telemetry = r), (this.filterProviders = n)
      }
      async fetch() {
        let e = this.getFilters(),
          r = {}
        for (let a of e.keys()) {
          let l = e.get(a)
          r[a] = l
        }
        let n
        try {
          n = await this.httpClient.get({ headers: r })
        } catch (a) {
          let l = a,
            c = new Map()
          l.response ? c.set(Fq, 'ServerError') : l.request ? c.set(Fq, 'NoResponse') : c.set(Fq, 'GenericError'),
            this.telemetry.postEvent(hm.TASAPI_FETCHERROR_EVENTNAME, c)
        }
        if (!n) throw Error(hm.TASAPI_FETCHERROR_EVENTNAME)
        e.keys.length > 0 && this.PostEventToTelemetry(r)
        let i = n.data,
          o = i.Configs,
          s = []
        for (let a of o)
          if (a.Parameters)
            for (let l of Object.keys(a.Parameters)) {
              let c = l + (a.Parameters[l] ? '' : 'cf')
              s.includes(c) || s.push(c)
            }
        return { features: s, assignmentContext: i.AssignmentContext, configs: o }
      }
    }
  hm.TasApiFeatureProvider = Uq
})
var zhe = handleExports(Vhe => {
  'use strict'
  var iVe = require('url').parse,
    oVe = { ftp: 21, gopher: 70, http: 80, https: 443, ws: 80, wss: 443 },
    sVe =
      String.prototype.endsWith ||
      function (t) {
        return t.length <= this.length && this.indexOf(t, this.length - t.length) !== -1
      }
  function aVe(t) {
    var e = typeof t == 'string' ? iVe(t) : t || {},
      r = e.protocol,
      n = e.host,
      i = e.port
    if (
      typeof n != 'string' ||
      !n ||
      typeof r != 'string' ||
      ((r = r.split(':', 1)[0]), (n = n.replace(/:\d*$/, '')), (i = parseInt(i) || oVe[r] || 0), !cVe(n, i))
    )
      return ''
    var o = i1('npm_config_' + r + '_proxy') || i1(r + '_proxy') || i1('npm_config_proxy') || i1('all_proxy')
    return o && o.indexOf('://') === -1 && (o = r + '://' + o), o
  }
  function cVe(t, e) {
    var r = (i1('npm_config_no_proxy') || i1('no_proxy')).toLowerCase()
    return r
      ? r === '*'
        ? !1
        : r.split(/[,\s]/).every(function (n) {
            if (!n) return !0
            var i = n.match(/^(.+):(\d+)$/),
              o = i ? i[1] : n,
              s = i ? parseInt(i[2]) : 0
            return s && s !== e
              ? !0
              : /^[.*]/.test(o)
              ? (o.charAt(0) === '*' && (o = o.slice(1)), !sVe.call(t, o))
              : t !== o
          })
      : !0
  }
  function i1(t) {
    return process.env[t.toLowerCase()] || process.env[t.toUpperCase()] || ''
  }
  Vhe.getProxyForUrl = aVe
})
var Whe = handleExports((Y5t, $he) => {
  var GT
  $he.exports = function () {
    if (!GT) {
      try {
        GT = La()('follow-redirects')
      } catch {}
      typeof GT != 'function' && (GT = function () {})
    }
    GT.apply(null, arguments)
  }
})
var ege = handleExports((Q5t, zq) => {
  var vv = require('url'),
    Bq = vv.URL,
    lVe = require('http'),
    uVe = require('https'),
    Hq = require('stream').Writable,
    Qhe = require('assert'),
    Xhe = Whe(),
    jq = ['abort', 'aborted', 'connect', 'error', 'socket', 'timeout'],
    Gq = Object.create(null)
  jq.forEach(function (t) {
    Gq[t] = function (e, r, n) {
      this._redirectable.emit(t, e, r, n)
    }
  })
  var pVe = zT('ERR_INVALID_URL', 'Invalid URL', TypeError),
    Khe = zT('ERR_FR_REDIRECTION_FAILURE', 'Redirected request failed'),
    dVe = zT('ERR_FR_TOO_MANY_REDIRECTS', 'Maximum number of redirects exceeded'),
    fVe = zT('ERR_FR_MAX_BODY_LENGTH_EXCEEDED', 'Request body larger than maxBodyLength limit'),
    mVe = zT('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
    hVe = Hq.prototype.destroy || Zhe
  function ks(t, e) {
    Hq.call(this),
      this._sanitizeOptions(t),
      (this._options = t),
      (this._ended = !1),
      (this._ending = !1),
      (this._redirectCount = 0),
      (this._redirects = []),
      (this._requestBodyLength = 0),
      (this._requestBodyBuffers = []),
      e && this.on('response', e)
    var r = this
    ;(this._onNativeResponse = function (n) {
      r._processResponse(n)
    }),
      this._performRequest()
  }
  ks.prototype = Object.create(Hq.prototype)
  ks.prototype.abort = function () {
    Vq(this._currentRequest), this._currentRequest.abort(), this.emit('abort')
  }
  ks.prototype.destroy = function (t) {
    return Vq(this._currentRequest, t), hVe.call(this, t), this
  }
  ks.prototype.write = function (t, e, r) {
    if (this._ending) throw new mVe()
    if (!_v(t) && !vVe(t)) throw new TypeError('data should be a string, Buffer or Uint8Array')
    if ((VT(e) && ((r = e), (e = null)), t.length === 0)) {
      r && r()
      return
    }
    this._requestBodyLength + t.length <= this._options.maxBodyLength
      ? ((this._requestBodyLength += t.length),
        this._requestBodyBuffers.push({ data: t, encoding: e }),
        this._currentRequest.write(t, e, r))
      : (this.emit('error', new fVe()), this.abort())
  }
  ks.prototype.end = function (t, e, r) {
    if ((VT(t) ? ((r = t), (t = e = null)) : VT(e) && ((r = e), (e = null)), !t))
      (this._ended = this._ending = !0), this._currentRequest.end(null, null, r)
    else {
      var n = this,
        i = this._currentRequest
      this.write(t, e, function () {
        ;(n._ended = !0), i.end(null, null, r)
      }),
        (this._ending = !0)
    }
  }
  ks.prototype.setHeader = function (t, e) {
    ;(this._options.headers[t] = e), this._currentRequest.setHeader(t, e)
  }
  ks.prototype.removeHeader = function (t) {
    delete this._options.headers[t], this._currentRequest.removeHeader(t)
  }
  ks.prototype.setTimeout = function (t, e) {
    var r = this
    function n(s) {
      s.setTimeout(t), s.removeListener('timeout', s.destroy), s.addListener('timeout', s.destroy)
    }
    function i(s) {
      r._timeout && clearTimeout(r._timeout),
        (r._timeout = setTimeout(function () {
          r.emit('timeout'), o()
        }, t)),
        n(s)
    }
    function o() {
      r._timeout && (clearTimeout(r._timeout), (r._timeout = null)),
        r.removeListener('abort', o),
        r.removeListener('error', o),
        r.removeListener('response', o),
        r.removeListener('close', o),
        e && r.removeListener('timeout', e),
        r.socket || r._currentRequest.removeListener('socket', i)
    }
    return (
      e && this.on('timeout', e),
      this.socket ? i(this.socket) : this._currentRequest.once('socket', i),
      this.on('socket', n),
      this.on('abort', o),
      this.on('error', o),
      this.on('response', o),
      this.on('close', o),
      this
    )
  }
  ;['flushHeaders', 'getHeader', 'setNoDelay', 'setSocketKeepAlive'].forEach(function (t) {
    ks.prototype[t] = function (e, r) {
      return this._currentRequest[t](e, r)
    }
  })
  ;['aborted', 'connection', 'socket'].forEach(function (t) {
    Object.defineProperty(ks.prototype, t, {
      get: function () {
        return this._currentRequest[t]
      },
    })
  })
  ks.prototype._sanitizeOptions = function (t) {
    if (
      (t.headers || (t.headers = {}),
      t.host && (t.hostname || (t.hostname = t.host), delete t.host),
      !t.pathname && t.path)
    ) {
      var e = t.path.indexOf('?')
      e < 0 ? (t.pathname = t.path) : ((t.pathname = t.path.substring(0, e)), (t.search = t.path.substring(e)))
    }
  }
  ks.prototype._performRequest = function () {
    var t = this._options.protocol,
      e = this._options.nativeProtocols[t]
    if (!e) {
      this.emit('error', new TypeError('Unsupported protocol ' + t))
      return
    }
    if (this._options.agents) {
      var r = t.slice(0, -1)
      this._options.agent = this._options.agents[r]
    }
    var n = (this._currentRequest = e.request(this._options, this._onNativeResponse))
    n._redirectable = this
    for (var i of jq) n.on(i, Gq[i])
    if (
      ((this._currentUrl = /^\//.test(this._options.path) ? vv.format(this._options) : this._options.path),
      this._isRedirect)
    ) {
      var o = 0,
        s = this,
        a = this._requestBodyBuffers
      ;(function l(c) {
        if (n === s._currentRequest)
          if (c) s.emit('error', c)
          else if (o < a.length) {
            var u = a[o++]
            n.finished || n.write(u.data, u.encoding, l)
          } else s._ended && n.end()
      })()
    }
  }
  ks.prototype._processResponse = function (t) {
    var e = t.statusCode
    this._options.trackRedirects && this._redirects.push({ url: this._currentUrl, headers: t.headers, statusCode: e })
    var r = t.headers.location
    if (!r || this._options.followRedirects === !1 || e < 300 || e >= 400) {
      ;(t.responseUrl = this._currentUrl),
        (t.redirects = this._redirects),
        this.emit('response', t),
        (this._requestBodyBuffers = [])
      return
    }
    if ((Vq(this._currentRequest), t.destroy(), ++this._redirectCount > this._options.maxRedirects)) {
      this.emit('error', new dVe())
      return
    }
    var n,
      i = this._options.beforeRedirect
    i && (n = Object.assign({ Host: t.req.getHeader('host') }, this._options.headers))
    var o = this._options.method
    ;(((e === 301 || e === 302) && this._options.method === 'POST') ||
      (e === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))) &&
      ((this._options.method = 'GET'), (this._requestBodyBuffers = []), qq(/^content-/i, this._options.headers))
    var s = qq(/^host$/i, this._options.headers),
      a = vv.parse(this._currentUrl),
      l = s || a.host,
      c = /^\w+:/.test(r) ? this._currentUrl : vv.format(Object.assign(a, { host: l })),
      u
    try {
      u = vv.resolve(c, r)
    } catch (m) {
      this.emit('error', new Khe({ cause: m }))
      return
    }
    Xhe('redirecting to', u), (this._isRedirect = !0)
    var p = vv.parse(u)
    if (
      (Object.assign(this._options, p),
      ((p.protocol !== a.protocol && p.protocol !== 'https:') || (p.host !== l && !gVe(p.host, l))) &&
        qq(/^(?:authorization|cookie)$/i, this._options.headers),
      VT(i))
    ) {
      var d = { headers: t.headers, statusCode: e },
        f = { url: c, method: o, headers: n }
      try {
        i(this._options, d, f)
      } catch (m) {
        this.emit('error', m)
        return
      }
      this._sanitizeOptions(this._options)
    }
    try {
      this._performRequest()
    } catch (m) {
      this.emit('error', new Khe({ cause: m }))
    }
  }
  function Jhe(t) {
    var e = { maxRedirects: 21, maxBodyLength: 10485760 },
      r = {}
    return (
      Object.keys(t).forEach(function (n) {
        var i = n + ':',
          o = (r[i] = t[n]),
          s = (e[n] = Object.create(o))
        function a(c, u, p) {
          if (_v(c)) {
            var d
            try {
              d = Yhe(new Bq(c))
            } catch {
              d = vv.parse(c)
            }
            if (!_v(d.protocol)) throw new pVe({ input: c })
            c = d
          } else Bq && c instanceof Bq ? (c = Yhe(c)) : ((p = u), (u = c), (c = { protocol: i }))
          return (
            VT(u) && ((p = u), (u = null)),
            (u = Object.assign({ maxRedirects: e.maxRedirects, maxBodyLength: e.maxBodyLength }, c, u)),
            (u.nativeProtocols = r),
            !_v(u.host) && !_v(u.hostname) && (u.hostname = '::1'),
            Qhe.equal(u.protocol, i, 'protocol mismatch'),
            Xhe('options', u),
            new ks(u, p)
          )
        }
        function l(c, u, p) {
          var d = s.request(c, u, p)
          return d.end(), d
        }
        Object.defineProperties(s, {
          request: { value: a, configurable: !0, enumerable: !0, writable: !0 },
          get: { value: l, configurable: !0, enumerable: !0, writable: !0 },
        })
      }),
      e
    )
  }
  function Zhe() {}
  function Yhe(t) {
    var e = {
      protocol: t.protocol,
      hostname: t.hostname.startsWith('[') ? t.hostname.slice(1, -1) : t.hostname,
      hash: t.hash,
      search: t.search,
      pathname: t.pathname,
      path: t.pathname + t.search,
      href: t.href,
    }
    return t.port !== '' && (e.port = Number(t.port)), e
  }
  function qq(t, e) {
    var r
    for (var n in e) t.test(n) && ((r = e[n]), delete e[n])
    return r === null || typeof r > 'u' ? void 0 : String(r).trim()
  }
  function zT(t, e, r) {
    function n(i) {
      Error.captureStackTrace(this, this.constructor),
        Object.assign(this, i || {}),
        (this.code = t),
        (this.message = this.cause ? e + ': ' + this.cause.message : e)
    }
    return (
      (n.prototype = new (r || Error)()), (n.prototype.constructor = n), (n.prototype.name = 'Error [' + t + ']'), n
    )
  }
  function Vq(t, e) {
    for (var r of jq) t.removeListener(r, Gq[r])
    t.on('error', Zhe), t.destroy(e)
  }
  function gVe(t, e) {
    Qhe(_v(t) && _v(e))
    var r = t.length - e.length - 1
    return r > 0 && t[r] === '.' && t.endsWith(e)
  }
  function _v(t) {
    return typeof t == 'string' || t instanceof String
  }
  function VT(t) {
    return typeof t == 'function'
  }
  function vVe(t) {
    return typeof t == 'object' && 'length' in t
  }
  zq.exports = Jhe({ http: lVe, https: uVe })
  zq.exports.wrap = Jhe
})
var Vge = handleExports((X5t, Gge) => {
  'use strict'
  var _Ve = tB(),
    yVe = require('url'),
    xVe = zhe(),
    bVe = require('http'),
    EVe = require('https'),
    _ge = require('util'),
    TVe = ege(),
    SVe = require('zlib'),
    yge = require('stream'),
    CVe = require('events')
  function Gp(t) {
    return t && typeof t == 'object' && 'default' in t ? t : { default: t }
  }
  var xge = Gp(_Ve),
    IVe = Gp(yVe),
    wVe = Gp(bVe),
    AVe = Gp(EVe),
    RVe = Gp(_ge),
    DVe = Gp(TVe),
    ym = Gp(SVe),
    vm = Gp(yge),
    PVe = Gp(CVe)
  function bge(t, e) {
    return function () {
      return t.apply(e, arguments)
    }
  }
  var { toString: NVe } = Object.prototype,
    { getPrototypeOf: sH } = Object,
    iN = (t => e => {
      let r = NVe.call(e)
      return t[r] || (t[r] = r.slice(8, -1).toLowerCase())
    })(Object.create(null)),
    pu = t => ((t = t.toLowerCase()), e => iN(e) === t),
    oN = t => e => typeof e === t,
    { isArray: c1 } = Array,
    KT = oN('undefined')
  function kVe(t) {
    return (
      t !== null &&
      !KT(t) &&
      t.constructor !== null &&
      !KT(t.constructor) &&
      oc(t.constructor.isBuffer) &&
      t.constructor.isBuffer(t)
    )
  }
  var Ege = pu('ArrayBuffer')
  function OVe(t) {
    let e
    return (
      typeof ArrayBuffer < 'u' && ArrayBuffer.isView
        ? (e = ArrayBuffer.isView(t))
        : (e = t && t.buffer && Ege(t.buffer)),
      e
    )
  }
  var LVe = oN('string'),
    oc = oN('function'),
    Tge = oN('number'),
    sN = t => t !== null && typeof t == 'object',
    MVe = t => t === !0 || t === !1,
    eN = t => {
      if (iN(t) !== 'object') return !1
      let e = sH(t)
      return (
        (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) &&
        !(Symbol.toStringTag in t) &&
        !(Symbol.iterator in t)
      )
    },
    FVe = pu('Date'),
    UVe = pu('File'),
    BVe = pu('Blob'),
    qVe = pu('FileList'),
    HVe = t => sN(t) && oc(t.pipe),
    jVe = t => {
      let e
      return (
        t &&
        ((typeof FormData == 'function' && t instanceof FormData) ||
          (oc(t.append) &&
            ((e = iN(t)) === 'formdata' || (e === 'object' && oc(t.toString) && t.toString() === '[object FormData]'))))
      )
    },
    GVe = pu('URLSearchParams'),
    VVe = t => (t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''))
  function QT(t, e, { allOwnKeys: r = !1 } = {}) {
    if (t === null || typeof t > 'u') return
    let n, i
    if ((typeof t != 'object' && (t = [t]), c1(t))) for (n = 0, i = t.length; n < i; n++) e.call(null, t[n], n, t)
    else {
      let o = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
        s = o.length,
        a
      for (n = 0; n < s; n++) (a = o[n]), e.call(null, t[a], a, t)
    }
  }
  function Sge(t, e) {
    e = e.toLowerCase()
    let r = Object.keys(t),
      n = r.length,
      i
    for (; n-- > 0; ) if (((i = r[n]), e === i.toLowerCase())) return i
    return null
  }
  var Cge = (() =>
      typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : global)(),
    Ige = t => !KT(t) && t !== Cge
  function Qq() {
    let { caseless: t } = (Ige(this) && this) || {},
      e = {},
      r = (n, i) => {
        let o = (t && Sge(e, i)) || i
        eN(e[o]) && eN(n) ? (e[o] = Qq(e[o], n)) : eN(n) ? (e[o] = Qq({}, n)) : c1(n) ? (e[o] = n.slice()) : (e[o] = n)
      }
    for (let n = 0, i = arguments.length; n < i; n++) arguments[n] && QT(arguments[n], r)
    return e
  }
  var zVe = (t, e, r, { allOwnKeys: n } = {}) => (
      QT(
        e,
        (i, o) => {
          r && oc(i) ? (t[o] = bge(i, r)) : (t[o] = i)
        },
        { allOwnKeys: n }
      ),
      t
    ),
    $Ve = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    WVe = (t, e, r, n) => {
      ;(t.prototype = Object.create(e.prototype, n)),
        (t.prototype.constructor = t),
        Object.defineProperty(t, 'super', { value: e.prototype }),
        r && Object.assign(t.prototype, r)
    },
    KVe = (t, e, r, n) => {
      let i,
        o,
        s,
        a = {}
      if (((e = e || {}), t == null)) return e
      do {
        for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0; )
          (s = i[o]), (!n || n(s, t, e)) && !a[s] && ((e[s] = t[s]), (a[s] = !0))
        t = r !== !1 && sH(t)
      } while (t && (!r || r(t, e)) && t !== Object.prototype)
      return e
    },
    YVe = (t, e, r) => {
      ;(t = String(t)), (r === void 0 || r > t.length) && (r = t.length), (r -= e.length)
      let n = t.indexOf(e, r)
      return n !== -1 && n === r
    },
    QVe = t => {
      if (!t) return null
      if (c1(t)) return t
      let e = t.length
      if (!Tge(e)) return null
      let r = new Array(e)
      for (; e-- > 0; ) r[e] = t[e]
      return r
    },
    XVe = (
      t => e =>
        t && e instanceof t
    )(typeof Uint8Array < 'u' && sH(Uint8Array)),
    JVe = (t, e) => {
      let n = (t && t[Symbol.iterator]).call(t),
        i
      for (; (i = n.next()) && !i.done; ) {
        let o = i.value
        e.call(t, o[0], o[1])
      }
    },
    ZVe = (t, e) => {
      let r,
        n = []
      for (; (r = t.exec(e)) !== null; ) n.push(r)
      return n
    },
    eze = pu('HTMLFormElement'),
    tze = t =>
      t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (r, n, i) {
        return n.toUpperCase() + i
      }),
    tge = (
      ({ hasOwnProperty: t }) =>
      (e, r) =>
        t.call(e, r)
    )(Object.prototype),
    rze = pu('RegExp'),
    wge = (t, e) => {
      let r = Object.getOwnPropertyDescriptors(t),
        n = {}
      QT(r, (i, o) => {
        let s
        ;(s = e(i, o, t)) !== !1 && (n[o] = s || i)
      }),
        Object.defineProperties(t, n)
    },
    nze = t => {
      wge(t, (e, r) => {
        if (oc(t) && ['arguments', 'caller', 'callee'].indexOf(r) !== -1) return !1
        let n = t[r]
        if (oc(n)) {
          if (((e.enumerable = !1), 'writable' in e)) {
            e.writable = !1
            return
          }
          e.set ||
            (e.set = () => {
              throw Error("Can not rewrite read-only method '" + r + "'")
            })
        }
      })
    },
    ize = (t, e) => {
      let r = {},
        n = i => {
          i.forEach(o => {
            r[o] = !0
          })
        }
      return c1(t) ? n(t) : n(String(t).split(e)), r
    },
    oze = () => {},
    sze = (t, e) => ((t = +t), Number.isFinite(t) ? t : e),
    $q = 'abcdefghijklmnopqrstuvwxyz',
    rge = '0123456789',
    Age = { DIGIT: rge, ALPHA: $q, ALPHA_DIGIT: $q + $q.toUpperCase() + rge },
    aze = (t = 16, e = Age.ALPHA_DIGIT) => {
      let r = '',
        { length: n } = e
      for (; t--; ) r += e[(Math.random() * n) | 0]
      return r
    }
  function cze(t) {
    return !!(t && oc(t.append) && t[Symbol.toStringTag] === 'FormData' && t[Symbol.iterator])
  }
  var lze = t => {
      let e = new Array(10),
        r = (n, i) => {
          if (sN(n)) {
            if (e.indexOf(n) >= 0) return
            if (!('toJSON' in n)) {
              e[i] = n
              let o = c1(n) ? [] : {}
              return (
                QT(n, (s, a) => {
                  let l = r(s, i + 1)
                  !KT(l) && (o[a] = l)
                }),
                (e[i] = void 0),
                o
              )
            }
          }
          return n
        }
      return r(t, 0)
    },
    uze = pu('AsyncFunction'),
    pze = t => t && (sN(t) || oc(t)) && oc(t.then) && oc(t.catch),
    he = {
      isArray: c1,
      isArrayBuffer: Ege,
      isBuffer: kVe,
      isFormData: jVe,
      isArrayBufferView: OVe,
      isString: LVe,
      isNumber: Tge,
      isBoolean: MVe,
      isObject: sN,
      isPlainObject: eN,
      isUndefined: KT,
      isDate: FVe,
      isFile: UVe,
      isBlob: BVe,
      isRegExp: rze,
      isFunction: oc,
      isStream: HVe,
      isURLSearchParams: GVe,
      isTypedArray: XVe,
      isFileList: qVe,
      forEach: QT,
      merge: Qq,
      extend: zVe,
      trim: VVe,
      stripBOM: $Ve,
      inherits: WVe,
      toFlatObject: KVe,
      kindOf: iN,
      kindOfTest: pu,
      endsWith: YVe,
      toArray: QVe,
      forEachEntry: JVe,
      matchAll: ZVe,
      isHTMLForm: eze,
      hasOwnProperty: tge,
      hasOwnProp: tge,
      reduceDescriptors: wge,
      freezeMethods: nze,
      toObjectSet: ize,
      toCamelCase: tze,
      noop: oze,
      toFiniteNumber: sze,
      findKey: Sge,
      global: Cge,
      isContextDefined: Ige,
      ALPHABET: Age,
      generateString: aze,
      isSpecCompliantForm: cze,
      toJSONObject: lze,
      isAsyncFn: uze,
      isThenable: pze,
    }
  function ot(t, e, r, n, i) {
    Error.call(this),
      Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack),
      (this.message = t),
      (this.name = 'AxiosError'),
      e && (this.code = e),
      r && (this.config = r),
      n && (this.request = n),
      i && (this.response = i)
  }
  he.inherits(ot, Error, {
    toJSON: function () {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: he.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null,
      }
    },
  })
  var Rge = ot.prototype,
    Dge = {}
  ;[
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL',
  ].forEach(t => {
    Dge[t] = { value: t }
  })
  Object.defineProperties(ot, Dge)
  Object.defineProperty(Rge, 'isAxiosError', { value: !0 })
  ot.from = (t, e, r, n, i, o) => {
    let s = Object.create(Rge)
    return (
      he.toFlatObject(
        t,
        s,
        function (l) {
          return l !== Error.prototype
        },
        a => a !== 'isAxiosError'
      ),
      ot.call(s, t.message, e, r, n, i),
      (s.cause = t),
      (s.name = t.name),
      o && Object.assign(s, o),
      s
    )
  }
  function Xq(t) {
    return he.isPlainObject(t) || he.isArray(t)
  }
  function Pge(t) {
    return he.endsWith(t, '[]') ? t.slice(0, -2) : t
  }
  function nge(t, e, r) {
    return t
      ? t
          .concat(e)
          .map(function (i, o) {
            return (i = Pge(i)), !r && o ? '[' + i + ']' : i
          })
          .join(r ? '.' : '')
      : e
  }
  function dze(t) {
    return he.isArray(t) && !t.some(Xq)
  }
  var fze = he.toFlatObject(he, {}, null, function (e) {
    return /^is[A-Z]/.test(e)
  })
  function aN(t, e, r) {
    if (!he.isObject(t)) throw new TypeError('target must be an object')
    ;(e = e || new (xge.default || FormData)()),
      (r = he.toFlatObject(r, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (h, g) {
        return !he.isUndefined(g[h])
      }))
    let n = r.metaTokens,
      i = r.visitor || u,
      o = r.dots,
      s = r.indexes,
      l = (r.Blob || (typeof Blob < 'u' && Blob)) && he.isSpecCompliantForm(e)
    if (!he.isFunction(i)) throw new TypeError('visitor must be a function')
    function c(m) {
      if (m === null) return ''
      if (he.isDate(m)) return m.toISOString()
      if (!l && he.isBlob(m)) throw new ot('Blob is not supported. Use a Buffer instead.')
      return he.isArrayBuffer(m) || he.isTypedArray(m)
        ? l && typeof Blob == 'function'
          ? new Blob([m])
          : Buffer.from(m)
        : m
    }
    function u(m, h, g) {
      let v = m
      if (m && !g && typeof m == 'object') {
        if (he.endsWith(h, '{}')) (h = n ? h : h.slice(0, -2)), (m = JSON.stringify(m))
        else if ((he.isArray(m) && dze(m)) || ((he.isFileList(m) || he.endsWith(h, '[]')) && (v = he.toArray(m))))
          return (
            (h = Pge(h)),
            v.forEach(function (y, b) {
              !(he.isUndefined(y) || y === null) &&
                e.append(s === !0 ? nge([h], b, o) : s === null ? h : h + '[]', c(y))
            }),
            !1
          )
      }
      return Xq(m) ? !0 : (e.append(nge(g, h, o), c(m)), !1)
    }
    let p = [],
      d = Object.assign(fze, { defaultVisitor: u, convertValue: c, isVisitable: Xq })
    function f(m, h) {
      if (!he.isUndefined(m)) {
        if (p.indexOf(m) !== -1) throw Error('Circular reference detected in ' + h.join('.'))
        p.push(m),
          he.forEach(m, function (v, _) {
            ;(!(he.isUndefined(v) || v === null) && i.call(e, v, he.isString(_) ? _.trim() : _, h, d)) === !0 &&
              f(v, h ? h.concat(_) : [_])
          }),
          p.pop()
      }
    }
    if (!he.isObject(t)) throw new TypeError('data must be an object')
    return f(t), e
  }
  function ige(t) {
    let e = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' }
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (n) {
      return e[n]
    })
  }
  function Nge(t, e) {
    ;(this._pairs = []), t && aN(t, this, e)
  }
  var kge = Nge.prototype
  kge.append = function (e, r) {
    this._pairs.push([e, r])
  }
  kge.toString = function (e) {
    let r = e
      ? function (n) {
          return e.call(this, n, ige)
        }
      : ige
    return this._pairs
      .map(function (i) {
        return r(i[0]) + '=' + r(i[1])
      }, '')
      .join('&')
  }
  function mze(t) {
    return encodeURIComponent(t)
      .replace(/%3A/gi, ':')
      .replace(/%24/g, '$')
      .replace(/%2C/gi, ',')
      .replace(/%20/g, '+')
      .replace(/%5B/gi, '[')
      .replace(/%5D/gi, ']')
  }
  function aH(t, e, r) {
    if (!e) return t
    let n = (r && r.encode) || mze,
      i = r && r.serialize,
      o
    if ((i ? (o = i(e, r)) : (o = he.isURLSearchParams(e) ? e.toString() : new Nge(e, r).toString(n)), o)) {
      let s = t.indexOf('#')
      s !== -1 && (t = t.slice(0, s)), (t += (t.indexOf('?') === -1 ? '?' : '&') + o)
    }
    return t
  }
  var Jq = class {
      constructor() {
        this.handlers = []
      }
      use(e, r, n) {
        return (
          this.handlers.push({
            fulfilled: e,
            rejected: r,
            synchronous: n ? n.synchronous : !1,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        )
      }
      eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
      }
      clear() {
        this.handlers && (this.handlers = [])
      }
      forEach(e) {
        he.forEach(this.handlers, function (n) {
          n !== null && e(n)
        })
      }
    },
    oge = Jq,
    cH = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
    hze = IVe.default.URLSearchParams,
    gze = {
      isNode: !0,
      classes: { URLSearchParams: hze, FormData: xge.default, Blob: (typeof Blob < 'u' && Blob) || null },
      protocols: ['http', 'https', 'file', 'data'],
    },
    Oge = typeof window < 'u' && typeof document < 'u',
    vze = (t => Oge && ['ReactNative', 'NativeScript', 'NS'].indexOf(t) < 0)(
      typeof navigator < 'u' && navigator.product
    ),
    _ze = (() =>
      typeof WorkerGlobalScope < 'u' && self instanceof WorkerGlobalScope && typeof self.importScripts == 'function')(),
    yze = Object.freeze({
      __proto__: null,
      hasBrowserEnv: Oge,
      hasStandardBrowserWebWorkerEnv: _ze,
      hasStandardBrowserEnv: vze,
    }),
    ic = { ...yze, ...gze }
  function xze(t, e) {
    return aN(
      t,
      new ic.classes.URLSearchParams(),
      Object.assign(
        {
          visitor: function (r, n, i, o) {
            return ic.isNode && he.isBuffer(r)
              ? (this.append(n, r.toString('base64')), !1)
              : o.defaultVisitor.apply(this, arguments)
          },
        },
        e
      )
    )
  }
  function bze(t) {
    return he.matchAll(/\w+|\[(\w*)]/g, t).map(e => (e[0] === '[]' ? '' : e[1] || e[0]))
  }
  function Eze(t) {
    let e = {},
      r = Object.keys(t),
      n,
      i = r.length,
      o
    for (n = 0; n < i; n++) (o = r[n]), (e[o] = t[o])
    return e
  }
  function Lge(t) {
    function e(r, n, i, o) {
      let s = r[o++],
        a = Number.isFinite(+s),
        l = o >= r.length
      return (
        (s = !s && he.isArray(i) ? i.length : s),
        l
          ? (he.hasOwnProp(i, s) ? (i[s] = [i[s], n]) : (i[s] = n), !a)
          : ((!i[s] || !he.isObject(i[s])) && (i[s] = []),
            e(r, n, i[s], o) && he.isArray(i[s]) && (i[s] = Eze(i[s])),
            !a)
      )
    }
    if (he.isFormData(t) && he.isFunction(t.entries)) {
      let r = {}
      return (
        he.forEachEntry(t, (n, i) => {
          e(bze(n), i, r, 0)
        }),
        r
      )
    }
    return null
  }
  function Tze(t, e, r) {
    if (he.isString(t))
      try {
        return (e || JSON.parse)(t), he.trim(t)
      } catch (n) {
        if (n.name !== 'SyntaxError') throw n
      }
    return (r || JSON.stringify)(t)
  }
  var lH = {
    transitional: cH,
    adapter: ['xhr', 'http'],
    transformRequest: [
      function (e, r) {
        let n = r.getContentType() || '',
          i = n.indexOf('application/json') > -1,
          o = he.isObject(e)
        if ((o && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e)))
          return i && i ? JSON.stringify(Lge(e)) : e
        if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e)) return e
        if (he.isArrayBufferView(e)) return e.buffer
        if (he.isURLSearchParams(e))
          return r.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1), e.toString()
        let a
        if (o) {
          if (n.indexOf('application/x-www-form-urlencoded') > -1) return xze(e, this.formSerializer).toString()
          if ((a = he.isFileList(e)) || n.indexOf('multipart/form-data') > -1) {
            let l = this.env && this.env.FormData
            return aN(a ? { 'files[]': e } : e, l && new l(), this.formSerializer)
          }
        }
        return o || i ? (r.setContentType('application/json', !1), Tze(e)) : e
      },
    ],
    transformResponse: [
      function (e) {
        let r = this.transitional || lH.transitional,
          n = r && r.forcedJSONParsing,
          i = this.responseType === 'json'
        if (e && he.isString(e) && ((n && !this.responseType) || i)) {
          let s = !(r && r.silentJSONParsing) && i
          try {
            return JSON.parse(e)
          } catch (a) {
            if (s) throw a.name === 'SyntaxError' ? ot.from(a, ot.ERR_BAD_RESPONSE, this, null, this.response) : a
          }
        }
        return e
      },
    ],
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: { FormData: ic.classes.FormData, Blob: ic.classes.Blob },
    validateStatus: function (e) {
      return e >= 200 && e < 300
    },
    headers: { common: { Accept: 'application/json, text/plain, */*', 'Content-Type': void 0 } },
  }
  he.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], t => {
    lH.headers[t] = {}
  })
  var uH = lH,
    Sze = he.toObjectSet([
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ]),
    Cze = t => {
      let e = {},
        r,
        n,
        i
      return (
        t &&
          t
            .split(
              `
`
            )
            .forEach(function (s) {
              ;(i = s.indexOf(':')),
                (r = s.substring(0, i).trim().toLowerCase()),
                (n = s.substring(i + 1).trim()),
                !(!r || (e[r] && Sze[r])) &&
                  (r === 'set-cookie' ? (e[r] ? e[r].push(n) : (e[r] = [n])) : (e[r] = e[r] ? e[r] + ', ' + n : n))
            }),
        e
      )
    },
    sge = Symbol('internals')
  function $T(t) {
    return t && String(t).trim().toLowerCase()
  }
  function tN(t) {
    return t === !1 || t == null ? t : he.isArray(t) ? t.map(tN) : String(t)
  }
  function Ize(t) {
    let e = Object.create(null),
      r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g,
      n
    for (; (n = r.exec(t)); ) e[n[1]] = n[2]
    return e
  }
  var wze = t => ''
  // var wze = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim())
  function Wq(t, e, r, n, i) {
    if (he.isFunction(n)) return n.call(this, e, r)
    if ((i && (e = r), !!he.isString(e))) {
      if (he.isString(n)) return e.indexOf(n) !== -1
      if (he.isRegExp(n)) return n.test(e)
    }
  }
  function Aze(t) {
    return t
      .trim()
      .toLowerCase()
      .replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n)
  }
  function Rze(t, e) {
    let r = he.toCamelCase(' ' + e)
    ;['get', 'set', 'has'].forEach(n => {
      Object.defineProperty(t, n + r, {
        value: function (i, o, s) {
          return this[n].call(this, e, i, o, s)
        },
        configurable: !0,
      })
    })
  }
  var o1 = class {
    constructor(e) {
      e && this.set(e)
    }
    set(e, r, n) {
      let i = this
      function o(a, l, c) {
        let u = $T(l)
        if (!u) throw new Error('header name must be a non-empty string')
        let p = he.findKey(i, u)
        ;(!p || i[p] === void 0 || c === !0 || (c === void 0 && i[p] !== !1)) && (i[p || l] = tN(a))
      }
      let s = (a, l) => he.forEach(a, (c, u) => o(c, u, l))
      return (
        he.isPlainObject(e) || e instanceof this.constructor
          ? s(e, r)
          : he.isString(e) && (e = e.trim()) && !wze(e)
          ? s(Cze(e), r)
          : e != null && o(r, e, n),
        this
      )
    }
    get(e, r) {
      if (((e = $T(e)), e)) {
        let n = he.findKey(this, e)
        if (n) {
          let i = this[n]
          if (!r) return i
          if (r === !0) return Ize(i)
          if (he.isFunction(r)) return r.call(this, i, n)
          if (he.isRegExp(r)) return r.exec(i)
          throw new TypeError('parser must be boolean|regexp|function')
        }
      }
    }
    has(e, r) {
      if (((e = $T(e)), e)) {
        let n = he.findKey(this, e)
        return !!(n && this[n] !== void 0 && (!r || Wq(this, this[n], n, r)))
      }
      return !1
    }
    delete(e, r) {
      let n = this,
        i = !1
      function o(s) {
        if (((s = $T(s)), s)) {
          let a = he.findKey(n, s)
          a && (!r || Wq(n, n[a], a, r)) && (delete n[a], (i = !0))
        }
      }
      return he.isArray(e) ? e.forEach(o) : o(e), i
    }
    clear(e) {
      let r = Object.keys(this),
        n = r.length,
        i = !1
      for (; n--; ) {
        let o = r[n]
        ;(!e || Wq(this, this[o], o, e, !0)) && (delete this[o], (i = !0))
      }
      return i
    }
    normalize(e) {
      let r = this,
        n = {}
      return (
        he.forEach(this, (i, o) => {
          let s = he.findKey(n, o)
          if (s) {
            ;(r[s] = tN(i)), delete r[o]
            return
          }
          let a = e ? Aze(o) : String(o).trim()
          a !== o && delete r[o], (r[a] = tN(i)), (n[a] = !0)
        }),
        this
      )
    }
    concat(...e) {
      return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
      let r = Object.create(null)
      return (
        he.forEach(this, (n, i) => {
          n != null && n !== !1 && (r[i] = e && he.isArray(n) ? n.join(', ') : n)
        }),
        r
      )
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
      return Object.entries(this.toJSON()).map(([e, r]) => e + ': ' + r).join(`
`)
    }
    get [Symbol.toStringTag]() {
      return 'AxiosHeaders'
    }
    static from(e) {
      return e instanceof this ? e : new this(e)
    }
    static concat(e, ...r) {
      let n = new this(e)
      return r.forEach(i => n.set(i)), n
    }
    static accessor(e) {
      let n = (this[sge] = this[sge] = { accessors: {} }).accessors,
        i = this.prototype
      function o(s) {
        let a = $T(s)
        n[a] || (Rze(i, s), (n[a] = !0))
      }
      return he.isArray(e) ? e.forEach(o) : o(e), this
    }
  }
  o1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization'])
  he.reduceDescriptors(o1.prototype, ({ value: t }, e) => {
    let r = e[0].toUpperCase() + e.slice(1)
    return {
      get: () => t,
      set(n) {
        this[r] = n
      },
    }
  })
  he.freezeMethods(o1)
  var sc = o1
  function Kq(t, e) {
    let r = this || uH,
      n = e || r,
      i = sc.from(n.headers),
      o = n.data
    return (
      he.forEach(t, function (a) {
        o = a.call(r, o, i.normalize(), e ? e.status : void 0)
      }),
      i.normalize(),
      o
    )
  }
  function Mge(t) {
    return !!(t && t.__CANCEL__)
  }
  function yv(t, e, r) {
    ot.call(this, t ?? 'canceled', ot.ERR_CANCELED, e, r), (this.name = 'CanceledError')
  }
  he.inherits(yv, ot, { __CANCEL__: !0 })
  function WT(t, e, r) {
    let n = r.config.validateStatus
    !r.status || !n || n(r.status)
      ? t(r)
      : e(
          new ot(
            'Request failed with status code ' + r.status,
            [ot.ERR_BAD_REQUEST, ot.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
            r.config,
            r.request,
            r
          )
        )
  }
  function Dze(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
  }
  function Pze(t, e) {
    return e ? t.replace(/\/+$/, '') + '/' + e.replace(/^\/+/, '') : t
  }
  function pH(t, e) {
    return t && !Dze(e) ? Pze(t, e) : e
  }
  var nN = '1.6.1'
  function Fge(t) {
    let e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t)
    return (e && e[1]) || ''
  }
  var Nze = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/
  function kze(t, e, r) {
    let n = (r && r.Blob) || ic.classes.Blob,
      i = Fge(t)
    if ((e === void 0 && n && (e = !0), i === 'data')) {
      t = i.length ? t.slice(i.length + 1) : t
      let o = Nze.exec(t)
      if (!o) throw new ot('Invalid URL', ot.ERR_INVALID_URL)
      let s = o[1],
        a = o[2],
        l = o[3],
        c = Buffer.from(decodeURIComponent(l), a ? 'base64' : 'utf8')
      if (e) {
        if (!n) throw new ot('Blob is not supported', ot.ERR_NOT_SUPPORT)
        return new n([c], { type: s })
      }
      return c
    }
    throw new ot('Unsupported protocol ' + i, ot.ERR_NOT_SUPPORT)
  }
  function Oze(t, e) {
    let r = 0,
      n = 1e3 / e,
      i = null
    return function (s, a) {
      let l = Date.now()
      if (s || l - r > n) return i && (clearTimeout(i), (i = null)), (r = l), t.apply(null, a)
      i || (i = setTimeout(() => ((i = null), (r = Date.now()), t.apply(null, a)), n - (l - r)))
    }
  }
  function Uge(t, e) {
    t = t || 10
    let r = new Array(t),
      n = new Array(t),
      i = 0,
      o = 0,
      s
    return (
      (e = e !== void 0 ? e : 1e3),
      function (l) {
        let c = Date.now(),
          u = n[o]
        s || (s = c), (r[i] = l), (n[i] = c)
        let p = o,
          d = 0
        for (; p !== i; ) (d += r[p++]), (p = p % t)
        if (((i = (i + 1) % t), i === o && (o = (o + 1) % t), c - s < e)) return
        let f = u && c - u
        return f ? Math.round((d * 1e3) / f) : void 0
      }
    )
  }
  var ZP = Symbol('internals'),
    Zq = class extends vm.default.Transform {
      constructor(e) {
        ;(e = he.toFlatObject(
          e,
          { maxRate: 0, chunkSize: 64 * 1024, minChunkSize: 100, timeWindow: 500, ticksRate: 2, samplesCount: 15 },
          null,
          (a, l) => !he.isUndefined(l[a])
        )),
          super({ readableHighWaterMark: e.chunkSize })
        let r = this,
          n = (this[ZP] = {
            length: e.length,
            timeWindow: e.timeWindow,
            ticksRate: e.ticksRate,
            chunkSize: e.chunkSize,
            maxRate: e.maxRate,
            minChunkSize: e.minChunkSize,
            bytesSeen: 0,
            isCaptured: !1,
            notifiedBytesLoaded: 0,
            ts: Date.now(),
            bytes: 0,
            onReadCallback: null,
          }),
          i = Uge(n.ticksRate * e.samplesCount, n.timeWindow)
        this.on('newListener', a => {
          a === 'progress' && (n.isCaptured || (n.isCaptured = !0))
        })
        let o = 0
        n.updateProgress = Oze(function () {
          let l = n.length,
            c = n.bytesSeen,
            u = c - o
          if (!u || r.destroyed) return
          let p = i(u)
          ;(o = c),
            process.nextTick(() => {
              r.emit('progress', {
                loaded: c,
                total: l,
                progress: l ? c / l : void 0,
                bytes: u,
                rate: p || void 0,
                estimated: p && l && c <= l ? (l - c) / p : void 0,
              })
            })
        }, n.ticksRate)
        let s = () => {
          n.updateProgress(!0)
        }
        this.once('end', s), this.once('error', s)
      }
      _read(e) {
        let r = this[ZP]
        return r.onReadCallback && r.onReadCallback(), super._read(e)
      }
      _transform(e, r, n) {
        let i = this,
          o = this[ZP],
          s = o.maxRate,
          a = this.readableHighWaterMark,
          l = o.timeWindow,
          c = 1e3 / l,
          u = s / c,
          p = o.minChunkSize !== !1 ? Math.max(o.minChunkSize, u * 0.01) : 0
        function d(m, h) {
          let g = Buffer.byteLength(m)
          ;(o.bytesSeen += g),
            (o.bytes += g),
            o.isCaptured && o.updateProgress(),
            i.push(m)
              ? process.nextTick(h)
              : (o.onReadCallback = () => {
                  ;(o.onReadCallback = null), process.nextTick(h)
                })
        }
        let f = (m, h) => {
          let g = Buffer.byteLength(m),
            v = null,
            _ = a,
            y,
            b = 0
          if (s) {
            let x = Date.now()
            ;(!o.ts || (b = x - o.ts) >= l) && ((o.ts = x), (y = u - o.bytes), (o.bytes = y < 0 ? -y : 0), (b = 0)),
              (y = u - o.bytes)
          }
          if (s) {
            if (y <= 0)
              return setTimeout(() => {
                h(null, m)
              }, l - b)
            y < _ && (_ = y)
          }
          _ && g > _ && g - _ > p && ((v = m.subarray(_)), (m = m.subarray(0, _))),
            d(
              m,
              v
                ? () => {
                    process.nextTick(h, null, v)
                  }
                : h
            )
        }
        f(e, function m(h, g) {
          if (h) return n(h)
          g ? f(g, m) : n(null)
        })
      }
      setLength(e) {
        return (this[ZP].length = +e), this
      }
    },
    age = Zq,
    { asyncIterator: cge } = Symbol,
    Lze = async function* (t) {
      t.stream ? yield* t.stream() : t.arrayBuffer ? yield await t.arrayBuffer() : t[cge] ? yield* t[cge]() : yield t
    },
    Bge = Lze,
    Mze = he.ALPHABET.ALPHA_DIGIT + '-_',
    YT = new _ge.TextEncoder(),
    _m = `\r
`,
    Fze = YT.encode(_m),
    Uze = 2,
    eH = class {
      constructor(e, r) {
        let { escapeName: n } = this.constructor,
          i = he.isString(r),
          o = `Content-Disposition: form-data; name="${n(e)}"${!i && r.name ? `; filename="${n(r.name)}"` : ''}${_m}`
        i
          ? (r = YT.encode(String(r).replace(/\r?\n|\r\n?/g, _m)))
          : (o += `Content-Type: ${r.type || 'application/octet-stream'}${_m}`),
          (this.headers = YT.encode(o + _m)),
          (this.contentLength = i ? r.byteLength : r.size),
          (this.size = this.headers.byteLength + this.contentLength + Uze),
          (this.name = e),
          (this.value = r)
      }
      async *encode() {
        yield this.headers
        let { value: e } = this
        he.isTypedArray(e) ? yield e : yield* Bge(e), yield Fze
      }
      static escapeName(e) {
        return String(e).replace(/[\r\n"]/g, r => ({ '\r': '%0D', '\n': '%0A', '"': '%22' }[r]))
      }
    },
    Bze = (t, e, r) => {
      let { tag: n = 'form-data-boundary', size: i = 25, boundary: o = n + '-' + he.generateString(i, Mze) } = r || {}
      if (!he.isFormData(t)) throw TypeError('FormData instance required')
      if (o.length < 1 || o.length > 70) throw Error('boundary must be 10-70 characters long')
      let s = YT.encode('--' + o + _m),
        a = YT.encode('--' + o + '--' + _m + _m),
        l = a.byteLength,
        c = Array.from(t.entries()).map(([p, d]) => {
          let f = new eH(p, d)
          return (l += f.size), f
        })
      ;(l += s.byteLength * c.length), (l = he.toFiniteNumber(l))
      let u = { 'Content-Type': `multipart/form-data; boundary=${o}` }
      return (
        Number.isFinite(l) && (u['Content-Length'] = l),
        e && e(u),
        yge.Readable.from(
          (async function* () {
            for (let p of c) yield s, yield* p.encode()
            yield a
          })()
        )
      )
    },
    qze = Bze,
    tH = class extends vm.default.Transform {
      __transform(e, r, n) {
        this.push(e), n()
      }
      _transform(e, r, n) {
        if (e.length !== 0 && ((this._transform = this.__transform), e[0] !== 120)) {
          let i = Buffer.alloc(2)
          ;(i[0] = 120), (i[1] = 156), this.push(i, r)
        }
        this.__transform(e, r, n)
      }
    },
    Hze = tH,
    jze = (t, e) =>
      he.isAsyncFn(t)
        ? function (...r) {
            let n = r.pop()
            t.apply(this, r).then(i => {
              try {
                e ? n(null, ...e(i)) : n(null, i)
              } catch (o) {
                n(o)
              }
            }, n)
          }
        : t,
    Gze = jze,
    lge = { flush: ym.default.constants.Z_SYNC_FLUSH, finishFlush: ym.default.constants.Z_SYNC_FLUSH },
    Vze = {
      flush: ym.default.constants.BROTLI_OPERATION_FLUSH,
      finishFlush: ym.default.constants.BROTLI_OPERATION_FLUSH,
    },
    uge = he.isFunction(ym.default.createBrotliDecompress),
    { http: zze, https: $ze } = DVe.default,
    Wze = /https:?/,
    pge = ic.protocols.map(t => t + ':')
  function Kze(t) {
    t.beforeRedirects.proxy && t.beforeRedirects.proxy(t), t.beforeRedirects.config && t.beforeRedirects.config(t)
  }
  function qge(t, e, r) {
    let n = e
    if (!n && n !== !1) {
      let i = xVe.getProxyForUrl(r)
      i && (n = new URL(i))
    }
    if (n) {
      if ((n.username && (n.auth = (n.username || '') + ':' + (n.password || '')), n.auth)) {
        ;(n.auth.username || n.auth.password) && (n.auth = (n.auth.username || '') + ':' + (n.auth.password || ''))
        let o = Buffer.from(n.auth, 'utf8').toString('base64')
        t.headers['Proxy-Authorization'] = 'Basic ' + o
      }
      t.headers.host = t.hostname + (t.port ? ':' + t.port : '')
      let i = n.hostname || n.host
      ;(t.hostname = i),
        (t.host = i),
        (t.port = n.port),
        (t.path = r),
        n.protocol && (t.protocol = n.protocol.includes(':') ? n.protocol : `${n.protocol}:`)
    }
    t.beforeRedirects.proxy = function (o) {
      qge(o, e, o.href)
    }
  }
  var Yze = typeof process < 'u' && he.kindOf(process) === 'process',
    Qze = t =>
      new Promise((e, r) => {
        let n,
          i,
          o = (l, c) => {
            i || ((i = !0), n && n(l, c))
          },
          s = l => {
            o(l), e(l)
          },
          a = l => {
            o(l, !0), r(l)
          }
        t(s, a, l => (n = l)).catch(a)
      }),
    Xze = ({ address: t, family: e }) => {
      if (!he.isString(t)) throw TypeError('address must be a string')
      return { address: t, family: e || (t.indexOf('.') < 0 ? 6 : 4) }
    },
    dge = (t, e) => Xze(he.isObject(t) ? t : { address: t, family: e }),
    Jze =
      Yze &&
      function (e) {
        return Qze(async function (n, i, o) {
          let { data: s, lookup: a, family: l } = e,
            { responseType: c, responseEncoding: u } = e,
            p = e.method.toUpperCase(),
            d,
            f = !1,
            m
          if (a) {
            let A = Gze(a, X => (he.isArray(X) ? X : [X]))
            a = (X, fe, ce) => {
              A(X, fe, (oe, ae, je) => {
                let Ye = he.isArray(ae) ? ae.map(Ze => dge(Ze)) : [dge(ae, je)]
                fe.all ? ce(oe, Ye) : ce(oe, Ye[0].address, Ye[0].family)
              })
            }
          }
          let h = new PVe.default(),
            g = () => {
              e.cancelToken && e.cancelToken.unsubscribe(v),
                e.signal && e.signal.removeEventListener('abort', v),
                h.removeAllListeners()
            }
          o((A, X) => {
            ;(d = !0), X && ((f = !0), g())
          })
          function v(A) {
            h.emit('abort', !A || A.type ? new yv(null, e, m) : A)
          }
          h.once('abort', i),
            (e.cancelToken || e.signal) &&
              (e.cancelToken && e.cancelToken.subscribe(v),
              e.signal && (e.signal.aborted ? v() : e.signal.addEventListener('abort', v)))
          let _ = pH(e.baseURL, e.url),
            y = new URL(_, 'http://localhost'),
            b = y.protocol || pge[0]
          if (b === 'data:') {
            let A
            if (p !== 'GET') return WT(n, i, { status: 405, statusText: 'method not allowed', headers: {}, config: e })
            try {
              A = kze(e.url, c === 'blob', { Blob: e.env && e.env.Blob })
            } catch (X) {
              throw ot.from(X, ot.ERR_BAD_REQUEST, e)
            }
            return (
              c === 'text'
                ? ((A = A.toString(u)), (!u || u === 'utf8') && (A = he.stripBOM(A)))
                : c === 'stream' && (A = vm.default.Readable.from(A)),
              WT(n, i, { data: A, status: 200, statusText: 'OK', headers: new sc(), config: e })
            )
          }
          if (pge.indexOf(b) === -1) return i(new ot('Unsupported protocol ' + b, ot.ERR_BAD_REQUEST, e))
          let x = sc.from(e.headers).normalize()
          x.set('User-Agent', 'axios/' + nN, !1)
          let P = e.onDownloadProgress,
            U = e.onUploadProgress,
            H = e.maxRate,
            j,
            M
          if (he.isSpecCompliantForm(s)) {
            let A = x.getContentType(/boundary=([-_\w\d]{10,70})/i)
            s = qze(
              s,
              X => {
                x.set(X)
              },
              { tag: `axios-${nN}-boundary`, boundary: (A && A[1]) || void 0 }
            )
          } else if (he.isFormData(s) && he.isFunction(s.getHeaders)) {
            if ((x.set(s.getHeaders()), !x.hasContentLength()))
              try {
                let A = await RVe.default.promisify(s.getLength).call(s)
                Number.isFinite(A) && A >= 0 && x.setContentLength(A)
              } catch {}
          } else if (he.isBlob(s))
            s.size && x.setContentType(s.type || 'application/octet-stream'),
              x.setContentLength(s.size || 0),
              (s = vm.default.Readable.from(Bge(s)))
          else if (s && !he.isStream(s)) {
            if (!Buffer.isBuffer(s))
              if (he.isArrayBuffer(s)) s = Buffer.from(new Uint8Array(s))
              else if (he.isString(s)) s = Buffer.from(s, 'utf-8')
              else
                return i(
                  new ot(
                    'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                    ot.ERR_BAD_REQUEST,
                    e
                  )
                )
            if ((x.setContentLength(s.length, !1), e.maxBodyLength > -1 && s.length > e.maxBodyLength))
              return i(new ot('Request body larger than maxBodyLength limit', ot.ERR_BAD_REQUEST, e))
          }
          let F = he.toFiniteNumber(x.getContentLength())
          he.isArray(H) ? ((j = H[0]), (M = H[1])) : (j = M = H),
            s &&
              (U || j) &&
              (he.isStream(s) || (s = vm.default.Readable.from(s, { objectMode: !1 })),
              (s = vm.default.pipeline([s, new age({ length: F, maxRate: he.toFiniteNumber(j) })], he.noop)),
              U &&
                s.on('progress', A => {
                  U(Object.assign(A, { upload: !0 }))
                }))
          let z
          if (e.auth) {
            let A = e.auth.username || '',
              X = e.auth.password || ''
            z = A + ':' + X
          }
          if (!z && y.username) {
            let A = y.username,
              X = y.password
            z = A + ':' + X
          }
          z && x.delete('authorization')
          let q
          try {
            q = aH(y.pathname + y.search, e.params, e.paramsSerializer).replace(/^\?/, '')
          } catch (A) {
            let X = new Error(A.message)
            return (X.config = e), (X.url = e.url), (X.exists = !0), i(X)
          }
          x.set('Accept-Encoding', 'gzip, compress, deflate' + (uge ? ', br' : ''), !1)
          let L = {
            path: q,
            method: p,
            headers: x.toJSON(),
            agents: { http: e.httpAgent, https: e.httpsAgent },
            auth: z,
            protocol: b,
            family: l,
            beforeRedirect: Kze,
            beforeRedirects: {},
          }
          !he.isUndefined(a) && (L.lookup = a),
            e.socketPath
              ? (L.socketPath = e.socketPath)
              : ((L.hostname = y.hostname),
                (L.port = y.port),
                qge(L, e.proxy, b + '//' + y.hostname + (y.port ? ':' + y.port : '') + L.path))
          let S,
            T = Wze.test(L.protocol)
          if (
            ((L.agent = T ? e.httpsAgent : e.httpAgent),
            e.transport
              ? (S = e.transport)
              : e.maxRedirects === 0
              ? (S = T ? AVe.default : wVe.default)
              : (e.maxRedirects && (L.maxRedirects = e.maxRedirects),
                e.beforeRedirect && (L.beforeRedirects.config = e.beforeRedirect),
                (S = T ? $ze : zze)),
            e.maxBodyLength > -1 ? (L.maxBodyLength = e.maxBodyLength) : (L.maxBodyLength = 1 / 0),
            e.insecureHTTPParser && (L.insecureHTTPParser = e.insecureHTTPParser),
            (m = S.request(L, function (X) {
              if (m.destroyed) return
              let fe = [X],
                ce = +X.headers['content-length']
              if (P) {
                let Ze = new age({ length: he.toFiniteNumber(ce), maxRate: he.toFiniteNumber(M) })
                P &&
                  Ze.on('progress', ke => {
                    P(Object.assign(ke, { download: !0 }))
                  }),
                  fe.push(Ze)
              }
              let oe = X,
                ae = X.req || m
              if (e.decompress !== !1 && X.headers['content-encoding'])
                switch (
                  ((p === 'HEAD' || X.statusCode === 204) && delete X.headers['content-encoding'],
                  (X.headers['content-encoding'] || '').toLowerCase())
                ) {
                  case 'gzip':
                  case 'x-gzip':
                  case 'compress':
                  case 'x-compress':
                    fe.push(ym.default.createUnzip(lge)), delete X.headers['content-encoding']
                    break
                  case 'deflate':
                    fe.push(new Hze()), fe.push(ym.default.createUnzip(lge)), delete X.headers['content-encoding']
                    break
                  case 'br':
                    uge && (fe.push(ym.default.createBrotliDecompress(Vze)), delete X.headers['content-encoding'])
                }
              oe = fe.length > 1 ? vm.default.pipeline(fe, he.noop) : fe[0]
              let je = vm.default.finished(oe, () => {
                  je(), g()
                }),
                Ye = {
                  status: X.statusCode,
                  statusText: X.statusMessage,
                  headers: new sc(X.headers),
                  config: e,
                  request: ae,
                }
              if (c === 'stream') (Ye.data = oe), WT(n, i, Ye)
              else {
                let Ze = [],
                  ke = 0
                oe.on('data', function (tt) {
                  Ze.push(tt),
                    (ke += tt.length),
                    e.maxContentLength > -1 &&
                      ke > e.maxContentLength &&
                      ((f = !0),
                      oe.destroy(),
                      i(
                        new ot(
                          'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                          ot.ERR_BAD_RESPONSE,
                          e,
                          ae
                        )
                      ))
                }),
                  oe.on('aborted', function () {
                    if (f) return
                    let tt = new ot(
                      'maxContentLength size of ' + e.maxContentLength + ' exceeded',
                      ot.ERR_BAD_RESPONSE,
                      e,
                      ae
                    )
                    oe.destroy(tt), i(tt)
                  }),
                  oe.on('error', function (tt) {
                    m.destroyed || i(ot.from(tt, null, e, ae))
                  }),
                  oe.on('end', function () {
                    try {
                      let tt = Ze.length === 1 ? Ze[0] : Buffer.concat(Ze)
                      c !== 'arraybuffer' && ((tt = tt.toString(u)), (!u || u === 'utf8') && (tt = he.stripBOM(tt))),
                        (Ye.data = tt)
                    } catch (tt) {
                      return i(ot.from(tt, null, e, Ye.request, Ye))
                    }
                    WT(n, i, Ye)
                  })
              }
              h.once('abort', Ze => {
                oe.destroyed || (oe.emit('error', Ze), oe.destroy())
              })
            })),
            h.once('abort', A => {
              i(A), m.destroy(A)
            }),
            m.on('error', function (X) {
              i(ot.from(X, null, e, m))
            }),
            m.on('socket', function (X) {
              X.setKeepAlive(!0, 1e3 * 60)
            }),
            e.timeout)
          ) {
            let A = parseInt(e.timeout, 10)
            if (Number.isNaN(A)) {
              i(new ot('error trying to parse `config.timeout` to int', ot.ERR_BAD_OPTION_VALUE, e, m))
              return
            }
            m.setTimeout(A, function () {
              if (d) return
              let fe = e.timeout ? 'timeout of ' + e.timeout + 'ms exceeded' : 'timeout exceeded',
                ce = e.transitional || cH
              e.timeoutErrorMessage && (fe = e.timeoutErrorMessage),
                i(new ot(fe, ce.clarifyTimeoutError ? ot.ETIMEDOUT : ot.ECONNABORTED, e, m)),
                v()
            })
          }
          if (he.isStream(s)) {
            let A = !1,
              X = !1
            s.on('end', () => {
              A = !0
            }),
              s.once('error', fe => {
                ;(X = !0), m.destroy(fe)
              }),
              s.on('close', () => {
                !A && !X && v(new yv('Request stream has been aborted', e, m))
              }),
              s.pipe(m)
          } else m.end(s)
        })
      },
    Zze = ic.hasStandardBrowserEnv
      ? (function () {
          return {
            write: function (r, n, i, o, s, a) {
              let l = []
              l.push(r + '=' + encodeURIComponent(n)),
                he.isNumber(i) && l.push('expires=' + new Date(i).toGMTString()),
                he.isString(o) && l.push('path=' + o),
                he.isString(s) && l.push('domain=' + s),
                a === !0 && l.push('secure'),
                (document.cookie = l.join('; '))
            },
            read: function (r) {
              let n = document.cookie.match(new RegExp('(^|;\\s*)(' + r + ')=([^;]*)'))
              return n ? decodeURIComponent(n[3]) : null
            },
            remove: function (r) {
              this.write(r, '', Date.now() - 864e5)
            },
          }
        })()
      : (function () {
          return {
            write: function () {},
            read: function () {
              return null
            },
            remove: function () {},
          }
        })(),
    e$e = ic.hasStandardBrowserEnv
      ? (function () {
          let e = /(msie|trident)/i.test(navigator.userAgent),
            r = document.createElement('a'),
            n
          function i(o) {
            let s = o
            return (
              e && (r.setAttribute('href', s), (s = r.href)),
              r.setAttribute('href', s),
              {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, '') : '',
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, '') : '',
                hash: r.hash ? r.hash.replace(/^#/, '') : '',
                hostname: r.hostname,
                port: r.port,
                pathname: r.pathname.charAt(0) === '/' ? r.pathname : '/' + r.pathname,
              }
            )
          }
          return (
            (n = i(window.location.href)),
            function (s) {
              let a = he.isString(s) ? i(s) : s
              return a.protocol === n.protocol && a.host === n.host
            }
          )
        })()
      : (function () {
          return function () {
            return !0
          }
        })()
  function fge(t, e) {
    let r = 0,
      n = Uge(50, 250)
    return i => {
      let o = i.loaded,
        s = i.lengthComputable ? i.total : void 0,
        a = o - r,
        l = n(a),
        c = o <= s
      r = o
      let u = {
        loaded: o,
        total: s,
        progress: s ? o / s : void 0,
        bytes: a,
        rate: l || void 0,
        estimated: l && s && c ? (s - o) / l : void 0,
        event: i,
      }
      ;(u[e ? 'download' : 'upload'] = !0), t(u)
    }
  }
  var t$e = typeof XMLHttpRequest < 'u',
    r$e =
      t$e &&
      function (t) {
        return new Promise(function (r, n) {
          let i = t.data,
            o = sc.from(t.headers).normalize(),
            s = t.responseType,
            a
          function l() {
            t.cancelToken && t.cancelToken.unsubscribe(a), t.signal && t.signal.removeEventListener('abort', a)
          }
          let c
          if (he.isFormData(i)) {
            if (ic.hasStandardBrowserEnv || ic.hasStandardBrowserWebWorkerEnv) o.setContentType(!1)
            else if ((c = o.getContentType()) !== !1) {
              let [m, ...h] = c
                ? c
                    .split(';')
                    .map(g => g.trim())
                    .filter(Boolean)
                : []
              o.setContentType([m || 'multipart/form-data', ...h].join('; '))
            }
          }
          let u = new XMLHttpRequest()
          if (t.auth) {
            let m = t.auth.username || '',
              h = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : ''
            o.set('Authorization', 'Basic ' + btoa(m + ':' + h))
          }
          let p = pH(t.baseURL, t.url)
          u.open(t.method.toUpperCase(), aH(p, t.params, t.paramsSerializer), !0), (u.timeout = t.timeout)
          function d() {
            if (!u) return
            let m = sc.from('getAllResponseHeaders' in u && u.getAllResponseHeaders()),
              g = {
                data: !s || s === 'text' || s === 'json' ? u.responseText : u.response,
                status: u.status,
                statusText: u.statusText,
                headers: m,
                config: t,
                request: u,
              }
            WT(
              function (_) {
                r(_), l()
              },
              function (_) {
                n(_), l()
              },
              g
            ),
              (u = null)
          }
          if (
            ('onloadend' in u
              ? (u.onloadend = d)
              : (u.onreadystatechange = function () {
                  !u ||
                    u.readyState !== 4 ||
                    (u.status === 0 && !(u.responseURL && u.responseURL.indexOf('file:') === 0)) ||
                    setTimeout(d)
                }),
            (u.onabort = function () {
              u && (n(new ot('Request aborted', ot.ECONNABORTED, t, u)), (u = null))
            }),
            (u.onerror = function () {
              n(new ot('Network Error', ot.ERR_NETWORK, t, u)), (u = null)
            }),
            (u.ontimeout = function () {
              let h = t.timeout ? 'timeout of ' + t.timeout + 'ms exceeded' : 'timeout exceeded',
                g = t.transitional || cH
              t.timeoutErrorMessage && (h = t.timeoutErrorMessage),
                n(new ot(h, g.clarifyTimeoutError ? ot.ETIMEDOUT : ot.ECONNABORTED, t, u)),
                (u = null)
            }),
            ic.hasStandardBrowserEnv)
          ) {
            let m = e$e(p) && t.xsrfCookieName && Zze.read(t.xsrfCookieName)
            m && o.set(t.xsrfHeaderName, m)
          }
          i === void 0 && o.setContentType(null),
            'setRequestHeader' in u &&
              he.forEach(o.toJSON(), function (h, g) {
                u.setRequestHeader(g, h)
              }),
            he.isUndefined(t.withCredentials) || (u.withCredentials = !!t.withCredentials),
            s && s !== 'json' && (u.responseType = t.responseType),
            typeof t.onDownloadProgress == 'function' && u.addEventListener('progress', fge(t.onDownloadProgress, !0)),
            typeof t.onUploadProgress == 'function' &&
              u.upload &&
              u.upload.addEventListener('progress', fge(t.onUploadProgress)),
            (t.cancelToken || t.signal) &&
              ((a = m => {
                u && (n(!m || m.type ? new yv(null, t, u) : m), u.abort(), (u = null))
              }),
              t.cancelToken && t.cancelToken.subscribe(a),
              t.signal && (t.signal.aborted ? a() : t.signal.addEventListener('abort', a)))
          let f = Fge(p)
          if (f && ic.protocols.indexOf(f) === -1) {
            n(new ot('Unsupported protocol ' + f + ':', ot.ERR_BAD_REQUEST, t))
            return
          }
          u.send(i || null)
        })
      },
    rH = { http: Jze, xhr: r$e }
  he.forEach(rH, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, 'name', { value: e })
      } catch {}
      Object.defineProperty(t, 'adapterName', { value: e })
    }
  })
  var mge = t => `- ${t}`,
    n$e = t => he.isFunction(t) || t === null || t === !1,
    Hge = {
      getAdapter: t => {
        t = he.isArray(t) ? t : [t]
        let { length: e } = t,
          r,
          n,
          i = {}
        for (let o = 0; o < e; o++) {
          r = t[o]
          let s
          if (((n = r), !n$e(r) && ((n = rH[(s = String(r)).toLowerCase()]), n === void 0)))
            throw new ot(`Unknown adapter '${s}'`)
          if (n) break
          i[s || '#' + o] = n
        }
        if (!n) {
          let o = Object.entries(i).map(
              ([a, l]) =>
                `adapter ${a} ` + (l === !1 ? 'is not supported by the environment' : 'is not available in the build')
            ),
            s = e
              ? o.length > 1
                ? `since :
` +
                  o.map(mge).join(`
`)
                : ' ' + mge(o[0])
              : 'as no adapter specified'
          throw new ot('There is no suitable adapter to dispatch the request ' + s, 'ERR_NOT_SUPPORT')
        }
        return n
      },
      adapters: rH,
    }
  function Yq(t) {
    if ((t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)) throw new yv(null, t)
  }
  function hge(t) {
    return (
      Yq(t),
      (t.headers = sc.from(t.headers)),
      (t.data = Kq.call(t, t.transformRequest)),
      ['post', 'put', 'patch'].indexOf(t.method) !== -1 &&
        t.headers.setContentType('application/x-www-form-urlencoded', !1),
      Hge.getAdapter(t.adapter || uH.adapter)(t).then(
        function (n) {
          return Yq(t), (n.data = Kq.call(t, t.transformResponse, n)), (n.headers = sc.from(n.headers)), n
        },
        function (n) {
          return (
            Mge(n) ||
              (Yq(t),
              n &&
                n.response &&
                ((n.response.data = Kq.call(t, t.transformResponse, n.response)),
                (n.response.headers = sc.from(n.response.headers)))),
            Promise.reject(n)
          )
        }
      )
    )
  }
  var gge = t => (t instanceof sc ? t.toJSON() : t)
  function s1(t, e) {
    e = e || {}
    let r = {}
    function n(c, u, p) {
      return he.isPlainObject(c) && he.isPlainObject(u)
        ? he.merge.call({ caseless: p }, c, u)
        : he.isPlainObject(u)
        ? he.merge({}, u)
        : he.isArray(u)
        ? u.slice()
        : u
    }
    function i(c, u, p) {
      if (he.isUndefined(u)) {
        if (!he.isUndefined(c)) return n(void 0, c, p)
      } else return n(c, u, p)
    }
    function o(c, u) {
      if (!he.isUndefined(u)) return n(void 0, u)
    }
    function s(c, u) {
      if (he.isUndefined(u)) {
        if (!he.isUndefined(c)) return n(void 0, c)
      } else return n(void 0, u)
    }
    function a(c, u, p) {
      if (p in e) return n(c, u)
      if (p in t) return n(void 0, c)
    }
    let l = {
      url: o,
      method: o,
      data: o,
      baseURL: s,
      transformRequest: s,
      transformResponse: s,
      paramsSerializer: s,
      timeout: s,
      timeoutMessage: s,
      withCredentials: s,
      adapter: s,
      responseType: s,
      xsrfCookieName: s,
      xsrfHeaderName: s,
      onUploadProgress: s,
      onDownloadProgress: s,
      decompress: s,
      maxContentLength: s,
      maxBodyLength: s,
      beforeRedirect: s,
      transport: s,
      httpAgent: s,
      httpsAgent: s,
      cancelToken: s,
      socketPath: s,
      responseEncoding: s,
      validateStatus: a,
      headers: (c, u) => i(gge(c), gge(u), !0),
    }
    return (
      he.forEach(Object.keys(Object.assign({}, t, e)), function (u) {
        let p = l[u] || i,
          d = p(t[u], e[u], u)
        ;(he.isUndefined(d) && p !== a) || (r[u] = d)
      }),
      r
    )
  }
  var dH = {}
  ;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((t, e) => {
    dH[t] = function (n) {
      return typeof n === t || 'a' + (e < 1 ? 'n ' : ' ') + t
    }
  })
  var vge = {}
  dH.transitional = function (e, r, n) {
    function i(o, s) {
      return '[Axios v' + nN + "] Transitional option '" + o + "'" + s + (n ? '. ' + n : '')
    }
    return (o, s, a) => {
      if (e === !1) throw new ot(i(s, ' has been removed' + (r ? ' in ' + r : '')), ot.ERR_DEPRECATED)
      return (
        r &&
          !vge[s] &&
          ((vge[s] = !0),
          console.warn(i(s, ' has been deprecated since v' + r + ' and will be removed in the near future'))),
        e ? e(o, s, a) : !0
      )
    }
  }
  function i$e(t, e, r) {
    if (typeof t != 'object') throw new ot('options must be an object', ot.ERR_BAD_OPTION_VALUE)
    let n = Object.keys(t),
      i = n.length
    for (; i-- > 0; ) {
      let o = n[i],
        s = e[o]
      if (s) {
        let a = t[o],
          l = a === void 0 || s(a, o, t)
        if (l !== !0) throw new ot('option ' + o + ' must be ' + l, ot.ERR_BAD_OPTION_VALUE)
        continue
      }
      if (r !== !0) throw new ot('Unknown option ' + o, ot.ERR_BAD_OPTION)
    }
  }
  var nH = { assertOptions: i$e, validators: dH },
    gm = nH.validators,
    a1 = class {
      constructor(e) {
        ;(this.defaults = e), (this.interceptors = { request: new oge(), response: new oge() })
      }
      request(e, r) {
        typeof e == 'string' ? ((r = r || {}), (r.url = e)) : (r = e || {}), (r = s1(this.defaults, r))
        let { transitional: n, paramsSerializer: i, headers: o } = r
        n !== void 0 &&
          nH.assertOptions(
            n,
            {
              silentJSONParsing: gm.transitional(gm.boolean),
              forcedJSONParsing: gm.transitional(gm.boolean),
              clarifyTimeoutError: gm.transitional(gm.boolean),
            },
            !1
          ),
          i != null &&
            (he.isFunction(i)
              ? (r.paramsSerializer = { serialize: i })
              : nH.assertOptions(i, { encode: gm.function, serialize: gm.function }, !0)),
          (r.method = (r.method || this.defaults.method || 'get').toLowerCase())
        let s = o && he.merge(o.common, o[r.method])
        o &&
          he.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], m => {
            delete o[m]
          }),
          (r.headers = sc.concat(s, o))
        let a = [],
          l = !0
        this.interceptors.request.forEach(function (h) {
          ;(typeof h.runWhen == 'function' && h.runWhen(r) === !1) ||
            ((l = l && h.synchronous), a.unshift(h.fulfilled, h.rejected))
        })
        let c = []
        this.interceptors.response.forEach(function (h) {
          c.push(h.fulfilled, h.rejected)
        })
        let u,
          p = 0,
          d
        if (!l) {
          let m = [hge.bind(this), void 0]
          for (m.unshift.apply(m, a), m.push.apply(m, c), d = m.length, u = Promise.resolve(r); p < d; )
            u = u.then(m[p++], m[p++])
          return u
        }
        d = a.length
        let f = r
        for (p = 0; p < d; ) {
          let m = a[p++],
            h = a[p++]
          try {
            f = m(f)
          } catch (g) {
            h.call(this, g)
            break
          }
        }
        try {
          u = hge.call(this, f)
        } catch (m) {
          return Promise.reject(m)
        }
        for (p = 0, d = c.length; p < d; ) u = u.then(c[p++], c[p++])
        return u
      }
      getUri(e) {
        e = s1(this.defaults, e)
        let r = pH(e.baseURL, e.url)
        return aH(r, e.params, e.paramsSerializer)
      }
    }
  he.forEach(['delete', 'get', 'head', 'options'], function (e) {
    a1.prototype[e] = function (r, n) {
      return this.request(s1(n || {}, { method: e, url: r, data: (n || {}).data }))
    }
  })
  he.forEach(['post', 'put', 'patch'], function (e) {
    function r(n) {
      return function (o, s, a) {
        return this.request(
          s1(a || {}, { method: e, headers: n ? { 'Content-Type': 'multipart/form-data' } : {}, url: o, data: s })
        )
      }
    }
    ;(a1.prototype[e] = r()), (a1.prototype[e + 'Form'] = r(!0))
  })
  var rN = a1,
    iH = class t {
      constructor(e) {
        if (typeof e != 'function') throw new TypeError('executor must be a function.')
        let r
        this.promise = new Promise(function (o) {
          r = o
        })
        let n = this
        this.promise.then(i => {
          if (!n._listeners) return
          let o = n._listeners.length
          for (; o-- > 0; ) n._listeners[o](i)
          n._listeners = null
        }),
          (this.promise.then = i => {
            let o,
              s = new Promise(a => {
                n.subscribe(a), (o = a)
              }).then(i)
            return (
              (s.cancel = function () {
                n.unsubscribe(o)
              }),
              s
            )
          }),
          e(function (o, s, a) {
            n.reason || ((n.reason = new yv(o, s, a)), r(n.reason))
          })
      }
      throwIfRequested() {
        if (this.reason) throw this.reason
      }
      subscribe(e) {
        if (this.reason) {
          e(this.reason)
          return
        }
        this._listeners ? this._listeners.push(e) : (this._listeners = [e])
      }
      unsubscribe(e) {
        if (!this._listeners) return
        let r = this._listeners.indexOf(e)
        r !== -1 && this._listeners.splice(r, 1)
      }
      static source() {
        let e
        return {
          token: new t(function (i) {
            e = i
          }),
          cancel: e,
        }
      }
    },
    o$e = iH
  function s$e(t) {
    return function (r) {
      return t.apply(null, r)
    }
  }
  function a$e(t) {
    return he.isObject(t) && t.isAxiosError === !0
  }
  var oH = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  }
  Object.entries(oH).forEach(([t, e]) => {
    oH[e] = t
  })
  var c$e = oH
  function jge(t) {
    let e = new rN(t),
      r = bge(rN.prototype.request, e)
    return (
      he.extend(r, rN.prototype, e, { allOwnKeys: !0 }),
      he.extend(r, e, null, { allOwnKeys: !0 }),
      (r.create = function (i) {
        return jge(s1(t, i))
      }),
      r
    )
  }
  var ai = jge(uH)
  ai.Axios = rN
  ai.CanceledError = yv
  ai.CancelToken = o$e
  ai.isCancel = Mge
  ai.VERSION = nN
  ai.toFormData = aN
  ai.AxiosError = ot
  ai.Cancel = ai.CanceledError
  ai.all = function (e) {
    return Promise.all(e)
  }
  ai.spread = s$e
  ai.isAxiosError = a$e
  ai.mergeConfig = s1
  ai.AxiosHeaders = sc
  ai.formToJSON = t => Lge(he.isHTMLForm(t) ? new FormData(t) : t)
  ai.getAdapter = Hge.getAdapter
  ai.HttpStatusCode = c$e
  ai.default = ai
  Gge.exports = ai
})
var zge = handleExports(cN => {
  'use strict'
  Object.defineProperty(cN, '__esModule', { value: !0 })
  cN.AxiosHttpClient = void 0
  var l$e = Vge(),
    fH = class {
      constructor(e) {
        this.endpoint = e
      }
      get(e) {
        return l$e.default.get(this.endpoint, Object.assign(Object.assign({}, e), { proxy: !1 }))
      }
    }
  cN.AxiosHttpClient = fH
})
var $ge = handleExports(lN => {
  'use strict'
  Object.defineProperty(lN, '__esModule', { value: !0 })
  lN.MemoryKeyValueStorage = void 0
  var mH = class {
    constructor() {
      this.storage = new Map()
    }
    async getValue(e, r) {
      return this.storage.has(e) ? await Promise.resolve(this.storage.get(e)) : await Promise.resolve(r || void 0)
    }
    setValue(e, r) {
      this.storage.set(e, r)
    }
  }
  lN.MemoryKeyValueStorage = mH
})
var Wge = handleExports(uN => {
  'use strict'
  Object.defineProperty(uN, '__esModule', { value: !0 })
  uN.ExperimentationServiceBase = void 0
  var u$e = $ge(),
    hH = class {
      get features() {
        return this._features
      }
      set features(e) {
        ;(this._features = e),
          this.telemetry &&
            this.telemetry.setSharedProperty(
              this.assignmentContextTelemetryPropertyName,
              this.features.assignmentContext
            )
      }
      constructor(e, r, n, i, o) {
        ;(this.telemetry = e),
          (this.assignmentContextTelemetryPropertyName = r),
          (this.telemetryEventName = n),
          (this.storageKey = i),
          (this.storage = o),
          (this.featuresConsumed = !1),
          (this.cachedTelemetryEvents = []),
          (this._features = { features: [], assignmentContext: '', configs: [] }),
          this.storageKey || (this.storageKey = 'ABExp.Features'),
          this.storage || (o = new u$e.MemoryKeyValueStorage()),
          (this.loadCachePromise = this.loadCachedFeatureData()),
          (this.initializePromise = this.loadCachePromise),
          (this.initialFetch = new Promise((s, a) => {
            this.resolveInitialFetchPromise = s
          }))
      }
      async getFeaturesAsync(e = !1) {
        if (this.fetchPromise != null) {
          try {
            await this.fetchPromise
          } catch {}
          return this.features
        }
        if (!this.featureProviders || this.featureProviders.length === 0)
          return Promise.resolve({ features: [], assignmentContext: '', configs: [] })
        try {
          this.fetchPromise = Promise.all(this.featureProviders.map(async n => await n.getFeatures()))
          let r = await this.fetchPromise
          this.updateFeatures(r, e)
        } catch {}
        return (
          (this.fetchPromise = void 0),
          this.resolveInitialFetchPromise &&
            (this.resolveInitialFetchPromise(), (this.resolveInitialFetchPromise = void 0)),
          this.features
        )
      }
      updateFeatures(e, r = !1) {
        let n = { features: [], assignmentContext: '', configs: [] }
        for (let i of e) {
          for (let o of i.features) n.features.includes(o) || n.features.push(o)
          for (let o of i.configs) {
            let s = n.configs.find(a => a.Id === o.Id)
            s ? (s.Parameters = Object.assign(Object.assign({}, s.Parameters), o.Parameters)) : n.configs.push(o)
          }
          n.assignmentContext += i.assignmentContext
        }
        ;(r || !this.featuresConsumed) && (this.features = n), this.storage && this.storage.setValue(this.storageKey, n)
      }
      async loadCachedFeatureData() {
        let e
        this.storage &&
          ((e = await this.storage.getValue(this.storageKey)),
          e !== void 0 && e.configs === void 0 && (e.configs = [])),
          this.features.features.length === 0 &&
            (this.features = e || { features: [], assignmentContext: '', configs: [] })
      }
      isFlightEnabled(e) {
        return (this.featuresConsumed = !0), this.PostEventToTelemetry(e), this.features.features.includes(e)
      }
      async isCachedFlightEnabled(e) {
        return (
          await this.loadCachePromise,
          (this.featuresConsumed = !0),
          this.PostEventToTelemetry(e),
          this.features.features.includes(e)
        )
      }
      async isFlightEnabledAsync(e) {
        let r = await this.getFeaturesAsync(!0)
        return (this.featuresConsumed = !0), this.PostEventToTelemetry(e), r.features.includes(e)
      }
      getTreatmentVariable(e, r) {
        ;(this.featuresConsumed = !0), this.PostEventToTelemetry(`${e}.${r}`)
        let n = this.features.configs.find(i => i.Id === e)
        return n?.Parameters[r]
      }
      async getTreatmentVariableAsync(e, r, n) {
        if (n) {
          let i = this.featuresConsumed,
            o = this.getTreatmentVariable(e, r)
          if (o === void 0) this.featuresConsumed = i
          else return o
        }
        return await this.getFeaturesAsync(!0), this.getTreatmentVariable(e, r)
      }
      PostEventToTelemetry(e) {
        this.cachedTelemetryEvents.includes(e) ||
          (this.telemetry.postEvent(this.telemetryEventName, new Map([['ABExp.queriedFeature', e]])),
          this.cachedTelemetryEvents.push(e))
      }
      invokeInit() {
        this.init()
      }
      addFeatureProvider(...e) {
        if (!(e == null || this.featureProviders == null)) for (let r of e) this.featureProviders.push(r)
      }
    }
  uN.ExperimentationServiceBase = hH
})
var Kge = handleExports(pN => {
  'use strict'
  Object.defineProperty(pN, '__esModule', { value: !0 })
  pN.PollingService = void 0
  var gH = class {
    constructor(e) {
      this.fetchInterval = e
    }
    StopPolling() {
      clearInterval(this.intervalHandle), (this.intervalHandle = void 0)
    }
    OnPollTick(e) {
      this.onTick = e
    }
    StartPolling(e = !1) {
      this.intervalHandle && this.StopPolling(),
        this.onTick != null &&
          (e &&
            this.onTick()
              .then(() => {})
              .catch(() => {}),
          (this.intervalHandle = setInterval(async () => {
            await this.onTick()
          }, this.fetchInterval)),
          this.intervalHandle.unref && this.intervalHandle.unref())
    }
  }
  pN.PollingService = gH
})
var Yge = handleExports(dN => {
  'use strict'
  Object.defineProperty(dN, '__esModule', { value: !0 })
  dN.ExperimentationServiceAutoPolling = void 0
  var p$e = Wge(),
    d$e = Kge(),
    vH = class extends p$e.ExperimentationServiceBase {
      constructor(e, r, n, i, o, s, a) {
        if (
          (super(e, i, o, s, a),
          (this.telemetry = e),
          (this.filterProviders = r),
          (this.refreshRateMs = n),
          (this.assignmentContextTelemetryPropertyName = i),
          (this.telemetryEventName = o),
          (this.storageKey = s),
          (this.storage = a),
          n < 1e3 && n !== 0)
        )
          throw new Error(
            'The minimum refresh rate for polling is 1000 ms (1 second). If you wish to deactivate this auto-polling use value of 0.'
          )
        n > 0 &&
          ((this.pollingService = new d$e.PollingService(n)),
          this.pollingService.OnPollTick(async () => {
            await super.getFeaturesAsync()
          }))
      }
      init() {
        this.pollingService ? this.pollingService.StartPolling(!0) : super.getFeaturesAsync()
      }
      async getFeaturesAsync(e = !1) {
        if (this.pollingService) {
          this.pollingService.StopPolling()
          let r = await super.getFeaturesAsync(e)
          return this.pollingService.StartPolling(), r
        } else return await super.getFeaturesAsync(e)
      }
    }
  dN.ExperimentationServiceAutoPolling = vH
})
var Qge = handleExports(mN => {
  'use strict'
  Object.defineProperty(mN, '__esModule', { value: !0 })
  mN.ExperimentationService = void 0
  var f$e = Ghe(),
    m$e = zge(),
    h$e = Yge(),
    fN = class extends h$e.ExperimentationServiceAutoPolling {
      constructor(e) {
        super(
          e.telemetry,
          e.filterProviders || [],
          e.refetchInterval != null ? e.refetchInterval : 0,
          e.assignmentContextTelemetryPropertyName,
          e.telemetryEventName,
          e.storageKey,
          e.keyValueStorage
        ),
          (this.options = e),
          this.invokeInit()
      }
      init() {
        ;(this.featureProviders = []),
          this.addFeatureProvider(
            new f$e.TasApiFeatureProvider(
              new m$e.AxiosHttpClient(this.options.endpoint),
              this.telemetry,
              this.filterProviders
            )
          ),
          super.init()
      }
    }
  mN.ExperimentationService = fN
  fN.REFRESH_RATE_IN_MINUTES = 30
})
var Xge = handleExports(hN => {
  'use strict'
  Object.defineProperty(hN, '__esModule', { value: !0 })
  hN.ExperimentationService = void 0
  var g$e = Qge()
  Object.defineProperty(hN, 'ExperimentationService', {
    enumerable: !0,
    get: function () {
      return g$e.ExperimentationService
    },
  })
})
var Jge = handleExports(gN => {
  'use strict'
  Object.defineProperty(gN, '__esModule', { value: !0 })
  gN.MementoKeyValueStorage = void 0
  var _H = class {
    constructor(e) {
      this.mementoGlobalStorage = e
    }
    async getValue(e, r) {
      return (await this.mementoGlobalStorage.get(e)) || r
    }
    setValue(e, r) {
      this.mementoGlobalStorage.update(e, r)
    }
  }
  gN.MementoKeyValueStorage = _H
})
var Zge = handleExports(xH => {
  'use strict'
  Object.defineProperty(xH, '__esModule', { value: !0 })
  var yH = class {
    constructor() {
      ;(this.initializePromise = Promise.resolve()), (this.initialFetch = Promise.resolve())
    }
    isFlightEnabled(e) {
      return !1
    }
    isCachedFlightEnabled(e) {
      return Promise.resolve(!1)
    }
    isFlightEnabledAsync(e) {
      return Promise.resolve(!1)
    }
    getTreatmentVariable(e, r) {}
    getTreatmentVariableAsync(e, r) {
      return Promise.resolve(void 0)
    }
  }
  xH.default = yH
})
var tve = handleExports(l1 => {
  'use strict'
  Object.defineProperty(l1, '__esModule', { value: !0 })
  l1.getExperimentationServiceAsync = l1.getExperimentationService = void 0
  var v$e = Oq(),
    _$e = Xge(),
    bH = require('vscode'),
    y$e = Jge(),
    x$e = Zge(),
    b$e = 'https://default.exp-tas.com/vscode/ab',
    E$e = 'query-expfeature',
    T$e = 'abexp.assignmentcontext',
    S$e = 'VSCode.ABExp.FeatureData',
    C$e = 1e3 * 60 * 30
  function eve(t, e, r, n, i, ...o) {
    if (!i) throw new Error('Memento storage was not provided.')
    let s = bH.workspace.getConfiguration('telemetry')
    if (!(bH.env.isTelemetryEnabled === void 0 ? s.get('enableTelemetry', !0) : bH.env.isTelemetryEnabled))
      return new x$e.default()
    let c = [new v$e.VSCodeFilterProvider(t, e, r), ...o],
      u = new y$e.MementoKeyValueStorage(i)
    return new _$e.ExperimentationService({
      filterProviders: c,
      telemetry: n,
      storageKey: S$e,
      keyValueStorage: u,
      featuresTelemetryPropertyName: '',
      assignmentContextTelemetryPropertyName: T$e,
      telemetryEventName: E$e,
      endpoint: b$e,
      refetchInterval: C$e,
    })
  }
  l1.getExperimentationService = eve
  async function I$e(t, e, r, n, i, ...o) {
    let s = eve(t, e, r, n, i, ...o)
    return await s.initializePromise, s
  }
  l1.getExperimentationServiceAsync = I$e
})
var nve = handleExports(xm => {
  'use strict'
  Object.defineProperty(xm, '__esModule', { value: !0 })
  xm.TargetPopulation = xm.getExperimentationServiceAsync = xm.getExperimentationService = void 0
  var rve = tve()
  Object.defineProperty(xm, 'getExperimentationService', {
    enumerable: !0,
    get: function () {
      return rve.getExperimentationService
    },
  })
  Object.defineProperty(xm, 'getExperimentationServiceAsync', {
    enumerable: !0,
    get: function () {
      return rve.getExperimentationServiceAsync
    },
  })
  var w$e = Oq()
  Object.defineProperty(xm, 'TargetPopulation', {
    enumerable: !0,
    get: function () {
      return w$e.TargetPopulation
    },
  })
})
var ove = handleExports(vN => {
  'use strict'
  Object.defineProperty(vN, '__esModule', { value: !0 })
  vN.BaseTelemetryReporter = void 0
  var EH = class {
    constructor(e, r, n) {
      ;(this.telemetrySender = e),
        (this.vscodeAPI = r),
        (this.userOptIn = !1),
        (this.errorOptIn = !1),
        (this.disposables = []),
        (this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter()),
        (this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event),
        (this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, n)),
        this.updateUserOptIn(),
        this.telemetryLogger.onDidChangeEnableStates(() => {
          this.updateUserOptIn()
        })
    }
    updateUserOptIn() {
      ;(this.errorOptIn = this.telemetryLogger.isErrorsEnabled),
        (this.userOptIn = this.telemetryLogger.isUsageEnabled),
        (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) &&
          this.telemetrySender.instantiateSender(),
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel)
    }
    get telemetryLevel() {
      return this.errorOptIn && this.userOptIn ? 'all' : this.errorOptIn ? 'error' : 'off'
    }
    internalSendTelemetryEvent(e, r, n, i) {
      i
        ? this.telemetrySender.sendEventData(e, { properties: r, measurements: n })
        : this.telemetryLogger.logUsage(e, { properties: r, measurements: n })
    }
    sendTelemetryEvent(e, r, n) {
      this.internalSendTelemetryEvent(e, r, n, !1)
    }
    sendRawTelemetryEvent(e, r, n) {
      let i = { ...r }
      for (let o of Object.keys(i ?? {})) {
        let s = i[o]
        typeof o == 'string' &&
          s !== void 0 &&
          (i[o] = new this.vscodeAPI.TelemetryTrustedValue(typeof s == 'string' ? s : s.value))
      }
      this.sendTelemetryEvent(e, i, n)
    }
    sendDangerousTelemetryEvent(e, r, n) {
      this.telemetrySender.instantiateSender(), this.internalSendTelemetryEvent(e, r, n, !0)
    }
    internalSendTelemetryErrorEvent(e, r, n, i) {
      i
        ? this.telemetrySender.sendEventData(e, { properties: r, measurements: n })
        : this.telemetryLogger.logError(e, { properties: r, measurements: n })
    }
    sendTelemetryErrorEvent(e, r, n) {
      this.internalSendTelemetryErrorEvent(e, r, n, !1)
    }
    sendDangerousTelemetryErrorEvent(e, r, n) {
      this.telemetrySender.instantiateSender(), this.internalSendTelemetryErrorEvent(e, r, n, !0)
    }
    async dispose() {
      return (
        await this.telemetrySender.dispose(),
        this.telemetryLogger.dispose(),
        Promise.all(this.disposables.map(e => e.dispose()))
      )
    }
  }
  vN.BaseTelemetryReporter = EH
})
var sve = handleExports(_N => {
  'use strict'
  Object.defineProperty(_N, '__esModule', { value: !0 })
  _N.BaseTelemetrySender = void 0
  var Vp
  ;(function (t) {
    ;(t[(t.NOT_INSTANTIATED = 0)] = 'NOT_INSTANTIATED'),
      (t[(t.INSTANTIATING = 1)] = 'INSTANTIATING'),
      (t[(t.INSTANTIATED = 2)] = 'INSTANTIATED')
  })(Vp || (Vp = {}))
  var TH = class {
    constructor(e, r) {
      ;(this._instantiationStatus = Vp.NOT_INSTANTIATED),
        (this._eventQueue = []),
        (this._exceptionQueue = []),
        (this._clientFactory = r),
        (this._key = e)
    }
    sendEventData(e, r) {
      if (!this._telemetryClient) {
        this._instantiationStatus !== Vp.INSTANTIATED && this._eventQueue.push({ eventName: e, data: r })
        return
      }
      this._telemetryClient.logEvent(e, r)
    }
    sendErrorData(e, r) {
      if (!this._telemetryClient) {
        this._instantiationStatus !== Vp.INSTANTIATED && this._exceptionQueue.push({ exception: e, data: r })
        return
      }
      let n = { stack: e.stack, message: e.message, name: e.name }
      r ? (r.properties = { ...r.properties, ...n }) : (r = { properties: n }),
        this._telemetryClient.logEvent('unhandlederror', r)
    }
    async flush() {
      return this._telemetryClient?.flush()
    }
    async dispose() {
      this._telemetryClient && (await this._telemetryClient.dispose(), (this._telemetryClient = void 0))
    }
    _flushQueues() {
      this._eventQueue.forEach(({ eventName: e, data: r }) => this.sendEventData(e, r)),
        (this._eventQueue = []),
        this._exceptionQueue.forEach(({ exception: e, data: r }) => this.sendErrorData(e, r)),
        (this._exceptionQueue = [])
    }
    instantiateSender() {
      this._instantiationStatus === Vp.NOT_INSTANTIATED &&
        ((this._instantiationStatus = Vp.INSTANTIATING),
        this._clientFactory(this._key)
          .then(e => {
            ;(this._telemetryClient = e), (this._instantiationStatus = Vp.INSTANTIATED), this._flushQueues()
          })
          .catch(e => {
            console.error(e), (this._instantiationStatus = Vp.INSTANTIATED)
          }))
    }
  }
  _N.BaseTelemetrySender = TH
})
var CH = handleExports(yN => {
  'use strict'
  Object.defineProperty(yN, '__esModule', { value: !0 })
  yN.TelemetryUtil = void 0
  var SH = class t {
    static applyReplacements(e, r) {
      for (let n of Object.keys(e))
        for (let i of r)
          i.lookup.test(n) && (i.replacementString !== void 0 ? (e[n] = i.replacementString) : delete e[n])
    }
    static shouldUseOneDataSystemSDK(e) {
      return (
        e.length === 74 &&
        e[32] === '-' &&
        e[41] === '-' &&
        e[46] === '-' &&
        e[51] === '-' &&
        e[56] === '-' &&
        e[69] === '-'
      )
    }
    static getAdditionalCommonProperties(e) {
      return {
        'common.os': e.platform,
        'common.nodeArch': e.architecture,
        'common.platformversion': (e.release || '').replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, '$1$2$3'),
        'common.telemetryclientversion': '0.9.0',
      }
    }
    static getInstance() {
      return t._instance || (t._instance = new t()), t._instance
    }
  }
  yN.TelemetryUtil = SH
})
var u1,
  zp,
  du,
  Xc,
  p1,
  JT,
  IH = createGetter(() => {
    ;(u1 = 'function'), (zp = 'object'), (du = 'undefined'), (Xc = 'prototype'), (p1 = Object), (JT = p1[Xc])
  })
var Po,
  ln,
  d1,
  wH,
  bm,
  AH,
  $p,
  ac,
  ZT,
  RH,
  Wp,
  eS,
  tS,
  ave,
  xN,
  bN,
  Jc,
  DH,
  EN,
  TN,
  f1,
  Fn,
  SN,
  PH,
  No,
  NH,
  kH,
  _a,
  qt = createGetter(() => {
    ;(Po = void 0),
      (ln = null),
      (d1 = ''),
      (wH = 'boolean'),
      (bm = 'function'),
      (AH = 'number'),
      ($p = 'object'),
      (ac = 'prototype'),
      (ZT = '__proto__'),
      (RH = 'string'),
      (Wp = 'undefined'),
      (eS = 'constructor'),
      (tS = 'Symbol'),
      (ave = '_polyfill'),
      (xN = 'indexOf'),
      (bN = 'lastIndexOf'),
      (Jc = 'length'),
      (DH = 'done'),
      (EN = 'value'),
      (TN = 'name'),
      (f1 = 'slice'),
      (Fn = Object),
      (SN = Fn[ac]),
      (PH = String),
      (No = PH[ac]),
      (NH = Math),
      (kH = Array),
      (_a = kH[ac])
  })
function rS(t, e) {
  var r = e
  try {
    r = t()
  } catch {}
  return r
}
var OH = createGetter(() => {})
function m1(t) {
  return function (e) {
    return typeof e === t
  }
}
function xv(t) {
  var e = '[object ' + t + ']'
  return function (r) {
    return !!(r && bv(r) === e)
  }
}
function bv(t) {
  return SN.toString.call(t)
}
function CN(t, e) {
  return typeof t === e
}
function vt(t) {
  return typeof t === Wp || t === Wp
}
function we(t) {
  return t === ln || vt(t)
}
function LH(t) {
  return t === ln || !IN(t)
}
function IN(t) {
  return !!t || t !== Po
}
function Br(t) {
  return !t && we(t) ? !1 : !!t && typeof t === $p
}
function Em(t) {
  return !!t && mt(t.then)
}
function wN(t) {
  return (
    !t ||
    !rS(function () {
      return t && 0 + t
    }, t)
  )
}
function el(t) {
  return !(
    !t ||
    rS(function () {
      return !(t && 0 + t)
    }, !t)
  )
}
var R$e,
  MH,
  gt,
  mt,
  Xe,
  h1,
  Gi,
  Zc,
  D$e,
  P$e,
  N$e,
  k$e,
  O$e,
  fu,
  as = createGetter(() => {
    qt()
    OH()
    R$e = [RH, AH, wH, Wp, 'symbol', 'bigint']
    ;(MH = function (t) {
      return t !== $p && R$e.indexOf(t) !== -1
    }),
      (gt = m1(RH)),
      (mt = m1(bm))
    ;(Xe = kH.isArray),
      (h1 = xv('Date')),
      (Gi = m1(AH)),
      (Zc = m1(wH)),
      (D$e = xv('RegExp')),
      (P$e = xv('File')),
      (N$e = xv('FormData')),
      (k$e = xv('Blob')),
      (O$e = xv('ArrayBuffer')),
      (fu = xv('Error'))
  })
var Ev,
  AN = createGetter(() => {
    qt()
    Ev = Fn.getOwnPropertyDescriptor
  })
function Wn(t, e) {
  return t && SN.hasOwnProperty.call(t, e)
}
var RN = createGetter(() => {
  qt()
})
function cve(t, e) {
  return Wn(t, e) || !!Ev(t, e)
}
var Os,
  DN = createGetter(() => {
    qt()
    AN()
    RN()
    Os = Fn.hasOwn || cve
  })
function ze(t, e, r) {
  if (t && Br(t)) {
    for (var n in t) if (Os(t, n) && e.call(r || t, n, t[n]) === -1) break
  }
}
var Tm = createGetter(() => {
  as()
  DN()
})
function FH(t, e, r, n) {
  var i = {}
  return (
    ze(t, function (o, s) {
      ;(i[o] = e ? s : o), (i[s] = r ? s : o)
    }),
    n(i)
  )
}
var lve = createGetter(() => {
  Tm()
})
function Cn(t) {
  throw new Error(t)
}
function fn(t) {
  throw new TypeError(t)
}
var Sm = createGetter(() => {})
function uve(t) {
  var e = []
  return (
    ze(t, function (r, n) {
      e.push([r, n])
    }),
    e
  )
}
function pve(t) {
  var e = []
  return (
    ze(t, function (r, n) {
      e.push(n)
    }),
    e
  )
}
var dve = createGetter(() => {
  Tm()
})
function Si(t) {
  return (!Br(t) || t === ln) && fn('objKeys called on non-object'), Fn.keys(t)
}
function cs(t) {
  return (
    UH &&
      ze(t, function (e, r) {
        ;(Xe(r) || Br(r)) && UH(r)
      }),
    mu(t)
  )
}
var UH,
  fve,
  L$e,
  Tv,
  mu,
  PN,
  g1,
  M$e,
  H3t,
  v1 = createGetter(() => {
    qt()
    as()
    Sm()
    Tm()
    dve()
    ;(UH = Fn.freeze),
      (fve = function (t) {
        return t
      }),
      (L$e = function (t) {
        return t[ZT] || ln
      }),
      (Tv = Fn.assign)
    ;(mu = UH || fve),
      (PN = Fn.seal || fve),
      (g1 = Fn.getPrototypeOf || L$e),
      (M$e = Fn.entries || uve),
      (H3t = Fn.values || pve)
  })
function BH(t) {
  return FH(t, 1, 0, cs)
}
function qH(t) {
  return FH(t, 0, 0, cs)
}
function mve(t) {
  var e = {}
  return (
    ze(t, function (r, n) {
      ;(e[r] = n[1]), (e[n[0]] = n[1])
    }),
    cs(e)
  )
}
function HH(t) {
  return mve(t)
}
var jH = createGetter(() => {
  lve()
  Tm()
  v1()
})
var NN,
  GH = createGetter(() => {
    jH()
    NN = qH({
      asyncIterator: 0,
      hasInstance: 1,
      isConcatSpreadable: 2,
      iterator: 3,
      match: 4,
      matchAll: 5,
      replace: 6,
      search: 7,
      species: 8,
      split: 9,
      toPrimitive: 10,
      toStringTag: 11,
      unscopables: 12,
    })
  })
var ci,
  _1 = createGetter(() => {
    qt()
    ci = PH
  })
function zH() {
  var t
  return (
    typeof globalThis !== Wp && (t = globalThis),
    !t && typeof self !== Wp && (t = self),
    !t && typeof window !== Wp && (t = window),
    !t && typeof global !== Wp && (t = global),
    t
  )
}
function kN() {
  if (!VH) {
    var t = zH() || {}
    VH = t[hve] = t[hve] || {}
  }
  return VH
}
var hve,
  VH,
  ON = createGetter(() => {
    qt()
    hve = '__tsUtils$gblCfg'
  })
function $e(t, e) {
  var r = d1
  if (fu(t)) r = "{ stack: '" + t.stack + "', message: '" + t.message + "', name: '" + t.name + "'"
  else
    try {
      r = JSON.stringify(t, ln, e ? (Gi(e) ? e : 4) : Po)
    } catch (n) {
      r = ' - ' + $e(n, e)
    }
  return bv(t) + ': ' + r
}
var Cm = createGetter(() => {
  qt()
  as()
})
function vve(t) {
  return function (e) {
    return e[t]
  }
}
var $H,
  gve,
  LN,
  ko,
  cc,
  ls = createGetter(() => {
    Cm()
    Sm()
    _1()
    qt()
    ;($H = _a[f1]),
      (gve = function (t, e) {
        fn("'" + ci(t) + "' not defined for " + $e(e))
      }),
      (LN = function (t) {
        return function (e) {
          return e[t].apply(e, $H.call(arguments, 1))
        }
      }),
      (ko = function (t, e) {
        var r = e && e[t]
        return function (n) {
          var i = (n && n[t]) || r
          if (i) return i.apply(n, $H.call(arguments, 1))
          gve(t, n)
        }
      }),
      (cc = function (t, e, r) {
        var n = e && e[t]
        return function (i) {
          var o = (i && i[t]) || n
          if (o || r) {
            var s = arguments
            return (o || r).apply(i, o ? $H.call(s, 1) : s)
          }
          gve(t, i)
        }
      })
  })
var c8t,
  _ve,
  yve = createGetter(() => {
    qt()
    ;(c8t = NH.min), (_ve = NH.max)
  })
var WH,
  xve = createGetter(() => {
    qt()
    ls()
    WH = ko(f1, No)
  })
function bve(t, e, r) {
  return (
    we(t) && fn("'polyStrSubstr called with invalid " + $e(t)),
    r < 0 ? d1 : ((e = e || 0), e < 0 && (e = _ve(e + t[Jc], 0)), vt(r) ? WH(t, e) : WH(t, e, e + r))
  )
}
function Im(t, e) {
  return Un(t, 0, e)
}
var Un,
  tl,
  MN = createGetter(() => {
    as()
    Cm()
    Sm()
    qt()
    ls()
    yve()
    xve()
    ;(Un = ko('substring', No)), (tl = cc('substr', No, bve))
  })
function F$e(t, e, r) {
  gt(t) || fn("'" + $e(t) + "' is not a string")
  var n = gt(e) ? e : ci(e),
    i = n[Jc],
    o = r > 0 ? r : 0
  return Un(t, o, o + i) === n
}
var Sv,
  Eve = createGetter(() => {
    as()
    Cm()
    Sm()
    qt()
    ls()
    _1()
    MN()
    Sv = cc('startsWith', No, F$e)
  })
function U$e() {
  if (!KH) {
    var t = kN()
    KH = t.gblSym = t.gblSym || { k: {}, s: {} }
  }
  return KH
}
function FN(t) {
  var e = {
    description: ci(t),
    toString: function () {
      return tS + '(' + t + ')'
    },
  }
  return (e[ave] = !0), e
}
function Cve(t) {
  var e = U$e()
  if (!Os(e.k, t)) {
    var r = FN(t),
      n = Si(e.s).length
    ;(r[Tve] = function () {
      return n + '_' + r.toString()
    }),
      (e.k[t] = r),
      (e.s[r[Tve]()] = ci(t))
  }
  return e.k[t]
}
function Ive(t) {
  var e,
    r = NN[t]
  return r && (e = Sve[r] = Sve[r] || FN(tS + '.' + r)), e
}
var Tve,
  KH,
  Sve,
  wve = createGetter(() => {
    GH()
    qt()
    DN()
    _1()
    ON()
    v1()
    Tve = '_urid'
    Sve = {}
  })
function Ave(t) {
  var e = {}
  if (((e[UN.c] = !0), (e[UN.e] = !0), t.l)) {
    e.get = function () {
      return t.l.v
    }
    var r = Ev(t.l, 'v')
    r &&
      r.set &&
      (e.set = function (n) {
        t.l.v = n
      })
  }
  return (
    ze(t, function (n, i) {
      e[UN[n]] = vt(i) ? e[UN[n]] : i
    }),
    e
  )
}
function BN(t, e, r, n, i, o) {
  var s = { e: o, c: i }
  return r && (s.g = r), n && (s.s = n), li(t, e, Ave(s))
}
function xr(t, e, r) {
  return li(t, e, Ave(r))
}
var UN,
  li,
  B$e,
  y1 = createGetter(() => {
    qt()
    as()
    Tm()
    AN()
    UN = { e: 'enumerable', c: 'configurable', v: EN, w: 'writable', g: 'get', s: 'set' }
    ;(li = Fn.defineProperty), (B$e = Fn.defineProperties)
  })
function rl(t) {
  var e = {}
  return (
    YH && YH(),
    (e.b = Wr.lzy),
    li(e, 'v', {
      configurable: !0,
      get: function () {
        var r = t()
        return Wr.lzy || (li(e, 'v', { value: r }), e.b && delete e.b), Wr.lzy && e.b !== Wr.lzy && (e.b = Wr.lzy), r
      },
    }),
    e
  )
}
var Wr,
  YH,
  wm = createGetter(() => {
    qt()
    ON()
    y1()
    YH = function () {
      ;(Wr = kN()), (YH = ln)
    }
  })
function Kp(t, e) {
  return rl(function () {
    return rS(t, e)
  })
}
var qN = createGetter(() => {
  wm()
  OH()
})
var Rve,
  x1,
  b1,
  HN,
  jN,
  GN,
  QH,
  ya,
  Oo,
  Kr,
  Am,
  In,
  Rm,
  Bn,
  E1,
  ui,
  VN,
  nS,
  XH,
  iS = createGetter(() => {
    qt()
    ON()
    qN()
    wm()
    ;(Rve = 'window'),
      (ya = function (t) {
        return Kp(function () {
          return Kr(t) || Po
        }, Po)
      }),
      (Oo = function (t) {
        return (!x1 || t === !1 || (Wr && Wr.lzy && !x1.b)) && (x1 = Kp(zH, ln)), x1.v
      }),
      (Kr = function (t, e) {
        var r = !x1 || e === !1 ? Oo(e) : x1.v
        return r && r[t] ? r[t] : t === Rve && b1 ? b1.v : ln
      }),
      (Am = function () {
        return !!In()
      }),
      (In = function () {
        return (!HN || (Wr && Wr.lzy && !HN.b)) && (HN = ya('document')), HN.v
      }),
      (Rm = function () {
        return !!Bn()
      }),
      (Bn = function () {
        return (!b1 || (Wr && Wr.lzy && !b1.b)) && (b1 = ya(Rve)), b1.v
      }),
      (E1 = function () {
        return !!ui()
      }),
      (ui = function () {
        return (!jN || (Wr && Wr.lzy && !jN.b)) && (jN = ya('navigator')), jN.v
      }),
      (VN = function () {
        return !!nS()
      }),
      (nS = function () {
        return (!GN || (Wr && Wr.lzy && !GN.b)) && (GN = ya('history')), GN.v
      }),
      (XH = function () {
        return (
          !QH &&
            (QH = Kp(function () {
              return !!(process && (process.versions || {}).node)
            }, !1)),
          QH.v
        )
      })
  })
function Pve(t) {
  return Kp(function () {
    return us.v ? us.v[t] : Po
  }, Po)
}
function JH() {
  return !!oS()
}
function oS() {
  var t = !us || (Wr && Wr.lzy && !us.b)
  return t && (us = ya(tS)), (!zN || t) && (zN = Pve('for')), (!Dve || t) && (Dve = Pve('keyFor')), us.v
}
function Cv(t, e) {
  var r = NN[t]
  return (!us || (Wr.lzy && !us.b)) && oS(), us.v ? us.v[r || t] : e ? Po : Ive(t)
}
function Iv(t, e) {
  return (!us || (Wr.lzy && !us.b)) && oS(), us.v ? us.v(t) : e ? ln : FN(t)
}
function sS(t) {
  return (!zN || (Wr.lzy && !us.b)) && oS(), (zN.v || Cve)(t)
}
var us,
  zN,
  Dve,
  Nve,
  $N = createGetter(() => {
    qt()
    wve()
    GH()
    as()
    wm()
    qN()
    iS()
    Nve = m1('symbol')
  })
function aS(t) {
  return !!t && mt(t.next)
}
function kve(t) {
  return !LH(t) && mt(t[Cv(3)])
}
var ZH = createGetter(() => {
  $N()
  as()
})
function Ove(t, e, r) {
  if (
    t &&
    (aS(t) ||
      (!WN &&
        (WN = rl(function () {
          return Cv(3)
        })),
      (t = t[WN.v] ? t[WN.v]() : null)),
    aS(t))
  ) {
    var n = void 0,
      i = void 0
    try {
      for (var o = 0; !(i = t.next())[DH] && e.call(r || t, i[EN], o, t) !== -1; ) o++
    } catch (s) {
      ;(n = { e: s }), t.throw && ((i = null), t.throw(n))
    } finally {
      try {
        i && !i[DH] && t.return && t.return(i)
      } finally {
        if (n) throw n.e
      }
    }
  }
}
var WN,
  Lve = createGetter(() => {
    wm()
    qt()
    $N()
    ZH()
  })
var Yp,
  KN = createGetter(() => {
    ls()
    Yp = LN('apply')
  })
function lc(t, e) {
  return (
    !vt(e) &&
      t &&
      (Xe(e)
        ? Yp(t.push, t, e)
        : aS(e) || kve(e)
        ? Ove(e, function (r) {
            t.push(r)
          })
        : t.push(e)),
    t
  )
}
var Mve = createGetter(() => {
  as()
  ZH()
  Lve()
  KN()
})
function Ae(t, e, r) {
  if (t) for (var n = t[Jc] >>> 0, i = 0; i < n && !(i in t && e.call(r || t, t[i], i, t) === -1); i++);
}
var YN = createGetter(() => {
  qt()
})
var ir,
  q$e,
  ej = createGetter(() => {
    qt()
    ls()
    ;(ir = ko(xN, _a)), (q$e = ko(bN, _a))
  })
var hu,
  Fve = createGetter(() => {
    qt()
    ls()
    hu = ko('map', _a)
  })
var po,
  cS = createGetter(() => {
    qt()
    ls()
    po = ko(f1, _a)
  })
var lS,
  tj = createGetter(() => {
    ls()
    lS = LN('call')
  })
function Uve(t, e, r) {
  return ir(t, e, r) !== -1
}
var Bve = createGetter(() => {
  ej()
})
var QN,
  qve = createGetter(() => {
    qt()
    ls()
    Bve()
    QN = cc('includes', _a, Uve)
  })
var T1,
  Hve = createGetter(() => {
    qt()
    ls()
    T1 = ko('reduce', _a)
  })
function j$e(t) {
  if (!t) return {}
  var e = typeof t
  if (e !== $p && e !== bm) throw new TypeError('Prototype must be an Object or function: ' + $e(t))
  function r() {}
  return (r[ac] = t), new r()
}
var H$e,
  uS,
  rj = createGetter(() => {
    qt()
    Cm()
    ;(H$e = Fn.create), (uS = H$e || j$e)
  })
function ij(t, e) {
  var r =
    Fn.setPrototypeOf ||
    function (n, i) {
      !nj &&
        (nj = rl(function () {
          var o
          return (o = {}), (o[ZT] = []), o instanceof Array
        })),
        nj.v
          ? (n[ZT] = i)
          : ze(i, function (o, s) {
              return (n[o] = s)
            })
    }
  return r(t, e)
}
var nj,
  jve = createGetter(() => {
    wm()
    qt()
    Tm()
  })
function oj(t, e, r) {
  var n = r || Error,
    i = n[ac][TN],
    o = Error.captureStackTrace
  return G$e(
    t,
    function () {
      var s = this
      try {
        Gve(n, t)
        var a = Yp(n, s, po(arguments)) || s
        if (a !== s) {
          var l = g1(s)
          l !== g1(a) && ij(a, l)
        }
        return o && o(a, s[eS]), e && e(a, arguments), a
      } finally {
        Gve(n, i)
      }
    },
    n
  )
}
var G$e,
  Gve,
  Vve,
  zve = createGetter(() => {
    cS()
    KN()
    qt()
    rj()
    y1()
    v1()
    jve()
    ;(G$e = function (t, e, r) {
      Vve(e, t), (e = ij(e, r))
      function n() {
        ;(this.constructor = e), Vve(this, t)
      }
      return (e[ac] = r === ln ? uS(r) : ((n[ac] = r[ac]), new n())), e
    }),
      (Gve = function (t, e) {
        try {
          e && (t[TN] = e)
        } catch {}
      }),
      (Vve = function (t, e) {
        try {
          xr(t, TN, { v: e, c: !0, e: !1 })
        } catch {}
      })
  })
function wn() {
  return (Date.now || $ve)()
}
function $ve() {
  return new Date().getTime()
}
var sj = createGetter(() => {})
function aj(t) {
  return function (r) {
    return we(r) && fn('strTrim called [' + $e(r) + ']'), r && r.replace && (r = r.replace(t, d1)), r
  }
}
var Wve,
  Kve,
  Yve,
  Qve = createGetter(() => {
    as()
    Cm()
    Sm()
    qt()
    ;(Wve = aj(/^\s+|(?=\s)\s+$/g)), (Kve = aj(/^\s+/g)), (Yve = aj(/(?=\s)\s+$/g))
  })
var pr,
  V$e,
  z$e,
  Xve = createGetter(() => {
    qt()
    ls()
    Qve()
    ;(pr = cc('trim', No, Wve)), (V$e = cc('trimStart', No, Kve)), (z$e = cc('trimEnd', No, Yve))
  })
function Ci(t) {
  if (!t || typeof t !== $p) return !1
  uj || (uj = Rm() ? Bn() : !0)
  var e = !1
  if (t !== uj) {
    lj || ((cj = Function[ac].toString), (lj = lS(cj, Fn)))
    try {
      var r = g1(t)
      ;(e = !r), e || (Wn(r, eS) && (r = r[eS]), (e = r && typeof r === bm && cj.call(r) === lj))
    } catch {}
  }
  return e
}
var cj,
  lj,
  uj,
  pj = createGetter(() => {
    tj()
    iS()
    qt()
    RN()
    v1()
  })
function W$e(t, e, r, n) {
  var i
  return (
    Ae(t, function (o) {
      if (o.k === e) return (i = o), -1
    }),
    i || ((i = { k: e, v: e }), t.push(i), n(i)),
    i.v
  )
}
function dj(t, e, r, n) {
  var i = r.handler,
    o = r.path ? (n ? r.path.concat(n) : r.path) : [],
    s = { handler: r.handler, src: r.src, path: o },
    a = typeof e,
    l = !1,
    c = !1
  e && a === $p ? (l = Ci(e)) : (c = e === ln || MH(a))
  var u = {
    type: a,
    isPrim: c,
    isPlain: l,
    value: e,
    result: e,
    path: o,
    origin: r.src,
    copy: function (p, d) {
      return dj(t, p, d ? s : r, d)
    },
    copyTo: function (p, d) {
      return Zve(t, p, d, s)
    },
  }
  return u.isPrim
    ? i && lS(i, r, u)
      ? u.result
      : e
    : W$e(t, e, o, function (p) {
        xr(u, 'result', {
          g: function () {
            return p.v
          },
          s: function (m) {
            p.v = m
          },
        })
        for (var d = 0, f = i; !lS(f || (d < Jve.length ? Jve[d++] : $$e), r, u); ) f = ln
      })
}
function Zve(t, e, r, n) {
  if (!we(r)) for (var i in r) e[i] = dj(t, r[i], n, i)
  return e
}
function e0e(t, e, r) {
  var n = { handler: r, src: e, path: [] }
  return Zve([], t, e, n)
}
function t0e(t, e) {
  var r = { handler: e, src: t }
  return dj([], t, r)
}
function K$e(t) {
  var e = t.value
  if (Xe(e)) {
    var r = (t.result = [])
    return (r.length = e.length), t.copyTo(r, e), !0
  }
  return !1
}
function Y$e(t) {
  var e = t.value
  return h1(e) ? ((t.result = new Date(e.getTime())), !0) : !1
}
function Q$e(t) {
  return t.type === bm
}
function r0e(t) {
  var e = t.value
  if (e && t.isPlain) {
    var r = (t.result = {})
    return t.copyTo(r, e), !0
  }
  return !1
}
var $$e,
  Jve,
  n0e = createGetter(() => {
    YN()
    tj()
    as()
    qt()
    y1()
    pj()
    ;($$e = function (t) {
      return t.value && r0e(t), !0
    }),
      (Jve = [K$e, r0e, Q$e, Y$e])
  })
function X$e(t, e) {
  return (
    Ae(e, function (r) {
      e0e(t, r)
    }),
    t
  )
}
function XN(t, e, r, n, i, o, s) {
  return X$e(t0e(t) || {}, po(arguments))
}
var i0e = createGetter(() => {
  YN()
  cS()
  n0e()
})
var S1,
  o0e = createGetter(() => {
    qt()
    ls()
    S1 = vve(Jc)
  })
function Qp() {
  return (!JN || (!JN.b && Wr && Wr.lzy)) && (JN = ya('performance')), JN.v
}
function C1() {
  var t = Qp()
  return t && t.now ? t.now() : wn()
}
var JN,
  s0e = createGetter(() => {
    sj()
    iS()
    wm()
  })
function J$e(t, e, r) {
  gt(t) || fn("'" + $e(t) + "' is not a string")
  var n = gt(e) ? e : ci(e),
    i = n[Jc],
    o = t[Jc],
    s = !vt(r) && r < o ? r : o
  return Un(t, s - i, s) === n
}
var Dm,
  a0e = createGetter(() => {
    as()
    Cm()
    Sm()
    qt()
    ls()
    _1()
    MN()
    Dm = cc('endsWith', No, J$e)
  })
var ps,
  Z$e,
  c0e = createGetter(() => {
    qt()
    ls()
    ;(ps = ko(xN, No)), (Z$e = ko(bN, No))
  })
function u0e(t, e, r) {
  var n,
    i = !0,
    o = t ? e(ln) : ln,
    s,
    a = function () {
      return (i = !1), o && o[fj] && o[fj](), s
    },
    l = function () {
      return (i = !0), o && o[ZN] && o[ZN](), s
    },
    c = function () {
      return o && o[mj] ? o[mj]() : i
    },
    u = function () {
      return (o = e(o)), i || a(), s
    },
    p = function () {
      o && r(o), (o = ln)
    },
    d = function (f) {
      !f && o && p(), f && !o && u()
    }
  return (
    (s = ((n = { cancel: p, refresh: u }), (n[mj] = c), (n[ZN] = l), (n[fj] = a), (n[l0e] = !1), n)),
    li(s, l0e, {
      get: function () {
        return !!o
      },
      set: d,
    }),
    {
      h: s,
      dn: function () {
        o = ln
      },
    }
  )
}
var ZN,
  fj,
  mj,
  l0e,
  p0e = createGetter(() => {
    qt()
    y1()
    ;(ZN = 'ref'), (fj = 'un' + ZN), (mj = 'hasRef'), (l0e = 'enabled')
  })
function hj(t, e, r, n) {
  var i = Xe(r),
    o = i ? r.length : 0,
    s = (o > 0 ? r[0] : i ? Po : r) || setTimeout,
    a = (o > 1 ? r[1] : Po) || clearTimeout,
    l = n[0]
  n[0] = function () {
    c.dn(), Yp(l, t, po(arguments))
  }
  var c = u0e(
    e,
    function (u) {
      if (u) {
        if (u.refresh) return u.refresh(), u
        Yp(a, t, [u])
      }
      return Yp(s, t, n)
    },
    function (u) {
      Yp(a, t, [u])
    }
  )
  return c.h
}
function Ls(t, e) {
  return hj(this, !0, Po, po(arguments))
}
function gj(t, e, r) {
  return hj(this, !0, t, po(arguments, 1))
}
function vj(t, e) {
  return hj(this, !1, Po, po(arguments))
}
var d0e = createGetter(() => {
  cS()
  KN()
  as()
  qt()
  p0e()
})
var pt = createGetter(() => {
  Mve()
  YN()
  qve()
  ej()
  Fve()
  Hve()
  cS()
  as()
  zve()
  sj()
  Cm()
  jH()
  iS()
  i0e()
  wm()
  o0e()
  s0e()
  qN()
  Sm()
  rj()
  y1()
  Tm()
  AN()
  DN()
  RN()
  pj()
  v1()
  a0e()
  c0e()
  Eve()
  MN()
  _1()
  Xve()
  $N()
  d0e()
})
function Ms(t, e) {
  typeof e !== u1 && e !== null && fn('Class extends value ' + String(e) + ' is not a constructor or null'), _j(t, e)
  function r() {
    this.constructor = t
  }
  t[Xc] = e === null ? uS(e) : ((r[Xc] = e[Xc]), new r())
}
function ek(t, e) {
  for (var r = 0, n = e.length, i = t.length; r < n; r++, i++) t[i] = e[r]
  return t
}
var u9t,
  p9t,
  f0e,
  tWe,
  uc,
  _j,
  m0e = createGetter(() => {
    pt()
    IH()
    ;(u9t = (Oo() || {}).Symbol),
      (p9t = (Oo() || {}).Reflect),
      (f0e = 'hasOwnProperty'),
      (tWe = function (t) {
        for (var e, r = 1, n = arguments.length; r < n; r++) {
          e = arguments[r]
          for (var i in e) JT[f0e].call(e, i) && (t[i] = e[i])
        }
        return t
      }),
      (uc = Tv || tWe),
      (_j = function (t, e) {
        return (
          (_j =
            p1.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (r, n) {
                r.__proto__ = n
              }) ||
            function (r, n) {
              for (var i in n) n[f0e](i) && (r[i] = n[i])
            }),
          _j(t, e)
        )
      })
  })
var h0e = createGetter(() => {})
var Fs = createGetter(() => {
  IH()
  m0e()
  h0e()
  pt()
})
function E0e(t) {
  return t && (t === Cj[Pm] || t === Array[Pm])
}
function Ij(t) {
  return E0e(t) || t === Function[Pm]
}
function wv(t) {
  var e
  if (t) {
    if (dS) return dS(t)
    var r = t[b0e] || t[Pm] || (t[ik] ? t[ik][Pm] : null)
    ;(e = t[rk] || r), Wn(t, rk) || (delete t[yj], (e = t[rk] = t[yj] || t[rk]), (t[yj] = r))
  }
  return e
}
function ak(t, e) {
  var r = []
  if (_0e) r = _0e(t)
  else for (var n in t) typeof n == 'string' && Wn(t, n) && r.push(n)
  if (r && r.length > 0) for (var i = 0; i < r.length; i++) e(r[i])
}
function wj(t, e, r) {
  return e !== ik && typeof t[e] === ok && (r || Wn(t, e))
}
function ck(t) {
  fn('DynamicProto: ' + t)
}
function nWe(t) {
  var e = {}
  return (
    ak(t, function (r) {
      !e[r] && wj(t, r, !1) && (e[r] = t[r])
    }),
    e
  )
}
function Aj(t, e) {
  for (var r = t.length - 1; r >= 0; r--) if (t[r] === e) return !0
  return !1
}
function iWe(t, e, r, n) {
  function i(l, c, u) {
    var p = c[u]
    if (p[bj] && n) {
      var d = l[sk] || {}
      d[pS] !== !1 && (p = (d[c[I1]] || {})[u] || p)
    }
    return function () {
      return p.apply(l, arguments)
    }
  }
  var o = {}
  ak(r, function (l) {
    o[l] = i(e, r, l)
  })
  for (var s = wv(t), a = []; s && !Ij(s) && !Aj(a, s); )
    ak(s, function (l) {
      !o[l] && wj(s, l, !dS) && (o[l] = i(e, s, l))
    }),
      a.push(s),
      (s = wv(s))
  return o
}
function oWe(t, e, r, n) {
  var i = null
  if (t && Wn(r, I1)) {
    var o = t[sk] || {}
    if (((i = (o[r[I1]] || {})[e]), i || ck('Missing [' + e + '] ' + ok), !i[Ej] && o[pS] !== !1)) {
      for (var s = !Wn(t, e), a = wv(t), l = []; s && a && !Ij(a) && !Aj(l, a); ) {
        var c = a[e]
        if (c) {
          s = c === n
          break
        }
        l.push(a), (a = wv(a))
      }
      try {
        s && (t[e] = i), (i[Ej] = 1)
      } catch {
        o[pS] = !1
      }
    }
  }
  return i
}
function sWe(t, e, r) {
  var n = e[t]
  return n === r && (n = wv(e)[t]), typeof n !== ok && ck('[' + t + '] is not a ' + ok), n
}
function aWe(t, e, r, n, i) {
  function o(l, c) {
    var u = function () {
      var p = oWe(this, c, l, u) || sWe(c, l, u)
      return p.apply(this, arguments)
    }
    return (u[bj] = 1), u
  }
  if (!E0e(t)) {
    var s = (r[sk] = r[sk] || {}),
      a = (s[e] = s[e] || {})
    s[pS] !== !1 && (s[pS] = !!i),
      ak(r, function (l) {
        wj(r, l, !1) &&
          r[l] !== n[l] &&
          ((a[l] = r[l]), delete r[l], (!Wn(t, l) || (t[l] && !t[l][bj])) && (t[l] = o(t, l)))
      })
  }
}
function cWe(t, e) {
  if (dS) {
    for (var r = [], n = wv(e); n && !Ij(n) && !Aj(r, n); ) {
      if (n === t) return !0
      r.push(n), (n = wv(n))
    }
    return !1
  }
  return !0
}
function xj(t, e) {
  return Wn(t, Pm) ? t.name || e || g0e : ((t || {})[ik] || {}).name || e || g0e
}
function Wt(t, e, r, n) {
  Wn(t, Pm) || ck('theClass is an invalid class definition.')
  var i = t[Pm]
  cWe(i, e) || ck('[' + xj(t) + '] not in hierarchy of [' + xj(e) + ']')
  var o = null
  Wn(i, I1) ? (o = i[I1]) : ((o = rWe + xj(t, '_') + '$' + Sj.n), Sj.n++, (i[I1] = o))
  var s = Wt[x0e],
    a = !!s[nk]
  a && n && n[nk] !== void 0 && (a = !!n[nk])
  var l = nWe(e),
    c = iWe(i, e, l, a)
  r(e, c)
  var u = !!dS && !!s[Tj]
  u && n && (u = !!n[Tj]), aWe(i, o, e, l, u !== !1)
}
var tk,
  ik,
  Pm,
  ok,
  sk,
  bj,
  I1,
  rWe,
  Ej,
  pS,
  x0e,
  g0e,
  b0e,
  rk,
  v0e,
  yj,
  nk,
  Tj,
  Cj,
  dS,
  _0e,
  y0e,
  Sj,
  fo = createGetter(() => {
    pt()
    ;(ik = 'constructor'),
      (Pm = 'prototype'),
      (ok = 'function'),
      (sk = '_dynInstFuncs'),
      (bj = '_isDynProxy'),
      (I1 = '_dynClass'),
      (rWe = '_dynCls$'),
      (Ej = '_dynInstChk'),
      (pS = Ej),
      (x0e = '_dfOpts'),
      (g0e = '_unknown_'),
      (b0e = '__proto__'),
      (rk = '_dyn' + b0e),
      (v0e = '__dynProto$Gbl'),
      (yj = '_dynInstProto'),
      (nk = 'useBaseInst'),
      (Tj = 'setInstFuncs'),
      (Cj = Object),
      (dS = Cj.getPrototypeOf),
      (_0e = Cj.getOwnPropertyNames),
      (y0e = Oo()),
      (Sj = y0e[v0e] || (y0e[v0e] = { o: ((tk = {}), (tk[Tj] = !0), (tk[nk] = !0), tk), n: 1e3 }))
    Wt[x0e] = Sj.o
  })
var Rj,
  T0e = createGetter(() => {
    'use strict'
    Rj = 100
  })
var Vi,
  Dj,
  lk = createGetter(() => {
    pt()
    ;(Vi = BH), (Dj = HH)
  })
var nl,
  S0e = createGetter(() => {
    lk()
    nl = Vi({ Unknown: 0, NonRetryableStatus: 1, InvalidEvent: 2, SizeLimitExceeded: 3, KillSwitch: 4, QueueFull: 5 })
  })
var gu,
  Nm,
  ct,
  Av,
  Rv,
  w1,
  Xp,
  il,
  pc,
  kr,
  km,
  Ht,
  vu,
  uk,
  Dv,
  Pv,
  _u,
  Us,
  Om,
  Pj,
  Lo,
  Lm,
  Ii,
  pk,
  A1,
  R1,
  D1,
  Mm,
  Nj,
  Bs,
  fS,
  Nv,
  dk,
  yu,
  xa,
  P1,
  Fm,
  ol,
  qs,
  N1,
  kv,
  ba,
  Um,
  mS,
  xu,
  fk,
  Jp,
  kj,
  Hs,
  hS,
  gS,
  Ov,
  sl,
  mk,
  k1,
  O1,
  Bm,
  Yr = createGetter(() => {
    ;(gu = 'toLowerCase'),
      (Nm = 'blkVal'),
      (ct = 'length'),
      (Av = 'rdOnly'),
      (Rv = 'notify'),
      (w1 = 'warnToConsole'),
      (Xp = 'throwInternal'),
      (il = 'setDf'),
      (pc = 'watch'),
      (kr = 'logger'),
      (km = 'apply'),
      (Ht = 'push'),
      (vu = 'splice'),
      (uk = 'hdlr'),
      (Dv = 'cancel'),
      (Pv = 'initialize'),
      (_u = 'identifier'),
      (Us = 'isInitialized'),
      (Om = 'getPlugin'),
      (Pj = 'pollInternalLogs'),
      (Lo = 'name'),
      (Lm = 'time'),
      (Ii = 'processNext'),
      (pk = 'getProcessTelContext'),
      (A1 = 'getNotifyMgr'),
      (R1 = 'addNotificationListener'),
      (D1 = 'removeNotificationListener'),
      (Mm = 'enabled'),
      (Nj = 'stopPollingInternalLogs'),
      (Bs = 'unload'),
      (fS = 'onComplete'),
      (Nv = 'version'),
      (dk = 'loggingLevelConsole'),
      (yu = 'createNew'),
      (xa = 'teardown'),
      (P1 = 'messageId'),
      (Fm = 'message'),
      (ol = 'isAsync'),
      (qs = 'diagLog'),
      (N1 = '_doTeardown'),
      (kv = 'update'),
      (ba = 'getNext'),
      (Um = 'setNextPlugin'),
      (mS = 'userAgent'),
      (xu = 'split'),
      (fk = 'nodeType'),
      (Jp = 'replace'),
      (kj = 'logInternalMessage'),
      (Hs = 'type'),
      (hS = 'handler'),
      (gS = 'isChildEvt'),
      (Ov = 'getCtx'),
      (sl = 'setCtx'),
      (mk = 'complete'),
      (k1 = 'traceId'),
      (O1 = 'spanId'),
      (Bm = 'traceFlags')
  })
function C0e(t, e) {
  Oj ||
    (Oj = oj('AggregationError', function (n, i) {
      i[ct] > 1 && (n.errors = i[1])
    }))
  var r = t || 'One or more errors occurred.'
  throw (
    (Ae(e, function (n, i) {
      r += `
`
        .concat(i, ' > ')
        .concat($e(n))
    }),
    new Oj(r, e || []))
  )
}
var Oj,
  I0e = createGetter(() => {
    pt()
    Yr()
  })
function qm(t, e) {
  return hk(
    t,
    function (r) {
      e && e({ value: r, rejected: !1 })
    },
    function (r) {
      e && e({ rejected: !0, reason: r })
    }
  )
}
function hk(t, e, r, n) {
  var i = t
  return Em(t) ? (e || r) && (i = t.then(e, r)) : e && e(t), n && (i = w0e(i, n)), i
}
function w0e(t, e) {
  var r = t
  return (
    e &&
      (Em(t)
        ? t.finally
          ? (r = t.finally(e))
          : (r = t.then(
              function (n) {
                return e(), n
              },
              function (n) {
                throw (e(), n)
              }
            ))
        : e()),
    r
  )
}
var Lj = createGetter(() => {
  pt()
})
function A0e(t, e, r, n) {
  ;(Mj = Mj || {
    toString: function () {
      return '[[PromiseState]]'
    },
  }),
    (Fj = Fj || {
      toString: function () {
        return '[[PromiseResult]]'
      },
    }),
    (Uj = Uj || {
      toString: function () {
        return '[[PromiseIsHandled]]'
      },
    }),
    li(t, Mj, { get: e }),
    li(t, Fj, { get: r }),
    li(t, Uj, { get: n })
}
var Mj,
  Fj,
  Uj,
  Bj,
  R0e = createGetter(() => {
    pt()
    Bj = !1
  })
var gk,
  qj = createGetter(() => {
    gk = ['pending', 'resolving', 'resolved', 'rejected']
  })
function P0e(t, e, r, n) {
  var i = In()
  !vk &&
    (vk = Kp(function () {
      var l
      return i && i.createEvent && (l = i.createEvent('Event')), !!l && l.initEvent
    }, null))
  var o = vk.v ? i.createEvent('Event') : n ? new Event(e) : {}
  if ((r && r(o), vk.v && o.initEvent(e, !1, !0), o && t[D0e])) t[D0e](o)
  else {
    var s = t['on' + e]
    if (s) s(o)
    else {
      var a = Kr('console')
      a && (a.error || a.log)(e, $e(o))
    }
  }
}
var D0e,
  vk,
  N0e = createGetter(() => {
    pt()
    D0e = 'dispatchEvent'
  })
var L1,
  Hj = createGetter(() => {
    L1 = 'Promise'
  })
function k0e(t) {
  return mt(t) ? t.toString() : $e(t)
}
function L0e(t, e, r) {
  var n = po(arguments, 3),
    i = 0,
    o = !1,
    s,
    a = [],
    l = uWe++,
    c = vS.length > 0 ? vS[vS.length - 1] : void 0,
    u = !1,
    p = null,
    d
  !jj && (jj = ya(L1 + 'RejectionEvent'))
  var f = function (x, P) {
      try {
        vS.push(l), (u = !0), p && p.cancel(), (p = null)
        var U = t(function (H, j) {
          a.push(function () {
            try {
              var M = i === 2 ? x : P,
                F = vt(M) ? s : mt(M) ? M(s) : M
              Em(F) ? F.then(H, j) : M ? H(F) : i === 3 ? j(F) : H(F)
            } catch (z) {
              j(z)
            }
          }),
            o && v()
        }, n)
        return U
      } finally {
        vS.pop()
      }
    },
    m = function (x) {
      return f(void 0, x)
    },
    h = function (x) {
      var P = x,
        U = x
      return (
        mt(x) &&
          ((P = function (H) {
            return x && x(), H
          }),
          (U = function (H) {
            throw (x && x(), H)
          })),
        f(P, U)
      )
    },
    g = function () {
      return gk[i]
    },
    v = function () {
      if (a.length > 0) {
        var x = a.slice()
        ;(a = []), (u = !0), e(x), p && p.cancel(), (p = null)
      }
    },
    _ = function (x, P) {
      return function (U) {
        if (i === P) {
          if (x === 2 && Em(U)) {
            ;(i = 1), U.then(_(2, 1), _(3, 1))
            return
          }
          ;(i = x), (o = !0), (s = U), v(), !u && x === 3 && !p && (p = Ls(y, pWe))
        }
      }
    },
    y = function () {
      if (!u)
        if (XH()) process.emit(O0e, s, d)
        else {
          var x = Bn() || Oo()
          P0e(
            x,
            lWe,
            function (P) {
              return (
                xr(P, 'promise', {
                  g: function () {
                    return d
                  },
                }),
                (P.reason = s),
                P
              )
            },
            !!jj.v
          )
        }
    }
  ;(d = { then: f, catch: m, finally: h }),
    li(d, 'state', { get: g }),
    Bj &&
      A0e(
        d,
        g,
        function () {
          return bv(s)
        },
        function () {
          return u
        }
      ),
    JH() && (d[Cv(11)] = 'IPromise')
  var b = function () {
    return 'IPromise' + (Bj ? '[' + l + (vt(c) ? '' : ':' + c) + ']' : '') + ' ' + g() + (o ? ' - ' + k0e(s) : '')
  }
  return (
    (d.toString = b),
    (function () {
      mt(r) || fn(L1 + ': executor is not a function - ' + k0e(r))
      var P = _(3, 0)
      try {
        r.call(d, _(2, 0), P)
      } catch (U) {
        P(U)
      }
    })(),
    d
  )
}
function M1(t) {
  return function (e) {
    var r = po(arguments, 1)
    return t(function (n, i) {
      try {
        var o = [],
          s = 1
        Ae(e, function (a, l) {
          a &&
            (s++,
            hk(
              a,
              function (c) {
                ;(o[l] = c), --s === 0 && n(o)
              },
              i
            ))
        }),
          s--,
          s === 0 && n(o)
      } catch (a) {
        i(a)
      }
    }, r)
  }
}
function F1(t) {
  return function (e) {
    var r = po(arguments, 1)
    return Em(e)
      ? e
      : t(function (n) {
          n(e)
        }, r)
  }
}
function U1(t) {
  return function (e) {
    var r = po(arguments, 1)
    return t(function (n, i) {
      i(e)
    }, r)
  }
}
var O0e,
  lWe,
  vS,
  uWe,
  pWe,
  jj,
  _k = createGetter(() => {
    pt()
    Lj()
    R0e()
    qj()
    N0e()
    Hj()
    ;(O0e = 'unhandledRejection'), (lWe = O0e.toLowerCase()), (vS = []), (uWe = 0), (pWe = 10)
  })
function M0e(t) {
  var e = Gi(t) ? t : 0
  return function (r) {
    Ls(function () {
      dWe(r)
    }, e)
  }
}
var dWe,
  F0e = createGetter(() => {
    pt()
    dWe = function (t) {
      Ae(t, function (e) {
        try {
          e()
        } catch {}
      })
    }
  })
function B1(t, e) {
  return L0e(B1, M0e(e), t, e)
}
var l7t,
  u7t,
  p7t,
  U0e = createGetter(() => {
    _k()
    F0e()
    ;(l7t = M1(B1)), (u7t = F1(B1)), (p7t = U1(B1))
  })
function _S(t, e) {
  !Gj && (Gj = ya(L1))
  var r = Gj.v
  if (!r) return B1(t)
  mt(t) || fn(L1 + ': executor is not a function - ' + $e(t))
  var n = 0
  function i() {
    return gk[n]
  }
  var o = new r(function (s, a) {
    function l(u) {
      ;(n = 2), s(u)
    }
    function c(u) {
      ;(n = 3), a(u)
    }
    t(l, c)
  })
  return li(o, 'state', { get: i }), o
}
var Gj,
  _7t,
  y7t,
  x7t,
  B0e = createGetter(() => {
    U0e()
    _k()
    qj()
    pt()
    Hj()
    ;(_7t = M1(_S)), (y7t = F1(_S)), (x7t = U1(_S))
  })
function ds(t, e) {
  return (
    !Vj &&
      (Vj = rl(function () {
        return _S
      })),
    Vj.v.call(this, t, e)
  )
}
var Vj,
  zj,
  fWe,
  mWe,
  q0e = createGetter(() => {
    pt()
    _k()
    B0e()
    ;(zj = M1(ds)), (fWe = F1(ds)), (mWe = U1(ds))
  })
var q1 = createGetter(() => {
  Lj()
  q0e()
})
var Ea,
  _t,
  Hm,
  An,
  yk,
  yS,
  Zp,
  Lv,
  js,
  Mv,
  H1,
  jm,
  j1,
  bu,
  G1,
  xk,
  bk,
  H0e,
  pi = createGetter(() => {
    ;(Ea = void 0),
      (_t = ''),
      (Hm = 'channels'),
      (An = 'core'),
      (yk = 'createPerfMgr'),
      (yS = 'disabled'),
      (Zp = 'extensionConfig'),
      (Lv = 'extensions'),
      (js = 'processTelemetry'),
      (Mv = 'priority'),
      (H1 = 'eventsSent'),
      (jm = 'eventsDiscarded'),
      (j1 = 'eventsSendRequest'),
      (bu = 'perfEvent'),
      (G1 = 'getPerfMgr'),
      (xk = 'domain'),
      (bk = 'path'),
      (H0e = 'Not dynamic - ')
  })
function Eu(t) {
  return !we(t)
}
function Fv(t) {
  var e = t
  return (
    e &&
      gt(e) &&
      ((e = e[Jp](gWe, function (r, n) {
        return n.toUpperCase()
      })),
      (e = e[Jp](vWe, '_')),
      (e = e[Jp](_We, function (r, n) {
        return '_' + n
      }))),
    e
  )
}
function Kn(t, e) {
  return t && e ? ps(t, e) !== -1 : !1
}
function Ta(t) {
  return (t && t.toISOString()) || ''
}
function Qr(t) {
  return fu(t) ? t[Lo] : _t
}
function dc(t, e, r, n, i) {
  var o = r
  return t && ((o = t[e]), o !== r && (!i || i(o)) && (!n || n(r)) && ((o = r), (t[e] = o))), o
}
function xS(t, e, r) {
  var n
  return t ? ((n = t[e]), !n && we(n) && ((n = vt(r) ? {} : r), (t[e] = n))) : (n = vt(r) ? {} : r), n
}
function j0e(t, e) {
  var r = null,
    n = null
  return (
    mt(t) ? (r = t) : (n = t),
    function () {
      var i = arguments
      if ((r && (n = r()), n)) return n[e][km](n, i)
    }
  )
}
function $j(t, e, r) {
  if (t && e && Br(t) && Br(e)) {
    var n = function (o) {
      if (gt(o)) {
        var s = e[o]
        mt(s)
          ? (!r || r(o, !0, e, t)) && (t[o] = j0e(e, o))
          : (!r || r(o, !1, e, t)) &&
            (Os(t, o) && delete t[o],
            xr(t, o, {
              g: function () {
                return e[o]
              },
              s: function (a) {
                e[o] = a
              },
            }))
      }
    }
    for (var i in e) n(i)
  }
  return t
}
function ed(t, e, r, n, i) {
  t && e && r && (i !== !1 || vt(t[e])) && (t[e] = j0e(r, n))
}
function Sa(t, e, r, n) {
  return (
    t &&
      e &&
      Br(t) &&
      Xe(r) &&
      Ae(r, function (i) {
        gt(i) && ed(t, i, e, i, n)
      }),
    t
  )
}
function Wj(t) {
  return (function () {
    function e() {
      var r = this
      t &&
        ze(t, function (n, i) {
          r[n] = i
        })
    }
    return e
  })()
}
function fc(t) {
  return t && Tv && (t = p1(Tv({}, t))), t
}
function Ek(t, e, r, n, i, o) {
  var s = arguments,
    a = s[0] || {},
    l = s[ct],
    c = !1,
    u = 1
  for (l > 0 && Zc(a) && ((c = a), (a = s[u] || {}), u++), Br(a) || (a = {}); u < l; u++) {
    var p = s[u],
      d = Xe(p),
      f = Br(p)
    for (var m in p) {
      var h = (d && m in p) || (f && Os(p, m))
      if (h) {
        var g = p[m],
          v = void 0
        if (c && g && ((v = Xe(g)) || Ci(g))) {
          var _ = a[m]
          v ? Xe(_) || (_ = []) : Ci(_) || (_ = {}), (g = Ek(c, _, g))
        }
        g !== void 0 && (a[m] = g)
      }
    }
  }
  return a
}
var hWe,
  gWe,
  vWe,
  _We,
  L7t,
  td = createGetter(() => {
    Fs()
    pt()
    Yr()
    pi()
    ;(hWe = 'getPrototypeOf'),
      (gWe = /-([a-z])/g),
      (vWe = /([^\w\d_$])/g),
      (_We = /^(\d+[\w\d_$])/),
      (L7t = Object[hWe])
  })
function $0e(t, e) {
  var r = !1
  if (t) {
    try {
      if (((r = e in t), !r)) {
        var n = t[Xc]
        n && (r = e in n)
      }
    } catch {}
    if (!r)
      try {
        var i = new t()
        r = !vt(i[e])
      } catch {}
  }
  return r
}
function Zj(t) {
  z0e = t
}
function Uv(t) {
  if (t && z0e) {
    var e = Kr('__mockLocation')
    if (e) return e
  }
  return typeof location === zp && location ? location : Kr(xWe)
}
function bS() {
  return typeof console !== du ? console : Kr(bWe)
}
function Tu() {
  return !!((typeof JSON === zp && JSON) || Kr(G0e) !== null)
}
function mo() {
  return Tu() ? JSON || Kr(G0e) : null
}
function ES() {
  return Kr(EWe)
}
function TS() {
  return Kr(TWe)
}
function Gm() {
  var t = ui()
  return t && t.product ? t.product === SWe : !1
}
function Vm() {
  var t = ui()
  if (t && (t[mS] !== Yj || Kj === null)) {
    Yj = t[mS]
    var e = (Yj || _t)[gu]()
    Kj = Kn(e, Xj) || Kn(e, Jj)
  }
  return Kj
}
function SS(t) {
  if ((t === void 0 && (t = null), !t)) {
    var e = ui() || {}
    t = e ? (e.userAgent || _t)[gu]() : _t
  }
  var r = (t || _t)[gu]()
  if (Kn(r, Xj)) {
    var n = In() || {}
    return Math.max(parseInt(r[xu](Xj)[1]), n[yWe] || 0)
  } else if (Kn(r, Jj)) {
    var i = parseInt(r[xu](Jj)[1])
    if (i) return i + 4
  }
  return null
}
function Ca(t) {
  return (Qj === null || t === !1) && (Qj = E1() && !!ui().sendBeacon), Qj
}
function rd(t) {
  var e = !1
  try {
    e = !!Kr('fetch')
    var r = Kr('Request')
    e && t && r && (e = $0e(r, 'keepalive'))
  } catch {}
  return e
}
function Bv() {
  return (
    V1 === null && ((V1 = typeof XDomainRequest !== du), V1 && zm() && (V1 = V1 && !$0e(Kr(V0e), 'withCredentials'))),
    V1
  )
}
function zm() {
  var t = !1
  try {
    var e = Kr(V0e)
    t = !!e
  } catch {}
  return t
}
function W0e(t, e) {
  if (t)
    for (var r = 0; r < t[ct]; r++) {
      var n = t[r]
      if (n[Lo] && n[Lo] === e) return n
    }
  return {}
}
function eG(t) {
  var e = In()
  return e && t ? W0e(e.querySelectorAll('meta'), t).content : null
}
function tG(t) {
  var e,
    r = Qp()
  if (r) {
    var n = r.getEntriesByType('navigation') || []
    e = W0e((n[ct] > 0 ? n[0] : {}).serverTiming, t).description
  }
  return e
}
var yWe,
  xWe,
  bWe,
  G0e,
  EWe,
  TWe,
  SWe,
  Xj,
  Jj,
  V0e,
  Kj,
  Yj,
  z0e,
  V1,
  Qj,
  z1 = createGetter(() => {
    'use strict'
    Fs()
    pt()
    Yr()
    td()
    pi()
    ;(yWe = 'documentMode'),
      (xWe = 'location'),
      (bWe = 'console'),
      (G0e = 'JSON'),
      (EWe = 'crypto'),
      (TWe = 'msCrypto'),
      (SWe = 'ReactNative'),
      (Xj = 'msie'),
      (Jj = 'trident/'),
      (V0e = 'XMLHttpRequest'),
      (Kj = null),
      (Yj = null),
      (z0e = !1),
      (V1 = null),
      (Qj = null)
  })
function CWe(t) {
  t < 0 && (t >>>= 0), (CS = (Y0e + t) & $m), (IS = (Q0e - t) & $m), (X0e = !0)
}
function IWe() {
  try {
    var t = wn() & 2147483647
    CWe(((Math.random() * K0e) ^ t) + t)
  } catch {}
}
function wS(t) {
  return t > 0 ? Math.floor((nd() / $m) * (t + 1)) >>> 0 : 0
}
function nd(t) {
  var e = 0,
    r = ES() || TS()
  return (
    r && r.getRandomValues && (e = r.getRandomValues(new Uint32Array(1))[0] & $m),
    e === 0 && Vm() && (X0e || IWe(), (e = J0e() & $m)),
    e === 0 && (e = Math.floor((K0e * Math.random()) | 0)),
    t || (e >>>= 0),
    e
  )
}
function J0e(t) {
  ;(IS = (36969 * (IS & 65535) + (IS >> 16)) & $m), (CS = (18e3 * (CS & 65535) + (CS >> 16)) & $m)
  var e = ((((IS << 16) + (CS & 65535)) >>> 0) & $m) | 0
  return t || (e >>>= 0), e
}
function AS(t) {
  t === void 0 && (t = 22)
  for (
    var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', r = nd() >>> 0, n = 0, i = _t;
    i[ct] < t;

  )
    n++, (i += e.charAt(r & 63)), (r >>>= 6), n === 5 && ((r = (((nd() << 2) & 4294967295) | (r & 3)) >>> 0), (n = 0))
  return i
}
var K0e,
  $m,
  Y0e,
  Q0e,
  X0e,
  CS,
  IS,
  Tk = createGetter(() => {
    pt()
    Yr()
    z1()
    pi()
    ;(K0e = 4294967296), ($m = 4294967295), (Y0e = 123456789), (Q0e = 987654321), (X0e = !1), (CS = Y0e), (IS = Q0e)
  })
function e_e(t) {
  return t[fk] === 1 || t[fk] === 9 || !+t[fk]
}
function RWe(t, e) {
  var r = e[t.id]
  if (!r) {
    r = {}
    try {
      e_e(e) && xr(e, t.id, { e: !1, v: r })
    } catch {}
  }
  return r
}
function ho(t, e) {
  return e === void 0 && (e = !1), Fv(t + AWe++ + (e ? '.' + Z0e : _t) + wWe)
}
function Sk(t) {
  var e = {
    id: ho('_aiData-' + (t || _t) + '.' + Z0e),
    accept: function (r) {
      return e_e(r)
    },
    get: function (r, n, i, o) {
      var s = r[e.id]
      return s ? s[Fv(n)] : (o && ((s = RWe(e, r)), (s[Fv(n)] = i)), i)
    },
    kill: function (r, n) {
      if (r && r[n])
        try {
          delete r[n]
        } catch {}
    },
  }
  return e
}
var Z0e,
  wWe,
  AWe,
  $1 = createGetter(() => {
    pt()
    Yr()
    td()
    pi()
    Tk()
    ;(Z0e = '3.0.5'), (wWe = '.' + AS(6)), (AWe = 0)
  })
function Ck(t) {
  return t && Br(t) && (t.isVal || t.fb || Os(t, 'v') || Os(t, 'mrg') || Os(t, 'ref') || t.set)
}
function t_e(t, e, r) {
  var n,
    i = r.dfVal || IN
  if (e && r.fb) {
    var o = r.fb
    Xe(o) || (o = [o])
    for (var s = 0; s < o[ct]; s++) {
      var a = o[s],
        l = e[a]
      if ((i(l) ? (n = l) : t && ((l = t.cfg[a]), i(l) && (n = l), t.set(t.cfg, ci(a), l)), i(n))) break
    }
  }
  return !i(n) && i(r.v) && (n = r.v), n
}
function rG(t, e, r) {
  var n = r
  if ((r && Ck(r) && (n = t_e(t, e, r)), n)) {
    Ck(n) && (n = rG(t, e, n))
    var i
    Xe(n) ? ((i = []), (i[ct] = n[ct])) : Ci(n) && (i = {}),
      i &&
        (ze(n, function (o, s) {
          s && Ck(s) && (s = rG(t, e, s)), (i[o] = s)
        }),
        (n = i))
  }
  return n
}
function RS(t, e, r, n) {
  var i,
    o,
    s,
    a = n,
    l,
    c,
    u,
    p
  Ck(a)
    ? ((i = a.isVal),
      (o = a.set),
      (u = a[Av]),
      (p = a[Nm]),
      (l = a.mrg),
      (c = a.ref),
      !c && vt(c) && (c = !!l),
      (s = t_e(t, e, a)))
    : (s = n),
    p && t[Nm](e, r)
  var d,
    f = !0,
    m = e[r]
  ;(m || !we(m)) &&
    ((d = m), (f = !1), i && d !== s && !i(d) && ((d = s), (f = !0)), o && ((d = o(d, s, e)), (f = d === s))),
    f
      ? s
        ? (d = rG(t, e, s))
        : (d = s)
      : (Ci(d) || Xe(s)) &&
        l &&
        s &&
        (Ci(s) || Xe(s)) &&
        ze(s, function (h, g) {
          RS(t, d, h, g)
        }),
    t.set(e, r, d),
    c && t.ref(e, r),
    u && t[Av](e, r)
}
var nG = createGetter(() => {
  pt()
  Yr()
})
function iG(t) {
  if (t) {
    var e
    if ((Xe(t) ? ((e = []), (e[ct] = t[ct])) : Ci(t) && (e = {}), e))
      return (
        ze(t, function (r, n) {
          e[r] = iG(n)
        }),
        e
      )
  }
  return t
}
function DS(t) {
  if (t) {
    var e = t[Su] || t
    if (e.cfg && (e.cfg === t || e.cfg[Su] === e)) return e
  }
  return null
}
function PS(t) {
  if (t && (Ci(t) || Xe(t)))
    try {
      t[r_e] = !0
    } catch {}
  return t
}
function oG(t) {
  if (t)
    try {
      t[n_e] = !0
    } catch {}
  return t
}
function Ik(t, e, r) {
  var n = !1
  return r && !t[e.blkVal] && ((n = r[n_e]), !n && !r[r_e] && (n = Ci(r) || Xe(r))), n
}
function wk(t) {
  fn('InvalidAccess:' + t)
}
var Su,
  r_e,
  n_e,
  Ak = createGetter(() => {
    pt()
    Yr()
    ;(Su = sS('[[ai_dynCfg_1]]')), (r_e = sS('[[ai_blkDynCfg_1]]')), (n_e = sS('[[ai_frcDynCfg_1]]'))
  })
function PWe(t, e, r) {
  Xe(e) &&
    Ae(DWe, function (n) {
      var i = e[n]
      e[n] = function () {
        for (var o = [], s = 0; s < arguments.length; s++) o[s] = arguments[s]
        var a = i[km](this, o)
        return NS(t, e, r, 'Patching'), a
      }
    })
}
function Rk(t, e) {
  var r = Ev(t, e)
  return r && r.get
}
function NWe(t, e, r, n) {
  var i = {
      n: r,
      h: [],
      trk: function (c) {
        c && c.fn && (ir(i.h, c) === -1 && i.h[Ht](c), t.trk(c, i))
      },
      clr: function (c) {
        var u = ir(i.h, c)
        u !== -1 && i.h[vu](u, 1)
      },
    },
    o = !0,
    s = !1
  function a() {
    o && ((s = s || Ik(a, t, n)), n && !n[Su] && s && (n = NS(t, n, r, 'Converting')), (o = !1))
    var c = t.act
    return c && i.trk(c), n
  }
  a[t.prop] = {
    chng: function () {
      t.add(i)
    },
  }
  function l(c) {
    if (n !== c) {
      a[t.ro] && !t.upd && wk('[' + r + '] is read-only:' + $e(e)), o && ((s = s || Ik(a, t, n)), (o = !1))
      var u = s && a[t.rf]
      if (s)
        if (u) {
          ze(n, function (d) {
            n[d] = c ? c[d] : Ea
          })
          try {
            ze(c, function (d, f) {
              kS(t, n, d, f)
            }),
              (c = n)
          } catch (d) {
            W1((t.hdlr || {})[kr], r, 'Assigning', d), (s = !1)
          }
        } else
          n &&
            n[Su] &&
            ze(n, function (d) {
              var f = Rk(n, d)
              if (f) {
                var m = f[t.prop]
                m && m.chng()
              }
            })
      if (c !== n) {
        var p = c && Ik(a, t, c)
        !u && p && (c = NS(t, c, r, 'Converting')), (n = c), (s = p)
      }
      t.add(i)
    }
  }
  xr(e, i.n, { g: a, s: l })
}
function kS(t, e, r, n) {
  if (e) {
    var i = Rk(e, r),
      o = i && !!i[t.prop]
    o ? (e[r] = n) : NWe(t, e, r, n)
  }
  return e
}
function Dk(t, e, r, n) {
  if (e) {
    var i = Rk(e, r),
      o = i && !!i[t.prop],
      s = n && n[0],
      a = n && n[1],
      l = n && n[2]
    if (!o) {
      if (l)
        try {
          PS(e)
        } catch (c) {
          W1((t.hdlr || {})[kr], r, 'Blocking', c)
        }
      try {
        kS(t, e, r, e[r]), (i = Rk(e, r))
      } catch (c) {
        W1((t.hdlr || {})[kr], r, 'State', c)
      }
    }
    s && (i[t.rf] = s), a && (i[t.ro] = a), l && (i[t.blkVal] = !0)
  }
  return e
}
function NS(t, e, r, n) {
  try {
    ze(e, function (i, o) {
      kS(t, e, i, o)
    }),
      e[Su] ||
        (li(e, Su, {
          get: function () {
            return t[uk]
          },
        }),
        PWe(t, e, r))
  } catch (i) {
    W1((t.hdlr || {})[kr], r, n, i)
  }
  return e
}
var DWe,
  W1,
  i_e = createGetter(() => {
    pt()
    pi()
    Yr()
    Ak()
    ;(DWe = ['push', 'pop', 'shift', 'unshift', 'splice']),
      (W1 = function (t, e, r, n) {
        t && t[Xp](3, 108, ''.concat(r, ' [').concat(e, '] failed - ') + $e(n))
      })
  })
function o_e(t) {
  var e,
    r = Iv(OS + 'get' + t.uid + LS),
    n = Iv(OS + 'ro' + t.uid + LS),
    i = Iv(OS + 'rf' + t.uid + LS),
    o = Iv(OS + 'blkVal' + t.uid + LS),
    s = Iv(OS + 'dtl' + t.uid + LS),
    a = null,
    l = null,
    c
  function u(m, h) {
    var g = c.act
    try {
      ;(c.act = m),
        m &&
          m[s] &&
          (Ae(m[s], function (_) {
            _.clr(m)
          }),
          (m[s] = [])),
        h({ cfg: t.cfg, set: t.set.bind(t), setDf: t[il].bind(t), ref: t.ref.bind(t), rdOnly: t[Av].bind(t) })
    } catch (_) {
      var v = t[kr]
      throw (v && v[Xp](1, 107, $e(_)), _)
    } finally {
      c.act = g || null
    }
  }
  function p() {
    if (a) {
      var m = a
      ;(a = null), l && l[Dv](), (l = null)
      var h = []
      if (
        (Ae(m, function (g) {
          if (
            g &&
            (g[s] &&
              (Ae(g[s], function (v) {
                v.clr(g)
              }),
              (g[s] = null)),
            g.fn)
          )
            try {
              u(g, g.fn)
            } catch (v) {
              h[Ht](v)
            }
        }),
        a)
      )
        try {
          p()
        } catch (g) {
          h[Ht](g)
        }
      h[ct] > 0 && C0e('Watcher error(s): ', h)
    }
  }
  function d(m) {
    if (m && m.h[ct] > 0) {
      a || (a = []),
        l ||
          (l = Ls(function () {
            ;(l = null), p()
          }, 0))
      for (var h = 0; h < m.h[ct]; h++) {
        var g = m.h[h]
        g && ir(a, g) === -1 && a[Ht](g)
      }
    }
  }
  function f(m, h) {
    if (m) {
      var g = (m[s] = m[s] || [])
      ir(g, h) === -1 && g[Ht](h)
    }
  }
  return (
    (c =
      ((e = { prop: r, ro: n, rf: i }),
      (e[Nm] = o),
      (e[uk] = t),
      (e.add = d),
      (e[Rv] = p),
      (e.use = u),
      (e.trk = f),
      e)),
    c
  )
}
var OS,
  LS,
  s_e = createGetter(() => {
    pt()
    I0e()
    Yr()
    ;(OS = '[[ai_'), (LS = ']]')
  })
function kWe(t, e) {
  var r = {
    fn: e,
    rm: function () {
      ;(r.fn = null), (t = null), (e = null)
    },
  }
  return t.use(r, e), r
}
function OWe(t, e, r) {
  var n,
    i = DS(e)
  if (i) return i
  var o = ho('dyncfg', !0),
    s = e && r !== !1 ? e : iG(e),
    a
  function l() {
    a[Rv]()
  }
  function c(v, _, y) {
    try {
      v = kS(a, v, _, y)
    } catch (b) {
      W1(t, _, 'Setting value', b)
    }
    return v[_]
  }
  function u(v) {
    return kWe(a, v)
  }
  function p(v, _) {
    a.use(null, function (y) {
      var b = a.upd
      try {
        vt(_) || (a.upd = _), v(y)
      } finally {
        a.upd = b
      }
    })
  }
  function d(v, _) {
    var y
    return Dk(a, v, _, ((y = {}), (y[0] = !0), y))[_]
  }
  function f(v, _) {
    var y
    return Dk(a, v, _, ((y = {}), (y[1] = !0), y))[_]
  }
  function m(v, _) {
    var y
    return Dk(a, v, _, ((y = {}), (y[2] = !0), y))[_]
  }
  function h(v, _) {
    return (
      _ &&
        ze(_, function (y, b) {
          RS(g, v, y, b)
        }),
      v
    )
  }
  var g =
    ((n = { uid: null, cfg: s }),
    (n[kr] = t),
    (n[Rv] = l),
    (n.set = c),
    (n[il] = h),
    (n[pc] = u),
    (n.ref = d),
    (n[Av] = f),
    (n[Nm] = m),
    (n._block = p),
    n)
  return xr(g, 'uid', { c: !1, e: !1, w: !1, v: o }), (a = o_e(g)), NS(a, s, 'config', 'Creating'), g
}
function LWe(t, e) {
  t ? (t[w1](e), t[Xp](2, 108, e)) : wk(e)
}
function mn(t, e, r, n) {
  var i = OWe(r, t || {}, n)
  return e && i[il](i.cfg, e), i
}
function di(t, e, r) {
  var n = t[Su] || t
  return n.cfg && (n.cfg === t || n.cfg[Su] === n) ? n[pc](e) : (LWe(r, H0e + $e(t)), mn(t, null, r)[pc](e))
}
var Wm = createGetter(() => {
  pt()
  $1()
  pi()
  Yr()
  nG()
  i_e()
  s_e()
  Ak()
})
function id(t, e) {
  if (t && t[Bs]) return t[Bs](e)
}
function Pk(t, e, r) {
  var n
  return (
    r ||
      (n = ds(function (i) {
        r = i
      })),
    t && S1(t) > 0
      ? qm(id(t[0], e), function () {
          Pk(po(t, 1), e, r)
        })
      : r(),
    n
  )
}
var sG = createGetter(() => {
  q1()
  pt()
  Yr()
})
var a_e,
  c_e = createGetter(() => {
    a_e = 500
  })
function MWe(t, e, r) {
  return !t && we(t) ? e : Zc(t) ? t : ci(t)[gu]() === 'true'
}
function aG(t) {
  return { mrg: !0, v: t }
}
function K1(t, e, r) {
  return { fb: r, isVal: t, v: e }
}
function al(t, e) {
  return { fb: e, set: MWe, v: !!t }
}
var cG = createGetter(() => {
  pt()
  Yr()
})
function FWe(t, e) {
  return function () {
    var r = arguments,
      n = uG(e)
    if (n) {
      var i = n.listener
      i && i[t] && i[t][km](i, r)
    }
  }
}
function UWe() {
  var t = Kr('Microsoft')
  return t && (kk = t.ApplicationInsights), kk
}
function uG(t) {
  var e = kk
  return !e && t.disableDbgExt !== !0 && (e = kk || UWe()), e ? e.ChromeDbgExt : null
}
function l_e(t) {
  if (!Nk) {
    Nk = {}
    for (var e = 0; e < lG[ct]; e++) Nk[lG[e]] = FWe(lG[e], t)
  }
  return Nk
}
var lG,
  kk,
  Nk,
  pG = createGetter(() => {
    pt()
    Yr()
    pi()
    ;(lG = [H1, jm, j1, bu]), (kk = null)
  })
function u_e(t) {
  return t ? '"' + t[Jp](/\"/g, _t) + '"' : _t
}
function dG(t, e) {
  var r = bS()
  if (r) {
    var n = 'log'
    r[t] && (n = t), mt(r[n]) && r[n](e)
  }
}
function cl(t, e) {
  return (t || {})[kr] || new Km(e)
}
function fG(t) {
  return t || new Km()
}
function Ue(t, e, r, n, i, o) {
  o === void 0 && (o = !1), fG(t)[Xp](e, r, n, i, o)
}
function Ia(t, e) {
  fG(t)[w1](e)
}
function mG(t, e, r) {
  fG(t)[kj](e, r)
}
var Y1,
  p_e,
  BWe,
  qWe,
  HWe,
  jWe,
  GWe,
  qv,
  Km,
  od = createGetter(() => {
    'use strict'
    fo()
    pt()
    Wm()
    Yr()
    pG()
    z1()
    pi()
    ;(p_e = 'warnToConsole'),
      (BWe = 'AI (Internal): '),
      (qWe = 'AI: '),
      (HWe = 'AITR_'),
      (jWe = { loggingLevelConsole: 0, loggingLevelTelemetry: 1, maxMessageLimit: 25, enableDebug: !1 }),
      (GWe = ((Y1 = {}), (Y1[0] = null), (Y1[1] = 'errorToConsole'), (Y1[2] = p_e), (Y1[3] = 'debugToConsole'), Y1))
    qv = (function () {
      function t(e, r, n, i) {
        n === void 0 && (n = !1)
        var o = this
        ;(o[P1] = e), (o[Fm] = (n ? qWe : BWe) + e)
        var s = _t
        Tu() && (s = mo().stringify(i))
        var a = (r ? ' message:' + u_e(r) : _t) + (i ? ' props:' + u_e(s) : _t)
        o[Fm] += a
      }
      return (t.dataType = 'MessageData'), t
    })()
    Km = (function () {
      function t(e) {
        ;(this.identifier = 'DiagnosticLogger'), (this.queue = [])
        var r = 0,
          n = {},
          i,
          o,
          s,
          a,
          l
        Wt(t, this, function (c) {
          ;(l = p(e || {})),
            (c.consoleLoggingLevel = function () {
              return i
            }),
            (c[Xp] = function (m, h, g, v, _) {
              _ === void 0 && (_ = !1)
              var y = new qv(h, g, _, v)
              if (a) throw $e(y)
              var b = GWe[m] || p_e
              if (vt(y[Fm])) f('throw' + (m === 1 ? 'Critical' : 'Warning'), y)
              else {
                if (_) {
                  var x = +y[P1]
                  !n[x] && i >= m && (c[b](y[Fm]), (n[x] = !0))
                } else i >= m && c[b](y[Fm])
                u(m, y)
              }
            }),
            (c.debugToConsole = function (m) {
              dG('debug', m), f('warning', m)
            }),
            (c[w1] = function (m) {
              dG('warn', m), f('warning', m)
            }),
            (c.errorToConsole = function (m) {
              dG('error', m), f('error', m)
            }),
            (c.resetInternalMessageCount = function () {
              ;(r = 0), (n = {})
            }),
            (c[kj] = u),
            (c[Bs] = function (m) {
              l && l.rm(), (l = null)
            })
          function u(m, h) {
            if (!d()) {
              var g = !0,
                v = HWe + h[P1]
              if (
                (n[v] ? (g = !1) : (n[v] = !0),
                g && (m <= o && (c.queue[Ht](h), r++, f(m === 1 ? 'error' : 'warn', h)), r === s))
              ) {
                var _ = 'Internal events throttle limit per PageView reached for this app.',
                  y = new qv(23, _, !1)
                c.queue[Ht](y), m === 1 ? c.errorToConsole(_) : c[w1](_)
              }
            }
          }
          function p(m) {
            return di(mn(m, jWe, c).cfg, function (h) {
              var g = h.cfg
              ;(i = g[dk]), (o = g.loggingLevelTelemetry), (s = g.maxMessageLimit), (a = g.enableDebug)
            })
          }
          function d() {
            return r >= s
          }
          function f(m, h) {
            var g = uG(e || {})
            g && g[qs] && g[qs](m, h)
          }
        })
      }
      return (t.__ieDyn = 1), t
    })()
  })
function xG() {
  !Cu &&
    (Cu = rl(function () {
      return In()
    }))
}
function zWe(t, e) {
  var r = sd[Ym] || Mk[Ym]
  return r || ((r = sd[Ym] = sd(t, e)), (Mk[Ym] = r)), r
}
function Lk(t) {
  return t ? t.isEnabled() : !0
}
function b_e(t, e) {
  return e && t && Xe(t.ignoreCookies) ? ir(t.ignoreCookies, e) !== -1 : !1
}
function $We(t, e) {
  return e && t && Xe(t.blockedCookies) && ir(t.blockedCookies, e) !== -1 ? !0 : b_e(t, e)
}
function v_e(t, e) {
  var r = e[Mm]
  if (we(r)) {
    var n = void 0
    vt(t[m_e]) || (n = !t[m_e]), vt(t[_G]) || (n = !t[_G]), (r = n)
  }
  return r
}
function bG(t, e) {
  var r
  if (t) r = t.getCookieMgr()
  else if (e) {
    var n = e.cookieCfg
    n && n[Ym] ? (r = n[Ym]) : (r = sd(e))
  }
  return r || (r = zWe(e, (t || {})[kr])), r
}
function sd(t, e) {
  var r, n, i, o, s, a, l, c, u
  ;(t = mn(t || Mk, null, e).cfg),
    (s = di(
      t,
      function (d) {
        d[il](d.cfg, VWe),
          (n = d.ref(d.cfg, 'cookieCfg')),
          (i = n[bk] || '/'),
          (o = n[xk]),
          (a = v_e(t, n) !== !1),
          (l = n.getCookie || WWe),
          (c = n.setCookie || x_e),
          (u = n.delCookie || x_e)
      },
      e
    ))
  var p =
    ((r = {
      isEnabled: function () {
        var d = v_e(t, n) !== !1 && a && Q1(e),
          f = Mk[Ym]
        return d && f && p !== f && (d = Lk(f)), d
      },
      setEnabled: function (d) {
        ;(a = d !== !1), (n[Mm] = d)
      },
      set: function (d, f, m, h, g) {
        var v = !1
        if (Lk(p) && !$We(n, d)) {
          var _ = {},
            y = pr(f || _t),
            b = ps(y, ';')
          if ((b !== -1 && ((y = pr(Im(f, b))), (_ = E_e(Un(f, b + 1)))), dc(_, xk, h || o, el, vt), !we(m))) {
            var x = Vm()
            if (vt(_[gG])) {
              var P = wn(),
                U = P + m * 1e3
              if (U > 0) {
                var H = new Date()
                H.setTime(U), dc(_, gG, __e(H, x ? d_e : f_e) || __e(H, x ? d_e : f_e) || _t, el)
              }
            }
            x || dc(_, 'max-age', _t + m, null, vt)
          }
          var j = Uv()
          j &&
            j.protocol === 'https:' &&
            (dc(_, 'secure', null, null, vt),
            vG === null && (vG = !Fk((ui() || {})[mS])),
            vG && dc(_, 'SameSite', 'None', null, vt)),
            dc(_, bk, g || i, null, vt),
            c(d, y_e(y, _)),
            (v = !0)
        }
        return v
      },
      get: function (d) {
        var f = _t
        return Lk(p) && !b_e(n, d) && (f = l(d)), f
      },
      del: function (d, f) {
        var m = !1
        return Lk(p) && (m = p.purge(d, f)), m
      },
      purge: function (d, f) {
        var m,
          h = !1
        if (Q1(e)) {
          var g = ((m = {}), (m[bk] = f || '/'), (m[gG] = 'Thu, 01 Jan 1970 00:00:01 GMT'), m)
          Vm() || (g['max-age'] = '0'), u(d, y_e(_t, g)), (h = !0)
        }
        return h
      },
    }),
    (r[Bs] = function (d) {
      s && s.rm(), (s = null)
    }),
    r)
  return (p[Ym] = p), p
}
function Q1(t) {
  if (Ok === null) {
    ;(Ok = !1), !Cu && xG()
    try {
      var e = Cu.v || {}
      Ok = e[yG] !== void 0
    } catch (r) {
      Ue(t, 2, 68, 'Cannot access document.cookie - ' + Qr(r), { exception: $e(r) })
    }
  }
  return Ok
}
function E_e(t) {
  var e = {}
  if (t && t[ct]) {
    var r = pr(t)[xu](';')
    Ae(r, function (n) {
      if (((n = pr(n || _t)), n)) {
        var i = ps(n, '=')
        i === -1 ? (e[n] = null) : (e[pr(Im(n, i))] = pr(Un(n, i + 1)))
      }
    })
  }
  return e
}
function __e(t, e) {
  return mt(t[e]) ? t[e]() : null
}
function y_e(t, e) {
  var r = t || _t
  return (
    ze(e, function (n, i) {
      r += '; ' + n + (we(i) ? _t : '=' + i)
    }),
    r
  )
}
function WWe(t) {
  var e = _t
  if ((!Cu && xG(), Cu.v)) {
    var r = Cu.v[yG] || _t
    h_e !== r && ((g_e = E_e(r)), (h_e = r)), (e = pr(g_e[t] || _t))
  }
  return e
}
function x_e(t, e) {
  !Cu && xG(), Cu.v && (Cu.v[yG] = t + '=' + e)
}
function Fk(t) {
  return gt(t)
    ? !!(
        Kn(t, 'CPU iPhone OS 12') ||
        Kn(t, 'iPad; CPU OS 12') ||
        (Kn(t, 'Macintosh; Intel Mac OS X 10_14') && Kn(t, 'Version/') && Kn(t, 'Safari')) ||
        (Kn(t, 'Macintosh; Intel Mac OS X 10_14') && Dm(t, 'AppleWebKit/605.1.15 (KHTML, like Gecko)')) ||
        Kn(t, 'Chrome/5') ||
        Kn(t, 'Chrome/6') ||
        (Kn(t, 'UnrealEngine') && !Kn(t, 'Chrome')) ||
        Kn(t, 'UCBrowser/12') ||
        Kn(t, 'UCBrowser/11')
      )
    : !1
}
var hG,
  Hv,
  d_e,
  f_e,
  yG,
  gG,
  m_e,
  _G,
  Ym,
  Ok,
  vG,
  h_e,
  Cu,
  g_e,
  Mk,
  VWe,
  EG = createGetter(() => {
    pt()
    cG()
    Wm()
    Yr()
    od()
    z1()
    td()
    pi()
    ;(d_e = 'toGMTString'),
      (f_e = 'toUTCString'),
      (yG = 'cookie'),
      (gG = 'expires'),
      (m_e = 'isCookieUseDisabled'),
      (_G = 'disableCookiesUsage'),
      (Ym = '_ckMgr'),
      (Ok = null),
      (vG = null),
      (h_e = null),
      (g_e = {}),
      (Mk = {}),
      (VWe =
        ((hG = {
          cookieCfg: aG(
            ((Hv = {}),
            (Hv[xk] = { fb: 'cookieDomain', dfVal: Eu }),
            (Hv.path = { fb: 'cookiePath', dfVal: Eu }),
            (Hv.enabled = Ea),
            (Hv.ignoreCookies = Ea),
            (Hv.blockedCookies = Ea),
            Hv)
          ),
          cookieDomain: Ea,
          cookiePath: Ea,
        }),
        (hG[_G] = Ea),
        hG))
  })
function MS(t, e, r, n) {
  Ae(t, function (i) {
    if (i && i[e])
      if (r)
        Ls(function () {
          return n(i)
        }, 0)
      else
        try {
          n(i)
        } catch {}
  })
}
var KWe,
  US,
  TG = createGetter(() => {
    fo()
    q1()
    pt()
    Wm()
    Yr()
    pi()
    KWe = { perfEvtsSendAll: !1 }
    US = (function () {
      function t(e) {
        this.listeners = []
        var r,
          n,
          i = [],
          o = mn(e, KWe)
        ;(n = o[pc](function (s) {
          r = !!s.cfg.perfEvtsSendAll
        })),
          Wt(t, this, function (s) {
            xr(s, 'listeners', {
              g: function () {
                return i
              },
            }),
              (s[R1] = function (a) {
                i[Ht](a)
              }),
              (s[D1] = function (a) {
                for (var l = ir(i, a); l > -1; ) i[vu](l, 1), (l = ir(i, a))
              }),
              (s[H1] = function (a) {
                MS(i, H1, !0, function (l) {
                  l[H1](a)
                })
              }),
              (s[jm] = function (a, l) {
                MS(i, jm, !0, function (c) {
                  c[jm](a, l)
                })
              }),
              (s[j1] = function (a, l) {
                MS(i, j1, l, function (c) {
                  c[j1](a, l)
                })
              }),
              (s[bu] = function (a) {
                a &&
                  (r || !a[gS]()) &&
                  MS(i, bu, !1, function (l) {
                    a[ol]
                      ? Ls(function () {
                          return l[bu](a)
                        }, 0)
                      : l[bu](a)
                  })
              }),
              (s[Bs] = function (a) {
                var l = function () {
                    n && n.rm(), (n = null), (i = [])
                  },
                  c
                if (
                  (MS(i, 'unload', !1, function (u) {
                    var p = u[Bs](a)
                    p && (c || (c = []), c[Ht](p))
                  }),
                  c)
                )
                  return ds(function (u) {
                    return qm(zj(c), function () {
                      l(), u()
                    })
                  })
                l()
              })
          })
      }
      return (t.__ieDyn = 1), t
    })()
  })
function qn(t, e, r, n, i) {
  if (t) {
    var o = t
    if ((o[G1] && (o = o[G1]()), o)) {
      var s = void 0,
        a = o[Ov](SG)
      try {
        if (((s = o.create(e(), n, i)), s)) {
          if (a && s[sl] && (s[sl](jv[CG], a), a[Ov] && a[sl])) {
            var l = a[Ov](jv[BS])
            l || ((l = []), a[sl](jv[BS], l)), l[Ht](s)
          }
          return o[sl](SG, s), r(s)
        }
      } catch (c) {
        s && s[sl] && s[sl]('exception', c)
      } finally {
        s && o.fire(s), o[sl](SG, a)
      }
    }
  }
  return r()
}
function IG() {
  return YWe
}
var X1,
  CG,
  BS,
  YWe,
  jv,
  qS,
  SG,
  Uk = createGetter(() => {
    fo()
    pt()
    Yr()
    pi()
    ;(X1 = 'ctx'),
      (CG = 'ParentContextKey'),
      (BS = 'ChildrenContextKey'),
      (YWe = null),
      (jv = (function () {
        function t(e, r, n) {
          var i = this
          if (
            ((i.start = wn()),
            (i[Lo] = e),
            (i[ol] = n),
            (i[gS] = function () {
              return !1
            }),
            mt(r))
          ) {
            var o
            xr(i, 'payload', {
              g: function () {
                return !o && mt(r) && ((o = r()), (r = null)), o
              },
            })
          }
          ;(i[Ov] = function (s) {
            return s ? (s === t[CG] || s === t[BS] ? i[s] : (i[X1] || {})[s]) : null
          }),
            (i[sl] = function (s, a) {
              if (s)
                if (s === t[CG])
                  i[s] ||
                    (i[gS] = function () {
                      return !0
                    }),
                    (i[s] = a)
                else if (s === t[BS]) i[s] = a
                else {
                  var l = (i[X1] = i[X1] || {})
                  l[s] = a
                }
            }),
            (i[mk] = function () {
              var s = 0,
                a = i[Ov](t[BS])
              if (Xe(a))
                for (var l = 0; l < a[ct]; l++) {
                  var c = a[l]
                  c && (s += c[Lm])
                }
              ;(i[Lm] = wn() - i.start), (i.exTime = i[Lm] - s), (i[mk] = function () {})
            })
        }
        return (t.ParentContextKey = 'parent'), (t.ChildrenContextKey = 'childEvts'), t
      })()),
      (qS = (function () {
        function t(e) {
          ;(this.ctx = {}),
            Wt(t, this, function (r) {
              ;(r.create = function (n, i, o) {
                return new jv(n, i, o)
              }),
                (r.fire = function (n) {
                  n && (n[mk](), e && mt(e[bu]) && e[bu](n))
                }),
                (r[sl] = function (n, i) {
                  if (n) {
                    var o = (r[X1] = r[X1] || {})
                    o[n] = i
                  }
                }),
                (r[Ov] = function (n) {
                  return (r[X1] || {})[n]
                })
            })
        }
        return (t.__ieDyn = 1), t
      })()),
      (SG = 'CoreUtils.doPerf')
  })
function HS() {
  var t = Gv()
  return Un(t, 0, 8) + '-' + Un(t, 8, 12) + '-' + Un(t, 12, 16) + '-' + Un(t, 16, 20) + '-' + Un(t, 20)
}
function Gv() {
  for (
    var t = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'], e = _t, r, n = 0;
    n < 4;
    n++
  )
    (r = nd()),
      (e +=
        t[r & 15] +
        t[(r >> 4) & 15] +
        t[(r >> 8) & 15] +
        t[(r >> 12) & 15] +
        t[(r >> 16) & 15] +
        t[(r >> 20) & 15] +
        t[(r >> 24) & 15] +
        t[(r >> 28) & 15])
  var i = t[(8 + (nd() & 3)) | 0]
  return tl(e, 0, 8) + tl(e, 9, 4) + '4' + tl(e, 13, 3) + i + tl(e, 16, 3) + tl(e, 19, 12)
}
var wG = createGetter(() => {
  'use strict'
  pt()
  pi()
  Tk()
})
function ad(t, e, r) {
  return t && t[ct] === e && t !== r ? !!t.match(/^[\da-f]*$/i) : !1
}
function S_e(t, e, r) {
  return ad(t, e) ? t : r
}
function C_e(t) {
  ;(isNaN(t) || t < 0 || t > 255) && (t = 1)
  for (var e = t.toString(16); e[ct] < 2; ) e = '0' + e
  return e
}
function jS(t, e, r, n) {
  var i
  return (
    (i = {}),
    (i[Nv] = ad(n, 2, RG) ? n : AG),
    (i[k1] = Iu(t) ? t : Gv()),
    (i[O1] = wu(e) ? e : Im(Gv(), 16)),
    (i.traceFlags = r >= 0 && r <= 255 ? r : 1),
    i
  )
}
function Vv(t, e) {
  var r
  if (!t || (Xe(t) && (t = t[0] || ''), !t || !gt(t) || t[ct] > 8192)) return null
  if (t.indexOf(',') !== -1) {
    var n = t[xu](',')
    t = n[e > 0 && n[ct] > e ? e : 0]
  }
  var i = QWe.exec(pr(t))
  return !i || i[1] === RG || i[2] === Bk || i[3] === qk
    ? null
    : ((r = { version: (i[1] || _t)[gu](), traceId: (i[2] || _t)[gu](), spanId: (i[3] || _t)[gu]() }),
      (r[Bm] = parseInt(i[4], 16)),
      r)
}
function Iu(t) {
  return ad(t, 32, Bk)
}
function wu(t) {
  return ad(t, 16, qk)
}
function J1(t) {
  return !(!t || !ad(t[Nv], 2, RG) || !ad(t[k1], 32, Bk) || !ad(t[O1], 16, qk) || !ad(C_e(t[Bm]), 2))
}
function GS(t) {
  return J1(t) ? (t[Bm] & T_e) === T_e : !1
}
function VS(t) {
  if (t) {
    var e = C_e(t[Bm])
    ad(e, 2) || (e = '01')
    var r = t[Nv] || AG
    return (
      r !== '00' && r !== 'ff' && (r = AG),
      ''
        .concat(r.toLowerCase(), '-')
        .concat(S_e(t.traceId, 32, Bk).toLowerCase(), '-')
        .concat(S_e(t.spanId, 16, qk).toLowerCase(), '-')
        .concat(e.toLowerCase())
    )
  }
  return ''
}
function zS(t) {
  var e = 'traceparent',
    r = Vv(eG(e), t)
  return r || (r = Vv(tG(e), t)), r
}
var QWe,
  AG,
  RG,
  Bk,
  qk,
  T_e,
  DG = createGetter(() => {
    pt()
    Yr()
    wG()
    z1()
    pi()
    ;(QWe = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i),
      (AG = '00'),
      (RG = 'ff'),
      (Bk = '00000000000000000000000000000000'),
      (qk = '0000000000000000'),
      (T_e = 1)
  })
function cd(t) {
  return XWe.get(t, 'state', {}, !0)
}
function PG(t, e) {
  for (var r = [], n = null, i = t[ba](), o; i; ) {
    var s = i[Om]()
    if (s) {
      n && n[Um] && s[js] && n[Um](s), (o = cd(s))
      var a = !!o[Us]
      s[Us] && (a = s[Us]()), a || r[Ht](s), (n = s), (i = i[ba]())
    }
  }
  Ae(r, function (l) {
    var c = t[An]()
    l[Pv](t.getCfg(), c, e, t[ba]()), (o = cd(l)), !l[An] && !o[An] && (o[An] = c), (o[Us] = !0), delete o[xa]
  })
}
function Hk(t) {
  return t.sort(function (e, r) {
    var n = 0
    if (r) {
      var i = r[js]
      e[js] ? (n = i ? e[Mv] - r[Mv] : 1) : i && (n = -1)
    } else n = e ? 1 : -1
    return n
  })
}
function I_e(t) {
  var e = {}
  return {
    getName: function () {
      return e[Lo]
    },
    setName: function (r) {
      t && t.setName(r), (e[Lo] = r)
    },
    getTraceId: function () {
      return e[k1]
    },
    setTraceId: function (r) {
      t && t.setTraceId(r), Iu(r) && (e[k1] = r)
    },
    getSpanId: function () {
      return e[O1]
    },
    setSpanId: function (r) {
      t && t.setSpanId(r), wu(r) && (e[O1] = r)
    },
    getTraceFlags: function () {
      return e[Bm]
    },
    setTraceFlags: function (r) {
      t && t.setTraceFlags(r), (e[Bm] = r)
    },
  }
}
var XWe,
  NG = createGetter(() => {
    'use strict'
    pt()
    Yr()
    $1()
    pi()
    DG()
    XWe = Sk('plugin')
  })
function ZWe(t, e, r) {
  for (; t; ) {
    if (t[Om]() === r) return t
    t = t[ba]()
  }
  return Qm([r], e.config || {}, e)
}
function kG(t, e, r, n) {
  var i = null,
    o = []
  e || (e = mn({}, null, r[kr])), n !== null && (i = n ? ZWe(t, r, n) : t)
  var s = {
    _next: l,
    ctx: {
      core: function () {
        return r
      },
      diagLog: function () {
        return cl(r, e.cfg)
      },
      getCfg: function () {
        return e.cfg
      },
      getExtCfg: u,
      getConfig: p,
      hasNext: function () {
        return !!i
      },
      getNext: function () {
        return i
      },
      setNext: function (f) {
        i = f
      },
      iterate: d,
      onComplete: a,
    },
  }
  function a(f, m) {
    for (var h = [], g = 2; g < arguments.length; g++) h[g - 2] = arguments[g]
    f && o[Ht]({ func: f, self: vt(m) ? s.ctx : m, args: h })
  }
  function l() {
    var f = i
    if (((i = f ? f[ba]() : null), !f)) {
      var m = o
      m &&
        m[ct] > 0 &&
        (Ae(m, function (h) {
          try {
            h.func.call(h.self, h.args)
          } catch (g) {
            Ue(r[kr], 2, 73, 'Unexpected Exception during onComplete - ' + $e(g))
          }
        }),
        (o = []))
    }
    return f
  }
  function c(f, m) {
    var h = null,
      g = e.cfg
    if (g && f) {
      var v = g[Zp]
      !v && m && (v = {}),
        (g[Zp] = v),
        (v = e.ref(g, Zp)),
        v && ((h = v[f]), !h && m && (h = {}), (v[f] = h), (h = e.ref(v, f)))
    }
    return h
  }
  function u(f, m) {
    var h = c(f, !0)
    return (
      m &&
        ze(m, function (g, v) {
          if (we(h[g])) {
            var _ = e.cfg[g]
            ;(_ || !we(_)) && (h[g] = _)
          }
          RS(e, h, g, v)
        }),
      e[il](h, m)
    )
  }
  function p(f, m, h) {
    h === void 0 && (h = !1)
    var g,
      v = c(f, !1),
      _ = e.cfg
    return v && (v[m] || !we(v[m])) ? (g = v[m]) : (_[m] || !we(_[m])) && (g = _[m]), g || !we(g) ? g : h
  }
  function d(f) {
    for (var m; (m = s._next()); ) {
      var h = m[Om]()
      h && f(h)
    }
  }
  return s
}
function ms(t, e, r, n) {
  var i = mn(e),
    o = kG(t, i, r, n),
    s = o.ctx
  function a(c) {
    var u = o._next()
    return u && u[js](c, s), !u
  }
  function l(c, u) {
    return c === void 0 && (c = null), Xe(c) && (c = Qm(c, i.cfg, r, u)), ms(c || s[ba](), i.cfg, r, u)
  }
  return (s[Ii] = a), (s[yu] = l), s
}
function Z1(t, e, r) {
  var n = mn(e.config),
    i = kG(t, n, e, r),
    o = i.ctx
  function s(l) {
    var c = i._next()
    return c && c[Bs](o, l), !c
  }
  function a(l, c) {
    return l === void 0 && (l = null), Xe(l) && (l = Qm(l, n.cfg, e, c)), Z1(l || o[ba](), e, c)
  }
  return (o[Ii] = s), (o[yu] = a), o
}
function $S(t, e, r) {
  var n = mn(e.config),
    i = kG(t, n, e, r),
    o = i.ctx
  function s(l) {
    return o.iterate(function (c) {
      mt(c[kv]) && c[kv](o, l)
    })
  }
  function a(l, c) {
    return l === void 0 && (l = null), Xe(l) && (l = Qm(l, n.cfg, e, c)), $S(l || o[ba](), e, c)
  }
  return (o[Ii] = s), (o[yu] = a), o
}
function Qm(t, e, r, n) {
  var i = null,
    o = !n
  if (Xe(t) && t[ct] > 0) {
    var s = null
    Ae(t, function (a) {
      if ((!o && n === a && (o = !0), o && a && mt(a[js]))) {
        var l = eKe(a, e, r)
        i || (i = l), s && s._setNext(l), (s = l)
      }
    })
  }
  return n && !i ? Qm([n], e, r) : i
}
function eKe(t, e, r) {
  var n = null,
    i = mt(t[js]),
    o = mt(t[Um]),
    s
  t ? (s = t[_u] + '-' + t[Mv] + '-' + R_e++) : (s = 'Unknown-0-' + R_e++)
  var a = {
    getPlugin: function () {
      return t
    },
    getNext: function () {
      return n
    },
    processTelemetry: u,
    unload: p,
    update: d,
    _id: s,
    _setNext: function (f) {
      n = f
    },
  }
  function l() {
    var f
    return t && mt(t[A_e]) && (f = t[A_e]()), f || (f = ms(a, e, r)), f
  }
  function c(f, m, h, g, v) {
    var _ = !1,
      y = t ? t[_u] : JWe,
      b = f[w_e]
    return (
      b || (b = f[w_e] = {}),
      f.setNext(n),
      t &&
        qn(
          f[An](),
          function () {
            return y + ':' + h
          },
          function () {
            b[s] = !0
            try {
              var x = n ? n._id : _t
              x && (b[x] = !1), (_ = m(f))
            } catch (U) {
              var P = n ? b[n._id] : !0
              P && (_ = !0),
                (!n || !P) &&
                  Ue(f[qs](), 1, 73, 'Plugin [' + y + '] failed during ' + h + ' - ' + $e(U) + ', run flags: ' + $e(b))
            }
          },
          g,
          v
        ),
      _
    )
  }
  function u(f, m) {
    m = m || l()
    function h(g) {
      if (!t || !i) return !1
      var v = cd(t)
      return v[xa] || v[yS] ? !1 : (o && t[Um](n), t[js](f, g), !0)
    }
    c(
      m,
      h,
      'processTelemetry',
      function () {
        return { item: f }
      },
      !f.sync
    ) || m[Ii](f)
  }
  function p(f, m) {
    function h() {
      var g = !1
      if (t) {
        var v = cd(t),
          _ = t[An] || v[An]
        t &&
          (!_ || _ === f.core()) &&
          !v[xa] &&
          ((v[An] = null), (v[xa] = !0), (v[Us] = !1), t[xa] && t[xa](f, m) === !0 && (g = !0))
      }
      return g
    }
    c(f, h, 'unload', function () {}, m[ol]) || f[Ii](m)
  }
  function d(f, m) {
    function h() {
      var g = !1
      if (t) {
        var v = cd(t),
          _ = t[An] || v[An]
        t && (!_ || _ === f.core()) && !v[xa] && t[kv] && t[kv](f, m) === !0 && (g = !0)
      }
      return g
    }
    c(f, h, 'update', function () {}, !1) || f[Ii](m)
  }
  return mu(a)
}
var JWe,
  w_e,
  A_e,
  R_e,
  OG,
  jk = createGetter(() => {
    'use strict'
    pt()
    nG()
    Wm()
    Yr()
    od()
    td()
    pi()
    Uk()
    NG()
    ;(JWe = 'TelemetryPluginChain'), (w_e = '_hasRun'), (A_e = '_getTelCtx'), (R_e = 0)
    OG = (function () {
      function t(e, r, n, i) {
        var o = this,
          s = ms(e, r, n, i)
        Sa(o, s, Si(s))
      }
      return t
    })()
  })
function zv() {
  var t = []
  function e(n) {
    n && t[Ht](n)
  }
  function r(n, i) {
    Ae(t, function (o) {
      try {
        o(n, i)
      } catch (s) {
        Ue(n[qs](), 2, 73, 'Unexpected error calling unload handler - ' + $e(s))
      }
    }),
      (t = [])
  }
  return { add: e, run: r }
}
var Gk = createGetter(() => {
  pt()
  Yr()
  od()
})
function Vk() {
  var t = []
  function e(n) {
    var i = t
    ;(t = []),
      Ae(i, function (o) {
        try {
          ;(o.rm || o.remove).call(o)
        } catch (s) {
          Ue(n, 2, 73, 'Unloading:' + $e(s))
        }
      })
  }
  function r(n) {
    n && lc(t, n)
  }
  return { run: e, add: r }
}
var LG = createGetter(() => {
  pt()
  od()
})
var MG,
  Xm,
  tKe,
  ld,
  FG = createGetter(() => {
    'use strict'
    fo()
    pt()
    Wm()
    Yr()
    od()
    td()
    pi()
    jk()
    Gk()
    LG()
    ;(Xm = 'getPlugin'),
      (tKe = ((MG = {}), (MG[Zp] = { isVal: Eu, v: {} }), MG)),
      (ld = (function () {
        function t() {
          var e = this,
            r,
            n,
            i,
            o,
            s
          c(),
            Wt(t, e, function (u) {
              ;(u[Pv] = function (p, d, f, m) {
                l(p, d, m), (r = !0)
              }),
                (u[xa] = function (p, d) {
                  var f,
                    m = u[An]
                  if (!m || (p && m !== p[An]())) return
                  var h,
                    g = !1,
                    v = p || Z1(null, m, i && i[Xm] ? i[Xm]() : i),
                    _ = d || ((f = { reason: 0 }), (f[ol] = !1), f)
                  function y() {
                    g || ((g = !0), o.run(v, d), s.run(v[qs]()), h === !0 && v[Ii](_), c())
                  }
                  return !u[N1] || u[N1](v, _, y) !== !0 ? y() : (h = !0), h
                }),
                (u[kv] = function (p, d) {
                  var f = u[An]
                  if (!f || (p && f !== p[An]())) return
                  var m,
                    h = !1,
                    g = p || $S(null, f, i && i[Xm] ? i[Xm]() : i),
                    v = d || { reason: 0 }
                  function _() {
                    h || ((h = !0), l(g.getCfg(), g.core(), g[ba]()))
                  }
                  return !u._doUpdate || u._doUpdate(g, v, _) !== !0 ? _() : (m = !0), m
                }),
                ed(
                  u,
                  '_addUnloadCb',
                  function () {
                    return o
                  },
                  'add'
                ),
                ed(
                  u,
                  '_addHook',
                  function () {
                    return s
                  },
                  'add'
                ),
                xr(u, '_unloadHooks', {
                  g: function () {
                    return s
                  },
                })
            }),
            (e[qs] = function (u) {
              return a(u)[qs]()
            }),
            (e[Us] = function () {
              return r
            }),
            (e.setInitialized = function (u) {
              r = u
            }),
            (e[Um] = function (u) {
              i = u
            }),
            (e[Ii] = function (u, p) {
              p ? p[Ii](u) : i && mt(i[js]) && i[js](u, null)
            }),
            (e._getTelCtx = a)
          function a(u) {
            u === void 0 && (u = null)
            var p = u
            if (!p) {
              var d = n || ms(null, {}, e[An])
              i && i[Xm] ? (p = d[yu](null, i[Xm])) : (p = d[yu](null, i))
            }
            return p
          }
          function l(u, p, d) {
            mn(u, tKe, cl(p)), !d && p && (d = p[pk]()[ba]())
            var f = i
            i && i[Xm] && (f = i[Xm]()), (e[An] = p), (n = ms(d, u, p, f))
          }
          function c() {
            ;(r = !1), (e[An] = null), (n = null), (i = null), (s = Vk()), (o = zv())
          }
        }
        return (t.__ieDyn = 1), t
      })())
  })
function rKe(t, e, r) {
  var n = { id: e, fn: r }
  lc(t, n)
  var i = {
    remove: function () {
      Ae(t, function (o, s) {
        if (o.id === n.id) return t[vu](s, 1), -1
      })
    },
  }
  return i
}
function nKe(t, e, r) {
  for (var n = !1, i = t[ct], o = 0; o < i; ++o) {
    var s = t[o]
    if (s)
      try {
        if (s.fn[km](null, [e]) === !1) {
          n = !0
          break
        }
      } catch (a) {
        Ue(r, 2, 64, 'Telemetry initializer failed: ' + Qr(a), { exception: $e(a) }, !0)
      }
  }
  return !n
}
var D_e,
  P_e = createGetter(() => {
    Fs()
    fo()
    pt()
    Yr()
    FG()
    od()
    td()
    pi()
    D_e = (function (t) {
      Ms(e, t)
      function e() {
        var r = t.call(this) || this
        ;(r.identifier = 'TelemetryInitializerPlugin'), (r.priority = 199)
        var n, i
        o(),
          Wt(e, r, function (s, a) {
            ;(s.addTelemetryInitializer = function (l) {
              return rKe(i, n++, l)
            }),
              (s[js] = function (l, c) {
                nKe(i, l, c ? c[qs]() : s[qs]()) && s[Ii](l, c)
              }),
              (s[N1] = function () {
                o()
              })
          })
        function o() {
          ;(n = 0), (i = [])
        }
        return r
      }
      return (e.__ieDyn = 1), e
    })(ld)
  })
function sKe(t, e) {
  return new qS(e)
}
function aKe(t, e, r) {
  var n,
    i = [],
    o = [],
    s = {}
  return (
    Ae(r, function (a) {
      ;(we(a) || we(a[Pv])) && Cn(L_e)
      var l = a[Mv],
        c = a[_u]
      a && l && (we(s[l]) ? (s[l] = c) : Ia(t, 'Two extensions have same priority #' + l + ' - ' + s[l] + ', ' + c)),
        !l || l < e ? i[Ht](a) : o[Ht](a)
    }),
    (n = {}),
    (n[An] = i),
    (n[Hm] = o),
    n
  )
}
function k_e(t, e) {
  var r = !1
  return (
    Ae(e, function (n) {
      if (n === t) return (r = !0), -1
    }),
    r
  )
}
function BG(t, e, r, n) {
  r &&
    ze(r, function (i, o) {
      n && Ci(o) && Ci(e[i]) && BG(t, e[i], o, n), n && Ci(o) && Ci(e[i]) ? BG(t, e[i], o, n) : t.set(e, i, o)
    })
}
function O_e(t, e) {
  var r = null,
    n = -1
  return (
    Ae(t, function (i, o) {
      if (i.w === e) return (r = i), (n = o), -1
    }),
    { i: n, l: r }
  )
}
function cKe(t, e) {
  var r = O_e(t, e).l
  return (
    r ||
      ((r = {
        w: e,
        rm: function () {
          var n = O_e(t, e)
          n.i !== -1 && t[vu](n.i, 1)
        },
      }),
      t[Ht](r)),
    r
  )
}
function lKe(t, e, r) {
  Ae(e, function (n) {
    var i = di(t, n.w, r)
    delete n.w,
      (n.rm = function () {
        i.rm()
      })
  })
}
var Jm,
  L_e,
  iKe,
  N_e,
  oKe,
  UG,
  ud,
  M_e = createGetter(() => {
    'use strict'
    Fs()
    fo()
    q1()
    pt()
    Wm()
    Yr()
    sG()
    c_e()
    EG()
    $1()
    pG()
    od()
    td()
    pi()
    TG()
    Uk()
    jk()
    NG()
    P_e()
    Gk()
    LG()
    ;(L_e = 'Plugins must provide initialize method'),
      (iKe = '_notificationManager'),
      (N_e = 'SDK is still unloading...'),
      (oKe = 'SDK is not initialized'),
      (UG = cs(
        ((Jm = { cookieCfg: {} }),
        (Jm[Lv] = { rdOnly: !0, ref: !0, v: [] }),
        (Jm[Hm] = { rdOnly: !0, ref: !0, v: [] }),
        (Jm[Zp] = { ref: !0, v: {} }),
        (Jm[yk] = Ea),
        (Jm.loggingLevelConsole = 0),
        (Jm.diagnosticLogInterval = Ea),
        Jm)
      ))
    ud = (function () {
      function t() {
        var e, r, n, i, o, s, a, l, c, u, p, d, f, m, h, g, v, _, y, b, x, P, U, H, j, M, F, z
        Wt(t, this, function (q) {
          T(),
            (q._getDbgPlgTargets = function () {
              return [U]
            }),
            (q[Us] = function () {
              return r
            }),
            (q[Pv] = function (W, ne, ye, Te) {
              f && Cn(N_e),
                q[Us]() && Cn('Core cannot be initialized more than once'),
                (e = mn(W, UG, ye || q[kr], !1)),
                (W = e.cfg),
                ve(
                  e[pc](function (bt) {
                    x = bt.cfg.instrumentationKey
                    var Jt = bt.ref(bt.cfg, Zp)
                    ze(Jt, function (qr) {
                      bt.ref(Jt, qr)
                    }),
                      we(x) && Cn('Please provide instrumentation key')
                  })
                ),
                (o = Te),
                Ye(),
                Ze(),
                (q[kr] = ye)
              var Ne = W[Lv]
              if (
                ((u = []),
                u[Ht].apply(u, ek(ek([], ne, !1), Ne, !1)),
                (p = W[Hm]),
                X(null),
                (!d || d[ct] === 0) && Cn('No ' + Hm + ' available'),
                p && p[ct] > 1)
              ) {
                var qe = q[Om]('TeeChannelController')
                ;(!qe || !qe.plugin) && Ue(n, 1, 28, 'TeeChannel required')
              }
              lKe(W, P, n), (P = null), (r = !0), q.releaseQueue(), q[Pj]()
            }),
            (q.getChannels = function () {
              var W = []
              return (
                d &&
                  Ae(d, function (ne) {
                    W[Ht](ne)
                  }),
                mu(W)
              )
            }),
            (q.track = function (W) {
              qn(
                q[G1](),
                function () {
                  return 'AppInsightsCore:track'
                },
                function () {
                  W === null && (tt(W), Cn('Invalid telemetry item')),
                    !W[Lo] && we(W[Lo]) && (tt(W), Cn('telemetry name required')),
                    (W.iKey = W.iKey || x),
                    (W[Lm] = W[Lm] || Ta(new Date())),
                    (W.ver = W.ver || '4.0'),
                    !f && q[Us]() ? A()[Ii](W) : i[Ht](W)
                },
                function () {
                  return { item: W }
                },
                !W.sync
              )
            }),
            (q[pk] = A),
            (q[A1] = function () {
              return o || ((o = new US(e.cfg)), (q[iKe] = o)), o
            }),
            (q[R1] = function (W) {
              q[A1]()[R1](W)
            }),
            (q[D1] = function (W) {
              o && o[D1](W)
            }),
            (q.getCookieMgr = function () {
              return l || (l = sd(e.cfg, q[kr])), l
            }),
            (q.setCookieMgr = function (W) {
              l !== W && (id(l, !1), (l = W))
            }),
            (q[G1] = function () {
              return (
                !s &&
                  !a &&
                  ve(
                    e[pc](function (W) {
                      if (W.cfg.enablePerfMgr) {
                        var ne = W.cfg[yk]
                        mt(ne) && (a = ne(q, q[A1]()))
                      }
                    })
                  ),
                s || a || IG()
              )
            }),
            (q.setPerfMgr = function (W) {
              s = W
            }),
            (q.eventCnt = function () {
              return i[ct]
            }),
            (q.releaseQueue = function () {
              if (r && i[ct] > 0) {
                var W = i
                ;(i = []),
                  Ae(W, function (ne) {
                    A()[Ii](ne)
                  })
              }
            }),
            (q[Pj] = function (W) {
              return (h = W || null), (z = !1), M && M[Dv](), L(!0)
            })
          function L(W) {
            if ((!M || !M[Mm]) && !z) {
              var ne = W || (n && n.queue[ct] > 0)
              ne &&
                (F ||
                  ((F = !0),
                  ve(
                    e[pc](function (ye) {
                      var Te = ye.cfg.diagnosticLogInterval
                      ;(!Te || !(Te > 0)) && (Te = 1e4)
                      var Ne = !1
                      M && ((Ne = M[Mm]), M[Dv]()), (M = vj(ae, Te)), M.unref(), (M[Mm] = Ne)
                    })
                  )),
                (M[Mm] = !0))
            }
            return M
          }
          ;(q[Nj] = function () {
            ;(z = !0), M && M[Dv](), ae()
          }),
            Sa(
              q,
              function () {
                return m
              },
              ['addTelemetryInitializer']
            ),
            (q[Bs] = function (W, ne, ye) {
              var Te
              W === void 0 && (W = !0), r || Cn(oKe), f && Cn(N_e)
              var Ne = ((Te = { reason: 50 }), (Te[ol] = W), (Te.flushComplete = !1), Te),
                qe
              W &&
                !ne &&
                (qe = ds(function (qr) {
                  ne = qr
                }))
              var bt = Z1(ce(), q)
              bt[fS](function () {
                _.run(q[kr]),
                  Pk([l, o, n], W, function () {
                    T(), ne && ne(Ne)
                  })
              }, q)
              function Jt(qr) {
                ;(Ne.flushComplete = qr), (f = !0), v.run(bt, Ne), q[Nj](), bt[Ii](Ne)
              }
              return ae(), je(W, Jt, 6, ye) || Jt(!1), qe
            }),
            (q[Om] = fe),
            (q.addPlugin = function (W, ne, ye, Te) {
              if (!W) {
                Te && Te(!1), st(L_e)
                return
              }
              var Ne = fe(W[_u])
              if (Ne && !ne) {
                Te && Te(!1), st('Plugin [' + W[_u] + '] is already loaded!')
                return
              }
              var qe = { reason: 16 }
              function bt(le) {
                u[Ht](W), (qe.added = [W]), X(qe), Te && Te(!0)
              }
              if (Ne) {
                var Jt = [Ne.plugin],
                  qr = { reason: 2, isAsync: !!ye }
                oe(Jt, qr, function (le) {
                  le ? ((qe.removed = Jt), (qe.reason |= 32), bt(!0)) : Te && Te(!1)
                })
              } else bt(!1)
            }),
            (q.updateCfg = function (W, ne) {
              ne === void 0 && (ne = !0)
              var ye
              if (q[Us]()) {
                ;(ye = { reason: 1, cfg: e.cfg, oldCfg: XN({}, e.cfg), newConfig: XN({}, W), merge: ne }),
                  (W = ye.newConfig)
                var Te = e.cfg
                ;(W[Lv] = Te[Lv]), (W[Hm] = Te[Hm])
              }
              e._block(function (Ne) {
                var qe = Ne.cfg
                BG(Ne, qe, W, ne),
                  ne ||
                    ze(qe, function (bt) {
                      Os(W, bt) || Ne.set(qe, bt, Ea)
                    }),
                  Ne[il](qe, UG)
              }, !0),
                e[Rv](),
                ye && ke(ye)
            }),
            (q.evtNamespace = function () {
              return g
            }),
            (q.flush = je),
            (q.getTraceCtx = function (W) {
              return b || (b = I_e()), b
            }),
            (q.setTraceCtx = function (W) {
              b = W || null
            }),
            (q.addUnloadHook = ve),
            ed(
              q,
              'addUnloadCb',
              function () {
                return v
              },
              'add'
            ),
            (q.onCfgChange = function (W) {
              var ne
              return (
                r ? (ne = di(e.cfg, W, q[kr])) : (ne = cKe(P, W)),
                {
                  rm: function () {
                    ne.rm()
                  },
                }
              )
            }),
            (q.getWParam = function () {
              return Am() || e.cfg.enableWParam ? 0 : -1
            })
          function S() {
            var W = {}
            H = []
            var ne = function (ye) {
              ye &&
                Ae(ye, function (Te) {
                  if (Te[_u] && Te[Nv] && !W[Te.identifier]) {
                    var Ne = Te[_u] + '=' + Te[Nv]
                    H[Ht](Ne), (W[Te.identifier] = Te)
                  }
                })
            }
            ne(d),
              p &&
                Ae(p, function (ye) {
                  ne(ye)
                }),
              ne(u)
          }
          function T() {
            ;(r = !1),
              (e = mn({}, UG, q[kr])),
              (e.cfg[dk] = 1),
              xr(q, 'config', {
                g: function () {
                  return e.cfg
                },
                s: function (ne) {
                  q.updateCfg(ne, !1)
                },
              }),
              xr(q, 'pluginVersionStringArr', {
                g: function () {
                  return H || S(), H
                },
              }),
              xr(q, 'pluginVersionString', {
                g: function () {
                  return j || (H || S(), (j = H.join(';'))), j || _t
                },
              }),
              xr(q, 'logger', {
                g: function () {
                  return n || ((n = new Km(e.cfg)), (e[kr] = n)), n
                },
                s: function (ne) {
                  ;(e[kr] = ne), n !== ne && (id(n, !1), (n = ne))
                },
              }),
              (q[kr] = new Km(e.cfg)),
              (U = [])
            var W = q.config[Lv] || []
            W.splice(0, W[ct]),
              lc(W, U),
              (m = new D_e()),
              (i = []),
              id(o, !1),
              (o = null),
              (s = null),
              (a = null),
              id(l, !1),
              (l = null),
              (c = null),
              (u = []),
              (p = null),
              (d = null),
              (f = !1),
              (h = null),
              (g = ho('AIBaseCore', !0)),
              (v = zv()),
              (b = null),
              (x = null),
              (_ = Vk()),
              (P = []),
              (j = null),
              (H = null),
              (z = !1)
          }
          function A() {
            var W = ms(ce(), e.cfg, q)
            return W[fS](L), W
          }
          function X(W) {
            var ne = aKe(q[kr], a_e, u)
            ;(c = null), (j = null), (H = null), (d = (p || [])[0] || []), (d = Hk(lc(d, ne[Hm])))
            var ye = lc(Hk(ne[An]), d)
            U = mu(ye)
            var Te = q.config[Lv] || []
            Te.splice(0, Te[ct]), lc(Te, U)
            var Ne = A()
            d && d[ct] > 0 && PG(Ne[yu](d), ye), PG(Ne, ye), W && ke(W)
          }
          function fe(W) {
            var ne = null,
              ye = null,
              Te = []
            return (
              Ae(U, function (Ne) {
                if (Ne[_u] === W && Ne !== m) return (ye = Ne), -1
                Ne.getChannel && Te[Ht](Ne)
              }),
              !ye &&
                Te[ct] > 0 &&
                Ae(Te, function (Ne) {
                  if (((ye = Ne.getChannel(W)), !ye)) return -1
                }),
              ye &&
                (ne = {
                  plugin: ye,
                  setEnabled: function (Ne) {
                    cd(ye)[yS] = !Ne
                  },
                  isEnabled: function () {
                    var Ne = cd(ye)
                    return !Ne[xa] && !Ne[yS]
                  },
                  remove: function (Ne, qe) {
                    var bt
                    Ne === void 0 && (Ne = !0)
                    var Jt = [ye],
                      qr = ((bt = { reason: 1 }), (bt[ol] = Ne), bt)
                    oe(Jt, qr, function (le) {
                      le && X({ reason: 32, removed: Jt }), qe && qe(le)
                    })
                  },
                }),
              ne
            )
          }
          function ce() {
            if (!c) {
              var W = (U || []).slice()
              ir(W, m) === -1 && W[Ht](m), (c = Qm(Hk(W), e.cfg, q))
            }
            return c
          }
          function oe(W, ne, ye) {
            if (W && W[ct] > 0) {
              var Te = Qm(W, e.cfg, q),
                Ne = Z1(Te, q)
              Ne[fS](function () {
                var qe = !1,
                  bt = []
                Ae(u, function (qr, le) {
                  k_e(qr, W) ? (qe = !0) : bt[Ht](qr)
                }),
                  (u = bt),
                  (j = null),
                  (H = null)
                var Jt = []
                p &&
                  (Ae(p, function (qr, le) {
                    var ee = []
                    Ae(qr, function (te) {
                      k_e(te, W) ? (qe = !0) : ee[Ht](te)
                    }),
                      Jt[Ht](ee)
                  }),
                  (p = Jt)),
                  ye && ye(qe),
                  L()
              }),
                Ne[Ii](ne)
            } else ye(!1)
          }
          function ae() {
            if (n && n.queue) {
              var W = n.queue.slice(0)
              ;(n.queue[ct] = 0),
                Ae(W, function (ne) {
                  var ye,
                    Te =
                      ((ye = {}),
                      (ye[Lo] = h || 'InternalMessageId: ' + ne[P1]),
                      (ye.iKey = x),
                      (ye[Lm] = Ta(new Date())),
                      (ye.baseType = qv.dataType),
                      (ye.baseData = { message: ne[Fm] }),
                      ye)
                  q.track(Te)
                })
            }
          }
          function je(W, ne, ye, Te) {
            var Ne = 1,
              qe = !1,
              bt = null
            Te = Te || 5e3
            function Jt() {
              Ne--, qe && Ne === 0 && (bt && bt[Dv](), (bt = null), ne && ne(qe), (ne = null))
            }
            if (d && d[ct] > 0) {
              var qr = A()[yu](d)
              qr.iterate(function (le) {
                if (le.flush) {
                  Ne++
                  var ee = !1
                  le.flush(
                    W,
                    function () {
                      ;(ee = !0), Jt()
                    },
                    ye
                  ) ||
                    ee ||
                    (W && bt == null
                      ? (bt = Ls(function () {
                          ;(bt = null), Jt()
                        }, Te))
                      : Jt())
                }
              })
            }
            return (qe = !0), Jt(), !0
          }
          function Ye() {
            !o && q[A1](),
              ve(
                e[pc](function (W) {
                  var ne = W.cfg.disableDbgExt
                  ne === !0 && y && (o[D1](y), (y = null)), o && !y && ne !== !0 && ((y = l_e(W.cfg)), o[R1](y))
                })
              )
          }
          function Ze() {
            ve(
              e[pc](function (W) {
                var ne = W.cfg.enablePerfMgr
                !ne && a && (a = null), ne && xS(W.cfg, yk, sKe)
              })
            )
          }
          function ke(W) {
            var ne = $S(ce(), q)
            ne[fS](L), (!q._updateHook || q._updateHook(ne, W) !== !0) && ne[Ii](W)
          }
          function st(W) {
            var ne = q[kr]
            ne ? (Ue(ne, 2, 73, W), L()) : Cn(W)
          }
          function tt(W) {
            var ne = q[A1]()
            ne && ne[jm]([W], 2)
          }
          function ve(W) {
            _.add(W)
          }
        })
      }
      return (t.__ieDyn = 1), t
    })()
  })
function H_e(t) {
  return t && t[Jp] ? t[Jp](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, _t) : t
}
function Wk(t, e) {
  var r
  if (e) {
    var n = _t
    Xe(e)
      ? ((n = _t),
        Ae(e, function (o) {
          ;(o = H_e(o)), o && (o[0] !== '.' && (o = '.' + o), (n += o))
        }))
      : (n = H_e(e)),
      n && (n[0] !== '.' && (n = '.' + n), (t = (t || _t) + n))
  }
  var i = fKe.exec(t || _t) || []
  return (r = {}), (r[Hs] = i[1]), (r.ns = (i[2] || _t).replace(uKe, '.').replace(pKe, _t)[xu]('.').sort().join('.')), r
}
function qG(t, e, r) {
  var n = [],
    i = KS.get(t, zk, {}, !1),
    o = Wk(e, r)
  return (
    ze(i, function (s, a) {
      Ae(a, function (l) {
        var c
        ;(!o[Hs] || o[Hs] === l.evtName[Hs]) &&
          (!o.ns || o.ns === o.ns) &&
          n[Ht](((c = {}), (c[Lo] = l.evtName[Hs] + (l.evtName.ns ? '.' + l.evtName.ns : _t)), (c.handler = l[hS]), c))
      })
    }),
    n
  )
}
function Y_e(t, e, r) {
  r === void 0 && (r = !0)
  var n = KS.get(t, zk, {}, r),
    i = n[e]
  return i || (i = n[e] = []), i
}
function Q_e(t, e, r, n) {
  t && e && e[Hs] && (t[q_e] ? t[q_e](e[Hs], r, n) : t[B_e] && t[B_e](G_e + e[Hs], r))
}
function mKe(t, e, r, n) {
  var i = !1
  return (
    t && e && e[Hs] && r && (t[U_e] ? (t[U_e](e[Hs], r, n), (i = !0)) : t[F_e] && (t[F_e](G_e + e[Hs], r), (i = !0))), i
  )
}
function j_e(t, e, r, n) {
  for (var i = e[ct]; i--; ) {
    var o = e[i]
    o && (!r.ns || r.ns === o.evtName.ns) && (!n || n(o)) && (Q_e(t, o.evtName, o[hS], o.capture), e[vu](i, 1))
  }
}
function hKe(t, e, r) {
  if (e[Hs]) j_e(t, Y_e(t, e[Hs]), e, r)
  else {
    var n = KS.get(t, zk, {})
    ze(n, function (i, o) {
      j_e(t, o, e, r)
    }),
      Si(n)[ct] === 0 && KS.kill(t, zk)
  }
}
function wa(t, e) {
  var r
  return e ? (Xe(e) ? (r = [t].concat(e)) : (r = [t, e]), (r = Wk('xx', r).ns[xu]('.'))) : (r = t), r
}
function Au(t, e, r, n, i) {
  var o
  i === void 0 && (i = !1)
  var s = !1
  if (t)
    try {
      var a = Wk(e, n)
      if (((s = mKe(t, a, r, i)), s && KS.accept(t))) {
        var l = ((o = { guid: dKe++, evtName: a }), (o[hS] = r), (o.capture = i), o)
        Y_e(t, a.type)[Ht](l)
      }
    } catch {}
  return s
}
function pd(t, e, r, n, i) {
  if ((i === void 0 && (i = !1), t))
    try {
      var o = Wk(e, n),
        s = !1
      hKe(t, o, function (a) {
        return (o.ns && !r) || a[hS] === r ? ((s = !0), !0) : !1
      }),
        s || Q_e(t, o, r, i)
    } catch {}
}
function HG(t, e, r, n) {
  return n === void 0 && (n = !1), Au(t, e, r, null, n)
}
function jG(t, e, r, n) {
  n === void 0 && (n = !1), pd(t, e, r, null, n)
}
function Kk(t, e, r) {
  var n = !1,
    i = Bn()
  i && ((n = Au(i, t, e, r)), (n = Au(i.body, t, e, r) || n))
  var o = In()
  return o && (n = Au(o, t, e, r) || n), n
}
function Yk(t, e, r) {
  var n = Bn()
  n && (pd(n, t, e, r), pd(n.body, t, e, r))
  var i = In()
  i && pd(i, t, e, r)
}
function ex(t, e, r, n) {
  var i = !1
  return (
    e &&
      t &&
      t[ct] > 0 &&
      Ae(t, function (o) {
        o && (!r || ir(r, o) === -1) && (i = Kk(o, e, n) || i)
      }),
    i
  )
}
function Qk(t, e, r, n) {
  var i = !1
  return e && t && Xe(t) && ((i = ex(t, e, r, n)), !i && r && r[ct] > 0 && (i = ex(t, e, null, n))), i
}
function Zm(t, e, r) {
  t &&
    Xe(t) &&
    Ae(t, function (n) {
      n && Yk(n, e, r)
    })
}
function YS(t, e, r) {
  return Qk([$_e, z_e, $k], t, e, r)
}
function QS(t, e) {
  Zm([$_e, z_e, $k], t, e)
}
function tx(t, e, r) {
  function n(s) {
    var a = In()
    t && a && a.visibilityState === 'hidden' && t(s)
  }
  var i = wa(W_e, r),
    o = ex([$k], t, e, i)
  return (!e || ir(e, WS) === -1) && (o = ex([WS], n, e, i) || o), !o && e && (o = tx(t, null, r)), o
}
function XS(t, e) {
  var r = wa(W_e, e)
  Zm([$k], t, r), Zm([WS], null, r)
}
function rx(t, e, r) {
  function n(s) {
    var a = In()
    t && a && a.visibilityState === 'visible' && t(s)
  }
  var i = wa(K_e, r),
    o = ex([V_e], t, e, i)
  return (o = ex([WS], n, e, i) || o), !o && e && (o = rx(t, null, r)), o
}
function JS(t, e) {
  var r = wa(K_e, e)
  Zm([V_e], t, r), Zm([WS], null, r)
}
var G_e,
  F_e,
  U_e,
  B_e,
  q_e,
  zk,
  WS,
  $k,
  V_e,
  z_e,
  $_e,
  W_e,
  K_e,
  uKe,
  pKe,
  dKe,
  KS,
  fKe,
  X_e = createGetter(() => {
    pt()
    Yr()
    $1()
    pi()
    ;(G_e = 'on'),
      (F_e = 'attachEvent'),
      (U_e = 'addEventListener'),
      (B_e = 'detachEvent'),
      (q_e = 'removeEventListener'),
      (zk = 'events'),
      (WS = 'visibilitychange'),
      ($k = 'pagehide'),
      (V_e = 'pageshow'),
      (z_e = 'unload'),
      ($_e = 'beforeunload'),
      (W_e = ho('aiEvtPageHide')),
      (K_e = ho('aiEvtPageShow')),
      (uKe = /\.[\.]+/g),
      (pKe = /[\.]+$/),
      (dKe = 1),
      (KS = Sk('events')),
      (fKe = /^([^.]*)(?:\.(.+)|)/)
  })
var GG,
  J_e = createGetter(() => {
    lk()
    GG = Vi({ DISABLED: 0, CRITICAL: 1, WARNING: 2, DEBUG: 3 })
  })
var br = createGetter(() => {
  T0e()
  S0e()
  M_e()
  FG()
  Tk()
  wG()
  sG()
  td()
  pt()
  lk()
  X_e()
  z1()
  Fs()
  TG()
  Uk()
  od()
  jk()
  J_e()
  EG()
  $1()
  Gk()
  DG()
  Wm()
  Ak()
  cG()
})
var Ru,
  Z_e,
  VG,
  Xk,
  Jk = createGetter(() => {
    ;(Ru = ''),
      (Z_e = 'https://browser.events.data.microsoft.com/OneCollector/1.0/'),
      (VG = 'version'),
      (Xk = 'properties')
  })
var zG,
  $G,
  nx,
  Du,
  WG,
  hn,
  $v,
  dd,
  Zk,
  e4,
  t4,
  r4,
  ZS,
  n4 = createGetter(() => {
    ;(zG = 'initialize'),
      ($G = 'logger'),
      (nx = 'indexOf'),
      (Du = 'timings'),
      (WG = 'pollInternalLogs'),
      (hn = 'value'),
      ($v = 'kind'),
      (dd = 'length'),
      (Zk = 'processTelemetryStart'),
      (e4 = 'handleField'),
      (t4 = 'rmSanitizer'),
      (r4 = 'rmFieldSanitizer'),
      (ZS = 'canHandle')
  })
function zi(t) {
  return !(t === Ru || we(t))
}
function i4(t) {
  if (t) {
    var e = ps(t, '-')
    if (e > -1) return Im(t, e)
  }
  return Ru
}
function iye() {
  return KG === null && (KG = !vt(Uint8Array) && !xKe() && !Gm()), KG
}
function o4(t) {
  return !!(t && Gi(t) && t >= 1 && t <= 4)
}
function s4(t, e, r) {
  if ((!e && !zi(e)) || typeof t != 'string') return null
  var n = typeof e
  if (n === 'string' || n === 'number' || n === 'boolean' || Xe(e)) e = { value: e }
  else if (n === 'object' && !tye.call(e, 'value')) e = { value: r ? JSON.stringify(e) : e }
  else if (we(e[hn]) || e[hn] === Ru || (!gt(e[hn]) && !Gi(e[hn]) && !Zc(e[hn]) && !Xe(e[hn]))) return null
  if (Xe(e[hn]) && !QG(e[hn])) return null
  if (!we(e[$v])) {
    if (Xe(e[hn]) || !eC(e[$v])) return null
    e[hn] = e[hn].toString()
  }
  return e
}
function a4(t, e, r) {
  var n = -1
  if (!vt(t))
    if ((e > 0 && (e === 32 ? (n = 8192) : e <= 13 && (n = e << 5)), yKe(r))) n === -1 && (n = 0), (n |= r)
    else {
      var i = _Ke[Pu(t)] || -1
      n !== -1 && i !== -1 ? (n |= i) : i === 6 && (n = i)
    }
  return n
}
function oye(t, e, r) {
  r === void 0 && (r = !0)
  var n
  return t && ((n = t.get(e)), r && n && decodeURIComponent && (n = decodeURIComponent(n))), n || Ru
}
function sye(t) {
  t === void 0 && (t = 'D')
  var e = HS()
  return t === 'B' ? (e = '{' + e + '}') : t === 'P' ? (e = '(' + e + ')') : t === 'N' && (e = e.replace(/-/g, Ru)), e
}
function Wv(t, e, r, n, i) {
  var o = {},
    s = !1,
    a = 0,
    l = arguments[dd],
    c = arguments
  for (Zc(c[0]) && ((s = c[0]), a++); a < l; a++) {
    var t = c[a]
    ze(t, function (p, d) {
      s && d && Br(d)
        ? Xe(d)
          ? ((o[p] = o[p] || []),
            Ae(d, function (f, m) {
              f && Br(f) ? (o[p][m] = Wv(!0, o[p][m], f)) : (o[p][m] = f)
            }))
          : (o[p] = Wv(!0, o[p], d))
        : (o[p] = d)
    })
  }
  return o
}
function eC(t) {
  return t === 0 || (t > 0 && t <= 13) || t === 32
}
function yKe(t) {
  return t >= 0 && t <= 9
}
function xKe() {
  var t = ui()
  if (!vt(t) && t.userAgent) {
    var e = t.userAgent.toLowerCase()
    if ((e[nx]('safari') >= 0 || e[nx]('firefox') >= 0) && e[nx]('chrome') < 0) return !0
  }
  return !1
}
function QG(t) {
  return t[dd] > 0
}
function tC(t, e) {
  var r = t
  ;(r[Du] = r[Du] || {}), (r[Du][Zk] = r[Du][Zk] || {}), (r[Du][Zk][e] = Gs())
}
function Pu(t) {
  var e = 0
  if (t != null) {
    var r = typeof t
    r === 'string'
      ? (e = 1)
      : r === 'number'
      ? (e = 2)
      : r === 'boolean'
      ? (e = 3)
      : r === zp &&
        ((e = 4), Xe(t) ? ((e = 4096), t[dd] > 0 && (e |= Pu(t[0]))) : tye.call(t, 'value') && (e = 8192 | Pu(t[hn])))
  }
  return e
}
function c4() {
  return !!Kr('chrome')
}
function l4(t, e, r, n, i, o) {
  n === void 0 && (n = !1), i === void 0 && (i = !1)
  function s(l, c, u) {
    try {
      l[c] = u
    } catch {}
  }
  var a = new XMLHttpRequest()
  return n && s(a, gKe, n), r && s(a, eye, r), a.open(t, e, !i), r && s(a, eye, r), !i && o && s(a, vKe, o), a
}
function eh(t) {
  return t > 0
}
var fd,
  YG,
  ix,
  tye,
  gKe,
  eye,
  vKe,
  _Ke,
  KG,
  rye,
  nye,
  Gs,
  u4 = createGetter(() => {
    br()
    Fs()
    pt()
    Jk()
    n4()
    ;(YG = '4.0.4'),
      (ix = '1DS-Web-JS-' + YG),
      (tye = JT.hasOwnProperty),
      (gKe = 'Microsoft_ApplicationInsights_BypassAjaxInstrumentation'),
      (eye = 'withCredentials'),
      (vKe = 'timeout'),
      (_Ke =
        ((fd = {}),
        (fd[0] = 0),
        (fd[2] = 6),
        (fd[1] = 1),
        (fd[3] = 7),
        (fd[4098] = 6),
        (fd[4097] = 1),
        (fd[4099] = 7),
        fd)),
      (KG = null),
      (rye = Am()),
      (nye = Rm())
    Gs = C1
  })
function EKe(t) {
  return t && (!t.getProperty || !t.setProperty) && Cn('Invalid property storage override passed.'), !0
}
var bKe,
  aye,
  cye = createGetter(() => {
    Fs()
    fo()
    br()
    pt()
    Jk()
    u4()
    n4()
    bKe = cs({ endpointUrl: Z_e, propertyStorageOverride: { isVal: EKe } })
    aye = (function (t) {
      Ms(e, t)
      function e() {
        var r = t.call(this) || this
        return (
          Wt(e, r, function (n, i) {
            ;(n[zG] = function (o, s, a, l) {
              qn(
                n,
                function () {
                  return 'AppInsightsCore.initialize'
                },
                function () {
                  try {
                    i[zG](mn(o, bKe, a || n[$G], !1).cfg, s, a, l)
                  } catch (p) {
                    var c = n[$G],
                      u = $e(p)
                    u[nx]('channels') !== -1 &&
                      (u += `
 - Channels must be provided through config.channels only!`),
                      Ue(c, 1, 514, 'SDK Initialization Failed - no telemetry will be sent: ' + u)
                  }
                },
                function () {
                  return { config: o, extensions: s, logger: a, notificationManager: l }
                }
              )
            }),
              (n.track = function (o) {
                qn(
                  n,
                  function () {
                    return 'AppInsightsCore.track'
                  },
                  function () {
                    var s = o
                    if (s) {
                      ;(s[Du] = s[Du] || {}), (s[Du].trackStart = Gs()), o4(s.latency) || (s.latency = 1)
                      var a = (s.ext = s.ext || {})
                      ;(a.sdk = a.sdk || {}), (a.sdk.ver = ix)
                      var l = (s.baseData = s.baseData || {})
                      l[Xk] = l[Xk] || {}
                      var c = l[Xk]
                      c[VG] = c[VG] || n.pluginVersionString || Ru
                    }
                    i.track(s)
                  },
                  function () {
                    return { item: o }
                  },
                  !o.sync
                )
              }),
              (n[WG] = function (o) {
                return i[WG](o || 'InternalLog')
              })
          }),
          r
        )
      }
      return (e.__ieDyn = 1), e
    })(ud)
  })
var lye,
  uye,
  pye,
  dye,
  fye,
  mye = createGetter(() => {
    br()
    ;(lye = Vi({
      NotSet: 0,
      Pii_DistinguishedName: 1,
      Pii_GenericData: 2,
      Pii_IPV4Address: 3,
      Pii_IPv6Address: 4,
      Pii_MailSubject: 5,
      Pii_PhoneNumber: 6,
      Pii_QueryString: 7,
      Pii_SipAddress: 8,
      Pii_SmtpAddress: 9,
      Pii_Identity: 10,
      Pii_Uri: 11,
      Pii_Fqdn: 12,
      Pii_IPV4AddressLegacy: 13,
      CustomerContent_GenericContent: 32,
    })),
      (uye = Vi({ Normal: 1, CostDeferred: 2, RealTime: 3, Immediate: 4 })),
      (pye = Vi({
        Unspecified: 0,
        String: 1,
        Int32: 2,
        UInt32: 3,
        Int64: 4,
        UInt64: 5,
        Double: 6,
        Bool: 7,
        Guid: 8,
        DateTime: 9,
      })),
      (dye = Vi({ Normal: 1, Critical: 2 })),
      (fye = Vi({ NONE: 0, ERROR: 1, WARNING: 2, INFORMATION: 3 }))
  })
var hye,
  gye = createGetter(() => {
    br()
    pt()
    Jk()
    u4()
    n4()
    hye = (function () {
      function t(e) {
        var r = this,
          n = {},
          i = [],
          o = []
        e && o.push(e)
        function s(u, p) {
          var d,
            f = n[u]
          if ((f && (d = f[p]), !d && d !== null)) {
            if (gt(u) && gt(p))
              if (o[dd] > 0) {
                for (var m = 0; m < o[dd]; m++)
                  if (o[m][e4](u, p)) {
                    d = { canHandle: !0, fieldHandler: o[m] }
                    break
                  }
              } else i[dd] === 0 && (d = { canHandle: !0 })
            if (!d && d !== null) {
              d = null
              for (var m = 0; m < i[dd]; m++)
                if (i[m][e4](u, p)) {
                  d = { canHandle: !0, handler: i[m], fieldHandler: null }
                  break
                }
            }
            f || (f = n[u] = {}), (f[p] = d)
          }
          return d
        }
        ;(r.clearCache = function () {
          n = {}
        }),
          (r.addSanitizer = function (u) {
            u && (QN(i, u) || i.push(u), (n = {}))
          }),
          (r.addFieldSanitizer = function (u) {
            u && (QN(o, u) || o.push(u), (n = {}))
          }),
          (r[t4] = function (u) {
            if (u) {
              var p = ir(i, u)
              p !== -1 && (i.splice(p, 1), (n = {})),
                Ae(i, function (d) {
                  d && d[t4] && d[t4](u)
                })
            }
          }),
          (r[r4] = function (u) {
            if (u) {
              var p = ir(o, u)
              p !== -1 && (o.splice(p, 1), (n = {})),
                Ae(i, function (d) {
                  d && d[r4] && d[r4](u)
                })
            }
          }),
          (r.isEmpty = function () {
            return S1(i) + S1(o) === 0
          }),
          (r[e4] = function (u, p) {
            var d = s(u, p)
            return d ? d[ZS] : !1
          }),
          (r[hn] = function (u, p, d, f) {
            var m = s(u, p)
            if (m && m[ZS]) {
              if (!m || !m[ZS]) return null
              if (m.handler) return m.handler[hn](u, p, d, f)
              if (!gt(p) || we(d) || d === Ru) return null
              var h = null,
                g = Pu(d)
              if ((g & 8192) === 8192) {
                var v = g & -8193
                if (((h = d), !zi(h[hn]) || (v !== 1 && v !== 2 && v !== 3 && (v & 4096) !== 4096))) return null
              } else
                g === 1 || g === 2 || g === 3 || (g & 4096) === 4096
                  ? (h = l(u, p, d))
                  : g === 4 && (h = l(u, p, f ? JSON.stringify(d) : d))
              if (h) return a(m, u, p, g, h, f)
            }
            return null
          }),
          (r.property = function (u, p, d, f) {
            var m = s(u, p)
            if (!m || !m[ZS] || !gt(p) || we(d) || !zi(d[hn])) return null
            var h = Pu(d[hn])
            return h === 0 ? null : a(m, u, p, h, d, f)
          })
        function a(u, p, d, f, m, h) {
          if (u.handler) return u.handler.property(p, d, m, h)
          if (!we(m[$v])) {
            if ((f & 4096) === 4096 || !eC(m[$v])) return null
            m[hn] = m[hn].toString()
          }
          return c(u.fieldHandler, p, d, f, m)
        }
        function l(u, p, d) {
          return zi(d) ? { value: d } : null
        }
        function c(u, p, d, f, m) {
          if (m && u) {
            var h = u.getSanitizer(p, d, f, m[$v], m.propertyType)
            if (h)
              if (f === 4) {
                var g = {},
                  v = m[hn]
                ze(v, function (y, b) {
                  var x = p + '.' + d
                  if (zi(b)) {
                    var P = l(x, y, b)
                    ;(P = c(u, x, y, Pu(b), P)), P && (g[y] = P[hn])
                  }
                }),
                  (m[hn] = g)
              } else {
                var _ = { path: p, name: d, type: f, prop: m, sanitizer: r }
                m = h.call(r, _)
              }
          }
          return m
        }
      }
      return (t.getFieldType = Pu), t
    })()
  })
var vye = {}
defineProperties(vye, {
  AppInsightsCore: () => aye,
  BaseTelemetryPlugin: () => ld,
  DiagnosticLogger: () => Km,
  EventLatency: () => uye,
  EventPersistence: () => dye,
  EventPropertyType: () => pye,
  EventsDiscardedReason: () => nl,
  FullVersionString: () => ix,
  InternalAppInsightsCore: () => ud,
  LoggingSeverity: () => GG,
  MinChannelPriorty: () => Rj,
  NotificationManager: () => US,
  PerfEvent: () => jv,
  PerfManager: () => qS,
  ProcessTelemetryContext: () => OG,
  TraceLevel: () => fye,
  Undefined: () => du,
  ValueKind: () => lye,
  ValueSanitizer: () => hye,
  Version: () => YG,
  _InternalLogMessage: () => qv,
  __getRegisteredEvents: () => qG,
  _logInternalMessage: () => mG,
  _throwInternal: () => Ue,
  _warnToConsole: () => Ia,
  addEventHandler: () => Kk,
  addEventListeners: () => Qk,
  addPageHideEventListener: () => tx,
  addPageShowEventListener: () => rx,
  addPageUnloadEventListener: () => YS,
  areCookiesSupported: () => Q1,
  arrForEach: () => Ae,
  arrIndexOf: () => ir,
  arrMap: () => hu,
  arrReduce: () => T1,
  attachEvent: () => HG,
  blockDynamicConversion: () => PS,
  cookieAvailable: () => Q1,
  createCookieMgr: () => sd,
  createDynamicConfig: () => mn,
  createEnumStyle: () => Vi,
  createGuid: () => sye,
  createProcessTelemetryContext: () => ms,
  createTraceParent: () => jS,
  createUniqueNamespace: () => ho,
  createUnloadHandlerContainer: () => zv,
  dateNow: () => wn,
  detachEvent: () => jG,
  disallowsSameSiteNone: () => Fk,
  doPerf: () => qn,
  dumpObj: () => $e,
  eventOff: () => pd,
  eventOn: () => Au,
  extend: () => Wv,
  findW3cTraceParent: () => zS,
  forceDynamicConversion: () => oG,
  formatTraceParent: () => VS,
  generateW3CId: () => Gv,
  getCommonSchemaMetaData: () => a4,
  getConsole: () => bS,
  getCookieValue: () => oye,
  getCrypto: () => ES,
  getDocument: () => In,
  getDynamicConfigHandler: () => DS,
  getExceptionName: () => Qr,
  getFieldValueType: () => Pu,
  getGlobal: () => Oo,
  getGlobalInst: () => Kr,
  getHistory: () => nS,
  getIEVersion: () => SS,
  getISOString: () => Ta,
  getJSON: () => mo,
  getLocation: () => Uv,
  getMsCrypto: () => TS,
  getNavigator: () => ui,
  getPerformance: () => Qp,
  getSetValue: () => xS,
  getTenantId: () => i4,
  getTime: () => Gs,
  getWindow: () => Bn,
  hasDocument: () => Am,
  hasHistory: () => VN,
  hasJSON: () => Tu,
  hasNavigator: () => E1,
  hasOwnProperty: () => Wn,
  hasWindow: () => Rm,
  isArray: () => Xe,
  isArrayValid: () => QG,
  isBeaconsSupported: () => Ca,
  isBoolean: () => Zc,
  isChromium: () => c4,
  isDate: () => h1,
  isDocumentObjectAvailable: () => rye,
  isError: () => fu,
  isFetchSupported: () => rd,
  isFunction: () => mt,
  isGreaterThanZero: () => eh,
  isIE: () => Vm,
  isLatency: () => o4,
  isNotTruthy: () => wN,
  isNullOrUndefined: () => we,
  isNumber: () => Gi,
  isObject: () => Br,
  isReactNative: () => Gm,
  isSampledFlag: () => GS,
  isString: () => gt,
  isTruthy: () => el,
  isTypeof: () => CN,
  isUint8ArrayAvailable: () => iye,
  isUndefined: () => vt,
  isValidSpanId: () => wu,
  isValidTraceId: () => Iu,
  isValidTraceParent: () => J1,
  isValueAssigned: () => zi,
  isValueKind: () => eC,
  isWindowObjectAvailable: () => nye,
  isXhrSupported: () => zm,
  mergeEvtNamespace: () => wa,
  newGuid: () => HS,
  newId: () => AS,
  normalizeJsName: () => Fv,
  objDefineAccessors: () => BN,
  objForEachKey: () => ze,
  objFreeze: () => mu,
  objKeys: () => Si,
  objSeal: () => PN,
  onConfigChange: () => di,
  openXhr: () => l4,
  optimizeObject: () => fc,
  parseTraceParent: () => Vv,
  perfNow: () => C1,
  proxyAssign: () => $j,
  proxyFunctionAs: () => ed,
  proxyFunctions: () => Sa,
  random32: () => nd,
  randomValue: () => wS,
  removeEventHandler: () => Yk,
  removeEventListeners: () => Zm,
  removePageHideEventListener: () => XS,
  removePageShowEventListener: () => JS,
  removePageUnloadEventListener: () => QS,
  safeGetCookieMgr: () => bG,
  safeGetLogger: () => cl,
  sanitizeProperty: () => s4,
  setEnableEnvMocks: () => Zj,
  setProcessTelemetryTimings: () => tC,
  setValue: () => dc,
  strContains: () => Kn,
  strEndsWith: () => Dm,
  strFunction: () => u1,
  strObject: () => zp,
  strPrototype: () => Xc,
  strStartsWith: () => Sv,
  strTrim: () => pr,
  strUndefined: () => du,
  throwError: () => Cn,
  toISOString: () => Ta,
  useXDomainRequest: () => Bv,
})
var Kv = createGetter(() => {
  cye()
  mye()
  gye()
  br()
  u4()
})
var Yv,
  p4,
  d4,
  XG = createGetter(() => {
    ;(Yv = 'REAL_TIME'), (p4 = 'NEAR_REAL_TIME'), (d4 = 'BEST_EFFORT')
  })
var ll,
  f4,
  _ye,
  m4,
  yye,
  JG,
  xye,
  bye,
  Eye,
  ZG,
  eV,
  h4,
  Tye,
  tV,
  Sye,
  rV,
  g4,
  nV,
  v4,
  _4,
  y4,
  rC,
  iV,
  Cye,
  ox,
  oV,
  x4,
  nC = createGetter(() => {
    ;(ll = ''),
      (f4 = 'POST'),
      (_ye = 'Microsoft_ApplicationInsights_BypassAjaxInstrumentation'),
      (m4 = 'drop'),
      (yye = 'send'),
      (JG = 'requeue'),
      (xye = 'rspFail'),
      (bye = 'oth'),
      (Eye = 'no-cache, no-store'),
      (ZG = 'application/x-json-stream'),
      (eV = 'cache-control'),
      (h4 = 'content-type'),
      (Tye = 'kill-tokens'),
      (tV = 'kill-duration'),
      (Sye = 'kill-duration-seconds'),
      (rV = 'time-delta-millis'),
      (g4 = 'client-version'),
      (nV = 'client-id'),
      (v4 = 'time-delta-to-apply-millis'),
      (_4 = 'upload-time'),
      (y4 = 'apikey'),
      (rC = 'AuthMsaDeviceTicket'),
      (iV = 'AuthXToken'),
      (Cye = 'NoResponseBody'),
      (ox = 'msfpc'),
      (oV = 'trace'),
      (x4 = 'user')
  })
var iC,
  b4,
  E4,
  T4,
  oC,
  Nt,
  mc,
  hc,
  Yn,
  Nu,
  $i,
  ul,
  Qv,
  sx,
  ax,
  S4,
  cx,
  C4,
  I4,
  Iye,
  sV,
  aV,
  wye,
  Aye,
  w4,
  A4,
  cV,
  lV,
  uV,
  Rye,
  lx,
  th,
  pV,
  pl,
  sC,
  ku,
  dV,
  fV,
  ux,
  Mo,
  Vs,
  aC,
  px,
  R4,
  cC,
  Dye,
  D4,
  P4,
  dx,
  mV,
  lC,
  N4,
  k4,
  O4,
  L4,
  M4,
  uC,
  Pye,
  Nye,
  hV,
  gV,
  kye,
  Oye,
  Lye,
  pC,
  rh,
  F4,
  Xv,
  fx = createGetter(() => {
    ;(iC = 'allowRequestSending'),
      (b4 = 'firstRequestSent'),
      (E4 = 'shouldAddClockSkewHeaders'),
      (T4 = 'getClockSkewHeaderValue'),
      (oC = 'setClockSkew'),
      (Nt = 'length'),
      (mc = 'concat'),
      (hc = 'iKey'),
      (Yn = 'count'),
      (Nu = 'events'),
      ($i = 'push'),
      (ul = 'split'),
      (Qv = 'splice'),
      (sx = 'toLowerCase'),
      (ax = 'hdrs'),
      (S4 = 'useHdrs'),
      (cx = 'initialize'),
      (C4 = 'setTimeoutOverride'),
      (I4 = 'clearTimeoutOverride'),
      (Iye = 'payloadPreprocessor'),
      (sV = 'overrideEndpointUrl'),
      (aV = 'avoidOptions'),
      (wye = 'disableEventTimings'),
      (Aye = 'stringifyObjects'),
      (w4 = 'enableCompoundKey'),
      (A4 = 'disableXhrSync'),
      (cV = 'disableFetchKeepAlive'),
      (lV = 'useSendBeacon'),
      (uV = 'alwaysUseXhrOverride'),
      (Rye = 'unloadTransports'),
      (lx = 'urlString'),
      (th = 'timeout'),
      (pV = 'ontimeout'),
      (pl = 'data'),
      (sC = '_sendReason'),
      (ku = 'headers'),
      (dV = 'getResponseHeader'),
      (fV = 'getAllResponseHeaders'),
      (ux = '_thePayload'),
      (Mo = 'batches'),
      (Vs = 'sendType'),
      (aC = 'canSendRequest'),
      (px = 'sendQueuedRequests'),
      (R4 = 'isCompletelyIdle'),
      (cC = 'setUnloading'),
      (Dye = 'isTenantKilled'),
      (D4 = 'sendSynchronousBatch'),
      (P4 = '_transport'),
      (dx = 'getWParam'),
      (mV = 'isBeacon'),
      (lC = 'timings'),
      (N4 = 'isTeardown'),
      (k4 = 'isSync'),
      (O4 = 'sendPOST'),
      (L4 = 'setKillSwitchTenants'),
      (M4 = '_backOffTransmission'),
      (uC = 'identifier'),
      (Pye = 'disableOptimizeObj'),
      (Nye = 'ignoreMc1Ms0CookieProcessing'),
      (hV = 'eventsLimitInMem'),
      (gV = 'autoFlushEventsLimit'),
      (kye = 'disableAutoBatchFlushLimit'),
      (Oye = 'overrideInstrumentationKey'),
      (Lye = 'disableTelemetry'),
      (pC = 'sendAttempt'),
      (rh = 'latency'),
      (F4 = 'baseData'),
      (Xv = 'sync')
  })
function Fye(t) {
  var e = (t.ext || {}).intweb
  return e && zi(e[ox]) ? e[ox] : null
}
function Mye(t) {
  for (var e = null, r = 0; e === null && r < t[Nt]; r++) e = Fye(t[r])
  return e
}
var mx,
  vV = createGetter(() => {
    Kv()
    nC()
    fx()
    mx = (function () {
      function t(e, r) {
        var n = r ? [][mc](r) : [],
          i = this,
          o = Mye(n)
        ;(i[hc] = function () {
          return e
        }),
          (i.Msfpc = function () {
            return o || ll
          }),
          (i[Yn] = function () {
            return n[Nt]
          }),
          (i[Nu] = function () {
            return n
          }),
          (i.addEvent = function (s) {
            return s ? (n[$i](s), o || (o = Fye(s)), !0) : !1
          }),
          (i[ul] = function (s, a) {
            var l
            if (s < n[Nt]) {
              var c = n[Nt] - s
              we(a) || (c = a < c ? a : c), (l = n[Qv](s, c)), (o = Mye(n))
            }
            return new t(e, l)
          })
      }
      return (
        (t.create = function (e, r) {
          return new t(e, r)
        }),
        t
      )
    })()
  })
var _V,
  Uye = createGetter(() => {
    fo()
    fx()
    _V = (function () {
      function t() {
        var e = !0,
          r = !0,
          n = !0,
          i = 'use-collector-delta',
          o = !1
        Wt(t, this, function (s) {
          ;(s[iC] = function () {
            return e
          }),
            (s[b4] = function () {
              n && ((n = !1), o || (e = !1))
            }),
            (s[E4] = function () {
              return r
            }),
            (s[T4] = function () {
              return i
            }),
            (s[oC] = function (a) {
              o || (a ? ((i = a), (r = !0), (o = !0)) : (r = !1), (e = !0))
            })
        })
      }
      return (t.__ieDyn = 1), t
    })()
  })
var TKe,
  yV,
  Bye = createGetter(() => {
    fo()
    Kv()
    fx()
    ;(TKe = 1e3),
      (yV = (function () {
        function t() {
          var e = {}
          function r(n) {
            var i = []
            return (
              n &&
                Ae(n, function (o) {
                  i[$i](pr(o))
                }),
              i
            )
          }
          Wt(t, this, function (n) {
            ;(n[L4] = function (i, o) {
              if (i && o)
                try {
                  var s = r(i[ul](','))
                  if (o === 'this-request-only') return s
                  for (var a = parseInt(o, 10) * TKe, l = 0; l < s[Nt]; ++l) e[s[l]] = wn() + a
                } catch {
                  return []
                }
              return []
            }),
              (n[Dye] = function (i) {
                var o = e,
                  s = pr(i)
                return o[s] !== void 0 && o[s] > wn() ? !0 : (delete o[s], !1)
              })
          })
        }
        return (t.__ieDyn = 1), t
      })())
  })
function Hye(t) {
  return !((t >= 300 && t < 500 && t != 408 && t != 429) || t == 501 || t == 505)
}
function U4(t) {
  var e = 0,
    r = qye * SKe,
    n = qye * CKe,
    i = Math.floor(Math.random() * (n - r)) + r
  return (e = Math.pow(2, t) * i), Math.min(e, IKe)
}
var SKe,
  CKe,
  qye,
  IKe,
  xV = createGetter(() => {
    ;(SKe = 0.8), (CKe = 1.2), (qye = 3e3), (IKe = 6e5)
  })
function Gye(t, e, r, n) {
  if (n && t) {
    var i = a4(n.value, n.kind, n.propertyType)
    if (i > -1) {
      var o = t[jye]
      o || (o = t[jye] = { f: {} })
      var s = o[B4]
      if ((s || (s = o[B4] = {}), e))
        for (var a = 0; a < e.length; a++) {
          var l = e[a]
          s[l] || (s[l] = { f: {} })
          var c = s[l][B4]
          c || (c = s[l][B4] = {}), (s = c)
        }
      ;(s = s[r] = {}), Xe(n.value) ? (s.a = { t: i }) : (s.t = i)
    }
  }
}
var wKe,
  AKe,
  Vye,
  zye,
  RKe,
  jye,
  B4,
  DKe,
  $ye,
  Wye = createGetter(() => {
    fo()
    Kv()
    vV()
    nC()
    pt()
    ;(wKe = 20),
      (AKe = 3984588),
      (Vye = 65e3),
      (zye = 2e6),
      (RKe = Math.min(zye, Vye)),
      (jye = 'metadata'),
      (B4 = 'f'),
      (DKe = /\./),
      ($ye = (function () {
        function t(e, r, n, i) {
          var o = 'data',
            s = 'baseData',
            a = 'ext',
            l = !!i,
            c = !0,
            u = r,
            p = {}
          Wt(t, this, function (d) {
            ;(d.createPayload = function (h, g, v, _, y, b) {
              return {
                apiKeys: [],
                payloadBlob: ll,
                overflow: null,
                sizeExceed: [],
                failedEvts: [],
                batches: [],
                numEvents: 0,
                retryCnt: h,
                isTeardown: g,
                isSync: v,
                isBeacon: _,
                sendType: b,
                sendReason: y,
              }
            }),
              (d.appendPayload = function (h, g, v) {
                var _ = h && g && !h.overflow
                return (
                  _ &&
                    qn(
                      e,
                      function () {
                        return 'Serializer:appendPayload'
                      },
                      function () {
                        for (
                          var y = g.events(),
                            b = h.payloadBlob,
                            x = h.numEvents,
                            P = !1,
                            U = [],
                            H = [],
                            j = h.isBeacon,
                            M = j ? Vye : AKe,
                            F = j ? RKe : zye,
                            z = 0,
                            q = 0;
                          z < y.length;

                        ) {
                          var L = y[z]
                          if (L) {
                            if (x >= v) {
                              h.overflow = g.split(z)
                              break
                            }
                            var S = d.getEventBlob(L)
                            if (S && S.length <= F) {
                              var T = S.length,
                                A = b.length
                              if (A + T > M) {
                                h.overflow = g.split(z)
                                break
                              }
                              b &&
                                (b += `
`),
                                (b += S),
                                q++,
                                q > wKe && (tl(b, 0, 1), (q = 0)),
                                (P = !0),
                                x++
                            } else S ? U.push(L) : H.push(L), y.splice(z, 1), z--
                          }
                          z++
                        }
                        if (
                          (U.length > 0 && h.sizeExceed.push(mx.create(g.iKey(), U)),
                          H.length > 0 && h.failedEvts.push(mx.create(g.iKey(), H)),
                          P)
                        ) {
                          h.batches.push(g), (h.payloadBlob = b), (h.numEvents = x)
                          var X = g.iKey()
                          ir(h.apiKeys, X) === -1 && h.apiKeys.push(X)
                        }
                      },
                      function () {
                        return { payload: h, theBatch: { iKey: g.iKey(), evts: g.events() }, max: v }
                      }
                    ),
                  _
                )
              }),
              (d.getEventBlob = function (h) {
                try {
                  return qn(
                    e,
                    function () {
                      return 'Serializer.getEventBlob'
                    },
                    function () {
                      var g = {}
                      ;(g.name = h.name), (g.time = h.time), (g.ver = h.ver), (g.iKey = 'o:' + i4(h.iKey))
                      var v = {},
                        _ = h[a]
                      _ &&
                        ((g[a] = v),
                        ze(_, function (x, P) {
                          var U = (v[x] = {})
                          m(P, U, 'ext.' + x, !0, null, null, !0)
                        }))
                      var y = (g[o] = {})
                      y.baseType = h.baseType
                      var b = (y[s] = {})
                      return (
                        m(
                          h.baseData,
                          b,
                          s,
                          !1,
                          [s],
                          function (x, P, U) {
                            Gye(v, x, P, U)
                          },
                          c
                        ),
                        m(
                          h.data,
                          y,
                          o,
                          !1,
                          [],
                          function (x, P, U) {
                            Gye(v, x, P, U)
                          },
                          c
                        ),
                        JSON.stringify(g)
                      )
                    },
                    function () {
                      return { item: h }
                    }
                  )
                } catch {
                  return null
                }
              })
            function f(h, g) {
              var v = p[h]
              return v === void 0 && (h.length >= 7 && (v = Sv(h, 'ext.metadata') || Sv(h, 'ext.web')), (p[h] = v)), v
            }
            function m(h, g, v, _, y, b, x) {
              ze(h, function (P, U) {
                var H = null
                if (U || zi(U)) {
                  var j = v,
                    M = P,
                    F = y,
                    z = g
                  if (l && !_ && DKe.test(P)) {
                    var q = P.split('.'),
                      L = q.length
                    if (L > 1) {
                      F && (F = F.slice())
                      for (var S = 0; S < L - 1; S++) {
                        var T = q[S]
                        ;(z = z[T] = z[T] || {}), (j += '.' + T), F && F.push(T)
                      }
                      M = q[L - 1]
                    }
                  }
                  var A = _ && f(j, M)
                  if ((!A && u && u.handleField(j, M) ? (H = u.value(j, M, U, n)) : (H = s4(M, U, n)), H)) {
                    var X = H.value
                    if (((z[M] = X), b && b(F, M, H), x && typeof X == 'object' && !Xe(X))) {
                      var fe = F
                      fe && ((fe = fe.slice()), fe.push(M)), m(U, X, j + '.' + M, _, fe, b, x)
                    }
                  }
                }
              })
            }
          })
        }
        return (t.__ieDyn = 1), t
      })())
  })
function hx(t, e) {
  return {
    set: function (r, n) {
      for (var i = [], o = 2; o < arguments.length; o++) i[o - 2] = arguments[o]
      return gj([t, e], r, n, i)
    },
  }
}
var bV = createGetter(() => {
  pt()
})
function Zv(t, e, r) {
  ;(TV[t] = e), r !== !1 && (SV[e] = t)
}
function Yye(t) {
  try {
    return t.responseText
  } catch {}
  return ll
}
function Qye(t, e) {
  var r = !1
  if (t && e) {
    var n = Si(t)
    if (n && n[Nt] > 0)
      for (var i = e[sx](), o = 0; o < n[Nt]; o++) {
        var s = n[o]
        if (s && Wn(e, s) && s[sx]() === i) {
          r = !0
          break
        }
      }
  }
  return r
}
function gx(t, e, r, n) {
  e && r && r[Nt] > 0 && (n && TV[e] ? ((t[ax][TV[e]] = r), (t[S4] = !0)) : (t.url += '&' + e + '=' + r))
}
function Xye(t, e) {
  return e && (Gi(e) ? (t = [e][mc](t)) : Xe(e) && (t = e[mc](t))), t
}
function kKe(t, e, r) {
  for (var n = 0; n < t[Nt]; n++)
    if (t[n].name === e) {
      t[n].value = r
      return
    }
  t[$i]({ name: e, value: r })
}
function OKe(t, e) {
  for (var r = 0; r < t[Nt]; r++)
    if (t[r].name === e) {
      t[Qv](r, 1)
      return
    }
}
var Jv,
  EV,
  Kye,
  PKe,
  NKe,
  TV,
  SV,
  Jye,
  Zye = createGetter(() => {
    fo()
    Kv()
    pt()
    Uye()
    nC()
    Bye()
    xV()
    Wye()
    bV()
    fx()
    ;(EV = 'sendAttempt'),
      (Kye = '&' + Cye + '=true'),
      (PKe = '?cors=true&' + h4[sx]() + '=' + ZG),
      (NKe = ((Jv = {}), (Jv[1] = JG), (Jv[100] = JG), (Jv[200] = 'sent'), (Jv[8004] = m4), (Jv[8003] = m4), Jv)),
      (TV = {}),
      (SV = {})
    Zv(rC, rC, !1)
    Zv(g4, g4)
    Zv(nV, 'Client-Id')
    Zv(y4, y4)
    Zv(v4, v4)
    Zv(_4, _4)
    Zv(iV, iV)
    Jye = (function () {
      function t(e, r, n, i) {
        var o,
          s = new yV(),
          a = !1,
          l = new _V(),
          c = !1,
          u = 0,
          p,
          d,
          f,
          m,
          h = !0,
          g = [],
          v = {},
          _ = [],
          y = null,
          b = !1,
          x,
          P = !1,
          U = !1,
          H,
          j,
          M,
          F,
          z,
          q = [],
          L,
          S,
          T = [],
          A,
          X
        Wt(t, this, function (fe) {
          je()
          var ce = !0
          ;(fe[cx] = function (E, B, Y) {
            A ||
              ((m = B),
              (x = B.getCookieMgr()),
              (p = Y),
              (d = p.diagLog()),
              lc(
                q,
                di(E, function (Q) {
                  var me,
                    ge = Q.cfg,
                    se = Q.cfg.extensionConfig[Y.identifier]
                  ;(X = hx(se[C4], se[I4])),
                    zi(ge.anonCookieName) ? kKe(g, 'anoncknm', ge.anonCookieName) : OKe(g, 'anoncknm'),
                    (L = se[Iye]),
                    (S = se.payloadListener)
                  var V = se.httpXHROverride,
                    ie = se[sV] ? se[sV] : ge.endpointUrl
                  ;(o = ie + PKe), (U = vt(se[aV]) ? !0 : !se[aV]), (b = !se[wye])
                  var re = se.valueSanitizer,
                    xe = se[Aye],
                    Ie = !!ge[w4]
                  vt(se[w4]) || (Ie = !!se[w4]),
                    (H = se.xhrTimeout),
                    (j = !!se[A4]),
                    (M = !!se[cV]),
                    (z = se.addNoResponse !== !1),
                    B.getPlugin('LocalStorage') && (M = !0),
                    (c = !Gm()),
                    (y = new $ye(m, re, xe, Ie)),
                    we(se[lV]) || (c = !!se[lV])
                  var We = V,
                    ft = se[uV] ? V : null,
                    Et = se[uV] ? V : null,
                    It = [3, 2]
                  if (!V) {
                    h = !1
                    var Hn = Uv()
                    Hn && Hn.protocol && Hn.protocol[sx]() === 'file:' && (ce = !1)
                    var Zt = []
                    Gm() ? ((Zt = [2, 1]), (It = [2, 1, 3])) : (Zt = [1, 2, 3]),
                      (Zt = Xye(Zt, se.transports)),
                      (V = oe(Zt, !1)),
                      V || Ia(d, 'No available transport to send events'),
                      (We = oe(Zt, !0))
                  }
                  ft || ((It = Xye(It, se[Rye])), (ft = oe(It, !0))),
                    (F = !h && ((c && Ca()) || (!M && rd(!0)))),
                    (f =
                      ((me = {}),
                      (me[0] = V),
                      (me[1] = We || oe([1, 2, 3], !0)),
                      (me[2] = ft || We || oe([1], !0)),
                      (me[3] = Et || oe([2, 3], !0) || We || oe([1], !0)),
                      me))
                })
              ),
              (A = !0))
          }),
            (fe.addResponseHandler = function (E) {
              return (
                T[$i](E),
                {
                  rm: function () {
                    var B = T.indexOf(E)
                    B >= 0 && T[Qv](B, 1)
                  },
                }
              )
            })
          function oe(E, B) {
            for (var Y = 0, Q = null, me = 0; Q == null && me < E[Nt]; )
              (Y = E[me]),
                Y === 1
                  ? Bv()
                    ? (Q = ae)
                    : zm() && (Q = Ze)
                  : Y === 2 && rd(B) && (!B || (B && !M))
                  ? (Q = Ye)
                  : c && Y === 3 && Ca() && (Q = st),
                me++
            return Q ? { _transport: Y, _isSync: B, sendPOST: Q } : null
          }
          fe._getDbgPlgTargets = function () {
            return [f[0], s, y, f]
          }
          function ae(E, B, Y) {
            var Q = new XDomainRequest()
            Q.open(f4, E[lx]),
              E[th] && (Q[th] = E[th]),
              (Q.onload = function () {
                var me = Yye(Q)
                ke(B, 200, {}, me), G(me)
              }),
              (Q.onerror = function () {
                ke(B, 400, {})
              }),
              (Q[pV] = function () {
                ke(B, 500, {})
              }),
              (Q.onprogress = function () {}),
              Y
                ? Q.send(E[pl])
                : X.set(function () {
                    Q.send(E[pl])
                  }, 0)
          }
          function je() {
            var E
            ;(o = null),
              (s = new yV()),
              (a = !1),
              (l = new _V()),
              (c = !1),
              (u = 0),
              (p = null),
              (d = null),
              (f = null),
              (m = null),
              (h = !0),
              (g = []),
              (v = {}),
              (_ = []),
              (y = null),
              (b = !1),
              (x = null),
              (P = !1),
              (U = !1),
              (H = E),
              (j = E),
              (M = E),
              (F = E),
              (z = E),
              (q = []),
              (L = E),
              (S = E),
              (T = []),
              (A = !1),
              (X = hx())
          }
          function Ye(E, B, Y) {
            var Q,
              me = E[lx],
              ge = !1,
              se = !1,
              V = ((Q = { body: E[pl], method: f4 }), (Q[_ye] = !0), Q)
            Y && ((V.keepalive = !0), E[sC] === 2 && ((ge = !0), z && (me += Kye))),
              ce && (V.credentials = 'include'),
              E.headers && Si(E.headers)[Nt] > 0 && (V[ku] = E[ku])
            var ie = function (xe, Ie, We) {
                se || ((se = !0), ke(B, xe, Ie, We), G(We))
              },
              re = function () {
                se || ((se = !0), ke(B, 0, {}))
              }
            fetch(me, V)
              .then(function (xe) {
                var Ie = {},
                  We = ll,
                  ft = xe[ku]
                ft &&
                  ft.forEach(function (Et, It) {
                    Ie[It] = Et
                  }),
                  xe.body
                    ? xe.text().then(function (Et) {
                        ;(We = Et), ie(xe.status, Ie, We)
                      }, re)
                    : ie(xe.status, Ie, '')
              })
              .catch(re),
              ge && !se && ((se = !0), ke(B, 200, {})),
              !se &&
                E[th] > 0 &&
                X.set(function () {
                  se || ((se = !0), ke(B, 500, {}))
                }, E[th])
          }
          function Ze(E, B, Y) {
            var Q = E[lx]
            function me(ie, re, xe) {
              if (!ie[xe] && re && re[dV]) {
                var Ie = re[dV](xe)
                Ie && (ie[xe] = pr(Ie))
              }
              return ie
            }
            function ge(ie) {
              var re = {}
              return (
                ie[fV] ? (re = O(ie[fV]())) : ((re = me(re, ie, rV)), (re = me(re, ie, tV)), (re = me(re, ie, Sye))), re
              )
            }
            function se(ie, re) {
              ke(B, ie.status, ge(ie), re)
            }
            Y && E[A4] && (Y = !1)
            var V = l4(f4, Q, ce, !0, Y, E[th])
            ze(E[ku], function (ie, re) {
              V.setRequestHeader(ie, re)
            }),
              (V.onload = function () {
                var ie = Yye(V)
                se(V, ie), G(ie)
              }),
              (V.onerror = function () {
                se(V)
              }),
              (V[pV] = function () {
                se(V)
              }),
              V.send(E[pl])
          }
          function ke(E, B, Y, Q) {
            try {
              E(B, Y, Q)
            } catch (me) {
              Ue(d, 2, 518, $e(me))
            }
          }
          function st(E, B, Y) {
            var Q = E,
              me = 200,
              ge = Q[ux],
              se = E[lx] + (z ? Kye : ll)
            try {
              var V = ui()
              if (!V.sendBeacon(se, E[pl]))
                if (ge) {
                  var ie = !!m.getPlugin('LocalStorage'),
                    re = [],
                    xe = []
                  Ae(ge[Mo], function (Ie) {
                    if (re && Ie && Ie[Yn]() > 0)
                      for (var We = Ie[Nu](), ft = 0; ft < We[Nt]; ft++)
                        if (V.sendBeacon(se, y.getEventBlob(We[ft]))) xe[$i](Ie[ft])
                        else {
                          re[$i](Ie[ul](ft))
                          break
                        }
                    else re[$i](Ie[ul](0))
                  }),
                    xe[Nt] > 0 && (ge.sentEvts = xe),
                    ie || pe(re, 8003, ge[Vs], !0)
                } else me = 0
            } catch (Ie) {
              Ia(d, 'Failed to send telemetry using sendBeacon API. Ex:' + $e(Ie)), (me = 0)
            } finally {
              ke(B, me, {}, ll)
            }
          }
          function tt(E) {
            return E === 2 || E === 3
          }
          function ve(E) {
            return P && tt(E) && (E = 2), E
          }
          ;(fe.addHeader = function (E, B) {
            v[E] = B
          }),
            (fe[aC] = function () {
              return W() && l[iC]()
            }),
            (fe[px] = function (E, B) {
              vt(E) && (E = 0), P && ((E = ve(E)), (B = 2)), ye(_, E, 0) && Ne(ne(), 0, !1, E, B || 0)
            }),
            (fe[R4] = function () {
              return !a && u === 0 && _[Nt] === 0
            }),
            (fe[cC] = function (E) {
              P = E
            }),
            (fe.addBatch = function (E) {
              if (E && E[Yn]() > 0) {
                if (s.isTenantKilled(E[hc]())) return !1
                _[$i](E)
              }
              return !0
            }),
            (fe.teardown = function () {
              _[Nt] > 0 && Ne(ne(), 0, !0, 2, 2),
                Ae(q, function (E) {
                  E && E.rm && E.rm()
                }),
                (q = [])
            }),
            (fe.pause = function () {
              a = !0
            }),
            (fe.resume = function () {
              ;(a = !1), fe[px](0, 4)
            }),
            (fe[D4] = function (E, B, Y) {
              E && E[Yn]() > 0 && (we(B) && (B = 1), P && ((B = ve(B)), (Y = 2)), Ne([E], 0, !1, B, Y || 0))
            })
          function W() {
            return !a && u < r
          }
          function ne() {
            var E = _
            return (_ = []), E
          }
          function ye(E, B, Y) {
            var Q = !1
            return E && E[Nt] > 0 && !a && f[B] && y && (Q = B !== 0 || (W() && (Y > 0 || l[iC]()))), Q
          }
          function Te(E) {
            var B = {}
            return (
              E &&
                Ae(E, function (Y, Q) {
                  B[Q] = { iKey: Y[hc](), evts: Y[Nu]() }
                }),
              B
            )
          }
          function Ne(E, B, Y, Q, me) {
            if (!(!E || E[Nt] === 0)) {
              if (a) {
                pe(E, 1, Q)
                return
              }
              Q = ve(Q)
              try {
                var ge = E,
                  se = Q !== 0
                qn(
                  m,
                  function () {
                    return 'HttpManager:_sendBatches'
                  },
                  function (V) {
                    V && (E = E.slice(0))
                    for (
                      var ie = [],
                        re = null,
                        xe = Gs(),
                        Ie = f[Q] || (se ? f[1] : f[0]),
                        We = Ie && Ie[P4],
                        ft = F && (P || tt(Q) || We === 3 || (Ie._isSync && We === 2));
                      ye(E, Q, B);

                    ) {
                      var Et = E.shift()
                      Et &&
                        Et[Yn]() > 0 &&
                        (s.isTenantKilled(Et[hc]())
                          ? ie[$i](Et)
                          : ((re = re || y.createPayload(B, Y, se, ft, me, Q)),
                            y.appendPayload(re, Et, e)
                              ? re.overflow !== null &&
                                ((E = [re.overflow][mc](E)),
                                (re.overflow = null),
                                Jt(re, xe, Gs(), me),
                                (xe = Gs()),
                                (re = null))
                              : (Jt(re, xe, Gs(), me), (xe = Gs()), (E = [Et][mc](E)), (re = null))))
                    }
                    re && Jt(re, xe, Gs(), me), E[Nt] > 0 && (_ = E[mc](_)), pe(ie, 8004, Q)
                  },
                  function () {
                    return {
                      batches: Te(ge),
                      retryCount: B,
                      isTeardown: Y,
                      isSynchronous: se,
                      sendReason: me,
                      useSendBeacon: tt(Q),
                      sendType: Q,
                    }
                  },
                  !se
                )
              } catch (V) {
                Ue(d, 2, 48, 'Unexpected Exception sending batch: ' + $e(V))
              }
            }
          }
          function qe(E, B) {
            var Y = { url: o, hdrs: {}, useHdrs: !1 }
            B
              ? ((Y[ax] = Wv(Y[ax], v)), (Y.useHdrs = Si(Y.hdrs)[Nt] > 0))
              : ze(v, function (V, ie) {
                  SV[V] ? gx(Y, SV[V], ie, !1) : ((Y[ax][V] = ie), (Y[S4] = !0))
                }),
              gx(Y, nV, 'NO_AUTH', B),
              gx(Y, g4, ix, B)
            var Q = ll
            Ae(E.apiKeys, function (V) {
              Q[Nt] > 0 && (Q += ','), (Q += V)
            }),
              gx(Y, y4, Q, B),
              gx(Y, _4, wn().toString(), B)
            var me = K(E)
            if ((zi(me) && (Y.url += '&ext.intweb.msfpc=' + me), l[E4]() && gx(Y, v4, l[T4](), B), m[dx])) {
              var ge = m[dx]()
              ge >= 0 && (Y.url += '&w=' + ge)
            }
            for (var se = 0; se < g[Nt]; se++) Y.url += '&' + g[se].name + '=' + g[se].value
            return Y
          }
          function bt(E, B, Y) {
            ;(E[B] = E[B] || {}), (E[B][p.identifier] = Y)
          }
          function Jt(E, B, Y, Q) {
            if (E && E.payloadBlob && E.payloadBlob[Nt] > 0) {
              var me = !!L,
                ge = f[E.sendType]
              !tt(E[Vs]) && E[mV] && E.sendReason === 2 && (ge = f[2] || f[3] || ge)
              var se = U
              ;(E.isBeacon || ge[P4] === 3) && (se = !1)
              var V = qe(E, se)
              se = se || V[S4]
              var ie = Gs()
              qn(
                m,
                function () {
                  return 'HttpManager:_doPayloadSend'
                },
                function () {
                  for (var re = 0; re < E.batches[Nt]; re++)
                    for (var xe = E[Mo][re], Ie = xe[Nu](), We = 0; We < Ie[Nt]; We++) {
                      var ft = Ie[We]
                      if (b) {
                        var Et = (ft[lC] = ft[lC] || {})
                        bt(Et, 'sendEventStart', ie),
                          bt(Et, 'serializationStart', B),
                          bt(Et, 'serializationCompleted', Y)
                      }
                      ft[EV] > 0 ? ft[EV]++ : (ft[EV] = 1)
                    }
                  pe(E[Mo], 1e3 + (Q || 0), E[Vs], !0)
                  var It = {
                    data: E.payloadBlob,
                    urlString: V.url,
                    headers: V[ax],
                    _thePayload: E,
                    _sendReason: Q,
                    timeout: H,
                    disableXhrSync: j,
                    disableFetchKeepAlive: M,
                  }
                  se && (Qye(It[ku], eV) || (It[ku][eV] = Eye), Qye(It[ku], h4) || (It[ku][h4] = ZG))
                  var Hn = null
                  ge &&
                    (Hn = function (Zt) {
                      l[b4]()
                      var Er = function (wd, FC) {
                          le(wd, FC, E, Q)
                        },
                        Rn = E[N4] || E[k4]
                      try {
                        ge[O4](Zt, Er, Rn), S && S(It, Zt, Rn, E[mV])
                      } catch (wd) {
                        Ia(d, 'Unexpected exception sending payload. Ex:' + $e(wd)), ke(Er, 0, {})
                      }
                    }),
                    qn(
                      m,
                      function () {
                        return 'HttpManager:_doPayloadSend.sender'
                      },
                      function () {
                        if (Hn)
                          if ((E[Vs] === 0 && u++, me && !E.isBeacon && ge[P4] !== 3)) {
                            var Zt = {
                                data: It[pl],
                                urlString: It[lx],
                                headers: Wv({}, It[ku]),
                                timeout: It[th],
                                disableXhrSync: It[A4],
                                disableFetchKeepAlive: It[cV],
                              },
                              Er = !1
                            qn(
                              m,
                              function () {
                                return 'HttpManager:_doPayloadSend.sendHook'
                              },
                              function () {
                                try {
                                  L(
                                    Zt,
                                    function (Rn) {
                                      ;(Er = !0),
                                        !h && !Rn[ux] && ((Rn[ux] = Rn[ux] || It[ux]), (Rn[sC] = Rn[sC] || It[sC])),
                                        Hn(Rn)
                                    },
                                    E.isSync || E[N4]
                                  )
                                } catch {
                                  Er || Hn(It)
                                }
                              }
                            )
                          } else Hn(It)
                      }
                    )
                },
                function () {
                  return { thePayload: E, serializationStart: B, serializationCompleted: Y, sendReason: Q }
                },
                E[k4]
              )
            }
            E.sizeExceed && E.sizeExceed[Nt] > 0 && pe(E.sizeExceed, 8003, E[Vs]),
              E.failedEvts && E.failedEvts[Nt] > 0 && pe(E.failedEvts, 8002, E[Vs])
          }
          function qr(E, B) {
            b &&
              Ae(E, function (Y) {
                var Q = (Y[lC] = Y[lC] || {})
                bt(Q, 'sendEventCompleted', B)
              })
          }
          function le(E, B, Y, Q) {
            var me = 9e3,
              ge = null,
              se = !1,
              V = !1
            try {
              var ie = !0
              if (typeof E !== du) {
                if (B) {
                  l[oC](B[rV])
                  var re = B[tV] || B['kill-duration-seconds']
                  Ae(s[L4](B[Tye], re), function (Ie) {
                    Ae(Y[Mo], function (We) {
                      if (We[hc]() === Ie) {
                        ge = ge || []
                        var ft = We[ul](0)
                        ;(Y.numEvents -= ft[Yn]()), ge[$i](ft)
                      }
                    })
                  })
                }
                if (E == 200 || E == 204) {
                  me = 200
                  return
                }
                ;(!Hye(E) || Y.numEvents <= 0) && (ie = !1), (me = 9e3 + (E % 1e3))
              }
              if (ie) {
                me = 100
                var xe = Y.retryCnt
                Y[Vs] === 0 &&
                  (xe < n
                    ? ((se = !0),
                      N(
                        function () {
                          Y[Vs] === 0 && u--, Ne(Y[Mo], xe + 1, Y[N4], P ? 2 : Y[Vs], 5)
                        },
                        P,
                        U4(xe)
                      ))
                    : ((V = !0), P && (me = 8001)))
              }
            } finally {
              se || (l[oC](), ee(Y, me, Q, V)), pe(ge, 8004, Y[Vs])
            }
          }
          function ee(E, B, Y, Q) {
            try {
              Q && p[M4]()
              var me = E[Mo]
              B === 200 && ((me = E.sentEvts || E[Mo]), !Q && !E[k4] && p._clearBackOff(), te(me)), pe(me, B, E[Vs], !0)
            } finally {
              E[Vs] === 0 && (u--, Y !== 5 && fe.sendQueuedRequests(E[Vs], Y))
            }
          }
          function te(E) {
            if (b) {
              var B = Gs()
              Ae(E, function (Y) {
                Y && Y[Yn]() > 0 && qr(Y[Nu](), B)
              })
            }
          }
          function N(E, B, Y) {
            B ? E() : X.set(E, Y)
          }
          function O(E) {
            var B = {}
            if (gt(E)) {
              var Y = pr(E)[ul](/[\r\n]+/)
              Ae(Y, function (Q) {
                if (Q) {
                  var me = Q.indexOf(': ')
                  if (me !== -1) {
                    var ge = pr(Q.substring(0, me))[sx](),
                      se = pr(Q.substring(me + 1))
                    B[ge] = se
                  } else B[pr(Q)] = 1
                }
              })
            }
            return B
          }
          function K(E) {
            for (var B = 0; B < E.batches[Nt]; B++) {
              var Y = E[Mo][B].Msfpc()
              if (Y) return encodeURIComponent(Y)
            }
            return ll
          }
          function G(E) {
            var B = T
            try {
              for (var Y = 0; Y < B[Nt]; Y++)
                try {
                  B[Y](E)
                } catch (me) {
                  Ue(d, 1, 519, 'Response handler failed: ' + me)
                }
              if (E) {
                var Q = JSON.parse(E)
                zi(Q.webResult) && zi(Q.webResult[ox]) && x.set('MSFPC', Q.webResult[ox], 365 * 86400)
              }
            } catch {}
          }
          function pe(E, B, Y, Q) {
            if (E && E[Nt] > 0 && i) {
              var me = i[be(B)]
              if (me) {
                var ge = Y !== 0
                qn(
                  m,
                  function () {
                    return 'HttpManager:_sendBatchesNotification'
                  },
                  function () {
                    N(
                      function () {
                        try {
                          me.call(i, E, B, ge, Y)
                        } catch (se) {
                          Ue(d, 1, 74, 'send request notification failed: ' + se)
                        }
                      },
                      Q || ge,
                      0
                    )
                  },
                  function () {
                    return { batches: Te(E), reason: B, isSync: ge, sendSync: Q, sendType: Y }
                  },
                  !ge
                )
              }
            }
          }
          function be(E) {
            var B = NKe[E]
            return (
              zi(B) ||
                ((B = bye),
                E >= 9e3 && E <= 9999
                  ? (B = xye)
                  : E >= 8e3 && E <= 8999
                  ? (B = m4)
                  : E >= 1e3 && E <= 1999 && (B = yye)),
              B
            )
          }
        })
      }
      return (t.__ieDyn = 1), t
    })()
  })
function qKe(t) {
  return t && t[O4]
}
var LKe,
  e1e,
  MKe,
  r1e,
  n1e,
  FKe,
  t1e,
  UKe,
  CV,
  e0,
  Wi,
  BKe,
  i1e,
  o1e = createGetter(() => {
    Fs()
    fo()
    Kv()
    q1()
    pt()
    XG()
    vV()
    Zye()
    nC()
    xV()
    bV()
    fx()
    ;(LKe = 0.25),
      (e1e = 500),
      (MKe = 20),
      (r1e = 6),
      (n1e = 2),
      (FKe = 4),
      (t1e = 2),
      (UKe = 1),
      (CV = 1e4),
      (e0 = 'eventsDiscarded'),
      (Wi = void 0),
      (BKe = cs({
        eventsLimitInMem: { isVal: eh, v: CV },
        immediateEventLimit: { isVal: eh, v: 500 },
        autoFlushEventsLimit: { isVal: eh, v: 0 },
        disableAutoBatchFlushLimit: !1,
        httpXHROverride: { isVal: qKe, v: Wi },
        overrideInstrumentationKey: Wi,
        overrideEndpointUrl: Wi,
        disableTelemetry: !1,
        ignoreMc1Ms0CookieProcessing: !1,
        setTimeoutOverride: Wi,
        clearTimeoutOverride: Wi,
        payloadPreprocessor: Wi,
        payloadListener: Wi,
        disableEventTimings: Wi,
        valueSanitizer: Wi,
        stringifyObjects: Wi,
        enableCompoundKey: Wi,
        disableOptimizeObj: !1,
        transports: Wi,
        unloadTransports: Wi,
        useSendBeacon: Wi,
        disableFetchKeepAlive: Wi,
        avoidOptions: !1,
        xhrTimeout: Wi,
        disableXhrSync: Wi,
        alwaysUseXhrOverride: !1,
        maxEventRetryAttempts: { isVal: Gi, v: r1e },
        maxUnloadEventRetryAttempts: { isVal: Gi, v: n1e },
        addNoResponse: Wi,
      }))
    i1e = (function (t) {
      Ms(e, t)
      function e() {
        var r = t.call(this) || this
        ;(r.identifier = 'PostChannel'), (r.priority = 1011), (r.version = '4.0.4')
        var n,
          i = !1,
          o = [],
          s,
          a = !1,
          l = 0,
          c,
          u = 0,
          p,
          d = {},
          f = Yv,
          m,
          h,
          g,
          v,
          _,
          y,
          b,
          x,
          P,
          U,
          H,
          j,
          M,
          F,
          z,
          q,
          L,
          S,
          T,
          A,
          X,
          fe
        return (
          Wt(e, r, function (ce, oe) {
            W(),
              (ce._getDbgPlgTargets = function () {
                return [_, n]
              }),
              (ce[cx] = function (V, ie, re) {
                qn(
                  ie,
                  function () {
                    return 'PostChannel:initialize'
                  },
                  function () {
                    oe[cx](V, ie, re), (T = ie.getNotifyMgr())
                    try {
                      ;(z = wa(ho(ce[uC]), ie.evtNamespace && ie.evtNamespace())),
                        ce._addHook(
                          di(V, function (xe) {
                            var Ie = xe.cfg,
                              We = ms(null, Ie, ie)
                            ;(n = We.getExtCfg(ce[uC], BKe)),
                              (q = hx(n[C4], n[I4])),
                              (H = !n[Pye] && c4()),
                              (L = n[Nye]),
                              je(ie),
                              (p = n[hV]),
                              (c = n.immediateEventLimit),
                              (b = n[gV]),
                              (M = n.maxEventRetryAttempts),
                              (F = n.maxUnloadEventRetryAttempts),
                              (S = n[kye]),
                              se(),
                              (X = n[Oye]),
                              (fe = !!n[Lye]),
                              A && ae()
                            var ft = Ie.disablePageUnloadEvents || []
                            ;(A = YS(Ye, ft, z)),
                              (A = tx(Ye, ft, z) || A),
                              (A = rx(Ze, Ie.disablePageShowEvents, z) || A)
                          })
                        ),
                        _[cx](V, ce.core, ce)
                    } catch (xe) {
                      throw (ce.setInitialized(!1), xe)
                    }
                  },
                  function () {
                    return { theConfig: V, core: ie, extensions: re }
                  }
                )
              }),
              (ce.processTelemetry = function (V, ie) {
                tC(V, ce[uC]), (ie = ie || ce._getTelCtx(ie))
                var re = V
                !fe && !i && (X && (re[hc] = X), ke(re, !0), j ? Te(2, 2) : ve()), ce.processNext(re, ie)
              }),
              (ce._doTeardown = function (V, ie) {
                Te(2, 2), (i = !0), _.teardown(), ae(), W()
              })
            function ae() {
              QS(null, z), XS(null, z), JS(null, z)
            }
            function je(V) {
              var ie = V[dx]
              V[dx] = function () {
                var re = 0
                return L && (re = re | 2), re | ie.call(V)
              }
            }
            function Ye(V) {
              var ie = V || Bn().event
              ie.type !== 'beforeunload' && ((j = !0), _[cC](j)), Te(2, 2)
            }
            function Ze(V) {
              ;(j = !1), _[cC](j)
            }
            function ke(V, ie) {
              if (
                (V[pC] || (V[pC] = 0),
                V[rh] || (V[rh] = 1),
                V.ext && V.ext[oV] && delete V.ext[oV],
                V.ext && V.ext[x4] && V.ext[x4].id && delete V.ext[x4].id,
                H && ((V.ext = fc(V.ext)), V[F4] && (V[F4] = fc(V[F4])), V[pl] && (V[pl] = fc(V[pl]))),
                V[Xv])
              ) {
                if (g || a) (V[rh] = 3), (V[Xv] = !1)
                else if (_) {
                  H && (V = fc(V)), _[D4](mx.create(V[hc], [V]), V[Xv] === !0 ? 1 : V[Xv], 3)
                  return
                }
              }
              var re = V[rh],
                xe = u,
                Ie = p
              re === 4 && ((xe = l), (Ie = c))
              var We = !1
              if (xe < Ie) We = !Jt(V, ie)
              else {
                var ft = 1,
                  Et = MKe
                re === 4 && ((ft = 4), (Et = 1)), (We = !0), qr(V[hc], V[rh], ft, Et) && (We = !Jt(V, ie))
              }
              We && be(e0, [V], nl.QueueFull)
            }
            ;(ce.setEventQueueLimits = function (V, ie) {
              ;(n[hV] = p = eh(V) ? V : CV), (n[gV] = b = eh(ie) ? ie : 0), se()
              var re = u > V
              if (!re && x > 0)
                for (var xe = 1; !re && xe <= 3; xe++) {
                  var Ie = y[xe]
                  Ie &&
                    Ie[Mo] &&
                    Ae(Ie[Mo], function (We) {
                      We && We[Yn]() >= x && (re = !0)
                    })
                }
              bt(!0, re)
            }),
              (ce.pause = function () {
                ye(), (a = !0), _.pause()
              }),
              (ce.resume = function () {
                ;(a = !1), _.resume(), ve()
              }),
              (ce._loadTransmitProfiles = function (V) {
                O(),
                  ze(V, function (ie, re) {
                    var xe = re[Nt]
                    if (xe >= 2) {
                      var Ie = xe > 2 ? re[2] : 0
                      if ((re[Qv](0, xe - 2), re[1] < 0 && (re[0] = -1), re[1] > 0 && re[0] > 0)) {
                        var We = re[0] / re[1]
                        re[0] = Math.ceil(We) * re[1]
                      }
                      Ie >= 0 && re[1] >= 0 && Ie > re[1] && (Ie = re[1]), re[$i](Ie), (d[ie] = re)
                    }
                  })
              }),
              (ce.flush = function (V, ie, re) {
                V === void 0 && (V = !0)
                var xe
                if (!a)
                  if (((re = re || 1), V))
                    ie ||
                      (xe = ds(function (We) {
                        ie = We
                      })),
                      s == null
                        ? (ye(),
                          ee(1, 0, re),
                          (s = ne(function () {
                            ;(s = null), te(ie, re)
                          }, 0)))
                        : o[$i](ie)
                  else {
                    var Ie = ye()
                    st(1, 1, re), ie && ie(), Ie && ve()
                  }
                return xe
              }),
              (ce.setMsaAuthTicket = function (V) {
                _.addHeader(rC, V)
              }),
              (ce.hasEvents = tt),
              (ce._setTransmitProfile = function (V) {
                f !== V && d[V] !== void 0 && (ye(), (f = V), ve())
              }),
              Sa(
                ce,
                function () {
                  return _
                },
                ['addResponseHandler']
              )
            function st(V, ie, re) {
              var xe = ee(V, ie, re)
              return _[px](ie, re), xe
            }
            function tt() {
              return u > 0
            }
            function ve() {
              if ((P >= 0 && ee(P, 0, U) && _[px](0, U), l > 0 && !h && !a)) {
                var V = d[f][2]
                V >= 0 &&
                  (h = ne(function () {
                    ;(h = null), st(4, 0, 1), ve()
                  }, V))
              }
              var ie = d[f][1]
              !m &&
                !s &&
                ie >= 0 &&
                !a &&
                (tt()
                  ? (m = ne(function () {
                      ;(m = null), st(v === 0 ? 3 : 1, 0, 1), v++, (v %= 2), ve()
                    }, ie))
                  : (v = 0))
            }
            ;(ce[M4] = function () {
              g < FKe && (g++, ye(), ve())
            }),
              (ce._clearBackOff = function () {
                g && ((g = 0), ye(), ve())
              })
            function W() {
              ;(n = null),
                (i = !1),
                (o = []),
                (s = null),
                (a = !1),
                (l = 0),
                (c = 500),
                (u = 0),
                (p = CV),
                (d = {}),
                (f = Yv),
                (m = null),
                (h = null),
                (g = 0),
                (v = 0),
                (y = {}),
                (b = 0),
                (A = !1),
                (x = 0),
                (P = -1),
                (U = null),
                (H = !0),
                (j = !1),
                (M = r1e),
                (F = n1e),
                (z = null),
                (X = null),
                (fe = !1),
                (q = hx()),
                (_ = new Jye(e1e, t1e, UKe, { requeue: G, send: B, sent: Y, drop: Q, rspFail: me, oth: ge })),
                K(),
                Ne(),
                se()
            }
            function ne(V, ie) {
              ie === 0 && g && (ie = 1)
              var re = 1e3
              return g && (re = U4(g - 1)), q.set(V, ie * re)
            }
            function ye() {
              return m !== null ? (m.cancel(), (m = null), (v = 0), !0) : !1
            }
            function Te(V, ie) {
              ye(), s && (s.cancel(), (s = null)), a || st(1, V, ie)
            }
            function Ne() {
              ;(y[4] = { batches: [], iKeyMap: {} }),
                (y[3] = { batches: [], iKeyMap: {} }),
                (y[2] = { batches: [], iKeyMap: {} }),
                (y[1] = { batches: [], iKeyMap: {} })
            }
            function qe(V, ie, re) {
              var xe = y[ie]
              xe || ((ie = 1), (xe = y[ie]))
              var Ie = xe.iKeyMap[V]
              return !Ie && re && ((Ie = mx.create(V)), xe.batches[$i](Ie), (xe.iKeyMap[V] = Ie)), Ie
            }
            function bt(V, ie) {
              _[aC]() && !g && (b > 0 && u > b && (ie = !0), ie && s == null && ce.flush(V, function () {}, 20))
            }
            function Jt(V, ie) {
              H && (V = fc(V))
              var re = V[rh],
                xe = qe(V[hc], re, !0)
              return xe.addEvent(V)
                ? (re !== 4 ? (u++, ie && V[pC] === 0 && bt(!V.sync, x > 0 && xe[Yn]() >= x)) : l++, !0)
                : !1
            }
            function qr(V, ie, re, xe) {
              for (; re <= ie; ) {
                var Ie = qe(V, ie, !0)
                if (Ie && Ie[Yn]() > 0) {
                  var We = Ie[ul](0, xe),
                    ft = We[Yn]()
                  if (ft > 0) return re === 4 ? (l -= ft) : (u -= ft), E(e0, [We], nl.QueueFull), !0
                }
                re++
              }
              return le(), !1
            }
            function le() {
              for (
                var V = 0,
                  ie = 0,
                  re = function (Ie) {
                    var We = y[Ie]
                    We &&
                      We[Mo] &&
                      Ae(We[Mo], function (ft) {
                        Ie === 4 ? (V += ft[Yn]()) : (ie += ft[Yn]())
                      })
                  },
                  xe = 1;
                xe <= 4;
                xe++
              )
                re(xe)
              ;(u = ie), (l = V)
            }
            function ee(V, ie, re) {
              var xe = !1,
                Ie = ie === 0
              return (
                !Ie || _[aC]()
                  ? qn(
                      ce.core,
                      function () {
                        return 'PostChannel._queueBatches'
                      },
                      function () {
                        for (var We = [], ft = 4; ft >= V; ) {
                          var Et = y[ft]
                          Et &&
                            Et.batches &&
                            Et.batches[Nt] > 0 &&
                            (Ae(Et[Mo], function (It) {
                              _.addBatch(It) ? (xe = xe || (It && It[Yn]() > 0)) : (We = We[mc](It[Nu]())),
                                ft === 4 ? (l -= It[Yn]()) : (u -= It[Yn]())
                            }),
                            (Et[Mo] = []),
                            (Et.iKeyMap = {})),
                            ft--
                        }
                        We[Nt] > 0 && be(e0, We, nl.KillSwitch), xe && P >= V && ((P = -1), (U = 0))
                      },
                      function () {
                        return { latency: V, sendType: ie, sendReason: re }
                      },
                      !Ie
                    )
                  : ((P = P >= 0 ? Math.min(P, V) : V), (U = Math.max(U, re))),
                xe
              )
            }
            function te(V, ie) {
              st(1, 0, ie),
                le(),
                N(function () {
                  V && V(),
                    o[Nt] > 0
                      ? (s = ne(function () {
                          ;(s = null), te(o.shift(), ie)
                        }, 0))
                      : ((s = null), ve())
                })
            }
            function N(V) {
              _[R4]()
                ? V()
                : (s = ne(function () {
                    ;(s = null), N(V)
                  }, LKe))
            }
            function O() {
              ye(), K(), (f = Yv), ve()
            }
            function K() {
              ;(d = {}), (d[Yv] = [2, 1, 0]), (d[p4] = [6, 3, 0]), (d[d4] = [18, 9, 0])
            }
            function G(V, ie) {
              var re = [],
                xe = M
              j && (xe = F),
                Ae(V, function (Ie) {
                  Ie &&
                    Ie[Yn]() > 0 &&
                    Ae(Ie[Nu](), function (We) {
                      We &&
                        (We[Xv] && ((We[rh] = 4), (We[Xv] = !1)),
                        We[pC] < xe ? (tC(We, ce[uC]), ke(We, !1)) : re[$i](We))
                    })
                }),
                re[Nt] > 0 && be(e0, re, nl.NonRetryableStatus),
                j && Te(2, 2)
            }
            function pe(V, ie) {
              var re = T || {},
                xe = re[V]
              if (xe)
                try {
                  xe.apply(re, ie)
                } catch (Ie) {
                  Ue(ce.diagLog(), 1, 74, V + ' notification failed: ' + Ie)
                }
            }
            function be(V, ie) {
              for (var re = [], xe = 2; xe < arguments.length; xe++) re[xe - 2] = arguments[xe]
              ie && ie[Nt] > 0 && pe(V, [ie][mc](re))
            }
            function E(V, ie) {
              for (var re = [], xe = 2; xe < arguments.length; xe++) re[xe - 2] = arguments[xe]
              ie &&
                ie[Nt] > 0 &&
                Ae(ie, function (Ie) {
                  Ie && Ie[Yn]() > 0 && pe(V, [Ie.events()][mc](re))
                })
            }
            function B(V, ie, re) {
              V && V[Nt] > 0 && pe('eventsSendRequest', [ie >= 1e3 && ie <= 1999 ? ie - 1e3 : 0, re !== !0])
            }
            function Y(V, ie) {
              E('eventsSent', V, ie), ve()
            }
            function Q(V, ie) {
              E(e0, V, ie >= 8e3 && ie <= 8999 ? ie - 8e3 : nl.Unknown)
            }
            function me(V) {
              E(e0, V, nl.NonRetryableStatus), ve()
            }
            function ge(V, ie) {
              E(e0, V, nl.Unknown), ve()
            }
            function se() {
              S ? (x = 0) : (x = Math.max(e1e * (t1e + 1), p / 6))
            }
          }),
          r
        )
      }
      return (e.__ieDyn = 1), e
    })(ld)
  })
var s1e = {}
defineProperties(s1e, { BE_PROFILE: () => d4, NRT_PROFILE: () => p4, PostChannel: () => i1e, RT_PROFILE: () => Yv })
var a1e = createGetter(() => {
  XG()
  o1e()
})
var l1e = handleExports(Ou => {
  'use strict'
  var HKe =
      (Ou && Ou.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r)
            var i = Object.getOwnPropertyDescriptor(e, r)
            ;(!i || ('get' in i ? !e.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              }),
              Object.defineProperty(t, n, i)
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    jKe =
      (Ou && Ou.__setModuleDefault) ||
      (Object.create
        ? function (t, e) {
            Object.defineProperty(t, 'default', { enumerable: !0, value: e })
          }
        : function (t, e) {
            t.default = e
          }),
    c1e =
      (Ou && Ou.__importStar) ||
      function (t) {
        if (t && t.__esModule) return t
        var e = {}
        if (t != null) for (var r in t) r !== 'default' && Object.prototype.hasOwnProperty.call(t, r) && HKe(e, t, r)
        return jKe(e, t), e
      }
  Object.defineProperty(Ou, '__esModule', { value: !0 })
  Ou.oneDataSystemClientFactory = void 0
  var GKe = async (t, e, r) => {
      let n = await Promise.resolve().then(() => c1e((Kv(), handleEsModuleExports(vye)))),
        i = await Promise.resolve().then(() => c1e((a1e(), handleEsModuleExports(s1e)))),
        o = new n.AppInsightsCore(),
        s = new i.PostChannel(),
        a = {
          instrumentationKey: t,
          endpointUrl: 'https://mobile.events.data.microsoft.com/OneCollector/1.0',
          loggingLevelTelemetry: 0,
          loggingLevelConsole: 0,
          disableCookiesUsage: !0,
          disableDbgExt: !0,
          disableInstrumentationKeyValidation: !0,
          channels: [[s]],
        }
      if (r) {
        a.extensionConfig = {}
        let u = { alwaysUseXhrOverride: !0, httpXHROverride: r }
        a.extensionConfig[s.identifier] = u
      }
      let c = e.workspace.getConfiguration('telemetry').get('internalTesting')
      return (
        o.initialize(a, []),
        o.addTelemetryInitializer(u => {
          c && ((u.ext = u.ext ?? {}), (u.ext.utc = u.ext.utc ?? {}), (u.ext.utc.flags = 8462029))
        }),
        o
      )
    },
    VKe = async (t, e, r) => {
      let n = await GKe(t, e, r)
      return {
        logEvent: (s, a) => {
          try {
            n?.track({ name: s, baseData: { name: s, properties: a?.properties, measurements: a?.measurements } })
          } catch (l) {
            throw new Error(
              `Failed to log event to app insights!
` + l.message
            )
          }
        },
        flush: async () => {
          try {
            return new Promise((a, l) => {
              if (!n) {
                a()
                return
              }
              n.flush(!0, c => {
                if (!c) {
                  l('Failed to flush app 1DS!')
                  return
                }
              })
            })
          } catch (s) {
            throw new Error(
              `Failed to flush 1DS!
` + s.message
            )
          }
        },
        dispose: async () =>
          new Promise(a => {
            if (!n) {
              a()
              return
            }
            n.unload(
              !1,
              () => {
                a(), (n = void 0)
              },
              1e3
            )
          }),
      }
    }
  Ou.oneDataSystemClientFactory = VKe
})
var vx,
  _x,
  yx,
  dC,
  nh,
  Lu,
  wi,
  q4,
  gc = createGetter(() => {
    ;(vx = 'Microsoft_ApplicationInsights_BypassAjaxInstrumentation'),
      (_x = 'sampleRate'),
      (yx = 'ProcessLegacy'),
      (dC = 'http.method'),
      (nh = 'https://dc.services.visualstudio.com'),
      (Lu = '/v2/track'),
      (wi = 'not_specified'),
      (q4 = 'iKey')
  })
var md,
  IV = createGetter(() => {
    br()
    md = Dj({
      requestContextHeader: [0, 'Request-Context'],
      requestContextTargetKey: [1, 'appId'],
      requestContextAppIdFormat: [2, 'appId=cid-v1:'],
      requestIdHeader: [3, 'Request-Id'],
      traceParentHeader: [4, 'traceparent'],
      traceStateHeader: [5, 'tracestate'],
      sdkContextHeader: [6, 'Sdk-Context'],
      sdkContextHeaderAppIdRequest: [7, 'appId'],
      requestContextHeaderLowerCase: [8, 'request-context'],
    })
  })
var hd,
  yt,
  Mu,
  ih,
  gd,
  H4,
  fi,
  dl,
  oh,
  j4,
  G4,
  V4,
  wV,
  z4,
  $4,
  t0,
  xx,
  AV,
  fC,
  r0,
  vc,
  Fo,
  Uo,
  n0,
  Fu,
  i0,
  W4,
  K4,
  RV,
  o0,
  sh,
  mC,
  hC,
  s0,
  bx,
  a0,
  DV,
  Ki = createGetter(() => {
    ;(hd = 'split'),
      (yt = 'length'),
      (Mu = 'toLowerCase'),
      (ih = 'ingestionendpoint'),
      (gd = 'toString'),
      (H4 = 'removeItem'),
      (fi = 'name'),
      (dl = 'message'),
      (oh = 'count'),
      (j4 = 'preTriggerDate'),
      (G4 = 'disabled'),
      (V4 = 'interval'),
      (wV = 'daysOfMonth'),
      (z4 = 'date'),
      ($4 = 'getUTCDate'),
      (t0 = 'stringify'),
      (xx = 'pathname'),
      (AV = 'correlationHeaderExcludePatterns'),
      (fC = 'extensionConfig'),
      (r0 = 'exceptions'),
      (vc = 'parsedStack'),
      (Fo = 'properties'),
      (Uo = 'measurements'),
      (n0 = 'sizeInBytes'),
      (Fu = 'typeName'),
      (i0 = 'severityLevel'),
      (W4 = 'problemGroup'),
      (K4 = 'isManual'),
      (RV = 'CreateFromInterface'),
      (o0 = 'assembly'),
      (sh = 'fileName'),
      (mC = 'hasFullStack'),
      (hC = 'level'),
      (s0 = 'method'),
      (bx = 'line'),
      (a0 = 'duration'),
      (DV = 'receivedResponse')
  })
function Y4(t, e, r) {
  var n = e[yt],
    i = PV(t, e)
  if (i[yt] !== n) {
    for (var o = 0, s = i; r[s] !== void 0; ) o++, (s = Un(i, 0, 150 - 3) + NV(o))
    i = s
  }
  return i
}
function PV(t, e) {
  var r
  return (
    e &&
      ((e = pr(ci(e))),
      e[yt] > 150 &&
        ((r = Un(e, 0, 150)),
        Ue(t, 2, 57, 'name is too long.  It has been truncated to 150 characters.', { name: e }, !0))),
    r || e
  )
}
function Pr(t, e, r) {
  r === void 0 && (r = 1024)
  var n
  return (
    e &&
      ((r = r || 1024),
      (e = pr(ci(e))),
      e[yt] > r &&
        ((n = Un(e, 0, r)),
        Ue(t, 2, 61, 'string value is too long. It has been truncated to ' + r + ' characters.', { value: e }, !0))),
    n || e
  )
}
function ah(t, e) {
  return J4(t, e, 2048, 66)
}
function Ex(t, e) {
  var r
  return (
    e &&
      e[yt] > 32768 &&
      ((r = Un(e, 0, 32768)),
      Ue(t, 2, 56, 'message is too long, it has been truncated to 32768 characters.', { message: e }, !0)),
    r || e
  )
}
function Q4(t, e) {
  var r
  if (e) {
    var n = '' + e
    n[yt] > 32768 &&
      ((r = Un(n, 0, 32768)),
      Ue(t, 2, 52, 'exception is too long, it has been truncated to 32768 characters.', { exception: e }, !0))
  }
  return r || e
}
function Bo(t, e) {
  if (e) {
    var r = {}
    ze(e, function (n, i) {
      if (Br(i) && Tu())
        try {
          i = mo()[t0](i)
        } catch (o) {
          Ue(t, 2, 49, 'custom property is not valid', { exception: o }, !0)
        }
      ;(i = Pr(t, i, 8192)), (n = Y4(t, n, r)), (r[n] = i)
    }),
      (e = r)
  }
  return e
}
function qo(t, e) {
  if (e) {
    var r = {}
    ze(e, function (n, i) {
      ;(n = Y4(t, n, r)), (r[n] = i)
    }),
      (e = r)
  }
  return e
}
function X4(t, e) {
  return e && J4(t, e, 128, 69)[gd]()
}
function J4(t, e, r, n) {
  var i
  return (
    e &&
      ((e = pr(ci(e))),
      e[yt] > r &&
        ((i = Un(e, 0, r)),
        Ue(t, 2, n, 'input is too long, it has been truncated to ' + r + ' characters.', { data: e }, !0))),
    i || e
  )
}
function NV(t) {
  var e = '00' + t
  return tl(e, e[yt] - 3)
}
var _c = createGetter(() => {
  br()
  pt()
  Ki()
})
function c0(t) {
  var e = p1e,
    r = zKe,
    n = r[e]
  return (
    u1e.createElement ? r[e] || (n = r[e] = u1e.createElement('a')) : (n = { host: kV(t, !0) }),
    (n.href = t),
    e++,
    e >= r[yt] && (e = 0),
    (p1e = e),
    n
  )
}
function d1e(t) {
  var e,
    r = c0(t)
  return r && (e = r.href), e
}
function f1e(t) {
  var e,
    r = c0(t)
  return r && (e = r[xx]), e
}
function m1e(t, e) {
  return t ? t.toUpperCase() + ' ' + e : e
}
function kV(t, e) {
  var r = gC(t, e) || ''
  if (r) {
    var n = r.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i)
    if (n != null && n[yt] > 3 && gt(n[2]) && n[2][yt] > 0) return n[2] + (n[3] || '')
  }
  return r
}
function gC(t, e) {
  var r = null
  if (t) {
    var n = t.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i)
    if (n != null && n[yt] > 2 && gt(n[2]) && n[2][yt] > 0 && ((r = n[2] || ''), e && n[yt] > 2)) {
      var i = (n[1] || '')[Mu](),
        o = n[3] || ''
      ;((i === 'http' && o === ':80') || (i === 'https' && o === ':443')) && (o = ''), (r += o)
    }
  }
  return r
}
var u1e,
  p1e,
  zKe,
  OV = createGetter(() => {
    br()
    Ki()
    ;(u1e = In() || {}), (p1e = 0), (zKe = [null, null, null, null, null])
  })
function Tx(t) {
  return ir($Ke, t[Mu]()) !== -1
}
function h1e(t) {
  LV = t
}
function g1e() {
  return LV
}
function v1e(t, e, r) {
  if (!e || (t && t.disableCorrelationHeaders)) return !1
  if (t && t[AV]) {
    for (var n = 0; n < t.correlationHeaderExcludePatterns[yt]; n++) if (t[AV][n].test(e)) return !1
  }
  var i = c0(e).host[Mu]()
  if (
    (i && (ps(i, ':443') !== -1 || ps(i, ':80') !== -1) && (i = (gC(e, !0) || '')[Mu]()),
    (!t || !t.enableCorsCorrelation) && i && i !== r)
  )
    return !1
  var o = t && t.correlationHeaderDomains
  if (o) {
    var s
    if (
      (Ae(o, function (c) {
        var u = new RegExp(c.toLowerCase().replace(/\\/g, '\\\\').replace(/\./g, '\\.').replace(/\*/g, '.*'))
        s = s || u.test(i)
      }),
      !s)
    )
      return !1
  }
  var a = t && t.correlationHeaderExcludedDomains
  if (!a || a[yt] === 0) return !0
  for (var n = 0; n < a[yt]; n++) {
    var l = new RegExp(a[n].toLowerCase().replace(/\\/g, '\\\\').replace(/\./g, '\\.').replace(/\*/g, '.*'))
    if (l.test(i)) return !1
  }
  return i && i[yt] > 0
}
function _1e(t) {
  if (t) {
    var e = MV(t, md[1])
    if (e && e !== LV) return e
  }
}
function MV(t, e) {
  if (t)
    for (var r = t[hd](','), n = 0; n < r[yt]; ++n) {
      var i = r[n][hd]('=')
      if (i[yt] === 2 && i[0] === e) return i[1]
    }
}
function y1e(t, e, r, n) {
  var i,
    o = n,
    s = n
  if (e && e[yt] > 0) {
    var a = c0(e)
    if (((i = a.host), !o))
      if (a[xx] != null) {
        var l = a.pathname[yt] === 0 ? '/' : a[xx]
        l.charAt(0) !== '/' && (l = '/' + l), (s = a[xx]), (o = Pr(t, r ? r + ' ' + l : l))
      } else o = Pr(t, e)
  } else (i = n), (o = n)
  return { target: i, name: o, data: s }
}
function x1e() {
  var t = Qp()
  if (t && t.now && t.timing) {
    var e = t.now() + t.timing.navigationStart
    if (e > 0) return e
  }
  return wn()
}
function b1e(t, e) {
  var r = null
  return t !== 0 && e !== 0 && !we(t) && !we(e) && (r = e - t), r
}
function E1e(t, e) {
  var r = t || {}
  return {
    getName: function () {
      return r[fi]
    },
    setName: function (n) {
      e && e.setName(n), (r[fi] = n)
    },
    getTraceId: function () {
      return r.traceID
    },
    setTraceId: function (n) {
      e && e.setTraceId(n), Iu(n) && (r.traceID = n)
    },
    getSpanId: function () {
      return r.parentID
    },
    setSpanId: function (n) {
      e && e.setSpanId(n), wu(n) && (r.parentID = n)
    },
    getTraceFlags: function () {
      return r.traceFlags
    },
    setTraceFlags: function (n) {
      e && e.setTraceFlags(n), (r.traceFlags = n)
    },
  }
}
var $Ke,
  LV,
  FV = createGetter(() => {
    br()
    pt()
    gc()
    IV()
    _c()
    OV()
    Ki()
    ;($Ke = [
      nh + Lu,
      'https://breeze.aimon.applicationinsights.io' + Lu,
      'https://dc-int.services.visualstudio.com' + Lu,
    ]),
      (LV = 'cid-v1:')
  })
var Sx,
  T1e,
  UV = createGetter(() => {
    br()
    ;(Sx = Vi({ LocalStorage: 0, SessionStorage: 1 })), (T1e = Vi({ AI: 0, AI_AND_W3C: 1, W3C: 2 }))
  })
function BV() {
  return Cx() ? Z4(Sx.LocalStorage) : null
}
function Z4(t) {
  try {
    if (we(Oo())) return null
    var e = new Date()[gd](),
      r = Kr(t === Sx.LocalStorage ? 'localStorage' : 'sessionStorage'),
      n = S1e + e
    r.setItem(n, e)
    var i = r.getItem(n) !== e
    if ((r[H4](n), !i)) return r
  } catch {}
  return null
}
function qV() {
  return l0() ? Z4(Sx.SessionStorage) : null
}
function C1e() {
  ;(ch = !1), (lh = !1)
}
function eO(t) {
  S1e = t || ''
}
function I1e() {
  ;(ch = Cx(!0)), (lh = l0(!0))
}
function Cx(t) {
  return (t || ch === void 0) && (ch = !!Z4(Sx.LocalStorage)), ch
}
function tO(t, e) {
  var r = BV()
  if (r !== null)
    try {
      return r.getItem(e)
    } catch (n) {
      ;(ch = !1), Ue(t, 2, 1, 'Browser failed read of local storage. ' + Qr(n), { exception: $e(n) })
    }
  return null
}
function rO(t, e, r) {
  var n = BV()
  if (n !== null)
    try {
      return n.setItem(e, r), !0
    } catch (i) {
      ;(ch = !1), Ue(t, 2, 3, 'Browser failed write to local storage. ' + Qr(i), { exception: $e(i) })
    }
  return !1
}
function w1e(t, e) {
  var r = BV()
  if (r !== null)
    try {
      return r[H4](e), !0
    } catch (n) {
      ;(ch = !1), Ue(t, 2, 5, 'Browser failed removal of local storage item. ' + Qr(n), { exception: $e(n) })
    }
  return !1
}
function l0(t) {
  return (t || lh === void 0) && (lh = !!Z4(Sx.SessionStorage)), lh
}
function A1e() {
  var t = []
  return (
    l0() &&
      ze(Kr('sessionStorage'), function (e) {
        t.push(e)
      }),
    t
  )
}
function nO(t, e) {
  var r = qV()
  if (r !== null)
    try {
      return r.getItem(e)
    } catch (n) {
      ;(lh = !1), Ue(t, 2, 2, 'Browser failed read of session storage. ' + Qr(n), { exception: $e(n) })
    }
  return null
}
function iO(t, e, r) {
  var n = qV()
  if (n !== null)
    try {
      return n.setItem(e, r), !0
    } catch (i) {
      ;(lh = !1), Ue(t, 2, 4, 'Browser failed write to session storage. ' + Qr(i), { exception: $e(i) })
    }
  return !1
}
function R1e(t, e) {
  var r = qV()
  if (r !== null)
    try {
      return r[H4](e), !0
    } catch (n) {
      ;(lh = !1), Ue(t, 2, 6, 'Browser failed removal of session storage item. ' + Qr(n), { exception: $e(n) })
    }
  return !1
}
var ch,
  lh,
  S1e,
  HV = createGetter(() => {
    br()
    UV()
    Ki()
    ;(ch = void 0), (lh = void 0), (S1e = '')
  })
var WKe,
  D1e,
  P1e = createGetter(() => {
    br()
    pt()
    HV()
    Ki()
    ;(WKe = 'appInsightsThrottle'),
      (D1e = (function () {
        function t(e, r) {
          var n = this,
            i,
            o,
            s,
            a,
            l,
            c,
            u,
            p = !1,
            d = !1
          m(),
            (n._getDbgPlgTargets = function () {
              return [u]
            }),
            (n.getConfig = function () {
              return s
            }),
            (n.canThrottle = function (L) {
              var S = F(L),
                T = h(L)
              return _(T, i, S)
            }),
            (n.isTriggered = function (L) {
              return z(L)
            }),
            (n.isReady = function () {
              return p
            }),
            (n.flush = function (L) {
              try {
                var S = q(L)
                if (S && S[yt] > 0) {
                  var T = S.slice(0)
                  return (
                    (u[L] = []),
                    Ae(T, function (A) {
                      f(A.msgID, A[dl], A.severity, !1)
                    }),
                    !0
                  )
                }
              } catch {}
              return !1
            }),
            (n.flushAll = function () {
              try {
                if (u) {
                  var L = !0
                  return (
                    ze(u, function (S) {
                      var T = n.flush(parseInt(S))
                      L = L && T
                    }),
                    L
                  )
                }
              } catch {}
              return !1
            }),
            (n.onReadyState = function (L, S) {
              return S === void 0 && (S = !0), (p = we(L) ? !0 : L), p && S ? n.flushAll() : null
            }),
            (n.sendMessage = function (L, S, T) {
              return f(L, S, T, !0)
            })
          function f(L, S, T, A) {
            if (p) {
              var X = M(L)
              if (!X) return
              var fe = h(L),
                ce = F(L),
                oe = _(fe, i, ce),
                ae = !1,
                je = 0,
                Ye = z(L)
              try {
                oe && !Ye
                  ? ((je = Math.min(fe.limit.maxSendNumber, ce[oh] + 1)),
                    (ce[oh] = 0),
                    (ae = !0),
                    (l[L] = !0),
                    (ce[j4] = new Date()))
                  : ((l[L] = oe), (ce[oh] += 1))
                var Ze = y(L)
                U(o, Ze, ce)
                for (var ke = 0; ke < je; ke++) j(L, o, S, T)
              } catch {}
              return { isThrottled: ae, throttleNum: je }
            } else if (A) {
              var st = q(L)
              st.push({ msgID: L, message: S, severity: T })
            }
            return null
          }
          function m() {
            ;(o = cl(e)),
              (l = {}),
              (a = {}),
              (u = {}),
              (s = {}),
              g(109),
              (c = Eu(r) ? r : ''),
              e.addUnloadHook(
                di(e.config, function (L) {
                  var S = L.cfg
                  i = Cx()
                  var T = S.throttleMgrCfg || {}
                  ze(T, function (A, X) {
                    g(parseInt(A), X)
                  })
                })
              )
          }
          function h(L) {
            return s[L] || s[109]
          }
          function g(L, S) {
            var T, A
            try {
              var X = S || {},
                fe = {}
              fe[G4] = !!X[G4]
              var ce = X[V4] || {}
              ;(d = ce?.daysOfMonth && ce?.daysOfMonth[yt] > 0), (fe[V4] = v(ce))
              var oe = {
                samplingRate: ((T = X.limit) === null || T === void 0 ? void 0 : T.samplingRate) || 100,
                maxSendNumber: ((A = X.limit) === null || A === void 0 ? void 0 : A.maxSendNumber) || 1,
              }
              ;(fe.limit = oe), (s[L] = fe)
            } catch {}
          }
          function v(L) {
            L = L || {}
            var S = L?.monthInterval,
              T = L?.dayInterval
            return (
              we(S) && we(T) && ((L.monthInterval = 3), d || ((L[wV] = [28]), (d = !0))),
              (L = { monthInterval: L?.monthInterval, dayInterval: L?.dayInterval, daysOfMonth: L?.daysOfMonth }),
              L
            )
          }
          function _(L, S, T) {
            if (L && !L[G4] && S && Eu(T)) {
              var A = P(),
                X = T[z4],
                fe = L[V4],
                ce = 1
              if (fe?.monthInterval) {
                var oe = (A.getUTCFullYear() - X.getUTCFullYear()) * 12 + A.getUTCMonth() - X.getUTCMonth()
                ce = H(fe.monthInterval, 0, oe)
              }
              var ae = 1
              if (d) ae = ir(fe[wV], A[$4]())
              else if (fe?.dayInterval) {
                var je = Math.floor((A.getTime() - X.getTime()) / 864e5)
                ae = H(fe.dayInterval, 0, je)
              }
              return ce >= 0 && ae >= 0
            }
            return !1
          }
          function y(L, S) {
            var T = Eu(S) ? S : ''
            return L ? WKe + T + '-' + L : null
          }
          function b(L) {
            try {
              if (L) {
                var S = new Date()
                return (
                  L.getUTCFullYear() === S.getUTCFullYear() &&
                  L.getUTCMonth() === S.getUTCMonth() &&
                  L[$4]() === S[$4]()
                )
              }
            } catch {}
            return !1
          }
          function x(L, S, T) {
            try {
              var A = { date: P(), count: 0 }
              if (L) {
                var X = JSON.parse(L),
                  fe = {
                    date: P(X[z4]) || A[z4],
                    count: X[oh] || A[oh],
                    preTriggerDate: X.preTriggerDate ? P(X[j4]) : void 0,
                  }
                return fe
              } else return U(S, T, A), A
            } catch {}
            return null
          }
          function P(L) {
            try {
              if (L) {
                var S = new Date(L)
                if (!isNaN(S.getDate())) return S
              } else return new Date()
            } catch {}
            return null
          }
          function U(L, S, T) {
            try {
              return rO(L, S, pr(JSON[t0](T)))
            } catch {}
            return !1
          }
          function H(L, S, T) {
            return L <= 0 ? 1 : T >= S && (T - S) % L == 0 ? Math.floor((T - S) / L) + 1 : -1
          }
          function j(L, S, T, A) {
            Ue(S, A || 1, L, T)
          }
          function M(L) {
            try {
              var S = h(L)
              return wS(1e6) <= S.limit.samplingRate
            } catch {}
            return !1
          }
          function F(L) {
            try {
              var S = a[L]
              if (!S) {
                var T = y(L, c)
                ;(S = x(tO(o, T), o, T)), (a[L] = S)
              }
              return a[L]
            } catch {}
            return null
          }
          function z(L) {
            var S = l[L]
            if (we(S)) {
              S = !1
              var T = F(L)
              T && (S = b(T[j4])), (l[L] = S)
            }
            return l[L]
          }
          function q(L) {
            return (u = u || {}), we(u[L]) && (u[L] = []), u[L]
          }
        }
        return t
      })())
  })
function vC(t) {
  if (!t) return {}
  var e = t[hd](KKe),
    r = T1(
      e,
      function (i, o) {
        var s = o[hd](YKe)
        if (s[yt] === 2) {
          var a = s[0][Mu](),
            l = s[1]
          i[a] = l
        }
        return i
      },
      {}
    )
  if (Si(r)[yt] > 0) {
    if (r.endpointsuffix) {
      var n = r.location ? r.location + '.' : ''
      r[ih] = r[ih] || 'https://' + n + 'dc.' + r.endpointsuffix
    }
    ;(r[ih] = r[ih] || nh), Dm(r[ih], '/') && (r[ih] = r[ih].slice(0, -1))
  }
  return r
}
var KKe,
  YKe,
  N1e,
  k1e = createGetter(() => {
    br()
    gc()
    Ki()
    ;(KKe = ';'), (YKe = '=')
    N1e = { parse: vC }
  })
var oO,
  O1e = createGetter(() => {
    br()
    gc()
    Ki()
    _c()
    oO = (function () {
      function t(e, r, n) {
        var i = this,
          o = this
        ;(o.ver = 1),
          (o.sampleRate = 100),
          (o.tags = {}),
          (o[fi] = Pr(e, n) || wi),
          (o.data = r),
          (o.time = Ta(new Date())),
          (o.aiDataContract = {
            time: 1,
            iKey: 1,
            name: 1,
            sampleRate: function () {
              return i.sampleRate === 100 ? 4 : 1
            },
            tags: 1,
            data: 1,
          })
      }
      return t
    })()
  })
var Uu,
  L1e = createGetter(() => {
    gc()
    Ki()
    _c()
    Uu = (function () {
      function t(e, r, n, i) {
        this.aiDataContract = { ver: 1, name: 1, properties: 0, measurements: 0 }
        var o = this
        ;(o.ver = 2), (o[fi] = Pr(e, r) || wi), (o[Fo] = Bo(e, n)), (o[Uo] = qo(e, i))
      }
      return (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.Event'), (t.dataType = 'EventData'), t
    })()
  })
function zV(t, e) {
  var r = t
  return (
    r &&
      !gt(r) &&
      (JSON && JSON[t0]
        ? ((r = JSON[t0](t)), e && (!r || r === '{}') && (mt(t[gd]) ? (r = t[gd]()) : (r = '' + t)))
        : (r = '' + t + ' - (Missing JSON.stringify)')),
    r || ''
  )
}
function q1e(t, e) {
  var r = t
  return (
    t &&
      (r && !gt(r) && (r = t[VV] || t[B1e] || r),
      r && !gt(r) && (r = zV(r, !0)),
      t.filename && (r = r + ' @' + (t.filename || '') + ':' + (t.lineno || '?') + ':' + (t.colno || '?'))),
    e && e !== 'String' && e !== 'Object' && e !== 'Error' && ps(r || '', e) === -1 && (r = e + ': ' + r),
    r || ''
  )
}
function XKe(t) {
  try {
    if (Br(t)) return 'hasFullStack' in t && 'typeName' in t
  } catch {}
  return !1
}
function JKe(t) {
  try {
    if (Br(t)) return 'ver' in t && 'exceptions' in t && 'properties' in t
  } catch {}
  return !1
}
function F1e(t) {
  return t && t.src && gt(t.src) && t.obj && Xe(t.obj)
}
function u0(t) {
  var e = t || ''
  gt(e) || (gt(e[zs]) ? (e = e[zs]) : (e = '' + e))
  var r = e[hd](`
`)
  return { src: e, obj: r }
}
function ZKe(t) {
  for (
    var e = [],
      r = t[hd](`
`),
      n = 0;
    n < r[yt];
    n++
  ) {
    var i = r[n]
    r[n + 1] && ((i += '@' + r[n + 1]), n++), e.push(i)
  }
  return { src: t, obj: e }
}
function H1e(t) {
  var e = null
  if (t)
    try {
      if (t[zs]) e = u0(t[zs])
      else if (t[Ix] && t[Ix][zs]) e = u0(t[Ix][zs])
      else if (t.exception && t.exception[zs]) e = u0(t.exception[zs])
      else if (F1e(t)) e = t
      else if (F1e(t[GV])) e = t[GV]
      else if (Bn() && Bn().opera && t[VV]) e = ZKe(t[dl])
      else if (t.reason && t.reason[zs]) e = u0(t.reason[zs])
      else if (gt(t)) e = u0(t)
      else {
        var r = t[VV] || t[B1e] || ''
        gt(t[M1e]) &&
          (r &&
            (r += `
`),
          (r += ' from ' + t[M1e])),
          r && (e = u0(r))
      }
    } catch (n) {
      e = u0(n)
    }
  return e || { src: '', obj: null }
}
function eYe(t) {
  var e = ''
  return (
    t &&
      (t.obj
        ? Ae(t.obj, function (r) {
            e +=
              r +
              `
`
          })
        : (e = t.src || '')),
    e
  )
}
function tYe(t) {
  var e,
    r = t.obj
  if (r && r[yt] > 0) {
    e = []
    var n = 0,
      i = 0
    Ae(r, function (m) {
      var h = m[gd]()
      if ($V.regex.test(h)) {
        var g = new $V(h, n++)
        ;(i += g[n0]), e.push(g)
      }
    })
    var o = 32 * 1024
    if (i > o)
      for (var s = 0, a = e[yt] - 1, l = 0, c = s, u = a; s < a; ) {
        var p = e[s][n0],
          d = e[a][n0]
        if (((l += p + d), l > o)) {
          var f = u - c + 1
          e.splice(c, f)
          break
        }
        ;(c = s), (u = a), s++, a--
      }
  }
  return e
}
function sO(t) {
  var e = ''
  if (t && ((e = t.typeName || t[fi] || ''), !e))
    try {
      var r = /function (.{1,200})\(/,
        n = r.exec(t.constructor[gd]())
      e = n && n[yt] > 1 ? n[1] : ''
    } catch {}
  return e
}
function jV(t) {
  if (t)
    try {
      if (!gt(t)) {
        var e = sO(t),
          r = zV(t, !1)
        return (
          (!r || r === '{}') && (t[Ix] && ((t = t[Ix]), (e = sO(t))), (r = zV(t, !0))),
          ps(r, e) !== 0 && e !== 'String' ? e + ':' + r : r
        )
      }
    } catch {}
  return '' + (t || '')
}
var QKe,
  Ix,
  zs,
  GV,
  M1e,
  VV,
  B1e,
  uh,
  U1e,
  $V,
  j1e = createGetter(() => {
    Fs()
    br()
    pt()
    gc()
    Ki()
    _c()
    ;(QKe = '<no_method>'),
      (Ix = 'error'),
      (zs = 'stack'),
      (GV = 'stackDetails'),
      (M1e = 'errorSrc'),
      (VV = 'message'),
      (B1e = 'description')
    ;(uh = (function () {
      function t(e, r, n, i, o, s) {
        this.aiDataContract = { ver: 1, exceptions: 1, severityLevel: 0, properties: 0, measurements: 0 }
        var a = this
        ;(a.ver = 2),
          JKe(r)
            ? ((a[r0] = r[r0] || []),
              (a[Fo] = r[Fo]),
              (a[Uo] = r[Uo]),
              r[i0] && (a[i0] = r[i0]),
              r.id && (a.id = r.id),
              r[W4] && (a[W4] = r[W4]),
              we(r[K4]) || (a[K4] = r[K4]))
            : (n || (n = {}),
              (a[r0] = [new U1e(e, r, n)]),
              (a[Fo] = Bo(e, n)),
              (a[Uo] = qo(e, i)),
              o && (a[i0] = o),
              s && (a.id = s))
      }
      return (
        (t.CreateAutoException = function (e, r, n, i, o, s, a, l) {
          var c,
            u = sO(o || s || e)
          return (
            (c = {}),
            (c[dl] = q1e(e, u)),
            (c.url = r),
            (c.lineNumber = n),
            (c.columnNumber = i),
            (c.error = jV(o || s || e)),
            (c.evt = jV(s || e)),
            (c[Fu] = u),
            (c.stackDetails = H1e(a || o || s)),
            (c.errorSrc = l),
            c
          )
        }),
        (t.CreateFromInterface = function (e, r, n, i) {
          var o =
              r[r0] &&
              hu(r[r0], function (a) {
                return U1e[RV](e, a)
              }),
            s = new t(e, uc(uc({}, r), { exceptions: o }), n, i)
          return s
        }),
        (t.prototype.toInterface = function () {
          var e,
            r = this,
            n = r.exceptions,
            i = r.properties,
            o = r.measurements,
            s = r.severityLevel,
            a = r.problemGroup,
            l = r.id,
            c = r.isManual,
            u =
              (n instanceof Array &&
                hu(n, function (p) {
                  return p.toInterface()
                })) ||
              void 0
          return (
            (e = { ver: '4.0' }),
            (e[r0] = u),
            (e.severityLevel = s),
            (e.properties = i),
            (e.measurements = o),
            (e.problemGroup = a),
            (e.id = l),
            (e.isManual = c),
            e
          )
        }),
        (t.CreateSimpleException = function (e, r, n, i, o, s) {
          var a
          return { exceptions: [((a = {}), (a[mC] = !0), (a.message = e), (a.stack = o), (a.typeName = r), a)] }
        }),
        (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.Exception'),
        (t.dataType = 'ExceptionData'),
        (t.formatError = jV),
        t
      )
    })()),
      (U1e = (function () {
        function t(e, r, n) {
          this.aiDataContract = {
            id: 0,
            outerId: 0,
            typeName: 1,
            message: 1,
            hasFullStack: 0,
            stack: 0,
            parsedStack: 2,
          }
          var i = this
          if (XKe(r)) (i[Fu] = r[Fu]), (i[dl] = r[dl]), (i[zs] = r[zs]), (i[vc] = r[vc] || []), (i[mC] = r[mC])
          else {
            var o = r,
              s = o && o.evt
            fu(o) || (o = o[Ix] || s || o), (i[Fu] = Pr(e, sO(o)) || wi), (i[dl] = Ex(e, q1e(r || o, i[Fu])) || wi)
            var a = r[GV] || H1e(r)
            ;(i[vc] = tYe(a)),
              Xe(i[vc]) &&
                hu(i[vc], function (l) {
                  ;(l[o0] = Pr(e, l[o0])), (l[sh] = Pr(e, l[sh]))
                }),
              (i[zs] = Q4(e, eYe(a))),
              (i.hasFullStack = Xe(i.parsedStack) && i.parsedStack[yt] > 0),
              n && (n[Fu] = n[Fu] || i[Fu])
          }
        }
        return (
          (t.prototype.toInterface = function () {
            var e,
              r = this,
              n =
                r[vc] instanceof Array &&
                hu(r[vc], function (o) {
                  return o.toInterface()
                }),
              i =
                ((e = {
                  id: r.id,
                  outerId: r.outerId,
                  typeName: r[Fu],
                  message: r[dl],
                  hasFullStack: r[mC],
                  stack: r[zs],
                }),
                (e[vc] = n || void 0),
                e)
            return i
          }),
          (t.CreateFromInterface = function (e, r) {
            var n =
                (r[vc] instanceof Array &&
                  hu(r[vc], function (o) {
                    return $V[RV](o)
                  })) ||
                r[vc],
              i = new t(e, uc(uc({}, r), { parsedStack: n }))
            return i
          }),
          t
        )
      })()),
      ($V = (function () {
        function t(e, r) {
          this.aiDataContract = { level: 1, method: 1, assembly: 0, fileName: 0, line: 0 }
          var n = this
          if (((n[n0] = 0), typeof e == 'string')) {
            var i = e
            ;(n[hC] = r), (n[s0] = QKe), (n[o0] = pr(i)), (n[sh] = ''), (n[bx] = 0)
            var o = i.match(t.regex)
            o && o[yt] >= 5 && ((n[s0] = pr(o[2]) || n[s0]), (n[sh] = pr(o[4])), (n[bx] = parseInt(o[5]) || 0))
          } else (n[hC] = e[hC]), (n[s0] = e[s0]), (n[o0] = e[o0]), (n[sh] = e[sh]), (n[bx] = e[bx]), (n[n0] = 0)
          ;(n.sizeInBytes += n.method[yt]),
            (n.sizeInBytes += n.fileName[yt]),
            (n.sizeInBytes += n.assembly[yt]),
            (n[n0] += t.baseSize),
            (n.sizeInBytes += n.level.toString()[yt]),
            (n.sizeInBytes += n.line.toString()[yt])
        }
        return (
          (t.CreateFromInterface = function (e) {
            return new t(e, null)
          }),
          (t.prototype.toInterface = function () {
            var e = this
            return { level: e[hC], method: e[s0], assembly: e[o0], fileName: e[sh], line: e[bx] }
          }),
          (t.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/),
          (t.baseSize = 58),
          t
        )
      })())
  })
var G1e,
  V1e = createGetter(() => {
    G1e = (function () {
      function t() {
        ;(this.aiDataContract = { name: 1, kind: 0, value: 1, count: 0, min: 0, max: 0, stdDev: 0 }), (this.kind = 0)
      }
      return t
    })()
  })
var Bu,
  z1e = createGetter(() => {
    gc()
    Ki()
    V1e()
    _c()
    Bu = (function () {
      function t(e, r, n, i, o, s, a, l, c) {
        this.aiDataContract = { ver: 1, metrics: 1, properties: 0 }
        var u = this
        u.ver = 2
        var p = new G1e()
        ;(p[oh] = i > 0 ? i : void 0),
          (p.max = isNaN(s) || s === null ? void 0 : s),
          (p.min = isNaN(o) || o === null ? void 0 : o),
          (p[fi] = Pr(e, r) || wi),
          (p.value = n),
          (p.stdDev = isNaN(a) || a === null ? void 0 : a),
          (u.metrics = [p]),
          (u[Fo] = Bo(e, l)),
          (u[Uo] = qo(e, c))
      }
      return (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.Metric'), (t.dataType = 'MetricData'), t
    })()
  })
function $1e(t, e) {
  return e === void 0 && (e = !1), t == null ? e : t.toString()[Mu]() === 'true'
}
function wx(t) {
  ;(isNaN(t) || t < 0) && (t = 0), (t = Math.round(t))
  var e = _C + (t % 1e3),
    r = _C + (Math.floor(t / 1e3) % 60),
    n = _C + (Math.floor(t / (1e3 * 60)) % 60),
    i = _C + (Math.floor(t / (1e3 * 60 * 60)) % 24),
    o = Math.floor(t / (1e3 * 60 * 60 * 24))
  return (
    (e = e[yt] === 1 ? '00' + e : e[yt] === 2 ? '0' + e : e),
    (r = r[yt] < 2 ? '0' + r : r),
    (n = n[yt] < 2 ? '0' + n : n),
    (i = i[yt] < 2 ? '0' + i : i),
    (o > 0 ? o + '.' : _C) + i + ':' + n + ':' + r + '.' + e
  )
}
function W1e(t, e) {
  var r = null
  return (
    Ae(t, function (n) {
      if (n.identifier === e) return (r = n), -1
    }),
    r
  )
}
function K1e(t, e, r, n, i) {
  return !i && gt(t) && (t === 'Script error.' || t === 'Script error')
}
var _C,
  aO = createGetter(() => {
    br()
    Ki()
    _C = ''
  })
var ph,
  Y1e = createGetter(() => {
    gc()
    aO()
    Ki()
    _c()
    ph = (function () {
      function t(e, r, n, i, o, s, a) {
        this.aiDataContract = { ver: 1, name: 0, url: 0, duration: 0, properties: 0, measurements: 0, id: 0 }
        var l = this
        ;(l.ver = 2),
          (l.id = X4(e, a)),
          (l.url = ah(e, n)),
          (l[fi] = Pr(e, r) || wi),
          isNaN(i) || (l[a0] = wx(i)),
          (l[Fo] = Bo(e, o)),
          (l[Uo] = qo(e, s))
      }
      return (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.Pageview'), (t.dataType = 'PageviewData'), t
    })()
  })
var dh,
  Q1e = createGetter(() => {
    aO()
    FV()
    Ki()
    _c()
    dh = (function () {
      function t(e, r, n, i, o, s, a, l, c, u, p, d) {
        c === void 0 && (c = 'Ajax'),
          (this.aiDataContract = {
            id: 1,
            ver: 1,
            name: 0,
            resultCode: 0,
            duration: 0,
            success: 0,
            data: 0,
            target: 0,
            type: 0,
            properties: 0,
            measurements: 0,
            kind: 0,
            value: 0,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            dependencyKind: 0,
            dependencySource: 0,
            commandName: 0,
            dependencyTypeName: 0,
          })
        var f = this
        ;(f.ver = 2), (f.id = r), (f[a0] = wx(o)), (f.success = s), (f.resultCode = a + ''), (f.type = Pr(e, c))
        var m = y1e(e, n, l, i)
        ;(f.data = ah(e, i) || m.data),
          (f.target = Pr(e, m.target)),
          u && (f.target = ''.concat(f.target, ' | ').concat(u)),
          (f[fi] = Pr(e, m[fi])),
          (f[Fo] = Bo(e, p)),
          (f[Uo] = qo(e, d))
      }
      return (
        (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.RemoteDependency'),
        (t.dataType = 'RemoteDependencyData'),
        t
      )
    })()
  })
var fh,
  X1e = createGetter(() => {
    gc()
    Ki()
    _c()
    fh = (function () {
      function t(e, r, n, i, o) {
        this.aiDataContract = { ver: 1, message: 1, severityLevel: 0, properties: 0 }
        var s = this
        ;(s.ver = 2), (r = r || wi), (s[dl] = Ex(e, r)), (s[Fo] = Bo(e, i)), (s[Uo] = qo(e, o)), n && (s[i0] = n)
      }
      return (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.Message'), (t.dataType = 'MessageData'), t
    })()
  })
var mh,
  J1e = createGetter(() => {
    gc()
    Ki()
    _c()
    mh = (function () {
      function t(e, r, n, i, o, s, a) {
        this.aiDataContract = {
          ver: 1,
          name: 0,
          url: 0,
          duration: 0,
          perfTotal: 0,
          networkConnect: 0,
          sentRequest: 0,
          receivedResponse: 0,
          domProcessing: 0,
          properties: 0,
          measurements: 0,
        }
        var l = this
        ;(l.ver = 2),
          (l.url = ah(e, n)),
          (l[fi] = Pr(e, r) || wi),
          (l[Fo] = Bo(e, o)),
          (l[Uo] = qo(e, s)),
          a &&
            ((l.domProcessing = a.domProcessing),
            (l[a0] = a[a0]),
            (l.networkConnect = a.networkConnect),
            (l.perfTotal = a.perfTotal),
            (l[DV] = a[DV]),
            (l.sentRequest = a.sentRequest))
      }
      return (
        (t.envelopeType = 'Microsoft.ApplicationInsights.{0}.PageviewPerformance'),
        (t.dataType = 'PageviewPerformanceData'),
        t
      )
    })()
  })
var qu,
  Z1e = createGetter(() => {
    qu = (function () {
      function t(e, r) {
        ;(this.aiDataContract = { baseType: 1, baseData: 1 }), (this.baseType = e), (this.baseData = r)
      }
      return t
    })()
  })
var cO,
  exe = createGetter(() => {
    br()
    cO = Vi({ Verbose: 0, Information: 1, Warning: 2, Error: 3, Critical: 4 })
  })
var txe,
  rxe = createGetter(() => {
    br()
    Ki()
    txe = (function () {
      function t() {}
      return (
        (t.getConfig = function (e, r, n, i) {
          i === void 0 && (i = !1)
          var o
          return n && e[fC] && e[fC][n] && !we(e[fC][n][r]) ? (o = e[fC][n][r]) : (o = e[r]), we(o) ? i : o
        }),
        t
      )
    })()
  })
function gh(t) {
  var e = 'ai.' + t + '.'
  return function (r) {
    return e + r
  }
}
var yC,
  Ai,
  lO,
  Ax,
  WV,
  hh,
  p0,
  xC,
  Rx,
  KV = createGetter(() => {
    Fs()
    br()
    ;(yC = gh('application')),
      (Ai = gh('device')),
      (lO = gh('location')),
      (Ax = gh('operation')),
      (WV = gh('session')),
      (hh = gh('user')),
      (p0 = gh('cloud')),
      (xC = gh('internal')),
      (Rx = (function (t) {
        Ms(e, t)
        function e() {
          return t.call(this) || this
        }
        return e
      })(
        Wj({
          applicationVersion: yC('ver'),
          applicationBuild: yC('build'),
          applicationTypeId: yC('typeId'),
          applicationId: yC('applicationId'),
          applicationLayer: yC('layer'),
          deviceId: Ai('id'),
          deviceIp: Ai('ip'),
          deviceLanguage: Ai('language'),
          deviceLocale: Ai('locale'),
          deviceModel: Ai('model'),
          deviceFriendlyName: Ai('friendlyName'),
          deviceNetwork: Ai('network'),
          deviceNetworkName: Ai('networkName'),
          deviceOEMName: Ai('oemName'),
          deviceOS: Ai('os'),
          deviceOSVersion: Ai('osVersion'),
          deviceRoleInstance: Ai('roleInstance'),
          deviceRoleName: Ai('roleName'),
          deviceScreenResolution: Ai('screenResolution'),
          deviceType: Ai('type'),
          deviceMachineName: Ai('machineName'),
          deviceVMName: Ai('vmName'),
          deviceBrowser: Ai('browser'),
          deviceBrowserVersion: Ai('browserVersion'),
          locationIp: lO('ip'),
          locationCountry: lO('country'),
          locationProvince: lO('province'),
          locationCity: lO('city'),
          operationId: Ax('id'),
          operationName: Ax('name'),
          operationParentId: Ax('parentId'),
          operationRootId: Ax('rootId'),
          operationSyntheticSource: Ax('syntheticSource'),
          operationCorrelationVector: Ax('correlationVector'),
          sessionId: WV('id'),
          sessionIsFirst: WV('isFirst'),
          sessionIsNew: WV('isNew'),
          userAccountAcquisitionDate: hh('accountAcquisitionDate'),
          userAccountId: hh('accountId'),
          userAgent: hh('userAgent'),
          userId: hh('id'),
          userStoreRegion: hh('storeRegion'),
          userAuthUserId: hh('authUserId'),
          userAnonymousUserAcquisitionDate: hh('anonUserAcquisitionDate'),
          userAuthenticatedUserAcquisitionDate: hh('authUserAcquisitionDate'),
          cloudName: p0('name'),
          cloudRole: p0('role'),
          cloudRoleVer: p0('roleVer'),
          cloudRoleInstance: p0('roleInstance'),
          cloudEnvironment: p0('environment'),
          cloudLocation: p0('location'),
          cloudDeploymentUnit: p0('deploymentUnit'),
          internalNodeName: xC('nodeName'),
          internalSdkVersion: xC('sdkVersion'),
          internalAgentVersion: xC('agentVersion'),
          internalSnippet: xC('snippet'),
          internalSdkSrc: xC('sdkSrc'),
        })
      ))
  })
function YV(t, e, r, n, i, o) {
  var s
  ;(r = Pr(n, r) || wi), (we(t) || we(e) || we(r)) && Cn("Input doesn't contain all required fields")
  var a = ''
  t[q4] && ((a = t[q4]), delete t[q4])
  var l =
    ((s = {}),
    (s[fi] = r),
    (s.time = Ta(new Date())),
    (s.iKey = a),
    (s.ext = o || {}),
    (s.tags = []),
    (s.data = {}),
    (s.baseType = e),
    (s.baseData = t),
    s)
  return (
    we(i) ||
      ze(i, function (c, u) {
        l.data[c] = u
      }),
    l
  )
}
var nxe,
  ixe = createGetter(() => {
    br()
    gc()
    _c()
    Ki()
    nxe = (function () {
      function t() {}
      return (t.create = YV), t
    })()
  })
var oxe,
  mi,
  sxe = createGetter(() => {
    KV()
    ;(oxe = {
      UserExt: 'user',
      DeviceExt: 'device',
      TraceExt: 'trace',
      WebExt: 'web',
      AppExt: 'app',
      OSExt: 'os',
      SessionExt: 'ses',
      SDKExt: 'sdk',
    }),
      (mi = new Rx())
  })
function axe(t) {
  var e = null
  if (mt(Event)) e = new Event(t)
  else {
    var r = In()
    r && r.createEvent && ((e = r.createEvent('Event')), e.initEvent(t, !0, !0))
  }
  return e
}
var cxe = createGetter(() => {
  br()
})
var lxe = {}
defineProperties(lxe, {
  AnalyticsPluginIdentifier: () => nYe,
  BreezeChannelIdentifier: () => QV,
  ConfigurationManager: () => txe,
  ConnectionStringParser: () => N1e,
  ContextTagKeys: () => Rx,
  CtxTagKeys: () => mi,
  DEFAULT_BREEZE_ENDPOINT: () => nh,
  DEFAULT_BREEZE_PATH: () => Lu,
  Data: () => qu,
  DisabledPropertyName: () => vx,
  DistributedTracingModes: () => T1e,
  Envelope: () => oO,
  Event: () => Uu,
  Exception: () => uh,
  Extensions: () => oxe,
  HttpMethod: () => dC,
  Metric: () => Bu,
  PageView: () => ph,
  PageViewPerformance: () => mh,
  ProcessLegacy: () => yx,
  PropertiesPluginIdentifier: () => rYe,
  RemoteDependencyData: () => dh,
  RequestHeaders: () => md,
  SampleRate: () => _x,
  SeverityLevel: () => cO,
  TelemetryItemCreator: () => nxe,
  ThrottleMgr: () => D1e,
  Trace: () => fh,
  correlationIdCanIncludeCorrelationHeader: () => v1e,
  correlationIdGetCorrelationContext: () => _1e,
  correlationIdGetCorrelationContextValue: () => MV,
  correlationIdGetPrefix: () => g1e,
  correlationIdSetPrefix: () => h1e,
  createDistributedTraceContextFromTrace: () => E1e,
  createDomEvent: () => axe,
  createTelemetryItem: () => YV,
  createTraceParent: () => jS,
  dataSanitizeException: () => Q4,
  dataSanitizeId: () => X4,
  dataSanitizeInput: () => J4,
  dataSanitizeKey: () => PV,
  dataSanitizeKeyAndAddUniqueness: () => Y4,
  dataSanitizeMeasurements: () => qo,
  dataSanitizeMessage: () => Ex,
  dataSanitizeProperties: () => Bo,
  dataSanitizeString: () => Pr,
  dataSanitizeUrl: () => ah,
  dateTimeUtilsDuration: () => b1e,
  dateTimeUtilsNow: () => x1e,
  dsPadNumber: () => NV,
  findW3cTraceParent: () => zS,
  formatTraceParent: () => VS,
  getExtensionByName: () => W1e,
  isBeaconApiSupported: () => Ca,
  isCrossOriginError: () => K1e,
  isInternalApplicationInsightsEndpoint: () => Tx,
  isSampledFlag: () => GS,
  isValidSpanId: () => wu,
  isValidTraceId: () => Iu,
  isValidTraceParent: () => J1,
  msToTimeSpan: () => wx,
  parseConnectionString: () => vC,
  parseTraceParent: () => Vv,
  strNotSpecified: () => wi,
  stringToBoolOrDefault: () => $1e,
  urlGetAbsoluteUrl: () => d1e,
  urlGetCompleteUrl: () => m1e,
  urlGetPathName: () => f1e,
  urlParseFullHost: () => gC,
  urlParseHost: () => kV,
  urlParseUrl: () => c0,
  utlCanUseLocalStorage: () => Cx,
  utlCanUseSessionStorage: () => l0,
  utlDisableStorage: () => C1e,
  utlEnableStorage: () => I1e,
  utlGetLocalStorage: () => tO,
  utlGetSessionStorage: () => nO,
  utlGetSessionStorageKeys: () => A1e,
  utlRemoveSessionStorage: () => R1e,
  utlRemoveStorage: () => w1e,
  utlSetLocalStorage: () => rO,
  utlSetSessionStorage: () => iO,
  utlSetStoragePrefix: () => eO,
})
var rYe,
  QV,
  nYe,
  vd = createGetter(() => {
    FV()
    P1e()
    k1e()
    IV()
    gc()
    O1e()
    L1e()
    j1e()
    z1e()
    Y1e()
    Q1e()
    X1e()
    J1e()
    Z1e()
    exe()
    rxe()
    KV()
    _c()
    ixe()
    sxe()
    UV()
    aO()
    br()
    cxe()
    HV()
    OV()
    ;(rYe = 'AppInsightsPropertiesPlugin'), (QV = 'AppInsightsChannelPlugin'), (nYe = 'ApplicationInsightsAnalytics')
  })
var vh,
  uxe = createGetter(() => {
    vh = 'duration'
  })
var hi,
  uO,
  gi,
  Hu,
  d0,
  Pt,
  _h,
  yh,
  yc,
  xh,
  _d,
  bC,
  EC,
  Dx,
  yd,
  bh,
  pO,
  xd,
  TC,
  bd,
  SC,
  CC,
  Px,
  f0,
  IC,
  dO,
  Ed,
  Nx,
  fO,
  kx,
  go,
  Ox,
  mO,
  XV,
  JV,
  hO,
  ZV,
  ez,
  Eh,
  tz,
  rz,
  nz,
  iz,
  gO,
  Lx,
  pxe,
  Th,
  vO,
  wC,
  AC,
  dxe,
  Mx,
  _O,
  oz,
  yO,
  fxe,
  Td = createGetter(() => {
    ;(hi = 'tags'),
      (uO = 'deviceType'),
      (gi = 'data'),
      (Hu = 'name'),
      (d0 = 'traceID'),
      (Pt = 'length'),
      (_h = 'stringify'),
      (yh = 'measurements'),
      (yc = 'dataType'),
      (xh = 'envelopeType'),
      (_d = 'toString'),
      (bC = 'onLine'),
      (EC = 'isOnline'),
      (Dx = '_get'),
      (yd = 'enqueue'),
      (bh = 'count'),
      (pO = 'eventsLimitInMem'),
      (xd = 'push'),
      (TC = 'emitLineDelimitedJson'),
      (bd = 'clear'),
      (SC = 'batchPayloads'),
      (CC = 'createNew'),
      (Px = 'markAsSent'),
      (f0 = 'clearSent'),
      (IC = 'bufferOverride'),
      (dO = 'BUFFER_KEY'),
      (Ed = 'SENT_BUFFER_KEY'),
      (Nx = 'MAX_BUFFER_SIZE'),
      (fO = 'sendPOST'),
      (kx = 'triggerSend'),
      (go = 'diagLog'),
      (Ox = '_sender'),
      (mO = 'customHeaders'),
      (XV = 'maxBatchSizeInBytes'),
      (JV = 'onunloadDisableBeacon'),
      (hO = 'isBeaconApiDisabled'),
      (ZV = 'alwaysUseXhrOverride'),
      (ez = 'enableSessionStorageBuffer'),
      (Eh = '_buffer'),
      (tz = 'onunloadDisableFetch'),
      (rz = 'instrumentationKey'),
      (nz = 'convertUndefined'),
      (iz = 'maxBatchInterval'),
      (gO = 'baseType'),
      (Lx = 'sampleRate'),
      (pxe = '_xhrReadyStateChange'),
      (Th = '_onError'),
      (vO = '_onPartialSuccess'),
      (wC = '_onSuccess'),
      (AC = 'itemsAccepted'),
      (dxe = 'itemsReceived'),
      (Mx = 'oriPayload'),
      (_O = 'setRequestHeader'),
      (oz = 'eventsSendRequest'),
      (yO = 'getSamplingScore'),
      (fxe = 'getHashCodeScore')
  })
function vi(t, e, r) {
  return dc(t, e, r, el)
}
function iYe(t, e, r) {
  var n = (r[hi] = r[hi] || {}),
    i = (e.ext = e.ext || {}),
    o = (e[hi] = e[hi] || []),
    s = i.user
  s && (vi(n, mi.userAuthUserId, s.authId), vi(n, mi.userId, s.id || s.localId))
  var a = i.app
  a && vi(n, mi.sessionId, a.sesId)
  var l = i.device
  l &&
    (vi(n, mi.deviceId, l.id || l.localId),
    vi(n, mi[uO], l.deviceClass),
    vi(n, mi.deviceIp, l.ip),
    vi(n, mi.deviceModel, l.model),
    vi(n, mi[uO], l[uO]))
  var c = e.ext.web
  if (c) {
    vi(n, mi.deviceLanguage, c.browserLang),
      vi(n, mi.deviceBrowserVersion, c.browserVer),
      vi(n, mi.deviceBrowser, c.browser)
    var u = (r[gi] = r[gi] || {}),
      p = (u[gn] = u[gn] || {}),
      d = (p[Yi] = p[Yi] || {})
    vi(d, 'domain', c.domain),
      vi(d, 'isManual', c.isManual ? mxe : null),
      vi(d, 'screenRes', c.screenRes),
      vi(d, 'userConsent', c.userConsent ? mxe : null)
  }
  var f = i.os
  f && vi(n, mi.deviceOS, f[Hu])
  var m = i.trace
  m && (vi(n, mi.operationParentId, m.parentID), vi(n, mi.operationName, Pr(t, m[Hu])), vi(n, mi.operationId, m[d0]))
  for (var h = {}, g = o[Pt] - 1; g >= 0; g--) {
    var v = o[g]
    ze(v, function (y, b) {
      h[y] = b
    }),
      o.splice(g, 1)
  }
  ze(o, function (y, b) {
    h[y] = b
  })
  var _ = uc(uc({}, n), h)
  _[mi.internalSdkVersion] || (_[mi.internalSdkVersion] = Pr(t, 'javascript:'.concat(oYe.Version), 64)), (r[hi] = fc(_))
}
function Sh(t, e, r) {
  we(t) ||
    ze(t, function (n, i) {
      Gi(i) ? (r[n] = i) : gt(i) ? (e[n] = i) : Tu() && (e[n] = mo()[_h](i))
    })
}
function m0(t, e) {
  we(t) ||
    ze(t, function (r, n) {
      t[r] = n || e
    })
}
function h0(t, e, r, n) {
  var i = new oO(t, n, e)
  vi(i, 'sampleRate', r[_x]), (r[gn] || {}).startTime && (i.time = Ta(r[gn].startTime)), (i.iKey = r.iKey)
  var o = r.iKey.replace(/-/g, '')
  return (i[Hu] = i[Hu].replace('{0}', o)), iYe(t, r, i), (r[hi] = r[hi] || []), fc(i)
}
function g0(t, e) {
  we(e[gn]) && Ue(t, 1, 46, 'telemetryItem.baseData cannot be null.')
}
function hxe(t, e, r) {
  g0(t, e)
  var n = e[gn][yh] || {},
    i = e[gn][Yi] || {}
  Sh(e[gi], i, n), we(r) || m0(i, r)
  var o = e[gn]
  if (we(o)) return Ia(t, 'Invalid input for dependency data'), null
  var s = o[Yi] && o[Yi][dC] ? o[Yi][dC] : 'GET',
    a = new dh(t, o.id, o.target, o[Hu], o[vh], o.success, o.responseCode, s, o.type, o.correlationContext, i, n),
    l = new qu(dh[yc], a)
  return h0(t, dh[xh], e, l)
}
function az(t, e, r) {
  g0(t, e)
  var n = {},
    i = {}
  e[sz] !== Uu[yc] && (n.baseTypeSource = e[sz]),
    e[sz] === Uu[yc] ? ((n = e[gn][Yi] || {}), (i = e[gn][yh] || {})) : e[gn] && Sh(e[gn], n, i),
    Sh(e[gi], n, i),
    we(r) || m0(n, r)
  var o = e[gn][Hu],
    s = new Uu(t, o, n, i),
    a = new qu(Uu[yc], s)
  return h0(t, Uu[xh], e, a)
}
function gxe(t, e, r) {
  g0(t, e)
  var n = e[gn][yh] || {},
    i = e[gn][Yi] || {}
  Sh(e[gi], i, n), we(r) || m0(i, r)
  var o = e[gn],
    s = uh.CreateFromInterface(t, o, i, n),
    a = new qu(uh[yc], s)
  return h0(t, uh[xh], e, a)
}
function vxe(t, e, r) {
  g0(t, e)
  var n = e[gn],
    i = n[Yi] || {},
    o = n[yh] || {}
  Sh(e[gi], i, o), we(r) || m0(i, r)
  var s = new Bu(t, n[Hu], n.average, n.sampleCount, n.min, n.max, n.stdDev, i, o),
    a = new qu(Bu[yc], s)
  return h0(t, Bu[xh], e, a)
}
function _xe(t, e, r) {
  g0(t, e)
  var n,
    i = e[gn]
  !we(i) && !we(i[Yi]) && !we(i[Yi][vh])
    ? ((n = i[Yi][vh]), delete i[Yi][vh])
    : !we(e[gi]) && !we(e[gi][vh]) && ((n = e[gi][vh]), delete e[gi][vh])
  var o = e[gn],
    s
  ;((e.ext || {}).trace || {})[d0] && (s = e.ext.trace[d0])
  var a = o.id || s,
    l = o[Hu],
    c = o.uri,
    u = o[Yi] || {},
    p = o[yh] || {}
  if (
    (we(o.refUri) || (u.refUri = o.refUri),
    we(o.pageType) || (u.pageType = o.pageType),
    we(o.isLoggedIn) || (u.isLoggedIn = o.isLoggedIn[_d]()),
    !we(o[Yi]))
  ) {
    var d = o[Yi]
    ze(d, function (h, g) {
      u[h] = g
    })
  }
  Sh(e[gi], u, p), we(r) || m0(u, r)
  var f = new ph(t, l, c, n, u, p, a),
    m = new qu(ph[yc], f)
  return h0(t, ph[xh], e, m)
}
function yxe(t, e, r) {
  g0(t, e)
  var n = e[gn],
    i = n[Hu],
    o = n.uri || n.url,
    s = n[Yi] || {},
    a = n[yh] || {}
  Sh(e[gi], s, a), we(r) || m0(s, r)
  var l = new mh(t, i, o, void 0, s, a, n),
    c = new qu(mh[yc], l)
  return h0(t, mh[xh], e, c)
}
function xxe(t, e, r) {
  g0(t, e)
  var n = e[gn].message,
    i = e[gn].severityLevel,
    o = e[gn][Yi] || {},
    s = e[gn][yh] || {}
  Sh(e[gi], o, s), we(r) || m0(o, r)
  var a = new fh(t, n, i, o, s),
    l = new qu(fh[yc], a)
  return h0(t, fh[xh], e, l)
}
var sz,
  gn,
  Yi,
  mxe,
  oYe,
  bxe = createGetter(() => {
    Fs()
    vd()
    br()
    uxe()
    Td()
    ;(sz = 'baseType'), (gn = 'baseData'), (Yi = 'properties'), (mxe = 'true')
    oYe = { Version: '3.0.5' }
  })
function Exe(t, e) {
  pd(t, null, null, e)
}
function Txe(t) {
  var e,
    r = In(),
    n = ui(),
    i = !1,
    o = !0,
    s = wa(ho('OfflineListener'), t)
  try {
    if ((l(Bn()) && (i = !0), r)) {
      var a = r.body || r
      a.ononline && l(a) && (i = !0)
    }
    i && n && !we(n[bC]) && (o = n[bC])
  } catch {
    i = !1
  }
  function l(f) {
    var m = !1
    return f && ((m = Au(f, 'online', c, s)), m && Au(f, 'offline', u, s)), m
  }
  function c() {
    o = !0
  }
  function u() {
    o = !1
  }
  function p() {
    var f = !0
    return i ? (f = o) : n && !we(n[bC]) && (f = n[bC]), f
  }
  function d() {
    var f = Bn()
    if (f && i) {
      if ((Exe(f, s), r)) {
        var m = r.body || r
        vt(m.ononline) || Exe(m, s)
      }
      i = !1
    }
  }
  return (
    (e = {}),
    (e[EC] = p),
    (e.isListening = function () {
      return i
    }),
    (e.unload = d),
    e
  )
}
var Sxe = createGetter(() => {
  br()
  Td()
})
var Cxe,
  xO,
  cz,
  Ixe = createGetter(() => {
    Fs()
    fo()
    vd()
    br()
    Td()
    ;(Cxe = (function () {
      function t(e, r) {
        var n = [],
          i = !1
        ;(this[Dx] = function () {
          return n
        }),
          (this._set = function (o) {
            return (n = o), n
          }),
          Wt(t, this, function (o) {
            ;(o[yd] = function (s) {
              if (o[bh]() >= r[pO]) {
                i || (Ue(e, 2, 105, 'Maximum in-memory buffer size reached: ' + o[bh](), !0), (i = !0))
                return
              }
              n[xd](s)
            }),
              (o[bh] = function () {
                return n[Pt]
              }),
              (o.size = function () {
                for (var s = n[Pt], a = 0; a < n[Pt]; a++) s += n[a][Pt]
                return r[TC] || (s += 2), s
              }),
              (o[bd] = function () {
                ;(n = []), (i = !1)
              }),
              (o.getItems = function () {
                return n.slice(0)
              }),
              (o[SC] = function (s) {
                if (s && s[Pt] > 0) {
                  var a = r[TC]
                    ? s.join(`
`)
                    : '[' + s.join(',') + ']'
                  return a
                }
                return null
              }),
              (o[CC] = function (s, a, l) {
                var c = n.slice(0)
                ;(s = s || e), (a = a || {})
                var u = l ? new cz(s, a) : new xO(s, a)
                return (
                  Ae(c, function (p) {
                    u[yd](p)
                  }),
                  u
                )
              })
          })
      }
      return (t.__ieDyn = 1), t
    })()),
      (xO = (function (t) {
        Ms(e, t)
        function e(r, n) {
          var i = t.call(this, r, n) || this
          return (
            Wt(e, i, function (o, s) {
              ;(o[Px] = function (a) {
                s[bd]()
              }),
                (o[f0] = function (a) {})
            }),
            i
          )
        }
        return (e.__ieDyn = 1), e
      })(Cxe)),
      (cz = (function (t) {
        Ms(e, t)
        function e(r, n) {
          var i = t.call(this, r, n) || this,
            o = !1,
            s = n?.namePrefix,
            a = n[IC] || { getItem: nO, setItem: iO },
            l = a.getItem,
            c = a.setItem
          return (
            Wt(e, i, function (u, p) {
              var d = g(e[dO]),
                f = g(e[Ed]),
                m = u._set(d.concat(f))
              m[Pt] > e[Nx] && (m[Pt] = e[Nx]),
                v(e[Ed], []),
                v(e[dO], m),
                (u[yd] = function (_) {
                  if (u[bh]() >= e[Nx]) {
                    o || (Ue(r, 2, 67, 'Maximum buffer size reached: ' + u[bh](), !0), (o = !0))
                    return
                  }
                  p[yd](_), v(e.BUFFER_KEY, u[Dx]())
                }),
                (u[bd] = function () {
                  p[bd](), v(e.BUFFER_KEY, u[Dx]()), v(e[Ed], []), (o = !1)
                }),
                (u[Px] = function (_) {
                  v(e[dO], u._set(h(_, u[Dx]())))
                  var y = g(e[Ed])
                  y instanceof Array &&
                    _ instanceof Array &&
                    ((y = y.concat(_)),
                    y[Pt] > e[Nx] &&
                      (Ue(r, 1, 67, 'Sent buffer reached its maximum size: ' + y[Pt], !0), (y[Pt] = e[Nx])),
                    v(e[Ed], y))
                }),
                (u[f0] = function (_) {
                  var y = g(e[Ed])
                  ;(y = h(_, y)), v(e[Ed], y)
                }),
                (u[CC] = function (_, y, b) {
                  b = !!b
                  var x = u[Dx]().slice(0),
                    P = g(e[Ed]).slice(0)
                  ;(_ = _ || r), (y = y || {}), u[bd]()
                  var U = b ? new e(_, y) : new xO(_, y)
                  return (
                    Ae(x, function (H) {
                      U[yd](H)
                    }),
                    b && U[Px](P),
                    U
                  )
                })
              function h(_, y) {
                var b = []
                return (
                  Ae(y, function (x) {
                    !mt(x) && ir(_, x) === -1 && b[xd](x)
                  }),
                  b
                )
              }
              function g(_) {
                var y = _
                try {
                  y = s ? s + '_' + y : y
                  var b = l(r, y)
                  if (b) {
                    var x = mo().parse(b)
                    if ((gt(x) && (x = mo().parse(x)), x && Xe(x))) return x
                  }
                } catch (P) {
                  Ue(r, 1, 42, ' storage key: ' + y + ', ' + Qr(P), { exception: $e(P) })
                }
                return []
              }
              function v(_, y) {
                var b = _
                try {
                  b = s ? s + '_' + b : b
                  var x = JSON[_h](y)
                  c(r, b, x)
                } catch (P) {
                  c(r, b, JSON[_h]([])),
                    Ue(r, 2, 41, ' storage key: ' + b + ', ' + Qr(P) + '. Buffer cleared', { exception: $e(P) })
                }
              }
            }),
            i
          )
        }
        return (e.BUFFER_KEY = 'AI_buffer'), (e.SENT_BUFFER_KEY = 'AI_sentBuffer'), (e.MAX_BUFFER_SIZE = 2e3), e
      })(Cxe))
  })
var wxe,
  Axe = createGetter(() => {
    fo()
    br()
    Td()
    wxe = (function () {
      function t(e) {
        Wt(t, this, function (r) {
          r.serialize = function (s) {
            var a = n(s, 'root')
            try {
              return mo()[_h](a)
            } catch (l) {
              Ue(e, 1, 48, l && mt(l[_d]) ? l[_d]() : 'Error serializing object', null, !0)
            }
          }
          function n(s, a) {
            var l = '__aiCircularRefCheck',
              c = {}
            if (!s) return Ue(e, 1, 48, 'cannot serialize object because it is null or undefined', { name: a }, !0), c
            if (s[l]) return Ue(e, 2, 50, 'Circular reference detected while serializing object', { name: a }, !0), c
            if (!s.aiDataContract) {
              if (a === 'measurements') c = o(s, 'number', a)
              else if (a === 'properties') c = o(s, 'string', a)
              else if (a === 'tags') c = o(s, 'string', a)
              else if (Xe(s)) c = i(s, a)
              else {
                Ue(
                  e,
                  2,
                  49,
                  'Attempting to serialize an object which does not implement ISerializable',
                  { name: a },
                  !0
                )
                try {
                  mo()[_h](s), (c = s)
                } catch (u) {
                  Ue(e, 1, 48, u && mt(u[_d]) ? u[_d]() : 'Error serializing object', null, !0)
                }
              }
              return c
            }
            return (
              (s[l] = !0),
              ze(s.aiDataContract, function (u, p) {
                var d = mt(p) ? p() & 1 : p & 1,
                  f = mt(p) ? p() & 4 : p & 4,
                  m = p & 2,
                  h = s[u] !== void 0,
                  g = Br(s[u]) && s[u] !== null
                if (d && !h && !m)
                  Ue(
                    e,
                    1,
                    24,
                    'Missing required field specification. The field is required but not present on source',
                    { field: u, name: a }
                  )
                else if (!f) {
                  var v = void 0
                  g ? (m ? (v = i(s[u], u)) : (v = n(s[u], u))) : (v = s[u]), v !== void 0 && (c[u] = v)
                }
              }),
              delete s[l],
              c
            )
          }
          function i(s, a) {
            var l
            if (s)
              if (!Xe(s))
                Ue(
                  e,
                  1,
                  54,
                  `This field was specified as an array in the contract but the item is not an array.\r
`,
                  { name: a },
                  !0
                )
              else {
                l = []
                for (var c = 0; c < s[Pt]; c++) {
                  var u = s[c],
                    p = n(u, a + '[' + c + ']')
                  l[xd](p)
                }
              }
            return l
          }
          function o(s, a, l) {
            var c
            return (
              s &&
                ((c = {}),
                ze(s, function (u, p) {
                  if (a === 'string')
                    p === void 0
                      ? (c[u] = 'undefined')
                      : p === null
                      ? (c[u] = 'null')
                      : p[_d]
                      ? (c[u] = p[_d]())
                      : (c[u] = 'invalid field: toString() is not defined.')
                  else if (a === 'number')
                    if (p === void 0) c[u] = 'undefined'
                    else if (p === null) c[u] = 'null'
                    else {
                      var d = parseFloat(p)
                      isNaN(d) ? (c[u] = 'NaN') : (c[u] = d)
                    }
                  else (c[u] = 'invalid field: ' + l + ' is of unknown type.'), Ue(e, 1, c[u], null, !0)
                })),
              c
            )
          }
        })
      }
      return (t.__ieDyn = 1), t
    })()
  })
var sYe,
  Rxe,
  Dxe = createGetter(() => {
    Td()
    ;(sYe = 8),
      (Rxe = (function () {
        function t() {}
        return (
          (t.prototype.getHashCodeScore = function (e) {
            var r = this.getHashCode(e) / t.INT_MAX_VALUE
            return r * 100
          }),
          (t.prototype.getHashCode = function (e) {
            if (e === '') return 0
            for (; e[Pt] < sYe; ) e = e.concat(e)
            for (var r = 5381, n = 0; n < e[Pt]; ++n) (r = (r << 5) + r + e.charCodeAt(n)), (r = r & r)
            return Math.abs(r)
          }),
          (t.INT_MAX_VALUE = 2147483647),
          t
        )
      })())
  })
var Pxe,
  Nxe = createGetter(() => {
    vd()
    Td()
    Dxe()
    Pxe = (function () {
      function t() {
        var e = this,
          r = new Rxe(),
          n = new Rx()
        e[yO] = function (i) {
          var o = 0
          return (
            i[hi] && i[hi][n.userId]
              ? (o = r.getHashCodeScore(i[hi][n.userId]))
              : i.ext && i.ext.user && i.ext.user.id
              ? (o = r[fxe](i.ext.user.id))
              : i[hi] && i[hi][n.operationId]
              ? (o = r.getHashCodeScore(i[hi][n.operationId]))
              : i.ext && i.ext.telemetryTrace && i.ext.telemetryTrace[d0]
              ? (o = r.getHashCodeScore(i.ext.telemetryTrace[d0]))
              : (o = Math.random() * 100),
            o
          )
        }
      }
      return t
    })()
  })
var kxe,
  Oxe = createGetter(() => {
    vd()
    br()
    Td()
    Nxe()
    kxe = (function () {
      function t(e, r) {
        this.INT_MAX_VALUE = 2147483647
        var n = r || cl(null)
        ;(e > 100 || e < 0) &&
          (n.throwInternal(
            2,
            58,
            'Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.',
            { samplingRate: e },
            !0
          ),
          (e = 100)),
          (this[Lx] = e),
          (this.samplingScoreGenerator = new Pxe())
      }
      return (
        (t.prototype.isSampledIn = function (e) {
          var r = this[Lx],
            n = !1
          return r == null || r >= 100 || e.baseType === Bu[yc] ? !0 : ((n = this.samplingScoreGenerator[yO](e) < r), n)
        }),
        t
      )
    })()
  })
function bO(t) {
  try {
    return t.responseText
  } catch {}
  return null
}
function cYe(t) {
  return t && t[fO]
}
function lYe(t) {
  return !isNaN(t) && t > 0 && t <= 100
}
var Qn,
  Sd,
  Ch,
  aYe,
  Lxe,
  uYe,
  RC,
  Mxe = createGetter(() => {
    Fs()
    fo()
    vd()
    br()
    q1()
    pt()
    bxe()
    Sxe()
    Ixe()
    Axe()
    Oxe()
    Td()
    ;(Ch = void 0), (aYe = 65e3)
    Lxe = cs(
      ((Qn = { endpointUrl: K1(el, nh + Lu) }),
      (Qn[TC] = al()),
      (Qn[iz] = 15e3),
      (Qn[XV] = 102400),
      (Qn.disableTelemetry = al()),
      (Qn[ez] = al(!0)),
      (Qn.isRetryDisabled = al()),
      (Qn[hO] = al(!0)),
      (Qn.disableXhr = al()),
      (Qn[tz] = al()),
      (Qn[JV] = al()),
      (Qn[rz] = Ch),
      (Qn.namePrefix = Ch),
      (Qn.samplingPercentage = K1(lYe, 100)),
      (Qn[mO] = Ch),
      (Qn[nz] = Ch),
      (Qn[pO] = 1e4),
      (Qn[IC] = !1),
      (Qn.httpXHROverride = { isVal: cYe, v: Ch }),
      (Qn[ZV] = al()),
      Qn)
    )
    ;(uYe =
      ((Sd = {}),
      (Sd[Uu.dataType] = az),
      (Sd[fh.dataType] = xxe),
      (Sd[ph.dataType] = _xe),
      (Sd[mh.dataType] = yxe),
      (Sd[uh.dataType] = gxe),
      (Sd[Bu.dataType] = vxe),
      (Sd[dh.dataType] = hxe),
      Sd)),
      (RC = (function (t) {
        Ms(e, t)
        function e() {
          var r = t.call(this) || this
          ;(r.priority = 1001), (r.identifier = QV)
          var n,
            i,
            o,
            s,
            a,
            l,
            c,
            u,
            p = 0,
            d,
            f,
            m,
            h,
            g,
            v,
            _,
            y,
            b,
            x,
            P,
            U,
            H,
            j,
            M,
            F,
            z,
            q,
            L,
            S,
            T
          return (
            Wt(e, r, function (A, X) {
              be(),
                (A.pause = function () {
                  le(), (s = !0)
                }),
                (A.resume = function () {
                  s && ((s = !1), (i = null), Ze(), qr())
                }),
                (A.flush = function (E, B, Y) {
                  if ((E === void 0 && (E = !0), !s)) {
                    le()
                    try {
                      return A[kx](E, null, Y || 1)
                    } catch (Q) {
                      Ue(A[go](), 1, 22, 'flush failed, telemetry will not be collected: ' + Qr(Q), {
                        exception: $e(Q),
                      })
                    }
                  }
                }),
                (A.onunloadFlush = function () {
                  if (!s)
                    if (_ || q)
                      try {
                        return A[kx](!0, ve, 2)
                      } catch (E) {
                        Ue(
                          A[go](),
                          1,
                          20,
                          'failed to flush with beacon sender on page unload, telemetry will not be collected: ' +
                            Qr(E),
                          { exception: $e(E) }
                        )
                      }
                    else A.flush(!1)
                }),
                (A.addHeader = function (E, B) {
                  u[E] = B
                }),
                (A.initialize = function (E, B, Y, Q) {
                  A.isInitialized() && Ue(A[go](), 1, 28, 'Sender is already initialized'), X.initialize(E, B, Y, Q)
                  var me = A.identifier
                  ;(l = new wxe(B.logger)), (n = 0), (i = null), (o = 0), (A[Ox] = null), (c = 0)
                  var ge = A[go]()
                  ;(m = wa(ho('Sender'), B.evtNamespace && B.evtNamespace())),
                    (f = Txe(m)),
                    A._addHook(
                      di(E, function (se) {
                        var V = se.cfg
                        V.storagePrefix && eO(V.storagePrefix)
                        var ie = ms(null, V, B),
                          re = ie.getExtCfg(me, Lxe)
                        xr(A, '_senderConfig', {
                          g: function () {
                            return re
                          },
                        }),
                          g !== re.endpointUrl && (h = g = re.endpointUrl),
                          y &&
                            y !== re[mO] &&
                            Ae(y, function (Er) {
                              delete u[Er.header]
                            }),
                          (v = re[XV]),
                          (_ = (re[JV] === !1 || re[hO] === !1) && Ca()),
                          (q = re[ZV]),
                          (L = !!re.disableXhr)
                        var xe = re[IC],
                          Ie = !!re[ez] && (!!xe || l0()),
                          We = re.namePrefix,
                          ft = Ie !== j || (Ie && F !== We) || (Ie && M !== xe)
                        if (A[Eh]) {
                          if (ft)
                            try {
                              A._buffer = A._buffer[CC](ge, re, Ie)
                            } catch (Er) {
                              Ue(
                                A[go](),
                                1,
                                12,
                                'failed to transfer telemetry to different buffer storage, telemetry will be lost: ' +
                                  Qr(Er),
                                { exception: $e(Er) }
                              )
                            }
                          Ze()
                        } else A[Eh] = Ie ? new cz(ge, re) : new xO(ge, re)
                        ;(F = We),
                          (j = Ie),
                          (M = xe),
                          (S = !re[tz] && rd(!0)),
                          (A._sample = new kxe(re.samplingPercentage, ge)),
                          (x = re[rz]),
                          pe(x, V) || Ue(ge, 1, 100, 'Invalid Instrumentation key ' + x),
                          (y = re[mO]),
                          !Tx(h) && y && y[Pt] > 0
                            ? Ae(y, function (Er) {
                                r.addHeader(Er.header, Er.value)
                              })
                            : (y = null),
                          (z = re.enableSendPromise)
                        var Et = re.httpXHROverride,
                          It = null,
                          Hn = null
                        It = ce([1, 2], !1)
                        var Zt = { sendPOST: ye }
                        ;(T = function (Er, Rn) {
                          return ae(Zt, Er, Rn)
                        }),
                          !re[hO] && Ca() && (It = ce([3], !1)),
                          (It = q ? Et : It || Et || Zt),
                          (A[Ox] = function (Er, Rn) {
                            return ae(It, Er, Rn)
                          }),
                          S && (d = Te),
                          (Hn = q ? Et : ce([3, 1], !0) || Et),
                          (q || !d) &&
                            Hn &&
                            (d = function (Er, Rn) {
                              return ae(Hn, Er, Rn)
                            }),
                          d || (d = T),
                          (b = re.disableTelemetry),
                          (P = re[nz] || Ch),
                          (U = re.isRetryDisabled),
                          (H = re[iz])
                      })
                    )
                }),
                (A.processTelemetry = function (E, B) {
                  B = A._getTelCtx(B)
                  var Y = B[go]()
                  try {
                    if (b) return
                    if (!E) {
                      Ue(Y, 1, 7, 'Cannot send empty telemetry')
                      return
                    }
                    if (E.baseData && !E[gO]) {
                      Ue(Y, 1, 70, 'Cannot send telemetry without baseData and baseType')
                      return
                    }
                    if ((E[gO] || (E[gO] = 'EventData'), !A[Ox])) {
                      Ue(Y, 1, 28, 'Sender was not initialized')
                      return
                    }
                    if (fe(E)) E[_x] = A._sample[Lx]
                    else {
                      Ue(Y, 2, 33, 'Telemetry item was sampled out and not sent', { SampleRate: A._sample[Lx] })
                      return
                    }
                    var Q = E.iKey || x,
                      me = e.constructEnvelope(E, Q, Y, P)
                    if (!me) {
                      Ue(Y, 1, 47, 'Unable to create an AppInsights envelope')
                      return
                    }
                    var ge = !1
                    if (
                      (E[hi] &&
                        E[hi][yx] &&
                        (Ae(E[hi][yx], function (ie) {
                          try {
                            ie && ie(me) === !1 && ((ge = !0), Ia(Y, 'Telemetry processor check returns false'))
                          } catch (re) {
                            Ue(
                              Y,
                              1,
                              64,
                              'One of telemetry initializers failed, telemetry item will not be sent: ' + Qr(re),
                              { exception: $e(re) },
                              !0
                            )
                          }
                        }),
                        delete E[hi][yx]),
                      ge)
                    )
                      return
                    var se = l.serialize(me),
                      V = A[Eh]
                    Ze(se), V[yd](se), qr()
                  } catch (ie) {
                    Ue(
                      Y,
                      2,
                      12,
                      "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + Qr(ie),
                      { exception: $e(ie) }
                    )
                  }
                  A.processNext(E, B)
                }),
                (A[pxe] = function (E, B, Y) {
                  E.readyState === 4 && ke(E.status, B, E.responseURL, Y, te(E), bO(E) || E.response)
                }),
                (A[kx] = function (E, B, Y) {
                  E === void 0 && (E = !0)
                  var Q
                  if (!s)
                    try {
                      var me = A[Eh]
                      if (b) me[bd]()
                      else {
                        if (me[bh]() > 0) {
                          var ge = me.getItems()
                          G(Y || 0, E), B ? (Q = B.call(A, ge, E)) : (Q = A[Ox](ge, E))
                        }
                        o = +new Date()
                      }
                      le()
                    } catch (V) {
                      var se = SS()
                      ;(!se || se > 9) &&
                        Ue(A[go](), 1, 40, 'Telemetry transmission failed, some telemetry will be lost: ' + Qr(V), {
                          exception: $e(V),
                        })
                    }
                  return Q
                }),
                (A._doTeardown = function (E, B) {
                  A.onunloadFlush(), id(f, !1), be()
                }),
                (A[Th] = function (E, B, Y) {
                  Ue(A[go](), 2, 26, 'Failed to send telemetry.', { message: B }), A._buffer && A._buffer[f0](E)
                }),
                (A[vO] = function (E, B) {
                  for (var Y = [], Q = [], me = B.errors.reverse(), ge = 0, se = me; ge < se.length; ge++) {
                    var V = se[ge],
                      ie = E.splice(V.index, 1)[0]
                    ee(V.statusCode) ? Q[xd](ie) : Y[xd](ie)
                  }
                  E[Pt] > 0 && A[wC](E, B[AC]),
                    Y[Pt] > 0 && A[Th](Y, te(null, ['partial success', B[AC], 'of', B.itemsReceived].join(' '))),
                    Q[Pt] > 0 &&
                      (bt(Q),
                      Ue(
                        A[go](),
                        2,
                        40,
                        'Partial success. Delivered: ' +
                          E[Pt] +
                          ', Failed: ' +
                          Y[Pt] +
                          '. Will retry to send ' +
                          Q[Pt] +
                          ' our of ' +
                          B[dxe] +
                          ' items'
                      ))
                }),
                (A[wC] = function (E, B) {
                  A._buffer && A._buffer[f0](E)
                }),
                (A._xdrOnLoad = function (E, B) {
                  var Y = bO(E)
                  if (E && (Y + '' == '200' || Y === '')) (n = 0), A[wC](B, 0)
                  else {
                    var Q = qe(Y)
                    Q && Q.itemsReceived && Q.itemsReceived > Q[AC] && !U ? A[vO](B, Q) : A[Th](B, O(E))
                  }
                })
              function fe(E) {
                return A._sample.isSampledIn(E)
              }
              function ce(E, B) {
                for (var Y, Q = null, me = null, ge = 0; me == null && ge < E[Pt]; )
                  (Q = E[ge]),
                    !L && Q === 1
                      ? Bv()
                        ? (me = N)
                        : zm() && (me = ye)
                      : Q === 2 && rd(B)
                      ? (me = Ye)
                      : Ca() && Q === 3 && (me = ne),
                    ge++
                return me ? ((Y = {}), (Y[fO] = me), Y) : null
              }
              function oe(E, B, Y, Q) {
                B === 200 && E && A._onSuccess(E, E[Pt]), Q && A[Th](E, Q)
              }
              function ae(E, B, Y) {
                var Q = function (se, V, ie) {
                    return oe(B, se, V, ie)
                  },
                  me = je(B),
                  ge = E && E[fO]
                return ge && me ? (A._buffer[Px](B), ge(me, Q, !Y)) : null
              }
              function je(E) {
                var B
                if (Xe(E) && E[Pt] > 0) {
                  var Y = A._buffer[SC](E),
                    Q =
                      ((B = {}),
                      (B[gi] = Y),
                      (B.urlString = h),
                      (B.headers = u),
                      (B.disableXhrSync = L),
                      (B.disableFetchKeepAlive = !S),
                      (B[Mx] = E),
                      B)
                  return Q
                }
                return null
              }
              function Ye(E, B, Y) {
                return Ne(E, B, !1)
              }
              function Ze(E) {
                var B = E ? E[Pt] : 0
                return A[Eh].size() + B > v ? ((!f || f[EC]()) && A[kx](!0, null, 10), !0) : !1
              }
              function ke(E, B, Y, Q, me, ge) {
                var se = null
                if (
                  (A._appId || ((se = qe(ge)), se && se.appId && (A._appId = se.appId)),
                  (E < 200 || E >= 300) && E !== 0)
                ) {
                  if ((E === 301 || E === 307 || E === 308) && !st(Y)) {
                    A[Th](B, me)
                    return
                  }
                  !U && ee(E)
                    ? (bt(B), Ue(A[go](), 2, 40, '. Response code ' + E + '. Will retry to send ' + B[Pt] + ' items.'))
                    : A[Th](B, me)
                } else if (f && !f[EC]()) {
                  if (!U) {
                    var V = 10
                    bt(B, V),
                      Ue(
                        A[go](),
                        2,
                        40,
                        '. Offline - Response Code: '
                          .concat(E, '. Offline status: ')
                          .concat(!f.isOnline(), '. Will retry to send ')
                          .concat(B.length, ' items.')
                      )
                  }
                } else
                  st(Y),
                    E === 206 ? (se || (se = qe(ge)), se && !U ? A[vO](B, se) : A[Th](B, me)) : ((n = 0), A[wC](B, Q))
              }
              function st(E) {
                return c >= 10 ? !1 : !we(E) && E !== '' && E !== h ? ((h = E), ++c, !0) : !1
              }
              function tt(E, B, Y, Q) {
                try {
                  E(B, Y, Q)
                } catch {}
              }
              function ve(E, B) {
                var Y = function (me, ge, se) {
                  return oe(E, me, ge, se)
                }
                if (d) d(E, !1)
                else {
                  var Q = je(E)
                  ne(Q, Y, !B)
                }
              }
              function W(E, B) {
                var Y = ui(),
                  Q = h,
                  me = new Blob([E], { type: 'text/plain;charset=UTF-8' }),
                  ge = Y.sendBeacon(Q, me)
                return ge && B(200, {}, E), ge
              }
              function ne(E, B, Y) {
                var Q = E,
                  me = Q && Q[gi]
                if (gt(me) && me[Pt] > 0 && !W(me, B)) {
                  var ge = [],
                    se = Q[Mx]
                  if (se[Pt] > 0)
                    for (var V = 0; V < me[Pt]; V++) {
                      var ie = E[V],
                        re = A._buffer[SC](ie)
                      W(re, B) || ge[xd](ie)
                    }
                  ge[Pt] > 0 &&
                    (T && T(ge, !0),
                    Ue(A[go](), 2, 40, '. Failed to send telemetry with Beacon API, retried with normal sender.'))
                }
              }
              function ye(E, B, Y) {
                var Q = E,
                  me,
                  ge,
                  se,
                  V = new XMLHttpRequest(),
                  ie = h
                try {
                  V[vx] = !0
                } catch {}
                return (
                  V.open('POST', ie, !Y),
                  V[_O]('Content-type', 'application/json'),
                  Tx(ie) && V[_O](md[6], md[7]),
                  Ae(Si(u), function (re) {
                    V[_O](re, u[re])
                  }),
                  (V.onreadystatechange = function () {
                    var re = Q[Mx]
                    A._xhrReadyStateChange(V, re, re[Pt]), V.readyState === 4 && ge && ge(!0)
                  }),
                  (V.onerror = function (re) {
                    tt(B, 400, {}, te(V)), se && se(re)
                  }),
                  !Y &&
                    z &&
                    (me = ds(function (re, xe) {
                      ;(ge = re), (se = xe)
                    })),
                  V.send(E[gi]),
                  me
                )
              }
              function Te(E, B) {
                var Y = function (se, V, ie) {
                  return oe(E, se, V, ie)
                }
                if (Xe(E)) {
                  for (var Q = E[Pt], me = 0; me < E[Pt]; me++) Q += E[me][Pt]
                  var ge = je(E)
                  p + Q <= aYe
                    ? Ne(ge, Y, !0)
                    : Ca()
                    ? ne(ge, Y, !B)
                    : (T && T(E, !0),
                      Ue(A[go](), 2, 40, '. Failed to send telemetry with Beacon API, retried with xhrSender.'))
                }
              }
              function Ne(E, B, Y) {
                var Q,
                  me = h,
                  ge = E,
                  se = ge[gi],
                  V = new Blob([se], { type: 'application/json' }),
                  ie,
                  re,
                  xe,
                  Ie = new Headers(),
                  We = se[Pt],
                  ft = !1,
                  Et = !1
                Tx(me) && Ie.append(md[6], md[7]),
                  Ae(Si(u), function (Zt) {
                    Ie.append(Zt, u[Zt])
                  })
                var It = ((Q = { method: 'POST', headers: Ie, body: V }), (Q[vx] = !0), Q)
                Y && ((It.keepalive = !0), (ft = !0), (p += We))
                var Hn = new Request(me, It)
                try {
                  Hn[vx] = !0
                } catch {}
                !Y &&
                  z &&
                  (ie = ds(function (Zt, Er) {
                    ;(re = Zt), (xe = Er)
                  }))
                try {
                  qm(fetch(Hn), function (Zt) {
                    if ((Y && ((p -= We), (We = 0)), !Et))
                      if (((Et = !0), Zt.rejected)) tt(B, 400, {}, Zt.reason && Zt.reason.message), xe && xe(Zt.reason)
                      else {
                        var Er = Zt.value
                        Er.ok
                          ? qm(Er.text(), function (Rn) {
                              var wd = ge[Mx]
                              ke(Er.status, wd, Er.url, wd[Pt], Er.statusText, Rn.value || ''), re && re(!0)
                            })
                          : (tt(B, 400, {}, Er.statusText), re && re(!1))
                      }
                  })
                } catch (Zt) {
                  Et || (tt(B, 400, {}, $e(Zt)), xe && xe(Zt))
                }
                return ft && !Et && ((Et = !0), tt(B, 200, {}), re && re(!0)), ie
              }
              function qe(E) {
                try {
                  if (E && E !== '') {
                    var B = mo().parse(E)
                    if (
                      B &&
                      B.itemsReceived &&
                      B.itemsReceived >= B[AC] &&
                      B.itemsReceived - B.itemsAccepted === B.errors[Pt]
                    )
                      return B
                  }
                } catch (Y) {
                  Ue(A[go](), 1, 43, 'Cannot parse the response. ' + Qr(Y), { response: E })
                }
                return null
              }
              function bt(E, B) {
                if ((B === void 0 && (B = 1), !(!E || E[Pt] === 0))) {
                  var Y = A[Eh]
                  Y[f0](E), n++
                  for (var Q = 0, me = E; Q < me.length; Q++) {
                    var ge = me[Q]
                    Y[yd](ge)
                  }
                  Jt(B), qr()
                }
              }
              function Jt(E) {
                var B = 10,
                  Y
                if (n <= 1) Y = B
                else {
                  var Q = (Math.pow(2, n) - 1) / 2,
                    me = Math.floor(Math.random() * Q * B) + 1
                  ;(me = E * me), (Y = Math.max(Math.min(me, 3600), B))
                }
                var ge = wn() + Y * 1e3
                i = ge
              }
              function qr() {
                if (!a && !s) {
                  var E = i ? Math.max(0, i - wn()) : 0,
                    B = Math.max(H, E)
                  a = Ls(function () {
                    ;(a = null), A[kx](!0, null, 1)
                  }, B)
                }
              }
              function le() {
                a && a.cancel(), (a = null), (i = null)
              }
              function ee(E) {
                return (
                  E === 401 || E === 403 || E === 408 || E === 429 || E === 500 || E === 502 || E === 503 || E === 504
                )
              }
              function te(E, B) {
                return E ? 'XMLHttpRequest,Status:' + E.status + ',Response:' + bO(E) || E.response || '' : B
              }
              function N(E, B, Y) {
                var Q = E,
                  me = Bn(),
                  ge = new XDomainRequest(),
                  se = Q[gi]
                ;(ge.onload = function () {
                  var re = Q[Mx]
                  A._xdrOnLoad(ge, re)
                }),
                  (ge.onerror = function () {
                    tt(B, 400, {}, O(ge))
                  })
                var V = (me && me.location && me.location.protocol) || ''
                if (h.lastIndexOf(V, 0) !== 0) {
                  Ue(
                    A[go](),
                    2,
                    40,
                    ". Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol."
                  ),
                    A._buffer[bd]()
                  return
                }
                var ie = h.replace(/^(https?:)/, '')
                ge.open('POST', ie), ge.send(se)
              }
              function O(E, B) {
                return E ? 'XDomainRequest,Response:' + bO(E) || '' : B
              }
              function K() {
                var E = 'getNotifyMgr'
                return A.core[E] ? A.core[E]() : A.core._notificationManager
              }
              function G(E, B) {
                var Y = K()
                if (Y && Y[oz])
                  try {
                    Y[oz](E, B)
                  } catch (Q) {
                    Ue(A[go](), 1, 74, 'send request notification failed: ' + Qr(Q), { exception: $e(Q) })
                  }
              }
              function pe(E, B) {
                var Y = B.disableInstrumentationKeyValidation,
                  Q = we(Y) ? !1 : Y
                if (Q) return !0
                var me = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
                  ge = new RegExp(me)
                return ge.test(E)
              }
              function be() {
                ;(A[Ox] = null),
                  (A[Eh] = null),
                  (A._appId = null),
                  (A._sample = null),
                  (u = {}),
                  (f = null),
                  (n = 0),
                  (i = null),
                  (o = null),
                  (s = !1),
                  (a = null),
                  (l = null),
                  (c = 0),
                  (p = 0),
                  (d = null),
                  (m = null),
                  (h = null),
                  (g = null),
                  (v = 0),
                  (_ = !1),
                  (y = null),
                  (b = !1),
                  (x = null),
                  (P = Ch),
                  (U = !1),
                  (j = null),
                  (F = Ch),
                  (L = !1),
                  (S = !1),
                  (T = null),
                  xr(A, '_senderConfig', {
                    g: function () {
                      return Ek({}, Lxe)
                    },
                  })
              }
            }),
            r
          )
        }
        return (
          (e.constructEnvelope = function (r, n, i, o) {
            var s
            n !== r.iKey && !we(n) ? (s = uc(uc({}, r), { iKey: n })) : (s = r)
            var a = uYe[s.baseType] || az
            return a(i, s, o)
          }),
          e
        )
      })(ld))
  })
var lz = createGetter(() => {
  Mxe()
})
var EO,
  TO,
  Fxe = createGetter(() => {
    ;(EO = 'instrumentationKey'), (TO = 'connectionString')
  })
var Uxe = {}
defineProperties(Uxe, {
  AppInsightsCore: () => ud,
  ApplicationInsights: () => fYe,
  Sender: () => RC,
  SeverityLevel: () => cO,
  arrForEach: () => Ae,
  isNullOrUndefined: () => we,
  proxyFunctions: () => Sa,
  throwError: () => Cn,
})
function dYe(t) {
  return t && t > 0
}
var pYe,
  fYe,
  Bxe = createGetter(() => {
    fo()
    lz()
    vd()
    br()
    pt()
    Fxe()
    br()
    vd()
    lz()
    pYe = { diagnosticLogInterval: K1(dYe, 1e4) }
    fYe = (function () {
      function t(e) {
        var r = new ud(),
          n
        ;(we(e) || (we(e[EO]) && we(e[TO]))) && Cn('Invalid input configuration'),
          Wt(t, this, function (o) {
            xr(o, 'config', {
              g: function () {
                return n
              },
            }),
              s(),
              (o.initialize = s),
              (o.track = i),
              Sa(o, r, [
                'flush',
                'pollInternalLogs',
                'stopPollingInternalLogs',
                'unload',
                'getPlugin',
                'addPlugin',
                'evtNamespace',
                'addUnloadCb',
                'onCfgChange',
              ])
            function s() {
              var a = mn(e || {}, pYe)
              ;(n = a.cfg),
                r.addUnloadHook(
                  di(a, function () {
                    if (n[TO]) {
                      var l = vC(n[TO]),
                        c = l.ingestionendpoint
                      ;(n.endpointUrl = c ? c + Lu : n.endpointUrl), (n[EO] = l.instrumentationkey || n[EO])
                    }
                  })
                ),
                r.initialize(n, [new RC()])
            }
          })
        function i(o) {
          o && ((o.baseData = o.baseData || {}), (o.baseType = o.baseType || 'EventData')), r.track(o)
        }
      }
      return (t.__ieDyn = 1), t
    })()
  })
var qxe = handleExports(ju => {
  'use strict'
  var mYe =
      (ju && ju.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r)
            var i = Object.getOwnPropertyDescriptor(e, r)
            ;(!i || ('get' in i ? !e.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              }),
              Object.defineProperty(t, n, i)
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    hYe =
      (ju && ju.__setModuleDefault) ||
      (Object.create
        ? function (t, e) {
            Object.defineProperty(t, 'default', { enumerable: !0, value: e })
          }
        : function (t, e) {
            t.default = e
          }),
    gYe =
      (ju && ju.__importStar) ||
      function (t) {
        if (t && t.__esModule) return t
        var e = {}
        if (t != null) for (var r in t) r !== 'default' && Object.prototype.hasOwnProperty.call(t, r) && mYe(e, t, r)
        return hYe(e, t), e
      }
  Object.defineProperty(ju, '__esModule', { value: !0 })
  ju.appInsightsClientFactory = void 0
  var vYe = (vd(), handleEsModuleExports(lxe)),
    _Ye = CH(),
    yYe = async (t, e, r) => {
      let n
      try {
        let o = await Promise.resolve().then(() => gYe((Bxe(), handleEsModuleExports(Uxe))))
        if (
          ((n = new o.ApplicationInsights({
            instrumentationKey: t,
            disableAjaxTracking: !0,
            disableExceptionTracking: !0,
            disableFetchTracking: !0,
            disableCorrelationHeaders: !0,
            disableCookiesUsage: !0,
            autoTrackPageVisitTime: !1,
            emitLineDelimitedJson: !1,
            disableInstrumentationKeyValidation: !0,
          })),
          e)
        ) {
          n.config.extensionConfig = {}
          let s = { alwaysUseXhrOverride: !0, httpXHROverride: e }
          n.config.extensionConfig[vYe.BreezeChannelIdentifier] = s
        }
      } catch (o) {
        return Promise.reject(o)
      }
      return {
        logEvent: (o, s) => {
          let a = { ...s?.properties, ...s?.measurements }
          r?.length && _Ye.TelemetryUtil.applyReplacements(a, r),
            n?.track({
              name: o,
              data: a,
              baseType: 'EventData',
              baseData: { name: o, properties: s?.properties, measurements: s?.measurements },
            })
        },
        flush: async () => {
          n?.flush(!1)
        },
        dispose: async () =>
          new Promise(s => {
            n?.unload(
              !0,
              () => {
                s(), (n = void 0)
              },
              1e3
            )
          }),
      }
    }
  ju.appInsightsClientFactory = yYe
})
var Vxe = handleExports(Cd => {
  'use strict'
  var xYe =
      (Cd && Cd.__createBinding) ||
      (Object.create
        ? function (t, e, r, n) {
            n === void 0 && (n = r)
            var i = Object.getOwnPropertyDescriptor(e, r)
            ;(!i || ('get' in i ? !e.__esModule : i.writable || i.configurable)) &&
              (i = {
                enumerable: !0,
                get: function () {
                  return e[r]
                },
              }),
              Object.defineProperty(t, n, i)
          }
        : function (t, e, r, n) {
            n === void 0 && (n = r), (t[n] = e[r])
          }),
    bYe =
      (Cd && Cd.__setModuleDefault) ||
      (Object.create
        ? function (t, e) {
            Object.defineProperty(t, 'default', { enumerable: !0, value: e })
          }
        : function (t, e) {
            t.default = e
          }),
    dz =
      (Cd && Cd.__importStar) ||
      function (t) {
        if (t && t.__esModule) return t
        var e = {}
        if (t != null) for (var r in t) r !== 'default' && Object.prototype.hasOwnProperty.call(t, r) && xYe(e, t, r)
        return bYe(e, t), e
      }
  Object.defineProperty(Cd, '__esModule', { value: !0 })
  var uz = dz(require('os')),
    Hxe = dz(require('vscode')),
    EYe = dz(require('https')),
    TYe = ove(),
    SYe = sve(),
    jxe = CH(),
    CYe = l1e(),
    IYe = qxe()
  function Gxe() {
    return {
      sendPOST: (e, r) => {
        let n = {
          method: 'POST',
          headers: { ...e.headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(e.data) },
        }
        try {
          let i = EYe.request(e.urlString, n, o => {
            o.on('data', function (s) {
              r(o.statusCode ?? 200, o.headers, s.toString())
            }),
              o.on('error', function () {
                r(0, {})
              })
          })
          i.write(e.data, o => {
            o && r(0, {})
          }),
            i.end()
        } catch {
          r(0, {})
        }
      },
    }
  }
  var pz = class extends TYe.BaseTelemetryReporter {
    constructor(e, r) {
      let n = s => (0, IYe.appInsightsClientFactory)(s, Gxe(), r)
      jxe.TelemetryUtil.shouldUseOneDataSystemSDK(e) && (n = s => (0, CYe.oneDataSystemClientFactory)(s, Hxe, Gxe()))
      let i = { release: uz.release(), platform: uz.platform(), architecture: uz.arch() },
        o = new SYe.BaseTelemetrySender(e, n)
      if (e && e.indexOf('AIF-') === 0)
        throw new Error('AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions')
      super(o, Hxe, { additionalCommonProperties: jxe.TelemetryUtil.getAdditionalCommonProperties(i) })
    }
  }
  Cd.default = pz
})
var rbe = handleExports((U$t, mz) => {
  'use strict'
  var PYe = require('net'),
    PO = class extends Error {
      constructor(e) {
        super(`${e} is locked`)
      }
    },
    Ux = { old: new Set(), young: new Set() },
    NYe = 1e3 * 15,
    DO,
    tbe = t =>
      new Promise((e, r) => {
        let n = PYe.createServer()
        n.unref(),
          n.on('error', r),
          n.listen(t, () => {
            let { port: i } = n.address()
            n.close(() => {
              e(i)
            })
          })
      }),
    kYe = function* (t) {
      t && (yield* t), yield 0
    }
  mz.exports = async t => {
    let e
    t && (e = typeof t.port == 'number' ? [t.port] : t.port),
      DO === void 0 &&
        ((DO = setInterval(() => {
          ;(Ux.old = Ux.young), (Ux.young = new Set())
        }, NYe)),
        DO.unref && DO.unref())
    for (let r of kYe(e))
      try {
        let n = await tbe({ ...t, port: r })
        for (; Ux.old.has(n) || Ux.young.has(n); ) {
          if (r !== 0) throw new PO(r)
          n = await tbe({ ...t, port: r })
        }
        return Ux.young.add(n), n
      } catch (n) {
        if (!['EADDRINUSE', 'EACCES'].includes(n.code) && !(n instanceof PO)) throw n
      }
    throw new Error('No available ports found')
  }
  mz.exports.makeRange = (t, e) => {
    if (!Number.isInteger(t) || !Number.isInteger(e)) throw new TypeError('`from` and `to` must be integer numbers')
    if (t < 1024 || t > 65535) throw new RangeError('`from` must be between 1024 and 65535')
    if (e < 1024 || e > 65536) throw new RangeError('`to` must be between 1024 and 65536')
    if (e < t) throw new RangeError('`to` must be greater than or equal to `from`')
    return (function* (n, i) {
      for (let o = n; o <= i; o++) yield o
    })(t, e)
  }
})

var extensionExports = {}
defineProperties(extensionExports, { activate: () => activateExtension, createExtensionContext: () => createContext, onDeactivate: () => deactivateExtension })
module.exports = handleEsModuleExports(extensionExports)
var Bx = handleDefaultExports(requestLight())
i$().install()
var vscode = require('vscode')
var events = require('events')
class ErrorHandler {
  constructor() {
    this.listeners = []
    this.unexpectedErrorHandler = function (error) {
      setTimeout(() => {
        if (error.stack) {
          throw CodeExpectedError.isErrorNoTelemetry(error)
            ? new CodeExpectedError(error.message + '\n' + error.stack)
            : new Error(error.message + '\n' + error.stack)
        } else {
          throw error
        }
      }, 0)
    }
  }

  addListener(listener) {
    this.listeners.push(listener)
    return () => {
      this._removeListener(listener)
    }
  }

  emit(error) {
    this.listeners.forEach(listener => {
      listener(error)
    })
  }

  _removeListener(listener) {
    const index = this.listeners.indexOf(listener)
    if (index > -1) {
      this.listeners.splice(index, 1)
    }
  }

  setUnexpectedErrorHandler(handler) {
    this.unexpectedErrorHandler = handler
  }

  getUnexpectedErrorHandler() {
    return this.unexpectedErrorHandler
  }

  onUnexpectedError(error) {
    this.unexpectedErrorHandler(error)
    this.emit(error)
  }

  onUnexpectedExternalError(error) {
    this.unexpectedErrorHandler(error)
  }
}
var errorHandler = new ErrorHandler()
function handleUnexpectedError(error) {
  if (!isCancellationError(error)) {
    errorHandler.onUnexpectedError(error)
  }
}
var cancellationMessage = 'Canceled'
function isCancellationError(error) {
  return error instanceof CancellationError ? true : error instanceof Error && error.name === cancellationMessage && error.message === cancellationMessage
}
class CancellationError extends Error {
  constructor() {
    super(cancellationMessage)
    this.name = this.message
  }
}
function throwIllegalArgumentError(argument) {
  return argument ? new Error(`Illegal argument: ${argument}`) : new Error('Illegal argument')
}
class CodeExpectedError extends Error {
  constructor(message) {
    super(message)
    this.name = 'CodeExpectedError'
  }
  static fromError(error) {
    if (error instanceof CodeExpectedError) return error
    let newError = new CodeExpectedError()
    newError.message = error.message
    newError.stack = error.stack
    return newError
  }
  static isErrorNoTelemetry(error) {
    return error.name === 'CodeExpectedError'
  }
}

function binarySearch(array, predicate, start = 0, end = array.length) {
  let low = start,
    high = end
  while (low < high) {
    let mid = Math.floor((low + high) / 2)
    predicate(array[mid]) ? (low = mid + 1) : (high = mid)
  }
  return low - 1
}

class MonotonousArray {
  constructor(array) {
    this._array = array
    this._lastMonotonousIndex = 0
  }
  static {
    this.checkInvariants = false
  }
  findLastMonotonous(predicate) {
    if (MonotonousArray.checkInvariants) {
      if (this._previousPredicate) {
        for (let item of this._array)
          if (this._previousPredicate(item) && !predicate(item))
            throw new Error(
              'MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.'
            )
      }
      this._previousPredicate = predicate
    }
    let index = binarySearch(this._array, predicate, this._lastMonotonousIndex)
    this._lastMonotonousIndex = index + 1
    return index === -1 ? undefined : this._array[index]
  }
}
function filterTruthyValues(array) {
  return array.filter(item => !!item)
}
function shuffleArray(array, seed) {
  let random
  if (typeof seed == 'number') {
    let count = seed
    random = () => {
      let value = Math.sin(count++) * 179426549
      return value - Math.floor(value)
    }
  } else random = Math.random
  for (let i = array.length - 1; i > 0; i -= 1) {
    let j = Math.floor(random() * (i + 1)),
      temp = array[i]
    array[i] = array[j]
    array[j] = temp
  }
}
var comparison
;(comparisonFunctions => {
  function isLessThan(value) {
    return value < 0
  }
  comparisonFunctions.isLessThan = isLessThan
  function isLessThanOrEqual(value) {
    return value <= 0
  }
  comparisonFunctions.isLessThanOrEqual = isLessThanOrEqual
  function isGreaterThan(value) {
    return value > 0
  }
  comparisonFunctions.isGreaterThan = isGreaterThan
  function isNeitherLessOrGreaterThan(value) {
    return value === 0
  }
  comparisonFunctions.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan
  comparisonFunctions.greaterThan = 1
  comparisonFunctions.lessThan = -1
  comparisonFunctions.neitherLessOrGreaterThan = 0
})((comparison ||= {}))

function createComparator(transform, compare) {
  return (a, b) => compare(transform(a), transform(b))
}

var subtract = (a, b) => a - b

class Iterable {
  constructor(iterate) {
    this.iterate = iterate
  }
  static {
    this.empty = new Iterable(() => {})
  }
  forEach(action) {
    this.iterate(item => {
      action(item)
      return true
    })
  }
  toArray() {
    let array = []
    this.iterate(item => {
      array.push(item)
      return true
    })
    return array
  }
  filter(predicate) {
    return new Iterable(callback => this.iterate(item => (predicate(item) ? callback(item) : true)))
  }
  map(transform) {
    return new Iterable(callback => this.iterate(item => callback(transform(item))))
  }
  some(predicate) {
    let found = false
    this.iterate(item => {
      found = predicate(item)
      return !found
    })
    return found
  }
  findFirst(predicate) {
    let found
    this.iterate(item => {
      if (predicate(item)) {
        found = item
        return false
      }
      return true
    })
    return found
  }
  findLast(predicate) {
    let found
    this.iterate(item => {
      if (predicate(item)) {
        found = item
      }
      return true
    })
    return found
  }
  findLastMaxBy(compare) {
    let maxItem,
      isFirst = true
    this.iterate(item => {
      if (isFirst || comparison.isGreaterThan(compare(item, maxItem))) {
        isFirst = false
        maxItem = item
      }
      return true
    })
    return maxItem
  }
}

function groupBy(array, keySelector) {
  let groups = Object.create(null)
  for (let item of array) {
    let key = keySelector(item),
      group = groups[key]
    if (!group) {
      group = groups[key] = []
    }
    group.push(item)
  }
  return groups
}

class Resource {
  constructor(uri, value) {
    this.uri = uri
    this.value = value
  }
}

function isArray(variable) {
  return Array.isArray(variable)
}

var toStringTagSymbol
var ResourceMap = class {
  constructor(keySelectorOrMap, keySelector) {
    this[toStringTagSymbol] = 'ResourceMap'
    if (keySelectorOrMap instanceof ResourceMap) {
      this.map = new Map(keySelectorOrMap.map)
      this.toKey = keySelector ?? ResourceMap.defaultToKey
    } else if (isArray(keySelectorOrMap)) {
      this.map = new Map()
      this.toKey = keySelector ?? ResourceMap.defaultToKey
      for (let [key, value] of keySelectorOrMap) {
        this.set(key, value)
      }
    } else {
      this.map = new Map()
      this.toKey = keySelectorOrMap ?? ResourceMap.defaultToKey
    }
  }

  static {
    this.defaultToKey = key => key.toString()
  }
  set(key, value) {
    return this.map.set(this.toKey(key), new Resource(key, value)), this
  }
  get(key) {
    return this.map.get(this.toKey(key))?.value
  }
  has(key) {
    return this.map.has(this.toKey(key))
  }
  get size() {
    return this.map.size
  }
  clear() {
    this.map.clear()
  }
  delete(key) {
    return this.map.delete(this.toKey(key))
  }
  forEach(callback, thisArg) {
    if (typeof thisArg !== 'undefined') {
      callback = callback.bind(thisArg)
    }
    for (let [key, resource] of this.map) {
      callback(resource.value, resource.uri, this)
    }
  }
  *values() {
    for (let resource of this.map.values()) {
      yield resource.value
    }
  }
  *keys() {
    for (let resource of this.map.values()) {
      yield resource.uri
    }
  }
  *entries() {
    for (let resource of this.map.values()) {
      yield [resource.uri, resource.value]
    }
  }
  *[((toStringTagSymbol = Symbol.toStringTag), Symbol.iterator)]() {
    for (let [, resource] of this.map) {
      yield [resource.uri, resource.value]
    }
  }
}
var toStringTagSymbol
var ResourceSet = class {
constructor(keySelectorOrSet, keySelector) {
  this[toStringTagSymbol] = 'ResourceSet'
  if (!keySelectorOrSet || typeof keySelectorOrSet == 'function') {
    this._map = new ResourceMap(keySelectorOrSet)
  } else {
    this._map = new ResourceMap(keySelector)
    keySelectorOrSet.forEach(this.add, this)
  }
}
get size() {
  return this._map.size
}
add(resource) {
  return this._map.set(resource, resource), this
}
clear() {
  this._map.clear()
}
delete(resource) {
  return this._map.delete(resource)
}
forEach(callback, thisArg) {
  this._map.forEach((value, key) => callback.call(thisArg, key, key, this))
}
has(resource) {
  return this._map.has(resource)
}
entries() {
  return this._map.entries()
}
keys() {
  return this._map.keys()
}
values() {
  return this._map.keys()
}
[((toStringTagSymbol = Symbol.toStringTag), Symbol.iterator)]() {
  return this.keys()
}
}
var toStringTagSymbol
var LinkedMap = class {
  constructor() {
    this[toStringTagSymbol] = 'LinkedMap'
    this._map = new Map()
    this._head = undefined
    this._tail = undefined
    this._size = 0
    this._state = 0
  }
  clear() {
    this._map.clear()
    this._head = undefined
    this._tail = undefined
    this._size = 0
    this._state++
  }
  isEmpty() {
    return !this._head && !this._tail
  }
  get size() {
    return this._size
  }
  get first() {
    return this._head?.value
  }
  get last() {
    return this._tail?.value
  }
  has(key) {
    return this._map.has(key)
  }
  get(key, touch = 0) {
    let node = this._map.get(key)
    if (node) {
      if (touch !== 0) {
        this.touch(node, touch)
      }
      return node.value
    }
  }
  set(key, value, touch = 0) {
    let node = this._map.get(key)
    if (node) {
      node.value = value
      if (touch !== 0) {
        this.touch(node, touch)
      }
    } else {
      node = { key: key, value: value, next: undefined, previous: undefined }
      switch (touch) {
        case 0:
          this.addItemLast(node)
          break
        case 1:
          this.addItemFirst(node)
          break
        case 2:
          this.addItemLast(node)
          break
        default:
          this.addItemLast(node)
          break
      }
      this._map.set(key, node)
      this._size++
    }
    return this
  }
  delete(key) {
    return !!this.remove(key)
  }
  remove(key) {
    let node = this._map.get(key)
    if (node) {
      this._map.delete(key)
      this.removeItem(node)
      this._size--
      return node.value
    }
  }
  shift() {
    if (!this._head && !this._tail) return
    if (!this._head || !this._tail) throw new Error('Invalid list')
    let node = this._head
    this._map.delete(node.key)
    this.removeItem(node)
    this._size--
    return node.value
  }
  forEach(callback, thisArg) {
    let state = this._state
    let node = this._head
    while (node) {
      if (thisArg) {
        callback.bind(thisArg)(node.value, node.key, this)
      } else {
        callback(node.value, node.key, this)
      }
      if (this._state !== state) {
        throw new Error('LinkedMap got modified during iteration.')
      }
      node = node.next
    }
  }
  keys() {
    let linkedMap = this
    let state = this._state
    let node = this._head
    let iterator = {
      [Symbol.iterator]() {
        return iterator
      },
      next() {
        if (linkedMap._state !== state) {
          throw new Error('LinkedMap got modified during iteration.')
        }
        if (node) {
          let result = { value: node.key, done: false }
          node = node.next
          return result
        } else {
          return { value: undefined, done: true }
        }
      },
    }
    return iterator
  }
  values() {
    let linkedMap = this
    let state = this._state
    let node = this._head
    let iterator = {
      [Symbol.iterator]() {
        return iterator
      },
      next() {
        if (linkedMap._state !== state) {
          throw new Error('LinkedMap got modified during iteration.')
        }
        if (node) {
          let result = { value: node.value, done: false }
          node = node.next
          return result
        } else {
          return { value: undefined, done: true }
        }
      },
    }
    return iterator
  }
  entries() {
    let linkedMap = this
    let state = this._state
    let node = this._head
    let iterator = {
      [Symbol.iterator]() {
        return iterator
      },
      next() {
        if (linkedMap._state !== state) {
          throw new Error('LinkedMap got modified during iteration.')
        }
        if (node) {
          let result = { value: [node.key, node.value], done: false }
          node = node.next
          return result
        } else {
          return { value: undefined, done: true }
        }
      },
    }
    return iterator
  }
  [((toStringTagSymbol = Symbol.toStringTag), Symbol.iterator)]() {
    return this.entries()
  }

  trimOld(maxSize) {
    if (maxSize >= this.size) return
    if (maxSize === 0) {
      this.clear()
      return
    }
    let currentNode = this._head,
      currentSize = this.size
    for (; currentNode && currentSize > maxSize; ) {
      this._map.delete(currentNode.key), (currentNode = currentNode.next), currentSize--
    }
    this._head = currentNode
    this._size = currentSize
    if (currentNode) {
      currentNode.previous = undefined
    }
    this._state++
  }


  addItemFirst(item) {
    if (!this._head && !this._tail) {
      this._tail = item
    } else if (this._head) {
      item.next = this._head
      this._head.previous = item
    } else {
      throw new Error('Invalid list')
    }
    this._head = item
    this._state++
  }

  addItemLast(item) {
    if (!this._head && !this._tail) {
      this._head = item
    } else if (this._tail) {
      item.previous = this._tail
      this._tail.next = item
    } else {
      throw new Error('Invalid list')
    }
    this._tail = item
    this._state++
  }

  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = undefined
      this._tail = undefined
    } else if (item === this._head) {
      if (!item.next) throw new Error('Invalid list')
      item.next.previous = undefined
      this._head = item.next
    } else if (item === this._tail) {
      if (!item.previous) throw new Error('Invalid list')
      item.previous.next = undefined
      this._tail = item.previous
    } else {
      let nextNode = item.next,
        previousNode = item.previous
      if (!nextNode || !previousNode) throw new Error('Invalid list')
      nextNode.previous = previousNode
      previousNode.next = nextNode
    }
    item.next = undefined
    item.previous = undefined
    this._state++
  }

  touch(item, touchType) {
    if (!this._head || !this._tail) throw new Error('Invalid list')
    if (touchType === 1 || touchType === 2) {
      if (touchType === 1) {
        if (item === this._head) return
        let nextNode = item.next,
          previousNode = item.previous
        if (item === this._tail) {
          previousNode.next = undefined
          this._tail = previousNode
        } else {
          nextNode.previous = previousNode
          previousNode.next = nextNode
        }
        item.previous = undefined
        item.next = this._head
        this._head.previous = item
        this._head = item
        this._state++
      } else if (touchType === 2) {
        if (item === this._tail) return
        let nextNode = item.next,
          previousNode = item.previous
        if (item === this._head) {
          nextNode.previous = undefined
          this._head = nextNode
        } else {
          nextNode.previous = previousNode
          previousNode.next = nextNode
        }
        item.next = undefined
        item.previous = this._tail
        this._tail.next = item
        this._tail = item
        this._state++
      }
    }
  }

  toJSON() {
    let json = []
    this.forEach((value, key) => {
      json.push([key, value])
    })
    return json
  }

  fromJSON(json) {
    this.clear()
    for (let [key, value] of json) {
      this.set(key, value)
    }
  }
}
class LimitedLinkedMap extends LinkedMap {
  constructor(limit, ratio = 1) {
    super()
    this._limit = limit
    this._ratio = Math.min(Math.max(0, ratio), 1)
  }
  get limit() {
    return this._limit
  }
  set limit(value) {
    this._limit = value
    this.checkTrim()
  }
  get ratio() {
    return this._ratio
  }
  set ratio(value) {
    this._ratio = Math.min(Math.max(0, value), 1)
    this.checkTrim()
  }
  get(key, touchType = 2) {
    return super.get(key, touchType)
  }
  peek(key) {
    return super.get(key, 0)
  }
  set(key, value) {
    super.set(key, value, 2)
    this.checkTrim()
    return this
  }
  checkTrim() {
    if (this.size > this._limit) {
      this.trimOld(Math.round(this._limit * this._ratio))
    }
  }
}
class MultiMap {
  constructor() {
    this.map = new Map()
  }
  add(key, value) {
    let set = this.map.get(key)
    if (!set) {
      set = new Set()
      this.map.set(key, set)
    }
    set.add(value)
  }
  delete(key, value) {
    let set = this.map.get(key)
    if (set) {
      set.delete(value)
      if (set.size === 0) {
        this.map.delete(key)
      }
    }
  }
  forEach(key, callback) {
    let set = this.map.get(key)
    if (set) {
      set.forEach(callback)
    }
  }
  get(key) {
    let set = this.map.get(key)
    return set || new Set()
  }
}
function once(fn, cleanup) {
  let context = this,
    hasRun = false,
    result
  return function () {
    if (hasRun) return result
    hasRun = true
    if (cleanup) {
      try {
        result = fn.apply(context, arguments)
      } finally {
        cleanup()
      }
    } else {
      result = fn.apply(context, arguments)
    }
    return result
  }
}
var iterableUtils
;(utils => {
  function isIterable(item) {
    return item && typeof item == 'object' && typeof item[Symbol.iterator] == 'function'
  }
  utils.is = isIterable

  let emptyArray = Object.freeze([])
  function empty() {
    return emptyArray
  }
  utils.empty = empty

  function* single(item) {
    yield item
  }
  utils.single = single

  function wrap(item) {
    return isIterable(item) ? item : single(item)
  }
  utils.wrap = wrap

  function from(item) {
    return item || emptyArray
  }
  utils.from = from

  function* reverse(array) {
    for (let i = array.length - 1; i >= 0; i--) yield array[i]
  }
  utils.reverse = reverse

  function isEmpty(item) {
    return !item || item[Symbol.iterator]().next().done === true
  }
  utils.isEmpty = isEmpty

  function first(item) {
    return item[Symbol.iterator]().next().value
  }
  utils.first = first
  function some(array, predicate) {
    for (let item of array) if (predicate(item)) return true
    return false
  }
  utils.some = some

  function find(array, predicate) {
    for (let item of array) if (predicate(item)) return item
  }
  utils.find = find

  function* filter(array, predicate) {
    for (let item of array) if (predicate(item)) yield item
  }
  utils.filter = filter

  function* map(array, transform) {
    let index = 0
    for (let item of array) yield transform(item, index++)
  }
  utils.map = map

  function* concat(...arrays) {
    for (let array of arrays) yield* array
  }
  utils.concat = concat

  function reduce(array, reducer, initialValue) {
    let result = initialValue
    for (let item of array) result = reducer(result, item)
    return result
  }
  utils.reduce = reduce

  function* slice(array, start, end = array.length) {
    for (start < 0 && (start += array.length), end < 0 ? (end += array.length) : end > array.length && (end = array.length); start < end; start++) yield array[start]
  }
  utils.slice = slice

  function consume(array, count = Number.POSITIVE_INFINITY) {
    let result = []
    if (count === 0) return [result, array]
    let iterator = array[Symbol.iterator]()
    for (let i = 0; i < count; i++) {
      let next = iterator.next()
      if (next.done) return [result, utils.empty()]
      result.push(next.value)
    }
    return [
      result,
      {
        [Symbol.iterator]() {
          return iterator
        },
      },
    ]
  }
  utils.consume = consume
})((iterableUtils ||= {}))
let isInitialized = false;
let globalTracker = null;

class DisposableTracker {
  constructor() {
      this.livingDisposables = new Map();
      this.idx = 0;
  }

  getDisposableData(disposable) {
      let data = this.livingDisposables.get(disposable);
      if (!data) {
          data = { parent: null, source: null, isSingleton: false, value: disposable, idx: this.idx++ };
          this.livingDisposables.set(disposable, data);
      }
      return data;
  }

  trackDisposable(disposable) {
      let data = this.getDisposableData(disposable);
      if (!data.source) {
          data.source = new Error().stack;
      }
  }

  setParent(disposable, parent) {
      let data = this.getDisposableData(disposable);
      data.parent = parent;
  }

  markAsDisposed(disposable) {
      this.livingDisposables.delete(disposable);
  }

  markAsSingleton(disposable) {
      this.getDisposableData(disposable).isSingleton = true;
  }

  getRootParent(data, cache) {
      let root = cache.get(data);
      if (root) {
          return root;
      }
      root = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;
      cache.set(data, root);
      return root;
  }

  getTrackedDisposables() {
      let rootCache = new Map();
      return [...this.livingDisposables.entries()]
          .filter(([, data]) => data.source !== null && !this.getRootParent(data, rootCache).isSingleton)
          .flatMap(([disposable]) => disposable);
  }
  computeLeakingDisposables(maxLeaks = 10, disposables) {
    let leaks;
    if (disposables) {
        leaks = disposables;
    } else {
        let rootCache = new Map();
        let candidates = [...this.livingDisposables.values()].filter(
            data => data.source !== null && !this.getRootParent(data, rootCache).isSingleton
        );
        if (candidates.length === 0) {
            return;
        }
        let candidateSet = new Set(candidates.map(data => data.value));
        leaks = candidates.filter(data => !(data.parent && candidateSet.has(data.parent)));
        if (leaks.length === 0) {
            throw new Error('There are cyclic disposable chains!');
        }
    }
    if (!leaks) {
        return;
    }

    function getStackTrace(data) {
        function removeUnwantedLines(lines, unwantedLines) {
            while (lines.length > 0 && unwantedLines.some(unwanted => (typeof unwanted == 'string' ? unwanted === lines[0] : lines[0].match(unwanted)))) {
                lines.shift();
            }
        }
        let stackTrace = data.source
            .split('\n')
            .map(line => line.trim().replace('at ', ''))
            .filter(line => line !== '');
        removeUnwantedLines(stackTrace, ['Error', /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]);
        return stackTrace.reverse();
    }

    let stackTraceMap = new MultiMap();
    for (let leak of leaks) {
        let stackTrace = getStackTrace(leak);
        for (let i = 0; i <= stackTrace.length; i++) {
            stackTraceMap.add(stackTrace.slice(0, i).join('\n'), leak);
        }
    }

    leaks.sort(createComparator(leak => leak.idx, subtract));

    let details = '';
    let count = 0;
    for (let leak of leaks.slice(0, maxLeaks)) {
        count++;
        let stackTrace = getStackTrace(leak);
        let lines = [];
        for (let i = 0; i < stackTrace.length; i++) {
            let line = stackTrace[i];
            line = `(shared with ${stackTraceMap.get(stackTrace.slice(0, i + 1).join('\n')).size}/${leaks.length} leaks) at ${line}`;
            let others = stackTraceMap.get(stackTrace.slice(0, i).join('\n'));
            let groupedOthers = groupBy([...others].map(other => getStackTrace(other)[i]), line => line);
            delete groupedOthers[stackTrace[i]];
            for (let [otherLine, otherLeaks] of Object.entries(groupedOthers)) {
                lines.unshift(`    - stacktraces of ${otherLeaks.length} other leaks continue with ${otherLine}`);
            }
            lines.unshift(line);
        }
        details += `

==================== Leaking disposable ${count}/${leaks.length}: ${leak.value.constructor.name} ====================
${lines.join('\n')}
============================================================

`;
    }

    if (leaks.length > maxLeaks) {
        details += `

... and ${leaks.length - maxLeaks} more leaking disposables

`;
    }

    return { leaks: leaks, details: details };
  }
}

function setGlobalTracker(tracker) {
  globalTracker = tracker;
}

if (isInitialized) {
  let trackingKey = '__is_disposable_tracked__';
  setGlobalTracker(
    new (class {
      trackDisposable(disposable) {
        let stackTrace = new Error('Potentially leaked disposable').stack;
        setTimeout(() => {
          if (!disposable[trackingKey]) {
            console.log(stackTrace);
          }
        }, 3000);
      }
      setParent(disposable, parent) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[trackingKey] = true;
          } catch {}
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[trackingKey] = true;
          } catch {}
        }
      }
      markAsSingleton(disposable) {}
    })()
  );
}

function trackDisposable(disposable) {
  globalTracker?.trackDisposable(disposable);
  return disposable;
}

function markAsDisposed(disposable) {
  globalTracker?.markAsDisposed(disposable);
}

function setParent(disposable, parent) {
  globalTracker?.setParent(disposable, parent);
}

function setParentForAll(disposables, parent) {
  if (globalTracker) {
    for (let disposable of disposables) {
      globalTracker.setParent(disposable, parent);
    }
  }
}

function dispose(disposable) {
  if (iterableUtils.is(disposable)) {
    let errors = [];
    for (let item of disposable) {
      if (item) {
        try {
          item.dispose();
        } catch (error) {
          errors.push(error);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    if (errors.length > 1) {
      throw new AggregateError(errors, 'Encountered errors while disposing of store');
    }
    return Array.isArray(disposable) ? [] : disposable;
  } else if (disposable) {
    disposable.dispose();
    return disposable;
  }
}

function disposeAll(...disposables) {
  let disposable = createDisposable(() => dispose(disposables));
  setParentForAll(disposables, disposable);
  return disposable;
}

function createDisposable(disposeFunction) {
  let disposable = trackDisposable({
    dispose: once(() => {
      markAsDisposed(disposable);
      disposeFunction();
    }),
  });
  return disposable;
}

var DisposableStore = class {
  constructor() {
    this._toDispose = new Set()
    this._isDisposed = false
    trackDisposable(this)
  }
  static {
    this.DISABLE_DISPOSED_WARNING = false
  }
  dispose() {
    if (!this._isDisposed) {
      markAsDisposed(this)
      this._isDisposed = true
      this.clear()
    }
  }
  get isDisposed() {
    return this._isDisposed
  }
  clear() {
    if (this._toDispose.size !== 0) {
      try {
        dispose(this._toDispose)
      } finally {
        this._toDispose.clear()
      }
    }
  }
  add(disposable) {
    if (!disposable) return disposable
    if (disposable === this) throw new Error('Cannot register a disposable on itself!')
    setParent(disposable, this)
    if (this._isDisposed) {
      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(
          new Error(
            'Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!'
          ).stack
        )
      }
    } else {
      this._toDispose.add(disposable)
    }
    return disposable
  }
  delete(disposable) {
    if (disposable) {
      if (disposable === this) throw new Error('Cannot dispose a disposable on itself!')
      this._toDispose.delete(disposable)
      disposable.dispose()
    }
  }
  deleteAndLeak(disposable) {
    if (disposable && this._toDispose.has(disposable)) {
      this._toDispose.delete(disposable)
      setParent(disposable, null)
    }
  }
}

var Disposable = class {
  constructor() {
    this._store = new DisposableStore()
    trackDisposable(this)
    setParent(this._store, this)
  }
  static {
    this.None = Object.freeze({ dispose() {} })
  }
  dispose() {
    markAsDisposed(this)
    this._store.dispose()
  }
  _register(disposable) {
    if (disposable === this) throw new Error('Cannot register a disposable on itself!')
    return this._store.add(disposable)
  }
}

var DisposableMap = class {
  constructor() {
    this._store = new Map()
    this._isDisposed = false
    trackDisposable(this)
  }
  dispose() {
    markAsDisposed(this)
    this._isDisposed = true
    this.clearAndDisposeAll()
  }
  clearAndDisposeAll() {
    if (this._store.size) {
      try {
        dispose(this._store.values())
      } finally {
        this._store.clear()
      }
    }
  }
  has(key) {
    return this._store.has(key)
  }
  get size() {
    return this._store.size
  }
  get(key) {
    return this._store.get(key)
  }
  set(key, value, doNotDispose = false) {
    if (this._isDisposed) {
      console.warn(
        new Error(
          'Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!'
        ).stack
      )
    }
    if (!doNotDispose) {
      this._store.get(key)?.dispose()
    }
    this._store.set(key, value)
  }
  deleteAndDispose(key) {
    this._store.get(key)?.dispose()
    this._store.delete(key)
  }
  keys() {
    return this._store.keys()
  }
  values() {
    return this._store.values()
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]()
  }
}

var packageInfo = getPackageInfo()
var isDevBuild = packageInfo.buildType !== 'dev'
var isPreRelease = packageInfo.isPreRelease || !isDevBuild

function isString(value) {
  return typeof value == 'string'
}

function isStringArray(value) {
  return Array.isArray(value) && value.every(e => isString(e))
}

function isPlainObject(value) {
  return typeof value == 'object' && value !== null && !Array.isArray(value) && !(value instanceof RegExp) && !(value instanceof Date)
}

var extensionId = 'github.copilot'

var ConfigManager = class {
  getConfigMixedWithDefaults(setting) {
    if (this.isDefaultSettingOverwritten(setting)) {
      let configValue = this.getConfig(setting)
      return isPlainObject(configValue) && isPlainObject(setting.defaultValue) ? { ...setting.defaultValue, ...configValue } : configValue
    }
    return setting.defaultValue
  }
}

var defaultValuesCache

function getDefaultValues() {
  if (!defaultValuesCache) {
    defaultValuesCache = new Map()
    let settings = config.contributes.configuration.properties
    for (let key of Object.keys(settings)) typeof settings[key].default < 'u' && defaultValuesCache.set(key, settings[key].default)
  }
  return defaultValuesCache
}

function validateAndFormatSetting(settingId, defaultValue) {
  let actualDefaultValue = getDefaultValues().get(`${extensionId}.${settingId}`)
  if (typeof actualDefaultValue < 'u' && defaultValue !== actualDefaultValue)
    throw new Error(`The default value for setting ${settingId} is different in package.json and in code`)
  let dotIndex = settingId.indexOf('.'),
    prefix = settingId.substring(0, dotIndex)
  if (prefix !== 'editor' && prefix !== 'chat' && prefix !== 'advanced' && prefix !== 'notebook')
    throw new Error(`Unexpected setting section ${prefix} in setting ${settingId}`)
  let suffix = settingId.substring(dotIndex + 1)
  return { id: settingId, firstPart: prefix, secondPart: suffix, defaultValue: defaultValue }
}

var settings = {
  EnableCodeActions: validateAndFormatSetting('editor.enableCodeActions', !0),
  LocaleOverride: validateAndFormatSetting('chat.localeOverride', 'auto'),
  WelcomeMessage: validateAndFormatSetting('chat.welcomeMessage', 'first'),
  AuthProvider: validateAndFormatSetting('advanced.authProvider', 'github'),
  NotebookIterativeImproving: validateAndFormatSetting('notebook.iterativeImproving', !1),
  DebugOverrideProxyUrl: validateAndFormatSetting('advanced.debug.overrideProxyUrl', ''),
  DebugChatOverrideProxyUrl: validateAndFormatSetting('advanced.debug.chatOverrideProxyUrl', ''),
  DebugTestOverrideProxyUrl: validateAndFormatSetting('advanced.debug.testOverrideProxyUrl', ''),
  DebugOverrideEngine: validateAndFormatSetting('advanced.debug.overrideEngine', ''),
  DebugOverrideChatEngine: validateAndFormatSetting('advanced.debug.overrideChatEngine', 'gpt-3.5-turbo'),
  DebugOverrideChatMaxTokenNum: validateAndFormatSetting('advanced.debug.overrideChatMaxTokenNum', 0),
  DebugOverrideChatOffTopicModel: validateAndFormatSetting('advanced.debug.overrideChatOffTopicModel', ''),
  DebugOverrideChatOffTopicModelTokenizer: validateAndFormatSetting('advanced.debug.overrideChatOffTopicModelTokenizer', ''),
  DebugOverrideChatOffTopicModelThreshold: validateAndFormatSetting('advanced.debug.overrideChatOffTopicModelThreshold', 0),
  DebugOverrideLogLevels: validateAndFormatSetting('advanced.debug.overrideLogLevels', {}),
  DebugFilterLogCategories: validateAndFormatSetting('advanced.debug.filterLogCategories', []),
  DebugReportFeedback: validateAndFormatSetting('advanced.debug.reportFeedback', !1),
  DebugUseNodeFetcher: validateAndFormatSetting('advanced.debug.useNodeFetcher', !1),
  ConversationSlashCommandEnablements: validateAndFormatSetting('advanced.slashCommands', { '*': !1 }),
  ConversationVariablesEnablements: validateAndFormatSetting('advanced.variables', { '*': isPreRelease }),
  ConversationAdditionalPromptContext: validateAndFormatSetting('advanced.conversationAdditionalPromptContext', 'firstTurn'),
  ConversationLoggingEnabled: validateAndFormatSetting('advanced.conversationLoggingEnabled', !1),
  ConversationIntentDetection: validateAndFormatSetting('advanced.conversationIntentDetection', !1),
  KerberosServicePrincipal: validateAndFormatSetting('advanced.kerberosServicePrincipal', ''),
  AgentsEndpointUrl: validateAndFormatSetting('advanced.agentsEndpointUrl', 'https://api.githubcopilot.com'),
  EnableRemoteAgents: validateAndFormatSetting('advanced.enableRemoteAgents', !1),
  ExplainIntentRefer: validateAndFormatSetting('advanced.explain.refer', !0),
  FixUseGPT4InInlineChat: validateAndFormatSetting('advanced.fix.useGPT4InInlineChat', !1),
  WorkspaceNewFlowEnabled: validateAndFormatSetting('advanced.workspace.useNewFlow', !0),
  WorkspaceCodeSearchEnabled: validateAndFormatSetting('advanced.workspace.codeSearchEnabled', void 0),
  WorkspaceUseAdaEnabled: validateAndFormatSetting('advanced.workspace.useAda', void 0),
  WorkspaceExperimentalFileLimit: validateAndFormatSetting('advanced.workspace.experimental.fileLimit', 0),
  InlineChatStreaming: validateAndFormatSetting('advanced.inlineChatStreaming', 'progressive'),
}
var LoggerManager = class {
    constructor(e, r) {
      this.logTargets = e
      this.configurationService = r
      this.loggers = new Map()
      this.promptResponseLoggers = new Map()
      this.myLogTarget = {
        logIt: (n, i, ...o) => {
          this.logTargets.forEach(s => s.logIt(n, i, ...o))
        },
      }
    }
    get defaultLogger() {
      return this.getLogger('extension')
    }
    getLogger(e) {
      return LoggerManager._getLogger(e, this.loggers, r => new Logger(r, this.myLogTarget, this.configurationService))
    }
    getPromptResponseLogger(e) {
      return LoggerManager._getLogger(e, this.promptResponseLoggers, r => new ConversationLogger(r, this.myLogTarget, this.configurationService))
    }
    registerAppender(e) {
      return (
        this.logTargets.push(e),
        createDisposable(() => {
          let r = this.logTargets.indexOf(e)
          r !== -1 && this.logTargets.splice(r, 1)
        })
      )
    }
    static _getLogger(e, r, n) {
      let i = r.get(e)
      return typeof i > 'u' && ((i = n(e)), r.set(e, i)), i
    }
  }

var LogLevel = ((level => (
  (level[(level.DEBUG = 0)] = 'DEBUG'),
  (level[(level.INFO = 1)] = 'INFO'),
  (level[(level.WARN = 2)] = 'WARN'),
  (level[(level.ERROR = 3)] = 'ERROR'),
  level
))(LogLevel || {}))

var ConsoleLogger = class {
  logIt(level, message, ...args) {
    level === LogLevel.ERROR ? console.error(message, ...args) : level === LogLevel.WARN && console.warn(message, ...args)
  }
}

var OutputLogger = class {
  constructor(output) {
    this.output = output
  }
  logIt(level, message, ...args) {
    this.output.appendLine(`${message} ${args.map(stringifyValue)}`)
  }
}

var Logger = class {
  constructor(category, target, configurationService) {
    this.category = category
    this.target = target
    this.configurationService = configurationService
  }
  stringToLevel(levelString) {
    return LogLevel[levelString]
  }
  log(level, ...messages) {
    if (!this.shouldLog(level, this.category)) return
    let prefix = `[${this.category}]`
    this.target.logIt(level, prefix, ...messages)
  }
  shouldLog(level, category) {
    let filterCategories = this.configurationService.getConfig(settings.DebugFilterLogCategories)
    if (filterCategories.length > 0 && !filterCategories.includes(category)) return false
    let overrideLevels = this.configurationService.getConfig(settings.DebugOverrideLogLevels),
      effectiveLevel = this.stringToLevel(overrideLevels[this.category]) ?? this.stringToLevel(overrideLevels['*']) ?? 1
    return level >= effectiveLevel
  }
  debug(...messages) {
    this.log(LogLevel.DEBUG, ...messages)
  }
  info(...messages) {
    this.log(LogLevel.INFO, ...messages)
  }
  warn(...messages) {
    this.log(LogLevel.WARN, ...messages)
  }
  error(...messages) {
    this.log(LogLevel.ERROR, ...messages)
  }
  exception(exception, message) {
    let prefix = message ? `${message}: ` : '',
      error = exception instanceof Error ? exception : new Error('Non-error thrown: ' + exception)
    this.log(LogLevel.ERROR, `${prefix}${error.stack}`)
  }
}

var ConversationLogger = class extends Logger {
  logPrompt(prompt) {
    if (!this.conversationLoggingEnabled()) return
    let separator = `
---------------------------------
`
    super.info(
      separator +
        prompt
          .map(
            entry => `${entry.role.toUpperCase()}:
${entry.content}`
          )
          .join(separator) +
        separator
    )
  }
  logResponse(response) {
    if (!this.conversationLoggingEnabled()) return
    let separator = `
---------------------------------
`
    if (typeof response != 'string') {
      if (response.type !== 'success') {
        super.info(`${separator}RESPONSE FAILED DUE TO ${response.type}${separator}`)
        return
      }
      response = Array.isArray(response.value)
        ? response.value.length === 1
          ? response.value[0]
          : `${response.value.map(value => `<<${value}>>`).join(', ')}`
        : response.value
    }
    super.info(`${separator}ASSISTANT:
${response}${separator}`)
  }
  debug(message, ...args) {
    this.conversationLoggingEnabled() && super.debug(message, ...args)
  }
  info(message, ...args) {
    this.conversationLoggingEnabled() && super.info(message, ...args)
  }
  warn(message, ...args) {
    this.conversationLoggingEnabled() && super.warn(message, ...args)
  }
  error(message, ...args) {
    this.conversationLoggingEnabled() && super.error(message, ...args)
  }
  conversationLoggingEnabled() {
    return this.configurationService.getConfig(settings.ConversationLoggingEnabled)
  }
}

function stringifyValue(value) {
  switch (typeof value) {
    case 'object':
      return JSON.stringify(value)
    default:
      return String(value)
  }
}
var BuildInfo = class {
    isProduction() {
      return isDevBuild
    }
    isPreRelease() {
      return isPreRelease
    }
    getBuildType() {
      return packageInfo.buildType
    }
    getVersion() {
      return packageInfo.version
    }
    getBuild() {
      return packageInfo.build
    }
    getName() {
      return packageInfo.name
    }
    getEditorVersionHeaders() {
      return {
        'Editor-Version': this.getEditorInfo().format(),
        'Editor-Plugin-Version': this.getEditorPluginInfo().format(),
      }
    }
  }
var VersionInfo = class {
  constructor(name, version) {
    this.name = name
    this.version = version
  }
  format() {
    return `${this.name}/${this.version}`
  }
}
var Events = require('events')
var EventEmitter = class extends events {
  constructor() {
    super()
  }
  emit(eventName, ...args) {
    return super.emit(eventName, ...args)
  }
}
function createServiceIdentifier(name) {
  return { name: name, _serviceIdentifierBrand: true }
}
var InstanceAccessor = class {
  constructor(instances, base) {
    this.constructionStack = []
    this.instances = new Map()
    this.isSealed = false
    this.base = base
    let stack = new Error().stack?.split(`
`)
    if (stack) this.constructionStack.push(...stack.slice(1))
    if (instances) for (let [key, value] of instances) this.instances.set(key, value)
  }
  get(identifier) {
    let instance = this.tryGet(identifier)
    if (instance) return instance
    throw new Error(`No instance of ${getName(identifier)} has been registered.
${this}`)
  }
  safeGet(identifier) {
    return this.tryGet(identifier)
  }
  tryGet(identifier) {
    let instance = this.instances.get(identifier)
    if (instance) return instance
    if (this.base) return this.base.tryGet(identifier)
  }
  define(identifier, instance) {
    if (this.isSealed) throw new Error('This accessor is sealed and cannot be modified anymore.')
    let oldInstance = this.instances.get(identifier)
    this.instances.set(identifier, instance)
    return oldInstance
  }
  defineIfNotDefined(identifier, instanceCreator) {
    if (!(typeof this.tryGet(identifier) < 'u')) return this.define(identifier, instanceCreator())
  }
  seal() {
    this.isSealed = true
  }
  toString() {
    let result = `    Accessor created at:
`
    for (let line of this.constructionStack || [])
      result += `    ${line}
`
    return (result += this.base?.toString() ?? ''), result
  }
  get debug() {
    let debugInfo = {}
    for (let [identifier, instance] of this.instances) debugInfo[getName(identifier)] = instance
    return debugInfo
  }
}
function getName(identifier) {
  return identifier.name
}
var TokenHandler = class {
  constructor(eventEmitter, trackingId, optedIn = false) {
    this.trackingId = trackingId
    this.optedIn = optedIn
    this.setupUpdateOnToken(eventEmitter)
  }
  setupUpdateOnToken(eventEmitter) {
    eventEmitter.get(EventEmitter).on('onCopilotToken', token => {
      let optedIn = token.getTokenValue('rt') === '1',
        trackingId = token.getTokenValue('tid'),
        organizationsList = token.organization_list
      if (trackingId !== void 0) {
        this.trackingId = trackingId
        this.organizationsList = organizationsList?.toString()
        this.optedIn = optedIn
      }
    })
  }
}
var telemetryUrl = 'https://copilot-telemetry.githubusercontent.com/telemetry'
var UrlProvider = class {
  constructor(url = telemetryUrl) {
    this.url = url
  }
  getUrl() {
    return this.url
  }
}
var IMSTelemetryService = createServiceIdentifier('IMSTelemetryService')
var IGHTelemetryService = createServiceIdentifier('IGHTelemetryService')
var Config = class {
  constructor(variables, assignmentContext, features) {
    this.variables = variables
    this.assignmentContext = assignmentContext
    this.features = features
  }
  static createFallbackConfig(telemetryService, reason) {
    telemetryService.get(IGHTelemetryService).sendExpProblemTelemetry({ reason: reason })
    return this.createEmptyConfig()
  }
  static createEmptyConfig() {
    return new Config({}, '', '')
  }
  addToTelemetry(telemetry) {
    telemetry.properties['VSCode.ABExp.Features'] = this.features
    telemetry.properties['abexp.assignmentcontext'] = this.assignmentContext
  }
}
var util = handleDefaultExports(require('util'))
var HeaderContributorList = class {
  constructor() {
    this.contributors = []
  }
  add(contributor) {
    this.contributors.push(contributor)
  }
  remove(contributor) {
    let index = this.contributors.indexOf(contributor)
    if (index !== -1) this.contributors.splice(index, 1)
  }
  contributeHeaders(headers) {
    for (let contributor of this.contributors) contributor.contributeHeaderValues(headers)
  }
  size() {
    return this.contributors.length
  }
}
var ConnectionSettings = class {
  set rejectUnauthorized(value) {
    this._rejectUnauthorized = value
  }
  get rejectUnauthorized() {
    return this._rejectUnauthorized
  }
}
var HttpResponse = class {
  constructor(status, statusText, headers, getText, getJson, getBody) {
    this.status = status
    this.statusText = statusText
    this.headers = headers
    this.getText = getText
    this.getJson = getJson
    this.getBody = getBody
    this.ok = this.status >= 200 && this.status < 300
  }
  async text() {
    return this.getText()
  }
  async json() {
    return this.getJson()
  }
  async body() {
    return this.getBody()
  }
}
var timeout = 30 * 1e3
function sendRequest(context, endpoint, token, intent, requestId, payload, cancellation) {
  let buildInfo = context.get(BuildInfo),
    headers = {
      Authorization: util.format('Bearer %s', token),
      'X-Request-Id': requestId,
      'VScode-SessionId': buildInfo.sessionId,
      'VScode-MachineId': buildInfo.machineId,
      ...buildInfo.getEditorVersionHeaders(),
      ...(endpoint.getExtraHeaders ? endpoint.getExtraHeaders() : {}),
    }
  endpoint.interceptBody && endpoint.interceptBody(payload), context.get(HeaderContributorList).contributeHeaders(headers), intent && (headers['OpenAI-Intent'] = intent)
  let options = { method: 'POST', headers: headers, json: payload, timeout: timeout },
    telemetryService = context.get(IGHTelemetryService),
    connectionSettings = context.get(ConnectionSettings)
  if (cancellation) {
    let abortController = connectionSettings.makeAbortController()
    cancellation.onCancellationRequested(() => {
      telemetryService.sendTelemetry('networking.cancelRequest', TelemetryEvent.createAndMarkAsIssued({ headerRequestId: requestId })), abortController.abort()
    }),
      (options.signal = abortController.signal)
  }
  return connectionSettings.fetch(endpoint.url, options).catch(error => {
    if (
      error.code === 'ECONNRESET' ||
      error.code === 'ETIMEDOUT' ||
      error.code === 'ERR_HTTP2_INVALID_SESSION' ||
      error.message === 'ERR_HTTP2_GOAWAY_SESSION'
    )
      return telemetryService.sendTelemetry('networking.disconnectAll'), connectionSettings.disconnectAll().then(() => connectionSettings.fetch(endpoint.url, options))
    throw error
  })
}
var BaseExperimentFetcher = class {}
var DefaultExperimentFetcher = class extends BaseExperimentFetcher {
  async fetchExperiments(context, headers) {
    let connectionSettings = context.get(ConnectionSettings),
      response
    try {
      response = await connectionSettings.fetch('https://default.exp-tas.com/vscode/ab', { method: 'GET', headers: headers })
    } catch (error) {
      return Config.createFallbackConfig(context, `Error fetching ExP config: ${error}`)
    }
    if (!response.ok) return Config.createFallbackConfig(context, `ExP responded with ${response.status}`)
    let json = await response.json(),
      config = json.Configs.find(config => config.Id === 'vscode') ?? { Id: 'vscode', Parameters: {} },
      features = Object.entries(config.Parameters).map(([key, value]) => key + (value ? '' : 'cf'))
    return new Config(config.Parameters, json.AssignmentContext, features.join(';'))
  }
}
var EmptyExperimentFetcher = class extends BaseExperimentFetcher {
  async fetchExperiments(context, headers) {
    return Config.createEmptyConfig()
  }
}
var CopilotHeaders = {
  'X-Copilot-ClientTimeBucket': 'timeBucket',
  'X-Copilot-OverrideEngine': 'engine',
  'X-Copilot-Repository': 'repo',
  'X-Copilot-FileType': 'fileType',
  'X-Copilot-UserKind': 'userKind',
}
var FilterManager = class {
  constructor(filters) {
    this.filters = filters
    for (let [key, value] of Object.entries(this.filters)) if (value === '') delete this.filters[key]
  }
  extends(other) {
    for (let [key, value] of Object.entries(other.filters)) if (this.filters[key] !== value) return false
    return true
  }
  addToTelemetry(telemetry) {
    for (let [key, value] of Object.entries(this.filters)) {
      let header = CopilotHeaders[key]
      if (header !== undefined) telemetry.properties[header] = value
    }
  }
  stringify() {
    let keys = Object.keys(this.filters)
    keys.sort()
    return keys.map(key => `${key}:${this.filters[key]}`).join(';')
  }
  toHeaders() {
    return { ...this.filters }
  }
  withChange(key, value) {
    return new FilterManager({ ...this.filters, [key]: value })
  }
}
var PrefixManager = class {
  constructor(prefix) {
    this.prefix = prefix
  }
  getCurrentAndUpComingValues(context) {
    let currentValue = this.getValue(context),
      upcomingValues = this.getUpcomingValues(context)
    return [currentValue, upcomingValues]
  }
}
var FixedPrefixManager = class extends PrefixManager {
  getValue(context) {
    return this.prefix
  }
  getUpcomingValues(context) {
    return []
  }
}
var createFixedPrefixManager = t => new FixedPrefixManager(t)
var TimeBucketPrefixManager = class extends PrefixManager {
  constructor(prefix, fetchBeforeFactor = 0.5, anchor = new Date().setUTCHours(0, 0, 0, 0)) {
    super(prefix)
    this.prefix = prefix
    this.fetchBeforeFactor = fetchBeforeFactor
    this.anchor = anchor
  }
  setTimePeriod(timePeriod) {
    isNaN(timePeriod) ? (this.timePeriodLengthMs = undefined) : (this.timePeriodLengthMs = timePeriod)
  }
  setByCallBuckets(numBuckets) {
    isNaN(numBuckets) ? (this.numByCallBuckets = undefined) : (this.numByCallBuckets = numBuckets)
  }
  getValue(date) {
    return this.prefix + this.getTimePeriodBucketString(date) + (this.numByCallBuckets ? this.timeHash(date) : '')
  }
  getTimePeriodBucketString(date) {
    return this.timePeriodLengthMs ? this.dateToTimePartString(date) : ''
  }
  getUpcomingValues(date) {
    let values = [],
      timePeriodBucketStrings = this.getUpcomingTimePeriodBucketStrings(date),
      byCallBucketStrings = this.getUpcomingByCallBucketStrings()
    for (let timePeriodBucket of timePeriodBucketStrings)
      for (let byCallBucket of byCallBucketStrings)
        values.push(this.prefix + timePeriodBucket + byCallBucket)
    return values
  }
  getUpcomingTimePeriodBucketStrings(date) {
    if (this.timePeriodLengthMs === undefined) return ['']
    if ((date.getTime() - this.anchor) % this.timePeriodLengthMs < this.fetchBeforeFactor * this.timePeriodLengthMs)
      return [this.getTimePeriodBucketString(date)]
    {
      let nextDate = new Date(date.getTime() + this.timePeriodLengthMs)
      return [this.getTimePeriodBucketString(date), this.getTimePeriodBucketString(nextDate)]
    }
  }
  getUpcomingByCallBucketStrings() {
    return this.numByCallBuckets === undefined
      ? ['']
      : Array.from(Array(this.numByCallBuckets).keys()).map(num => num.toString())
  }
  timeHash(date) {
    return this.numByCallBuckets === undefined
      ? 0
      : (7883 * (date.getTime() % this.numByCallBuckets)) % this.numByCallBuckets
  }
  dateToTimePartString(date) {
    return this.timePeriodLengthMs === undefined
      ? ''
      : Math.floor((date.getTime() - this.anchor) / this.timePeriodLengthMs).toString()
  }
}
var clientTimeBucketHeader = 'X-Copilot-ClientTimeBucket'
var CurrentTimeProvider = class {
  now() {
    return new Date()
  }
}
var GranularitySelector = class {
  constructor(prefix, clock = new CurrentTimeProvider()) {
    this.specs = new Map()
    this.prefix = prefix
    this.clock = clock
    this.defaultGranularity = createFixedPrefixManager(prefix)
  }
  selectGranularity(extension) {
    for (let [spec, granularity] of this.specs.entries()) if (extension.extends(spec)) return granularity
    return this.defaultGranularity
  }
  update(extension, byCallBuckets, timePeriod) {
    if (((byCallBuckets = byCallBuckets > 1 ? byCallBuckets : NaN), (timePeriod = timePeriod > 0 ? timePeriod : NaN), isNaN(byCallBuckets) && isNaN(timePeriod))) this.specs.delete(extension)
    else {
      let granularity = new TimeBucketPrefixManager(this.prefix)
      isNaN(byCallBuckets) || granularity.setByCallBuckets(byCallBuckets), isNaN(timePeriod) || granularity.setTimePeriod(timePeriod * 3600 * 1e3), this.specs.set(extension, granularity)
    }
  }
  extendFilters(extension) {
    let granularity = this.selectGranularity(extension),
      [currentValue, upcomingValues] = granularity.getCurrentAndUpComingValues(this.clock.now())
    return { newFilterSettings: extension.withChange(clientTimeBucketHeader, currentValue), otherFilterSettingsToPrefetch: upcomingValues.map(value => extension.withChange(clientTimeBucketHeader, value)) }
  }
}
var ExperimentConfigFetcher = class {
  constructor(accessor) {
    this.accessor = accessor
    this.cache = new LimitedLinkedMap(200)
  }
  async fetchExpConfig(filter) {
    let cachedConfig = this.cache.get(filter.stringify())
    return (
      cachedConfig ||
        ((cachedConfig = new CachedConfigProducer(() => this.accessor.get(BaseExperimentFetcher).fetchExperiments(this.accessor, filter.toHeaders()), 1e3 * 60 * 60)),
        this.cache.set(filter.stringify(), cachedConfig)),
      cachedConfig.run()
    )
  }
  getCachedExpConfig(filter) {
    return this.cache.get(filter.stringify())?.value()
  }
}
var CachedConfigProducer = class {
  constructor(producer, expirationMs = 1 / 0) {
    this.producer = producer
    this.expirationMs = expirationMs
  }
  async run() {
    return (
      this.promise === void 0 &&
        ((this.promise = this.producer()),
        this.storeResult(this.promise).then(() => {
          this.expirationMs < 1 / 0 &&
            this.promise !== void 0 &&
            setTimeout(() => (this.promise = void 0), this.expirationMs)
        })),
      this.promise
    )
  }
  async storeResult(promise) {
    try {
      this.result = await promise
    } finally {
      this.result === void 0 && (this.promise = void 0)
    }
  }
  value() {
    return this.result
  }
}
var ExperimentManager = class {
  constructor(accessor) {
    this.accessor = accessor
    this.staticFilters = {}
    this.dynamicFilters = {}
    this.upcomingDynamicFilters = {}
    this.assignments = new ExperimentConfigFetcher(this.accessor)
  }
  static {
    this.upcomingDynamicFilterCheckDelayMs = 20
  }
  static {
    this.upcomingTimeBucketMinutes = 5 + Math.floor(Math.random() * 11)
  }
  registerStaticFilters(filters) {
    Object.assign(this.staticFilters, filters)
  }
  registerDynamicFilter(filterName, filterFunction) {
    this.dynamicFilters[filterName] = filterFunction
  }
  getDynamicFilterValues() {
    let dynamicFilterValues = {}
    for (let [filterName, filterFunction] of Object.entries(this.dynamicFilters)) dynamicFilterValues[filterName] = filterFunction()
    return dynamicFilterValues
  }
  async getAssignment(variableName, additionalFilters = {}, telemetryData) {
    let granularityDirectory = this.getGranularityDirectory(),
      filterSettings = this.makeFilterSettings(additionalFilters),
      extendedFilters = granularityDirectory.extendFilters(filterSettings),
      expConfig = await this.getExpConfig(extendedFilters.newFilterSettings)
    granularityDirectory.update(filterSettings, +(expConfig.variables.copilotbycallbuckets ?? NaN), +(expConfig.variables.copilottimeperiodsizeinh ?? NaN))
    let newExtendedFilters = granularityDirectory.extendFilters(filterSettings),
      newFilterSettings = newExtendedFilters.newFilterSettings,
      newExpConfig = await this.getExpConfig(newFilterSettings),
      delayPromise = new Promise(resolve => setTimeout(resolve, ExperimentManager.upcomingDynamicFilterCheckDelayMs))
    for (let filterSetting of newExtendedFilters.otherFilterSettingsToPrefetch)
      delayPromise = delayPromise.then(async () => {
        await new Promise(resolve => setTimeout(resolve, ExperimentManager.upcomingDynamicFilterCheckDelayMs)), this.getExpConfig(filterSetting)
      })
    this.prepareForUpcomingFilters(newFilterSettings)
    if (telemetryData) telemetryData.filtersAndExp = { exp: newExpConfig, filters: newFilterSettings }
    return newExpConfig.variables[variableName]
  }
  getGranularityDirectory() {
    if (!this.granularityDirectory) {
      let machineId = this.accessor.get(BuildInfo).machineId
      this.granularityDirectory = new GranularitySelector(machineId)
    }
    return this.granularityDirectory
  }
  makeFilterSettings(additionalFilters) {
    return new FilterManager({ ...this.staticFilters, ...this.getDynamicFilterValues(), ...additionalFilters })
  }
  async getExpConfig(filterSettings) {
    try {
      return this.assignments.fetchExpConfig(filterSettings)
    } catch (error) {
      return Config.createFallbackConfig(this.accessor, `Error fetching ExP config: ${error}`)
    }
  }
  async prepareForUpcomingFilters(filterSettings) {
    if (!(new Date().getMinutes() < 60 - ExperimentManager.upcomingTimeBucketMinutes))
      for (let [filterName, filterFunction] of Object.entries(this.upcomingDynamicFilters))
        await new Promise(resolve => setTimeout(resolve, ExperimentManager.upcomingDynamicFilterCheckDelayMs)),
          this.getExpConfig(filterSettings.withChange(filterName, filterFunction()))
  }
  async fastCancellation() {
    return (await this.getAssignment('copilotoverridefastcancellation')) ?? true
  }
  async chatExpModel() {
    return (await this.getAssignment('copilotchatexpmodel')) ?? ''
  }
  async chatMaxNumTokens() {
    return (await this.getAssignment('copilotchatmaxnumtokens')) ?? 0
  }
  async chatOffTopicModel() {
    return (await this.getAssignment('copilotchatofftopicmodel')) ?? ''
  }
  async chatOffTopicModelTokenizer() {
    return (await this.getAssignment('copilotchatofftopicmodeltokenizer')) ?? ''
  }
  async chatOffTopicModelThreshold() {
    return (await this.getAssignment('copilotchatofftopicmodelthreshold')) ?? 0
  }
  async addExpAndFilterToTelemetry(telemetryData) {
    let filterSettings = this.makeFilterSettings({})
    telemetryData.filtersAndExp = { filters: filterSettings, exp: await this.getExpConfig(filterSettings) }
  }
}
var generateUUID = (function () {
  if (typeof crypto == 'object' && typeof crypto.randomUUID == 'function') return crypto.randomUUID.bind(crypto)
  let randomFunc
  typeof crypto == 'object' && typeof crypto.getRandomValues == 'function'
    ? (randomFunc = crypto.getRandomValues.bind(crypto))
    : (randomFunc = function (array) {
        for (let i = 0; i < array.length; i++) array[i] = Math.floor(Math.random() * 256)
        return array
      })
  let byteArray = new Uint8Array(16),
    hexArray = []
  for (let i = 0; i < 256; i++) hexArray.push(i.toString(16).padStart(2, '0'))
  return function () {
    randomFunc(byteArray), (byteArray[6] = (byteArray[6] & 15) | 64), (byteArray[8] = (byteArray[8] & 63) | 128)
    let index = 0,
      uuid = ''
    return (
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += '-'),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += '-'),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += '-'),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += '-'),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      (uuid += hexArray[byteArray[index++]]),
      uuid
    )
  }
})()
var TelemetryEvent = class Event {
  static {
    this.keysExemptedFromSanitization = ['abexp.assignmentcontext', 'VSCode.ABExp.Features']
  }
  constructor(properties, measurements, issuedTime) {
    this.properties = properties;
    this.measurements = measurements;
    this.issuedTime = issuedTime;
  }
  static createAndMarkAsIssued(properties, measurements) {
    return new Event(properties || {}, measurements || {}, Date.now())
  }
  extendedBy(properties, measurements) {
    let newProperties = { ...this.properties, ...properties },
      newMeasurements = { ...this.measurements, ...measurements },
      newEvent = new Event(newProperties, newMeasurements, this.issuedTime)
    newEvent.displayedTime = this.displayedTime;
    newEvent.filtersAndExp = this.filtersAndExp;
    return newEvent;
  }
  markAsDisplayed() {
    if(this.displayedTime === undefined) {
      this.displayedTime = Date.now();
    }
  }
  async extendWithExpTelemetry(experimentManager) {
    if(!this.filtersAndExp) {
      await experimentManager.get(ExperimentManager).addExpAndFilterToTelemetry(this);
    }
    this.filtersAndExp.exp.addToTelemetry(this);
    this.filtersAndExp.filters.addToTelemetry(this);
  }
  extendWithEditorAgnosticFields(buildInfo) {
    let info = buildInfo.get(BuildInfo);
    this.properties.editor_version = info.getEditorInfo().format();
    this.properties.editor_plugin_version = info.getEditorPluginInfo().format();
    this.properties.client_machineid = info.machineId;
    this.properties.client_sessionid = info.sessionId;
    this.properties.copilot_version = `copilot/${info.getVersion()}`;
    this.properties.common_extname = info.getEditorPluginInfo().name;
    this.properties.common_extversion = info.getEditorPluginInfo().version;
    this.properties.common_vscodeversion = info.getEditorInfo().format();
  }
  extendWithConfigProperties(configManager, buildInfo, tokenHandler) {
    let info = configManager.get(BuildInfo),
      config = configManager.get(ConfigManager).dumpConfig();
    config['copilot.build'] = info.getBuild();
    config['copilot.buildType'] = info.getBuildType();
    let token = configManager.get(TokenHandler);
    if(token.trackingId) {
      config['copilot.trackingId'] = token.trackingId;
    }
    if(token.organizationsList) {
      config.organizations_list = token.organizationsList;
    }
    this.properties = { ...this.properties, ...config };
  }
  extendWithRequestId(request) {
    let requestId = {
      completionId: request.completionId,
      created: request.created.toString(),
      headerRequestId: request.headerRequestId,
      serverExperiments: request.serverExperiments,
      deploymentId: request.deploymentId,
    }
    this.properties = { ...this.properties, ...requestId };
  }
  static {
    this.keysToRemoveFromStandardTelemetryHack = [
      'gitRepoHost',
      'gitRepoName',
      'gitRepoOwner',
      'gitRepoUrl',
      'gitRepoPath',
      'repo',
      'request_option_nwo',
      'userKind',
    ]
  }
  static maybeRemoveRepoInfoFromPropertiesHack(shouldRemove, properties) {
    if (shouldRemove) return properties;
    let newProperties = {};
    for (let key in properties) {
      if(!Event.keysToRemoveFromStandardTelemetryHack.includes(key)) {
        newProperties[key] = properties[key];
      }
    }
    return newProperties;
  }
  sanitizeKeys() {
    this.properties = Event.sanitizeKeys(this.properties);
    this.measurements = Event.sanitizeKeys(this.measurements);
  }
  static sanitizeKeys(properties) {
    properties = properties || {};
    let sanitizedProperties = {};
    for (let key in properties) {
      let sanitizedKey = Event.keysExemptedFromSanitization.includes(key) ? key : key.replace(/\./g, '_');
      sanitizedProperties[sanitizedKey] = properties[key];
    }
    return sanitizedProperties;
  }
  updateTimeSinceIssuedAndDisplayed() {
    let timeSinceIssued = Date.now() - this.issuedTime;
    this.measurements.timeSinceIssuedMs = timeSinceIssued;
    if(this.displayedTime !== undefined) {
      let timeSinceDisplayed = Date.now() - this.displayedTime;
      this.measurements.timeSinceDisplayedMs = timeSinceDisplayed;
    }
  }
  async makeReadyForSending(configManager, shouldIncludeExp) {
    this.extendWithConfigProperties(configManager);
    this.extendWithEditorAgnosticFields(configManager);
    this.sanitizeKeys();
    if(shouldIncludeExp === 'IncludeExp') {
      await this.extendWithExpTelemetry(configManager);
    }
    this.updateTimeSinceIssuedAndDisplayed();
    for (let key in this.properties) {
      if(this.properties[key] === undefined) {
        delete this.properties[key];
      }
    }
    addCommonProperties(configManager, this.properties);
  }
}
function addCommonProperties(configManager, properties) {
  properties.unique_id = generateUUID()
  let buildInfo = configManager.get(BuildInfo)
  properties.common_extname = buildInfo.getEditorPluginInfo().name
  properties.common_extversion = buildInfo.getEditorPluginInfo().version
  properties.common_vscodeversion = buildInfo.getEditorInfo().format()
}
var openURL = handleOpen()
var BaseUrlOpener = class {}
var URLHandler = class {
    async open(url) {
      await openURL(url)
    }
  }
var NotificationHandler = class {}
var certificateErrorCodes = ['UNABLE_TO_VERIFY_LEAF_SIGNATURE', 'CERT_SIGNATURE_FAILURE']
var CertificateErrorHandler = class {
  constructor() {
    this.notifiedErrorCodes = []
  }
  async notifyUser(configManager, error) {
    if (certificateErrorCodes.includes(error.code) && !this.didNotifyBefore(error.code)) {
      this.displayCertificateErrorNotification(configManager, error)
      this.notifiedErrorCodes.push(error.code)
    }
  }
  displayCertificateErrorNotification(configManager, error) {
    let helpURL = 'https://aka.ms/copilot-ssc',
      errorMessage = "Your current Copilot license doesn't support proxy connections with self-signed certificates."
    configManager
      .get(LoggerManager)
      .getLogger('certificates')
      .error(`${errorMessage} Please visit ${helpURL} to learn more. Original cause: ${JSON.stringify(error)}`)
    this.showCertificateWarningMessage(configManager, errorMessage, helpURL)
  }
  showCertificateWarningMessage(configManager, errorMessage, helpURL) {
    let action = { title: 'Learn more' }
    configManager.get(NotificationHandler)
      .showWarningMessage(errorMessage, action)
      .then(selectedAction => {
        if (selectedAction?.title === action.title) {
          configManager.get(BaseUrlOpener).open(helpURL)
        }
      })
  }
  didNotifyBefore(errorCode) {
    return this.notifiedErrorCodes.indexOf(errorCode) !== -1
  }
}
function formatStringWithArguments(string, args) {
  let result
  if (args.length === 0) {
    result = string
  } else {
    result = string.replace(/\{(\d+)\}/g, function (match, group) {
      let index = group[0]
      return typeof args[index] < 'u' ? args[index] : match
    })
  }
  return result
}
function format(t, string, ...args) {
  return formatStringWithArguments(string, args)
}
var defaultLocale = 'en',
isWindows = false,
isMac = false,
isLinux = false,
isSnap = false,
isNode = false,
isBrowser = false,
isElectron = false,
isTouchDevice = false,
isCI = false,
isMobile = false,
locale,
language = defaultLocale,
osLocale = defaultLocale,
translationsConfigFile,
userAgent,
globalContext = globalThis,
processObject;

if (typeof globalContext.vscode < 'undefined' && typeof globalContext.vscode.process < 'undefined') {
  processObject = globalContext.vscode.process;
} else if (typeof process < 'undefined') {
  processObject = process;
}

isElectron = typeof processObject?.versions?.electron == 'string';
var isRenderer = isElectron && processObject?.type === 'renderer';

if (typeof navigator == 'object' && !isRenderer) {
  userAgent = navigator.userAgent;
  isWindows = userAgent.indexOf('Windows') >= 0;
  isMac = userAgent.indexOf('Macintosh') >= 0;
  isTouchDevice = (userAgent.indexOf('Macintosh') >= 0 || userAgent.indexOf('iPad') >= 0 || userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  isLinux = userAgent.indexOf('Linux') >= 0;
  isMobile = userAgent?.indexOf('Mobi') >= 0;
  isBrowser = true;
  locale = defaultLocale;
  language = locale;
  osLocale = navigator.language;
} else if (typeof processObject == 'object') {
  isWindows = processObject.platform === 'win32';
  isMac = processObject.platform === 'darwin';
  isLinux = processObject.platform === 'linux';
  isSnap = isLinux && !!processObject.env.SNAP && !!processObject.env.SNAP_REVISION;
  isElectron = isElectron;
  isCI = !!processObject.env.CI || !!processObject.env.BUILD_ARTIFACTSTAGINGDIRECTORY;
  locale = defaultLocale;
  language = defaultLocale;

  let nlsConfig = processObject.env.VSCODE_NLS_CONFIG;
  if (nlsConfig) {
    try {
      let parsedConfig = JSON.parse(nlsConfig),
      availableLanguage = parsedConfig.availableLanguages['*'];
      locale = parsedConfig.locale;
      osLocale = parsedConfig.osLocale;
      language = availableLanguage || defaultLocale;
      translationsConfigFile = parsedConfig._translationsConfigFile;
    } catch {}
    isNode = true;
  }
} else {
  console.error('Unable to resolve platform.');
}
var platform = 0;
isMac ? (platform = 1) : isWindows ? (platform = 3) : isLinux && (platform = 2);
var isWindowsFlag = isWindows,
  isMacFlag = isMac,
  isLinuxFlag = isLinux;
var isNodeFlag = isNode;
var isBrowserFlag = isBrowser,
  isImportScriptsAvailable = isBrowser && typeof global.importScripts == 'function',
  globalOrigin = isImportScriptsAvailable ? global.origin : undefined;
var userAgentString = userAgent,
  languageString = language,
  languageObject;

((languageObjectParam) => {
  function getValue() {
    return languageString;
  }
  languageObjectParam.value = getValue;
  function isDefaultVariant() {
    return languageString.length === 2 ? languageString === 'en' : languageString.length >= 3 ? languageString[0] === 'e' && languageString[1] === 'n' && languageString[2] === '-' : false;
  }
  languageObjectParam.isDefaultVariant = isDefaultVariant;
  function isDefault() {
    return languageString === 'en';
  }
  languageObjectParam.isDefault = isDefault;
})((languageObject ||= {}));

var isPostMessageAvailable = typeof global.postMessage == 'function' && !global.importScripts,
  scheduleAsyncWork = (() => {
    if (isPostMessageAvailable) {
      let tasks = [];
      global.addEventListener('message', event => {
        if (event.data && event.data.vscodeScheduleAsyncWork)
          for (let index = 0, length = tasks.length; index < length; index++) {
            let task = tasks[index];
            if (task.id === event.data.vscodeScheduleAsyncWork) {
              tasks.splice(index, 1), task.callback();
              return;
            }
          }
      });
      let idCounter = 0;
      return callback => {
        let id = ++idCounter;
        tasks.push({ id: id, callback: callback }), global.postMessage({ vscodeScheduleAsyncWork: id }, '*');
      };
    }
    return callback => setTimeout(callback);
  })();
  var isChrome = !!(userAgentString && userAgentString.indexOf('Chrome') >= 0),
  isFirefox = !!(userAgentString && userAgentString.indexOf('Firefox') >= 0),
  isSafari = !!(!isChrome && userAgentString && userAgentString.indexOf('Safari') >= 0),
  isEdge = !!(userAgentString && userAgentString.indexOf('Edg/') >= 0),
  isAndroid = !!(userAgentString && userAgentString.indexOf('Android') >= 0);
var platformInfo,
  vscodeGlobal = globalThis.vscode;
if (typeof vscodeGlobal < 'u' && typeof vscodeGlobal.process < 'u') {
  let process = vscodeGlobal.process;
  platformInfo = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.cwd();
    },
  };
} else
  typeof process < 'u'
    ? (platformInfo = {
        get platform() {
          return process.platform;
        },
        get arch() {
          return process.arch;
        },
        get env() {
          return process.env;
        },
        cwd() {
          return process.env.VSCODE_CWD || process.cwd();
        },
      })
    : (platformInfo = {
        get platform() {
          return isWindowsFlag ? 'win32' : isMacFlag ? 'darwin' : 'linux';
        },
        get arch() {},
        get env() {
          return {};
        },
        cwd() {
          return '/';
        },
      });
var getCurrentWorkingDirectory = platformInfo.cwd,
  getEnvironment = platformInfo.env,
  getPlatform = platformInfo.platform,
  getArchitecture = platformInfo.arch;
var upperCaseA = 65,
  lowerCaseA = 97,
  upperCaseZ = 90,
  lowerCaseZ = 122,
  dot = 46,
  forwardSlash = 47,
  backSlash = 92,
  colon = 58,
  questionMark = 63,
  InvalidArgTypeError = class extends Error {
    constructor(arg, expectedType, receivedValue) {
      let notPrefix;
      typeof expectedType == 'string' && expectedType.indexOf('not ') === 0
        ? ((notPrefix = 'must not be'), (expectedType = expectedType.replace(/^not /, '')))
        : (notPrefix = 'must be');
      let type = arg.indexOf('.') !== -1 ? 'property' : 'argument',
        message = `The "${arg}" ${type} ${notPrefix} of type ${expectedType}`;
      message += `. Received type ${typeof receivedValue}`;
      super(message);
      this.code = 'ERR_INVALID_ARG_TYPE';
    }
  };
  function validateObject(input, argName) {
    if (input === null || typeof input != 'object') throw new InvalidArgTypeError(argName, 'Object', input)
  }
  function validateString(input, argName) {
    if (typeof input != 'string') throw new InvalidArgTypeError(argName, 'string', input)
  }
  var isWindows = getPlatform === 'win32'
  function isPathSeparator(charCode) {
    return charCode === forwardSlash || charCode === backSlash
  }
  function isForwardSlash(charCode) {
    return charCode === forwardSlash
  }
  function isAlphabet(charCode) {
    return (charCode >= upperCaseA && charCode <= upperCaseZ) || (charCode >= lowerCaseA && charCode <= lowerCaseZ)
  }
  function normalizePath(input, pathSeparator, dot, isPathSeparator) {
    let normalizedPath = '',
      dotCount = 0,
      lastSeparatorIndex = -1,
      consecutiveDots = 0,
      currentCharCode = 0
    for (let i = 0; i <= input.length; ++i) {
      if (i < input.length) currentCharCode = input.charCodeAt(i)
      else {
        if (isPathSeparator(currentCharCode)) break
        currentCharCode = forwardSlash
      }
      if (isPathSeparator(currentCharCode)) {
        if (!(lastSeparatorIndex === i - 1 || consecutiveDots === 1))
          if (consecutiveDots === 2) {
            if (normalizedPath.length < 2 || dotCount !== 2 || normalizedPath.charCodeAt(normalizedPath.length - 1) !== dot || normalizedPath.charCodeAt(normalizedPath.length - 2) !== dot) {
              if (normalizedPath.length > 2) {
                let lastDotIndex = normalizedPath.lastIndexOf(dot)
                lastDotIndex === -1 ? ((normalizedPath = ''), (dotCount = 0)) : ((normalizedPath = normalizedPath.slice(0, lastDotIndex)), (dotCount = normalizedPath.length - 1 - normalizedPath.lastIndexOf(dot))),
                  (lastSeparatorIndex = i),
                  (consecutiveDots = 0)
                continue
              } else if (normalizedPath.length !== 0) {
                ;(normalizedPath = ''), (dotCount = 0), (lastSeparatorIndex = i), (consecutiveDots = 0)
                continue
              }
            }
            pathSeparator && ((normalizedPath += normalizedPath.length > 0 ? `${dot}..` : '..'), (dotCount = 2))
          } else normalizedPath.length > 0 ? (normalizedPath += `${dot}${input.slice(lastSeparatorIndex + 1, i)}`) : (normalizedPath = input.slice(lastSeparatorIndex + 1, i)), (dotCount = i - lastSeparatorIndex - 1)
        ;(lastSeparatorIndex = i), (consecutiveDots = 0)
      } else currentCharCode === dot && consecutiveDots !== -1 ? ++consecutiveDots : (consecutiveDots = -1)
    }
    return normalizedPath
  }
  function formatPath(pathSeparator, pathObject) {
    validateObject(pathObject, 'pathObject')
    let directory = pathObject.dir || pathObject.root,
      base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`
    return directory ? (directory === pathObject.root ? `${directory}${base}` : `${directory}${pathSeparator}${base}`) : base
  }
function formatPath(t, e) {
  validateObject(e, 'pathObject')
  let r = e.dir || e.root,
    n = e.base || `${e.name || ''}${e.ext || ''}`
  return r ? (r === e.root ? `${r}${n}` : `${r}${t}${n}`) : n
}
var win32PathOperations = {
  resolve(...paths) {
    let resolvedAbsolute = '',
        resolvedPath = '',
        isAbsolute = false;
    for (let i = paths.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = paths[i];
        validateString(path, 'path');
        if (path.length === 0) continue;
      } else {
        if (resolvedAbsolute.length === 0) {
          path = getCurrentWorkingDirectory();
        } else {
          path = getEnvironmentVariable(resolvedAbsolute) || getCurrentWorkingDirectory();
          if (path === undefined || (path.slice(0, 2).toLowerCase() !== resolvedAbsolute.toLowerCase() && path.charCodeAt(2) === backSlash)) {
            path = `${resolvedAbsolute}\\`;
          }
        }
      }
      let pathLength = path.length,
          rootLength = 0,
          root = '',
          isUncPath = false,
          code = path.charCodeAt(0);
      if (pathLength === 1) {
        if (isPathSeparator(code)) {
          rootLength = 1;
          isUncPath = true;
        }
      } else if (isPathSeparator(code)) {
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2,
              start = j;
          while (j < pathLength && !isPathSeparator(path.charCodeAt(j))) j++;
          if (j < pathLength && j !== start) {
            let hostname = path.slice(start, j);
            start = j;
            while (j < pathLength && isPathSeparator(path.charCodeAt(j))) j++;
            if (j < pathLength && j !== start) {
              while (j < pathLength && !isPathSeparator(path.charCodeAt(j))) j++;
              if (j === pathLength || j !== start) {
                root = `\\\\${hostname}\\${path.slice(start, j)}`;
                rootLength = j;
              }
            }
          }
        } else {
          rootLength = 1;
        }
      } else if (isAlphabet(code) && path.charCodeAt(1) === colon) {
        root = path.slice(0, 2);
        rootLength = 2;
        if (pathLength > 2 && isPathSeparator(path.charCodeAt(2))) {
          isUncPath = true;
          rootLength = 3;
        }
      }
      if (root.length > 0) {
        if (resolvedAbsolute.length > 0) {
          if (root.toLowerCase() !== resolvedAbsolute.toLowerCase()) continue;
        } else {
          resolvedAbsolute = root;
        }
      }
      if (isAbsolute) {
        if (resolvedAbsolute.length > 0) break;
      } else {
        resolvedPath = `${path.slice(rootLength)}\\${resolvedPath}`;
        isAbsolute = isUncPath;
        if (isUncPath && resolvedAbsolute.length > 0) break;
      }
    }
    resolvedPath = normalizePath(resolvedPath, !isAbsolute, '\\', isPathSeparator);
    return isAbsolute ? `${resolvedAbsolute}\\${resolvedPath}` : `${resolvedAbsolute}${resolvedPath}` || '.';
  },
  normalize(path) {
    validateString(path, 'path')
    let pathLength = path.length
    if (pathLength === 0) return '.'
    let rootEnd = 0,
      root,
      isAbsolute = false,
      firstCharCode = path.charCodeAt(0)
    if (pathLength === 1) return isForwardSlash(firstCharCode) ? '\\' : path
    if (isPathSeparator(firstCharCode))
      if ((isAbsolute = true, isPathSeparator(path.charCodeAt(1)))) {
        let separatorIndex = 2,
          nextPartStart = separatorIndex
        while (separatorIndex < pathLength && !isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
        if (separatorIndex < pathLength && separatorIndex !== nextPartStart) {
          let server = path.slice(nextPartStart, separatorIndex)
          while (separatorIndex < pathLength && isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
          if (separatorIndex < pathLength && separatorIndex !== nextPartStart) {
            nextPartStart = separatorIndex
            while (separatorIndex < pathLength && !isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
            if (separatorIndex === pathLength) return `\\\\${server}\\${path.slice(nextPartStart)}\\`
            if (separatorIndex !== nextPartStart) {
              root = `\\\\${server}\\${path.slice(nextPartStart, separatorIndex)}`
              rootEnd = separatorIndex
            }
          }
        }
      } else rootEnd = 1
    else
    isAlphabet(firstCharCode) &&
        path.charCodeAt(1) === colon &&
        ((root = path.slice(0, 2)), (rootEnd = 2), pathLength > 2 && isPathSeparator(path.charCodeAt(2)) && ((isAbsolute = true), (rootEnd = 3)))
    let tail = rootEnd < pathLength ? normalizePath(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator) : ''
    if (tail.length === 0 && !isAbsolute) tail = '.'
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(pathLength - 1))) tail += '\\'
    return root === undefined ? (isAbsolute ? `\\${tail}` : tail) : isAbsolute ? `${root}\\${tail}` : `${root}${tail}`
  },
  isAbsolute(path) {
    validateString(path, 'path')
    let pathLength = path.length
    if (pathLength === 0) return false
    let firstCharCode = path.charCodeAt(0)
    return isPathSeparator(firstCharCode) || (pathLength > 2 && isAlphabet(firstCharCode) && path.charCodeAt(1) === colon && isPathSeparator(path.charCodeAt(2)))
  },
  join(...paths) {
    if (paths.length === 0) return '.'
    let joinedPath, firstPath
    for (let index = 0; index < paths.length; ++index) {
      let path = paths[index]
      validateString(path, 'path'), path.length > 0 && (joinedPath === void 0 ? (joinedPath = firstPath = path) : (joinedPath += `\\${path}`))
    }
    if (joinedPath === void 0) return '.'
    let isAbsolute = true,
      separatorIndex = 0
    if (typeof firstPath == 'string' && isPathSeparator(firstPath.charCodeAt(0))) {
      ++separatorIndex
      let pathLength = firstPath.length
      pathLength > 1 && isPathSeparator(firstPath.charCodeAt(1)) && (++separatorIndex, pathLength > 2 && (isPathSeparator(firstPath.charCodeAt(2)) ? ++separatorIndex : (isAbsolute = false)))
    }
    if (isAbsolute) {
      for (; separatorIndex < joinedPath.length && isPathSeparator(joinedPath.charCodeAt(separatorIndex)); ) separatorIndex++
      separatorIndex >= 2 && (joinedPath = `\\${joinedPath.slice(separatorIndex)}`)
    }
    return win32PathOperations.normalize(joinedPath)
  },
  relative(from, to) {
    if ((validateString(from, 'from'), validateString(to, 'to'), from === to)) return ''
    let resolvedFrom = win32PathOperations.resolve(from),
      resolvedTo = win32PathOperations.resolve(to)
    if (resolvedFrom === resolvedTo || ((from = resolvedFrom.toLowerCase()), (to = resolvedTo.toLowerCase()), from === to)) return ''
    let fromIndex = 0
    for (; fromIndex < from.length && from.charCodeAt(fromIndex) === backSlash; ) fromIndex++
    let fromLength = from.length
    for (; fromLength - 1 > fromIndex && from.charCodeAt(fromLength - 1) === backSlash; ) fromLength--
    let fromPartLength = fromLength - fromIndex,
      toIndex = 0
    for (; toIndex < to.length && to.charCodeAt(toIndex) === backSlash; ) toIndex++
    let toLength = to.length
    for (; toLength - 1 > toIndex && to.charCodeAt(toLength - 1) === backSlash; ) toLength--
    let toPartLength = toLength - toIndex,
      minLength = fromPartLength < toPartLength ? fromPartLength : toPartLength,
      lastCommonIndex = -1,
      currentIndex = 0
    for (; currentIndex < minLength; currentIndex++) {
      let fromCharCode = from.charCodeAt(fromIndex + currentIndex)
      if (fromCharCode !== to.charCodeAt(toIndex + currentIndex)) break
      fromCharCode === backSlash && (lastCommonIndex = currentIndex)
    }
    if (currentIndex !== minLength) {
      if (lastCommonIndex === -1) return resolvedTo
    } else {
      if (toPartLength > minLength) {
        if (to.charCodeAt(toIndex + currentIndex) === backSlash) return resolvedTo.slice(toIndex + currentIndex + 1)
        if (currentIndex === 2) return resolvedTo.slice(toIndex + currentIndex)
      }
      fromPartLength > minLength && (from.charCodeAt(fromIndex + currentIndex) === backSlash ? (lastCommonIndex = currentIndex) : currentIndex === 2 && (lastCommonIndex = 3)), lastCommonIndex === -1 && (lastCommonIndex = 0)
    }
    let relativePath = ''
    for (currentIndex = fromIndex + lastCommonIndex + 1; currentIndex <= fromLength; ++currentIndex) (currentIndex === fromLength || from.charCodeAt(currentIndex) === backSlash) && (relativePath += relativePath.length === 0 ? '..' : '\\..')
    return (toIndex += lastCommonIndex), relativePath.length > 0 ? `${relativePath}${resolvedTo.slice(toIndex, toLength)}` : (resolvedTo.charCodeAt(toIndex) === backSlash && ++toIndex, resolvedTo.slice(toIndex, toLength))
  },
  toNamespacedPath(path) {
    if (typeof path != 'string' || path.length === 0) return path
    let resolvedPath = win32PathOperations.resolve(path)
    if (resolvedPath.length <= 2) return path
    if (resolvedPath.charCodeAt(0) === backSlash) {
      if (resolvedPath.charCodeAt(1) === backSlash) {
        let thirdChar = resolvedPath.charCodeAt(2)
        if (thirdChar !== questionMark && thirdChar !== dot) return `\\\\?\\UNC\\${resolvedPath.slice(2)}`
      }
    } else if (isAlphabet(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === colon && resolvedPath.charCodeAt(2) === backSlash) return `\\\\?\\${resolvedPath}`
    return path
  },
  dirname(path) {
    validateString(path, 'path')
    let pathLength = path.length
    if (pathLength === 0) return '.'
    let root = -1,
      rootEnd = 0,
      firstCharCode = path.charCodeAt(0)
    if (pathLength === 1) return isPathSeparator(firstCharCode) ? path : '.'
    if (isPathSeparator(firstCharCode)) {
      if (((root = rootEnd = 1), isPathSeparator(path.charCodeAt(1)))) {
        let separatorIndex = 2,
          nextPartStart = separatorIndex
        while (separatorIndex < pathLength && !isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
        if (separatorIndex < pathLength && separatorIndex !== nextPartStart) {
          nextPartStart = separatorIndex
          while (separatorIndex < pathLength && isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
          if (separatorIndex < pathLength && separatorIndex !== nextPartStart) {
            nextPartStart = separatorIndex
            while (separatorIndex < pathLength && !isPathSeparator(path.charCodeAt(separatorIndex))) separatorIndex++
            if (separatorIndex === pathLength) return path
            if (separatorIndex !== nextPartStart) root = rootEnd = separatorIndex + 1
          }
        }
      }
    } else if (isAlphabet(firstCharCode) && path.charCodeAt(1) === colon) root = rootEnd = pathLength > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2
    let tail = -1,
      isTail = true
    for (let separatorIndex = pathLength - 1; separatorIndex >= rootEnd; --separatorIndex)
      if (isPathSeparator(path.charCodeAt(separatorIndex))) {
        if (!isTail) {
          tail = separatorIndex
          break
        }
      } else isTail = false
    if (tail === -1) {
      if (root === -1) return '.'
      tail = root
    }
    return path.slice(0, tail)
  },
  basename(path, ext) {
    if (ext !== void 0) validateString(ext, 'ext')
    validateString(path, 'path')
    let root = 0,
      tail = -1,
      isTail = true,
      pathIndex
    if (
      (path.length >= 2 && isAlphabet(path.charCodeAt(0)) && path.charCodeAt(1) === colon && (root = 2),
      ext !== void 0 && ext.length > 0 && ext.length <= path.length)
    ) {
      if (ext === path) return ''
      let extLength = ext.length - 1,
        extIndex = -1
      for (pathIndex = path.length - 1; pathIndex >= root; --pathIndex) {
        let charCode = path.charCodeAt(pathIndex)
        if (isPathSeparator(charCode)) {
          if (!isTail) {
            root = pathIndex + 1
            break
          }
        } else
          extIndex === -1 && ((isTail = false), (extIndex = pathIndex + 1)),
            extLength >= 0 && (charCode === ext.charCodeAt(extLength) ? --extLength === -1 && (tail = pathIndex) : ((extLength = -1), (tail = extIndex)))
      }
      return root === tail ? (tail = extIndex) : tail === -1 && (tail = path.length), path.slice(root, tail)
    }
    for (pathIndex = path.length - 1; pathIndex >= root; --pathIndex)
      if (isPathSeparator(path.charCodeAt(pathIndex))) {
        if (!isTail) {
          root = pathIndex + 1
          break
        }
      } else tail === -1 && ((isTail = false), (tail = pathIndex + 1))
    return tail === -1 ? '' : path.slice(root, tail)
  },
  extname(path) {
    validateString(path, 'path')
    let start = 0,
      dotPosition = -1,
      rootEnd = 0,
      nameEnd = -1,
      pathSeparator = true,
      nameStart = 0
    path.length >= 2 && path.charCodeAt(1) === colon && isAlphabet(path.charCodeAt(0)) && (start = rootEnd = 2)
    for (let i = path.length - 1; i >= start; --i) {
      let char = path.charCodeAt(i)
      if (isPathSeparator(char)) {
        if (!pathSeparator) {
          rootEnd = i + 1
          break
        }
        continue
      }
      nameEnd === -1 && ((pathSeparator = false), (nameEnd = i + 1)), char === dot ? (dotPosition === -1 ? (dotPosition = i) : nameStart !== 1 && (nameStart = 1)) : dotPosition !== -1 && (nameStart = -1)
    }
    return dotPosition === -1 || nameEnd === -1 || nameStart === 0 || (nameStart === 1 && dotPosition === nameEnd - 1 && dotPosition === rootEnd + 1) ? '' : path.slice(dotPosition, nameEnd)
  },
  format: formatPath.bind(null, '\\'),
  parse(path) {
    validateString(path, 'path')
    let pathObject = { root: '', dir: '', base: '', ext: '', name: '' }
    if (path.length === 0) return pathObject
    let length = path.length,
      rootEnd = 0,
      charCode = path.charCodeAt(0)
    if (length === 1) return isPathSeparator(charCode) ? ((pathObject.root = pathObject.dir = path), pathObject) : ((pathObject.base = pathObject.name = path), pathObject)
    if (isPathSeparator(charCode)) {
      if (((rootEnd = 1), isPathSeparator(path.charCodeAt(1)))) {
        let position = 2,
          separatorPosition = position
        for (; position < length && !isPathSeparator(path.charCodeAt(position)); ) position++
        if (position < length && position !== separatorPosition) {
          for (separatorPosition = position; position < length && isPathSeparator(path.charCodeAt(position)); ) position++
          if (position < length && position !== separatorPosition) {
            for (separatorPosition = position; position < length && !isPathSeparator(path.charCodeAt(position)); ) position++
            position === length ? (rootEnd = position) : position !== separatorPosition && (rootEnd = position + 1)
          }
        }
      }
    } else if (isAlphabet(charCode) && path.charCodeAt(1) === colon) {
      if (length <= 2) return (pathObject.root = pathObject.dir = path), pathObject
      if (((rootEnd = 2), isPathSeparator(path.charCodeAt(2)))) {
        if (length === 3) return (pathObject.root = pathObject.dir = path), pathObject
        rootEnd = 3
      }
    }
    rootEnd > 0 && (pathObject.root = path.slice(0, rootEnd))
    let dotPosition = -1,
      nameStart = rootEnd,
      nameEnd = -1,
      pathSeparator = true,
      lastPosition = path.length - 1,
      namePosition = 0
    for (; lastPosition >= rootEnd; --lastPosition) {
      if (((charCode = path.charCodeAt(lastPosition)), isPathSeparator(charCode))) {
        if (!pathSeparator) {
          nameStart = lastPosition + 1
          break
        }
        continue
      }
      nameEnd === -1 && ((pathSeparator = false), (nameEnd = lastPosition + 1)), charCode === dot ? (dotPosition === -1 ? (dotPosition = lastPosition) : namePosition !== 1 && (namePosition = 1)) : dotPosition !== -1 && (namePosition = -1)
    }
    return (
      nameEnd !== -1 &&
        (dotPosition === -1 || namePosition === 0 || (namePosition === 1 && dotPosition === nameEnd - 1 && dotPosition === nameStart + 1)
          ? (pathObject.base = pathObject.name = path.slice(nameStart, nameEnd))
          : ((pathObject.name = path.slice(nameStart, dotPosition)), (pathObject.base = path.slice(nameStart, nameEnd)), (pathObject.ext = path.slice(dotPosition, nameEnd)))),
      nameStart > 0 && nameStart !== rootEnd ? (pathObject.dir = path.slice(0, nameStart - 1)) : (pathObject.dir = pathObject.root),
      pathObject
    )
  },
  sep: '\\',
  delimiter: ';',
  win32: null,
  posix: null,
}
var getTransformedPath = (() => {
  if (isWindows) {
    let backslashGlobal = /\\/g
    return () => {
      let currentPath = getCurrentWorkingDirectory().replace(backslashGlobal, '/')
      return currentPath.slice(currentPath.indexOf('/'))
    }
  }
  return () => getCurrentWorkingDirectory()
})()
var posixPathOperations = {
  resolve(...segments) {
    let resolvedPath = '';
    let isAbsolute = false;
    for (let i = segments.length - 1; i >= -1 && !isAbsolute; i--) {
      let segment = i >= 0 ? segments[i] : getTransformedPath();
      validateString(segment, 'path');
      if (segment.length !== 0) {
        resolvedPath = `${segment}/${resolvedPath}`;
        isAbsolute = segment.charCodeAt(0) === forwardSlashCharCode;
      }
    }
    resolvedPath = normalizePath(resolvedPath, !isAbsolute, '/', isForwardSlash);
    return isAbsolute ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : '.';
  },
  normalize(path) {
    validateString(path, 'path');
    if (path.length === 0) return '.';
    let startsWithSlash = path.charCodeAt(0) === forwardSlashCharCode;
    let endsWithSlash = path.charCodeAt(path.length - 1) === forwardSlashCharCode;
    path = normalizePath(path, !startsWithSlash, '/', isForwardSlash);
    if (path.length === 0) return startsWithSlash ? '/' : endsWithSlash ? './' : '.';
    if (endsWithSlash) path += '/';
    return startsWithSlash ? `/${path}` : path;
  },
  isAbsolute(path) {
    validateString(path, 'path');
    return path.length > 0 && path.charCodeAt(0) === forwardSlashCharCode;
  },
  join(...segments) {
    if (segments.length === 0) return '.';
    let joinedPath;
    for (let i = 0; i < segments.length; ++i) {
      let segment = segments[i];
      validateString(segment, 'path');
      if (segment.length > 0) {
        joinedPath = joinedPath === undefined ? segment : `${joinedPath}/${segment}`;
      }
    }
    return joinedPath === undefined ? '.' : pathOperations.normalize(joinedPath);
  },
  relative(fromPath, toPath) {
    if ((validateString(fromPath, 'from'), validateString(toPath, 'to'), fromPath === toPath || ((fromPath = posixPathOperations.resolve(fromPath)), (toPath = posixPathOperations.resolve(toPath)), fromPath === toPath))) return ''
    let fromStart = 1,
      fromLength = fromPath.length,
      fromEnd = fromLength - fromStart,
      toStart = 1,
      toEnd = toPath.length - toStart,
      minLength = fromEnd < toEnd ? fromEnd : toEnd,
      lastCommonSep = -1,
      index = 0
    for (; index < minLength; index++) {
      let charCode = fromPath.charCodeAt(fromStart + index)
      if (charCode !== toPath.charCodeAt(toStart + index)) break
      charCode === forwardSlash && (lastCommonSep = index)
    }
    if (index === minLength)
      if (toEnd > minLength) {
        if (toPath.charCodeAt(toStart + index) === forwardSlash) return toPath.slice(toStart + index + 1)
        if (index === 0) return toPath.slice(toStart + index)
      } else fromEnd > minLength && (fromPath.charCodeAt(fromStart + index) === forwardSlash ? (lastCommonSep = index) : index === 0 && (lastCommonSep = 0))
    let relativePath = ''
    for (index = fromStart + lastCommonSep + 1; index <= fromLength; ++index) (index === fromLength || fromPath.charCodeAt(index) === forwardSlash) && (relativePath += relativePath.length === 0 ? '..' : '/..')
    return `${relativePath}${toPath.slice(toStart + lastCommonSep)}`
  },
  toNamespacedPath(path) {
    return path
  },
  dirname(path) {
    if ((validateString(path, 'path'), path.length === 0)) return '.'
    let isAbsolute = path.charCodeAt(0) === forwardSlash,
      lastSep = -1,
      seenNonSep = !0
    for (let index = path.length - 1; index >= 1; --index)
      if (path.charCodeAt(index) === forwardSlash) {
        if (!seenNonSep) {
          lastSep = index
          break
        }
      } else seenNonSep = !1
    return lastSep === -1 ? (isAbsolute ? '/' : '.') : isAbsolute && lastSep === 1 ? '//' : path.slice(0, lastSep)
  },
  basename(path, ext) {
    if (ext !== void 0) validateString(ext, 'ext')
    validateString(path, 'path')

    let start = 0,
      end = -1,
      seenNonSep = true,
      index

    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext === path) return ''

      let extIndex = ext.length - 1,
        firstNonSep = -1

      for (index = path.length - 1; index >= 0; --index) {
        let charCode = path.charCodeAt(index)
        if (charCode === forwardSlash) {
          if (!seenNonSep) {
            start = index + 1
            break
          }
        } else {
          if (firstNonSep === -1) {
            seenNonSep = false
            firstNonSep = index + 1
          }
          if (extIndex >= 0) {
            if (charCode === ext.charCodeAt(extIndex)) {
              if (--extIndex === -1) {
                end = index
              }
            } else {
              extIndex = -1
              end = firstNonSep
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSep
      } else if (end === -1) {
        end = path.length
      }
      return path.slice(start, end)
    }

    for (index = path.length - 1; index >= 0; --index) {
      if (path.charCodeAt(index) === forwardSlash) {
        if (!seenNonSep) {
          start = index + 1
          break
        }
      } else if (end === -1) {
        seenNonSep = false
        end = index + 1
      }
    }
    return end === -1 ? '' : path.slice(start, end)
  },
  extname(path) {
    validateString(path, 'path')

    let dotPos = -1,
      slashPos = 0,
      endPos = -1,
      seenNonSep = true,
      state = 0

    for (let index = path.length - 1; index >= 0; --index) {
      let charCode = path.charCodeAt(index)
      if (charCode === forwardSlash) {
        if (!seenNonSep) {
          slashPos = index + 1
          break
        }
        continue
      }
      if (endPos === -1) {
        seenNonSep = false
        endPos = index + 1
      }
      if (charCode === dot) {
        if (dotPos === -1) {
          dotPos = index
        } else if (state !== 1) {
          state = 1
        }
      } else if (dotPos !== -1) {
        state = -1
      }
    }
    return dotPos === -1 || endPos === -1 || state === 0 || (state === 1 && dotPos === endPos - 1 && dotPos === slashPos + 1) ? '' : path.slice(dotPos, endPos)
  },
  format: formatPath.bind(null, '/'),
  parse(path) {
    validateString(path, 'path')

    let pathObject = { root: '', dir: '', base: '', ext: '', name: '' }
    if (path.length === 0) return pathObject

    let isAbsolute = path.charCodeAt(0) === forwardSlash,
      index
    isAbsolute ? ((pathObject.root = '/'), (index = 1)) : (index = 0)

    let dotPos = -1,
      slashPos = 0,
      endPos = -1,
      seenNonSep = true,
      pathEnd = path.length - 1,
      state = 0

    for (; pathEnd >= index; --pathEnd) {
      let charCode = path.charCodeAt(pathEnd)
      if (charCode === forwardSlash) {
        if (!seenNonSep) {
          slashPos = pathEnd + 1
          break
        }
        continue
      }
      if (endPos === -1) {
        seenNonSep = false
        endPos = pathEnd + 1
      }
      if (charCode === dot) {
        if (dotPos === -1) {
          dotPos = pathEnd
        } else if (state !== 1) {
          state = 1
        }
      } else if (dotPos !== -1) {
        state = -1
      }
    }
    if (endPos !== -1) {
      let start = slashPos === 0 && isAbsolute ? 1 : slashPos
      if (dotPos === -1 || state === 0 || (state === 1 && dotPos === endPos - 1 && dotPos === slashPos + 1)) {
        pathObject.base = pathObject.name = path.slice(start, endPos)
      } else {
        pathObject.name = path.slice(start, dotPos)
        pathObject.base = path.slice(start, endPos)
        pathObject.ext = path.slice(dotPos, endPos)
      }
    }
    if (slashPos > 0) {
      pathObject.dir = path.slice(0, slashPos - 1)
    } else if (isAbsolute) {
      pathObject.dir = '/'
    }
    return pathObject
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null,
}
posixPathOperations.win32 = win32PathOperations.win32 = win32PathOperations
posixPathOperations.posix = win32PathOperations.posix = posixPathOperations
var normalizePath = isWindows ? win32PathOperations.normalize : posixPathOperations.normalize,
isAbsolutePath = isWindows ? win32PathOperations.isAbsolute : posixPathOperations.isAbsolute,
joinPath = isWindows ? win32PathOperations.join : posixPathOperations.join,
joinPath = isWindows ? win32PathOperations.resolve : posixPathOperations.resolve,
relativePath = isWindows ? win32PathOperations.relative : posixPathOperations.relative,
dirname = isWindows ? win32PathOperations.dirname : posixPathOperations.dirname,
basename = isWindows ? win32PathOperations.basename : posixPathOperations.basename,
extname = isWindows ? win32PathOperations.extname : posixPathOperations.extname,
formatPath = isWindows ? win32PathOperations.format : posixPathOperations.format,
parsePath = isWindows ? win32PathOperations.parse : posixPathOperations.parse,
toNamespacedPath = isWindows ? win32PathOperations.toNamespacedPath : posixPathOperations.toNamespacedPath,
pathSeparator = isWindows ? win32PathOperations.sep : posixPathOperations.sep,
pathDelimiter = isWindows ? win32PathOperations.delimiter : posixPathOperations.delimiter
var schemeRegex = /^\w[\w\d+.-]*$/,
singleSlashRegex = /^\//,
doubleSlashRegex = /^\/\//
function validateUri(uri, flag) {
  if (!uri.scheme && flag)
    throw new Error(
      `[UriError]: Scheme is missing: {scheme: "", authority: "${uri.authority}", path: "${uri.path}", query: "${uri.query}", fragment: "${uri.fragment}"}`
    )
  if (uri.scheme && !schemeRegex.test(uri.scheme)) throw new Error('[UriError]: Scheme contains illegal characters.')
  if (uri.path) {
    if (uri.authority) {
      if (!singleSlashRegex.test(uri.path))
        throw new Error(
          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character'
        )
    } else if (doubleSlashRegex.test(uri.path))
      throw new Error(
        '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")'
      )
  }
}
function getDefaultScheme(scheme, flag) {
  return !scheme && !flag ? 'file' : scheme
}
function addDefaultSlash(scheme, e) {
  switch (scheme) {
    case 'https':
    case 'http':
    case 'file':
      path ? path[0] !== slash && (path = slash + path) : (path = slash)
      break
  }
  return path
}
var emptyString = '',
slash = '/',
uriRegex = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
Uri = class Uri {
  static isUri(instance) {
    return instance instanceof Uri
      ? true
      : instance
      ? typeof instance.authority == 'string' &&
        typeof instance.fragment == 'string' &&
        typeof instance.path == 'string' &&
        typeof instance.query == 'string' &&
        typeof instance.scheme == 'string' &&
        typeof instance.fsPath == 'string' &&
        typeof instance.with == 'function' &&
        typeof instance.toString == 'function'
      : false
  }
  constructor(scheme, authority, path, query, fragment, isWindows = false) {
    typeof scheme == 'object'
      ? ((this.scheme = scheme.scheme || emptyString),
        (this.authority = scheme.authority || emptyString),
        (this.path = scheme.path || emptyString),
        (this.query = scheme.query || emptyString),
        (this.fragment = scheme.fragment || emptyString))
      : ((this.scheme = getDefaultScheme(scheme, isWindows)),
        (this.authority = authority || emptyString),
        (this.path = addDefaultSlash(this.scheme, path || emptyString)),
        (this.query = query || emptyString),
        (this.fragment = fragment || emptyString),
        validateUri(this, isWindows))
  }
  get fsPath() {
    return getFilePath(this, false)
  }
  with(changes) {
    if (!changes) return this
    let { scheme, authority, path, query, fragment } = changes
    return (
      scheme === undefined ? (scheme = this.scheme) : scheme === null && (scheme = emptyString),
      authority === undefined ? (authority = this.authority) : authority === null && (authority = emptyString),
      path === undefined ? (path = this.path) : path === null && (path = emptyString),
      query === undefined ? (query = this.query) : query === null && (query = emptyString),
      fragment === undefined ? (fragment = this.fragment) : fragment === null && (fragment = emptyString),
      scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment
        ? this
        : new UriWithFileSystemPath(scheme, authority, path, query, fragment)
    )
  }
  static parse(uriString, isWindows = false) {
    let match = uriRegex.exec(uriString)
    return match
      ? new UriWithFileSystemPath(match[2] || emptyString, decodeUri(match[4] || emptyString), decodeUri(match[5] || emptyString), decodeUri(match[7] || emptyString), decodeUri(match[9] || emptyString), isWindows)
      : new UriWithFileSystemPath(emptyString, emptyString, emptyString, emptyString, emptyString)
  }
  static file(path) {
    let authority = emptyString
    if ((isWindowsFlag && (path = path.replace(/\\/g, slash)), path[0] === slash && path[1] === slash)) {
      let index = path.indexOf(slash, 2)
      index === -1 ? ((authority = path.substring(2)), (path = slash)) : ((authority = path.substring(2, index)), (path = path.substring(index) || slash))
    }
    return new UriWithFileSystemPath('file', authority, path, emptyString, emptyString)
  }
  static from(uri, isWindows) {
    return new UriWithFileSystemPath(uri.scheme, uri.authority, uri.path, uri.query, uri.fragment, isWindows)
  }
  static joinPath(uri, ...paths) {
    if (!uri.path) throw new Error('[UriError]: cannot call joinPath on URI without path')
    let newPath
    return (
      isWindowsFlag && uri.scheme === 'file' ? (newPath = Uri.file(win32PathOperations.join(getFilePath(uri, true), ...paths)).path) : (newPath = posixPathOperations.join(uri.path, ...paths)),
      uri.with({ path: newPath })
    )
  }
  toString(skipEncoding = false) {
    return formatUri(this, skipEncoding)
  }
  toJSON() {
    return this
  }
  static revive(data) {
    if (data) {
      if (data instanceof Uri) return data
      {
        let revivedUri = new UriWithFileSystemPath(data)
        return (revivedUri._formatted = data.external ?? null), (revivedUri._fsPath = data._sep === pathSeparator ? data.fsPath ?? null : null), revivedUri
      }
    } else return data
  }
}
var pathSeparator = isWindowsFlag ? 1 : undefined;
var UriWithFileSystemPath = class extends Uri {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }

  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = getFilePath(this, false);
    }
    return this._fsPath;
  }

  toString(skipEncoding = false) {
    if (!this._formatted) {
      this._formatted = formatUri(this, false);
    }
    return skipEncoding ? formatUri(this, true) : this._formatted;
  }

  toJSON() {
    let json = { $mid: 1 };

    if (this._fsPath) {
      json.fsPath = this._fsPath;
      json._sep = pathSeparator;
    }

    if (this._formatted) {
      json.external = this._formatted;
    }

    if (this.path) {
      json.path = this.path;
    }

    if (this.scheme) {
      json.scheme = this.scheme;
    }

    if (this.authority) {
      json.authority = this.authority;
    }

    if (this.query) {
      json.query = this.query;
    }

    if (this.fragment) {
      json.fragment = this.fragment;
    }

    return json;
  }
};

var encodedCharacters = {
  58: '%3A',
  47: '%2F',
  63: '%3F',
  35: '%23',
  91: '%5B',
  93: '%5D',
  64: '%40',
  33: '%21',
  36: '%24',
  38: '%26',
  39: '%27',
  40: '%28',
  41: '%29',
  42: '%2A',
  43: '%2B',
  44: '%2C',
  59: '%3B',
  61: '%3D',
  32: '%20',
};

function encodeUriComponent(uriComponent, allowSlash, allowColonBrackets) {
  let encoded,
    lastEncodedIndex = -1;

  for (let i = 0; i < uriComponent.length; i++) {
    let charCode = uriComponent.charCodeAt(i);

    if (
      (charCode >= 97 && charCode <= 122) ||
      (charCode >= 65 && charCode <= 90) ||
      (charCode >= 48 && charCode <= 57) ||
      charCode === 45 ||
      charCode === 46 ||
      charCode === 95 ||
      charCode === 126 ||
      (allowSlash && charCode === 47) ||
      (allowColonBrackets && charCode === 91) ||
      (allowColonBrackets && charCode === 93) ||
      (allowColonBrackets && charCode === 58)
    ) {
      if (lastEncodedIndex !== -1) {
        encoded += encodeURIComponent(uriComponent.substring(lastEncodedIndex, i));
        lastEncodedIndex = -1;
      }
      if (encoded !== undefined) {
        encoded += uriComponent.charAt(i);
      }
    } else {
      if (encoded === undefined) {
        encoded = uriComponent.substr(0, i);
      }
      let encodedChar = encodedCharacters[charCode];
      if (encodedChar !== undefined) {
        if (lastEncodedIndex !== -1) {
          encoded += encodeURIComponent(uriComponent.substring(lastEncodedIndex, i));
          lastEncodedIndex = -1;
        }
        encoded += encodedChar;
      } else if (lastEncodedIndex === -1) {
        lastEncodedIndex = i;
      }
    }
  }

  if (lastEncodedIndex !== -1) {
    encoded += encodeURIComponent(uriComponent.substring(lastEncodedIndex));
  }

  return encoded !== undefined ? encoded : uriComponent;
}

function encodeHashAndQuestionMark(uri) {
  let encodedUri;
  for (let i = 0; i < uri.length; i++) {
    let charCode = uri.charCodeAt(i);
    if (charCode === 35 || charCode === 63) { // '#' or '?'
      if (encodedUri === undefined) {
        encodedUri = uri.substr(0, i);
      }
      encodedUri += encodedCharacters[charCode];
    } else if (encodedUri !== undefined) {
      encodedUri += uri[i];
    }
  }
  return encodedUri !== undefined ? encodedUri : uri;
}

function getFilePath(uri, isWindows) {
  let filePath;
  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
    filePath = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && // '/'
    ((uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90) || // 'A' - 'Z'
    (uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122)) && // 'a' - 'z'
    uri.path.charCodeAt(2) === 58) { // ':'
    filePath = isWindows ? uri.path.substr(1) : uri.path[1].toLowerCase() + uri.path.substr(2);
  } else {
    filePath = uri.path;
  }
  if (isWindows) {
    filePath = filePath.replace(/\//g, '\\');
  }
  return filePath;
}

function formatUri(uri, skipEncoding) {
  let encode = skipEncoding ? encodeHashAndQuestionMark : encodeUriComponent;
  let formattedUri = '';
  let { scheme, authority, path, query, fragment } = uri;

  if (scheme) {
    formattedUri += scheme + ':';
  }
  if (authority || scheme === 'file') {
    formattedUri += '//' + authority;
  }
  if (authority) {
    let atIndex = authority.indexOf('@');
    if (atIndex !== -1) {
      let userInfo = authority.substr(0, atIndex);
      authority = authority.substr(atIndex + 1);
      let colonIndex = userInfo.lastIndexOf(':');
      if (colonIndex === -1) {
        formattedUri += encode(userInfo, false, false);
      } else {
        formattedUri += encode(userInfo.substr(0, colonIndex), false, false) + ':' + encode(userInfo.substr(colonIndex + 1), false, true);
      }
      formattedUri += '@';
    }
    authority = authority.toLowerCase();
    let colonIndex = authority.lastIndexOf(':');
    if (colonIndex === -1) {
      formattedUri += encode(authority, false, true);
    } else {
      formattedUri += encode(authority.substr(0, colonIndex), false, true) + authority.substr(colonIndex);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      let charCode = path.charCodeAt(1);
      if (charCode >= 65 && charCode <= 90) { // 'A' - 'Z'
        path = `/${String.fromCharCode(charCode + 32)}:${path.substr(3)}`;
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) { // ':'
      let charCode = path.charCodeAt(0);
      if (charCode >= 65 && charCode <= 90) { // 'A' - 'Z'
        path = `${String.fromCharCode(charCode + 32)}:${path.substr(2)}`;
      }
    }
    formattedUri += encode(path, true, false);
  }
  if (query) {
    formattedUri += '?' + encode(query, false, false);
  }
  if (fragment) {
    formattedUri += '#' + (skipEncoding ? fragment : encodeUriComponent(fragment, false, false));
  }
  return formattedUri;
}

function decodeUriComponent(uriComponent) {
  try {
    return decodeURIComponent(uriComponent);
  } catch {
    return uriComponent.length > 3 ? uriComponent.substr(0, 3) + decodeUriComponent(uriComponent.substr(3)) : uriComponent;
  }
}

var encodedUriPattern = /(%[0-9A-Za-z][0-9A-Za-z])+/g;

function decodeUri(uri) {
  return uri.match(encodedUriPattern) ? uri.replace(encodedUriPattern, component => decodeUriComponent(component)) : uri;
}

var githubDomain = 'github.com',
  defaultBaseUrl = `https://${githubDomain}`,
  BaseBaseGithubApiServiceClass = class {},
  GitHubAPI = class extends BaseGithubApiService {
    constructor(baseUrl = defaultBaseUrl) {
      super();
      this.recalculateUrls(baseUrl);
    }
    isGitHubEnterprise() {
      return this.isEnterprise;
    }
    getTokenUrl(config) {
      return config.devOverride?.copilotTokenUrl ?? this.tokenUrl;
    }
    getNotificationUrl(config) {
      return config.devOverride?.notificationUrl ?? this.notificationUrl;
    }
    updateBaseUrl(context, newBaseUrl) {
      if (!newBaseUrl) return;
      let oldBaseUri = this.baseUri;
      this.recalculateUrls(newBaseUrl);
      if (oldBaseUri.toString() !== this.baseUri.toString()) {
        context.get(TokenManager).resetCopilotToken(context);
      }
    }
    recalculateUrls(baseUrl) {
      this.baseUri = Uri.parse(baseUrl);
      let apiUri = Uri.parse(`${this.baseUri.scheme}://api.${this.baseUri.authority}`);
      this.isEnterprise = this.baseUri.authority !== githubDomain;
      this.tokenUrl = Uri.joinPath(apiUri, '/copilot_internal/v2/token').toString();
      this.notificationUrl = Uri.joinPath(apiUri, '/copilot_internal/notification').toString();
    }
  };

function getLogger(context) {
  return context.get(LoggerManager).getLogger('auth');
}

var tokenRefreshInterval = 60,
tokenRefreshedEvent = 'token_refreshed',
githubTokenChangedEvent = 'github_token_changed'
function getCurrentTimestamp() {
  return Math.floor(Date.now() / 1e3)
}

async function fetchCopilotToken(context, config) {
  let logger = getLogger(context),
    telemetryService = context.get(TelemetryService);
  telemetryService.sendTelemetry('auth.new_login');

  let response = await fetchToken(context, config);
  if (!response) {
    logger.info('Failed to get copilot token');
    telemetryService.sendErrorTelemetry('auth.request_failed');
    return { kind: 'failure', reason: 'FailedToGetToken' };
  }

  let responseBody = await response.json();
  if (!responseBody) {
    logger.info('Failed to get copilot token');
    telemetryService.sendErrorTelemetry('auth.request_read_failed');
    return { kind: 'failure', reason: 'FailedToGetToken' };
  }

  if (response.status === 401) {
    logger.info('Failed to get copilot token due to 401 status');
    telemetryService.sendErrorTelemetry('auth.unknown_401');
    return { kind: 'failure', reason: 'HTTP401' };
  }

  if (!response.ok || !responseBody.token) {
    logger.info(`Invalid copilot token: missing token: ${response.status} ${response.statusText}`);
    telemetryService.sendErrorTelemetry(
      'auth.invalid_token',
      TelemetryEvent.createAndMarkAsIssued({ status: response.status.toString(), status_text: response.statusText })
    );
    return { kind: 'failure', reason: 'NotAuthorized', ...responseBody.error_details };
  }

  let originalExpiry = responseBody.expires_at;
  responseBody.expires_at = getCurrentTimestamp() + responseBody.refresh_in + tokenRefreshInterval;

  let { token, organization_list: organizations, ...otherDetails } = responseBody,
    copilotToken = new CopilotToken(token, organizations);

  return (
    context.get(EventEmitter).emit('onCopilotToken', copilotToken, otherDetails),
    telemetryService.sendTelemetry(
      'auth.new_token',
      TelemetryEvent.createAndMarkAsIssued({}, { adjusted_expires_at: responseBody.expires_at, expires_at: originalExpiry, current_time: getCurrentTimestamp() })
    ),
    { kind: 'success', ...responseBody }
  );
}

async function fetchToken(context, config) {
  let tokenUrl = context.get(BaseGithubApiService).getTokenUrl(config);
  try {
    return await context
      .get(ConnectionSettings)
      .fetch(tokenUrl, { headers: { Authorization: `token ${config.token}`, ...context.get(BuildInfo).getEditorVersionHeaders() } });
  } catch (error) {
    throw (context.get(CertificateErrorHandler).notifyUser(context, error), error);
  }
}

var TokenParser = class {
  constructor(token, organizationList) {
    this.token = token
    this.organizationList = organizationList
    this.tokenMap = this.parseToken(token)
  }
  parseToken(token) {
    let map = new Map(),
      items = token?.split(':')[0]?.split(';')
    for (let item of items) {
      let [key, value] = item.split('=')
      map.set(key, value)
    }
    return map
  }
  get isInternal() {
    let internalIds = [
      '4535c7beffc844b46bb1ed4aa04d759a',
      'a5db0bcaae94032fe715fb34a5e4bce2',
      '7184f66dfcee98cb5f08a1cb936d5225',
    ]
    if (!this.organizationList) return false
    for (let id of this.organizationList) if (internalIds.includes(id)) return true
    return false
  }
  getTokenValue(key) {
    return this.tokenMap.get(key)
  }
}
var BaseTokenHandler = class {
  constructor() {
    this.copilotTokenRefreshEventEmitter = new events.EventEmitter()
    this.githubTokenChangedEventEmitter = new events.EventEmitter()
  }
}
var DefaultTokenHandler = class extends BaseTokenHandler {
  constructor(completionsToken, embeddingsToken) {
    super()
    this.completionsToken = completionsToken
    this.embeddingsToken = embeddingsToken
    this.wasReset = false
  }
  getBasicGitHubToken() {
    return Promise.resolve('token')
  }
  getPermissiveGitHubToken() {
    return Promise.resolve('token')
  }
  async getCopilotToken(context, forceRefresh) {
    return new TokenParser(this.completionsToken)
  }
  async getEmbeddingsToken(context, forceRefresh) {
    return new TokenParser(this.embeddingsToken ?? this.completionsToken)
  }
  resetCopilotToken(context, httpErrorCode) {
    this.wasReset = true
  }
  async checkCopilotToken(context) {
    return { status: 'OK' }
  }
}
var GitHubTokenHandler = class extends BaseTokenHandler {
  constructor(githubToken) {
    super()
    this.githubToken = githubToken
    this.copilotToken = undefined
  }
  getBasicGitHubToken() {
    return Promise.resolve(this.githubToken.token)
  }
  getPermissiveGitHubToken() {
    return Promise.resolve(this.githubToken.token)
  }
  async getCopilotToken(context, forceRefresh) {
    if (!this.copilotToken || this.copilotToken.expires_at < getCurrentTimestamp() || forceRefresh) {
      let response = await fetchCopilotToken(context, this.githubToken)
      if (response.kind === 'failure') throw Error(`Failed to get copilot token: ${response.reason.toString()} ${response.message ?? ''}`)
      this.copilotToken = { ...response }
      scheduleTokenRefresh(context, this, response.refresh_in)
    }
    return new TokenParser(this.copilotToken.token, this.copilotToken.organizationList)
  }
  async checkCopilotToken(context) {
    if (!this.copilotToken || this.copilotToken.expires_at < getCurrentTimestamp()) {
      let response = await fetchCopilotToken(context, this.githubToken)
      if (response.kind === 'failure') return response
      this.copilotToken = { ...response }
      scheduleTokenRefresh(context, this, response.refresh_in)
    }
    return { status: 'OK' }
  }
  resetCopilotToken(context, httpErrorCode) {
    if (httpErrorCode !== undefined) {
      context.get(TelemetryService).sendTelemetry('auth.reset_token_' + httpErrorCode)
    }
    getLogger(context).debug(`Resetting copilot token on HTTP error ${httpErrorCode || 'unknown'}`)
    this.copilotToken = undefined
  }
}
var refreshCountMap = new WeakMap()
function scheduleTokenRefresh(context, tokenHandler, refreshIntervalInSeconds) {
  let currentTime = getCurrentTimestamp(),
    refreshCount = refreshCountMap.get(tokenHandler) ?? refreshCountMap.set(tokenHandler, { value: 0 }).get(tokenHandler)
  if (refreshCount.value <= 0) {
    refreshCount.value++
    setTimeout(async () => {
      let result,
        errorReason = ''
      try {
        refreshCount.value--
        await tokenHandler.getCopilotToken(context, true)
        result = 'success'
        tokenHandler.copilotTokenRefreshEventEmitter.emit(tokenRefreshedEvent)
      } catch (error) {
        result = 'failure'
        errorReason = error.toString()
      }
      let telemetryEvent = TelemetryEvent.createAndMarkAsIssued({ result: result }, { time_taken: getCurrentTimestamp() - currentTime, refresh_count: refreshCount.value })
      if (errorReason) {
        telemetryEvent.properties.reason = errorReason
      }
      context.get(TelemetryService).sendTelemetry('auth.token_refresh', telemetryEvent)
    }, refreshIntervalInSeconds * 1000)
  }
}
function handleGithubTokenChange(authProvider, tokenHandler) {
  if (authProvider.id === 'github') {
    tokenHandler.githubTokenChangedEventEmitter.emit(githubTokenChangedEvent, authProvider);
  }
}

var ContributionManager = new (class {
  constructor() {
    this.contributions = new Set();
  }
  start(contribution) {
    for (let contributor of this.contributions) contributor(contribution);
  }
  registerContribution(contribution) {
    this.contributions.add(contribution);
  }
})();
var ChatAgentServiceIdentifier = createServiceIdentifier('IChatAgentService'),
workspace = 'workspace',
vscode = 'vscode',
terminal = 'terminal'
var Crypto = require('crypto');

function createResponseMetadata(response, completion) {
  return {
    headerRequestId: response.headers.get('x-request-id') || '',
    completionId: completion && completion.id ? completion.id : '',
    created: completion && completion.created ? completion.created : 0,
    serverExperiments: response.headers.get('X-Copilot-Experiment') || '',
    deploymentId: response.headers.get('azureml-model-deployment') || '',
  };
}

function getProcessingTime(response) {
  let processingTime = response.headers.get('openai-processing-ms');
  return processingTime ? parseInt(processingTime, 10) : 0;
}

function isValidErrorDetails(error) {
  if (typeof error != 'object' || error === null || !('details' in error)) return false;
  let { details } = error;
  return (
    typeof details == 'object' &&
    details !== null &&
    'type' in details &&
    'description' in details &&
    typeof details.type == 'string' &&
    typeof details.description == 'string'
  );
}

var CompletionData = class {
  constructor() {
    this.logprobs = [];
    this.top_logprobs = [];
    this.text = [];
    this.newText = [];
    this.tokens = [];
    this.text_offset = [];
  }
  append(completion) {
    if (completion.text) {
      this.text.push(completion.text);
      this.newText.push(completion.text);
    }
    if (completion.delta?.content) {
      this.text.push(completion.delta.content);
      this.newText.push(completion.delta.content);
    }
    if (completion.logprobs) {
      this.tokens.push(completion.logprobs.tokens ?? []);
      this.text_offset.push(completion.logprobs.text_offset ?? []);
      this.logprobs.push(completion.logprobs.token_logprobs ?? []);
      this.top_logprobs.push(completion.logprobs.top_logprobs ?? []);
    }
  }
  flush() {
    let joinedText = this.newText.join('');
    this.newText = [];
    return joinedText;
  }
}

function splitAndFilterEmptyLines(text) {
  let lines = text.split('\n');
  let lastLine = lines.pop();
  return [lines.filter(line => line !== ''), lastLine];
}

var StreamProcessor = class {
  constructor(dependencies, expectedNumChoices, ourRequestId, response, body, telemetryData, dropCompletionReasons, fastCancellation, cancellationToken) {
    this.expectedNumChoices = expectedNumChoices;
    this.ourRequestId = ourRequestId;
    this.response = response;
    this.body = body;
    this.telemetryData = telemetryData;
    this.dropCompletionReasons = dropCompletionReasons;
    this.fastCancellation = fastCancellation;
    this.cancellationToken = cancellationToken;
    this.requestId = createResponseMetadata(this.response);
    this.stats = new ChoiceTracker(this.expectedNumChoices);
    this.solutions = {};
    this.logger = dependencies.get(LoggerManager).getLogger('streamChoices');
    this.ghTelemetry = dependencies.get(IGHTelemetryService);
  }
  static async create(dependencies, expectedNumChoices, ourRequestId, response, telemetryData, dropCompletionReasons, cancellationToken) {
    let body = await response.body();
    body.setEncoding('utf8');
    let fastCancellation = await dependencies.get(ExperimentManager).fastCancellation();
    return new StreamProcessor(dependencies, expectedNumChoices, ourRequestId, response, body, telemetryData, dropCompletionReasons ?? ['content_filter'], fastCancellation, cancellationToken);
  }
  async *processSSE(finishedCb = async () => {}) {
    try {
      yield* this.processSSEInner(finishedCb)
    } finally {
      this.fastCancellation && this.cancel(),
        this.logger.info(
          `request done: requestId: [${this.ourRequestId}] responseId: [${this.requestId.headerRequestId}] model deployment ID: [${this.requestId.deploymentId}]`
        ),
        this.logger.debug(`request stats: ${this.stats}`)
    }
  }
  async *processSSEInner(finishedCb) {
    let remaining = '',
      hasYielded = false;
    outer: for await (let chunk of this.body) {
      if (this.maybeCancel('after awaiting body chunk')) return;
      this.logger.debug('chunk', chunk.toString());
      let [lines, leftover] = splitAndFilterEmptyLines(remaining + chunk.toString());
      remaining = leftover;
      for (let line of lines) {
        let data = line.slice(5).trim();
        if (data === '[DONE]') {
          yield* this.finishSolutions();
          return;
        }
        let parsedData;
        try {
          parsedData = JSON.parse(data);
        } catch {
          this.logger.error(`Error parsing JSON stream data for request id ${this.requestId.headerRequestId}:`, line);
          logError(this.ghTelemetry, `Error parsing JSON stream data for request id ${this.requestId.headerRequestId}:`, a)
          continue;
        }
        if (parsedData.choices === undefined) {
          if (parsedData.error !== undefined) {
            this.logger.error(`Error in response for request id ${this.requestId.headerRequestId}:`, parsedData.error.message);
          } else {
            this.logger.error(`Unexpected response with no choices or error for request id ${this.requestId.headerRequestId}`);
          }
          continue;
        }
        if (this.requestId.created === 0) {
          this.requestId = createResponseMetadata(this.response, parsedData);
          if (this.requestId.created === 0 && parsedData.choices?.length) {
            this.logger.error(`Request id invalid, should have "completionId" and "created": ${JSON.stringify(this.requestId)}`, this.requestId);
          }
        }
        if (this.allSolutionsDone() && this.fastCancellation) break outer;
        for (let i = 0; i < parsedData.choices.length; i++) {
          let choice = parsedData.choices[i];
          this.logger.debug('choice', choice);
          this.stats.add(choice.index);
          if (!(choice.index in this.solutions)) this.solutions[choice.index] = new CompletionData();
          let solution = this.solutions[choice.index];
          if (solution === null) continue;
          let finishOffset,
            processChoice = async annotations => {
              if (annotations && (!Array.isArray(annotations) || !annotations.every(isValidErrorDetails))) {
                annotations = undefined;
              }
              finishOffset = await finishedCb(solution.text.join(''), choice.index, { text: solution.flush(), annotations });
              hasYielded = finishOffset !== undefined;
              return this.maybeCancel('after awaiting finishedCb');
            };
          if (choice.delta?.annotations?.CodeVulnerability) {
            if ((await processChoice()) || (!hasYielded && (solution.append(choice), await processChoice(choice.delta.annotations.CodeVulnerability)))) continue;
          } else {
            solution.append(choice);
            let hasNewline = choice.text?.indexOf('\n') > -1 || choice.delta?.content?.includes('\n');
            if ((choice.finish_reason || hasNewline) && (await processChoice())) continue;
          }
          if (!(!!choice.finish_reason || finishOffset !== undefined)) continue;
          let reason = choice.finish_reason ?? 'client-trimmed';
          if (this.dropCompletionReasons.includes(choice.finish_reason)) {
            this.solutions[choice.index] = null;
          } else {
            this.stats.markYielded(choice.index);
            yield {
              solution,
              finishOffset,
              reason,
              requestId: this.requestId,
              index: choice.index,
            };
            if (this.maybeCancel('after yielding finished choice')) return;
            this.solutions[choice.index] = null;
          }
        }
      }
    }
    for (let [index, solution] of Object.entries(this.solutions)) {
      let numericIndex = Number(index);
      if (
        solution !== null &&
        (this.stats.markYielded(numericIndex),
        yield { solution, finishOffset: undefined, reason: 'Iteration Done', requestId: this.requestId, index: numericIndex },
        this.maybeCancel('after yielding after iteration done'))
      )
        return;
    }
    if (remaining.length > 0 && !hasYielded) {
      try {
        let parsedData = JSON.parse(remaining);
        if (parsedData.error !== undefined) {
          this.logger.error(`Error in response: ${parsedData.error.message}`, parsedData.error);
        }
      } catch {
        this.logger.error(`Error parsing extraData for request id ${this.requestId.headerRequestId}: ${remaining}`);
      }
    }
  }
  async *finishSolutions() {
    for (let [index, solution] of Object.entries(this.solutions)) {
      let numericIndex = Number(index)
      if (
        solution !== null &&
        (this.stats.markYielded(numericIndex),
        yield { solution: solution, finishOffset: undefined, reason: 'DONE', requestId: this.requestId, index: numericIndex },
        this.maybeCancel('after yielding on DONE'))
      )
        return
    }
  }
  maybeCancel(reason) {
    return this.cancellationToken?.isCancellationRequested
      ? (this.logger.debug('Cancelled: ' + reason), this.cancel(), true)
      : false
  }
  cancel() {
    this.body.destroy()
  }
  allSolutionsDone() {
    let solutions = Object.values(this.solutions)
    return solutions.length === this.expectedNumChoices && solutions.every(solution => solution === null)
  }
}
function processResponse(response, data) {
  let processedData = { text: data.text.join(''), tokens: data.text }
  if (data.logprobs.length === 0) return processedData
  let tokenLogprobs = data.logprobs.reduce((accumulator, current) => accumulator.concat(current), []),
    topLogprobs = data.top_logprobs.reduce((accumulator, current) => accumulator.concat(current), []),
    textOffset = data.text_offset.reduce((accumulator, current) => accumulator.concat(current), []),
    tokens = data.tokens.reduce((accumulator, current) => accumulator.concat(current), [])
  return { ...processedData, logprobs: { token_logprobs: tokenLogprobs, top_logprobs: topLogprobs, text_offset: textOffset, tokens: tokens } }
}

var ChoiceTracker = class {
  constructor(size) {
    this.choices = new Map()
    for (let index = 0; index < size; index++) this.choices.set(index, new TokenCounter())
  }
  add(choiceIndex) {
    this.choices.get(choiceIndex).increment()
  }
  markYielded(choiceIndex) {
    this.choices.get(choiceIndex).markYielded()
  }
  toString() {
    return Array.from(this.choices.entries())
      .map(([index, counter]) => `${index}: ${counter.yieldedTokens} -> ${counter.seenTokens}`)
      .join(', ')
  }
}
var TokenCounter = class {
  constructor() {
    this.yieldedTokens = -1
    this.seenTokens = 0
  }
  increment() {
    this.seenTokens++
  }
  markYielded() {
    this.yieldedTokens = this.seenTokens
  }
}

function logError(telemetry, error, context) {
  let message = [error, context],
    formattedMessage = message.length > 0 ? JSON.stringify(message) : 'no msg'
  telemetry.sendRestrictedErrorTelemetry('log', TelemetryEvent.createAndMarkAsIssued({ context: 'fetch', level: LogLevel[3], message: formattedMessage })),
    telemetry.sendErrorTelemetry('log', TelemetryEvent.createAndMarkAsIssued({ context: 'fetch', level: LogLevel[3], message: '[redacted]' }))
}
var tokenSequenceConfig = [
  { max_token_sequence_length: 1, last_tokens_to_consider: 10 },
  { max_token_sequence_length: 10, last_tokens_to_consider: 30 },
  { max_token_sequence_length: 20, last_tokens_to_consider: 45 },
  { max_token_sequence_length: 30, last_tokens_to_consider: 60 },
]

function isClientTokenSequenceRepetitive(tokens, type = 'client') {
  if (type === 'proxy') return false
  let reversedTokens = tokens.slice()
  reversedTokens.reverse()
  return isRepetitive(reversedTokens) || isRepetitive(reversedTokens.filter(token => token.trim().length > 0))
}

function isRepetitive(tokens) {
  let prefixTable = buildPrefixTable(tokens)
  for (let config of tokenSequenceConfig) {
    if (tokens.length < config.last_tokens_to_consider) continue
    if (config.last_tokens_to_consider - 1 - prefixTable[config.last_tokens_to_consider - 1] <= config.max_token_sequence_length) return true
  }
  return false
}

function buildPrefixTable(tokens) {
  let prefixTable = Array(tokens.length).fill(0)
  prefixTable[0] = -1
  let matchedPrefixEnd = -1
  for (let i = 1; i < tokens.length; i++) {
    while (matchedPrefixEnd >= 0 && tokens[matchedPrefixEnd + 1] !== tokens[i]) {
      matchedPrefixEnd = prefixTable[matchedPrefixEnd]
    }
    if (tokens[matchedPrefixEnd + 1] === tokens[i]) {
      matchedPrefixEnd++
    }
    prefixTable[i] = matchedPrefixEnd
  }
  return prefixTable
}

function getConversationType(type) {
  switch (type) {
    case 1:
      return 'conversationInline'
    case 2:
      return 'conversationPanel'
    default:
      return 'none'
  }
}
var defaultExportsHandler = handleDefaultExports(AW()),
  path = require('path'),
  Tokenizer = class {
    constructor() {}
    tokenize(input) {
      if (!this._cl100kTokenizer) {
        this._cl100kTokenizer = this.initTokenizer();
      }
      return this._cl100kTokenizer.encode(input);
    }
    leadingString(input, prefix) {
      if (!this._cl100kTokenizer) {
        this._cl100kTokenizer = this.initTokenizer();
      }
      return this._cl100kTokenizer.encodeTrimPrefix(input, prefix).text;
    }
    tokenLength(input) {
      return input ? this.tokenize(input).length : 0;
    }
    initTokenizer() {
      return defaultExportsHandler.createTokenizer(
        path.join(__dirname, './cl100k_base.tiktoken'),
        defaultExportsHandler.getSpecialTokensByEncoder('cl100k_base'),
        defaultExportsHandler.getRegexByEncoder('cl100k_base'),
        64e3
      );
    }
  }
function calculateTokenLength(container, elements) {
  let tokenizer = container.get(Tokenizer),
    baseIncrement = 3,
    elementIncrement = 3,
    nameIncrement = -1,
    totalLength = 0;
  for (let element of elements) {
    totalLength += elementIncrement;
    for (let [key, value] of Object.entries(element)) {
      if (value) {
        totalLength += tokenizer.tokenLength(value);
        if (key === 'name') {
          totalLength += nameIncrement;
        }
      }
    }
  }
  return (totalLength += baseIncrement);
}
var Node = class Node {
  static {
    this.Undefined = new Node(void 0)
  }
  constructor(element) {
    this.element = element;
    this.next = Node.Undefined;
    this.prev = Node.Undefined;
  }
},
LinkedList = class {
  constructor() {
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node.Undefined;
  }
  clear() {
    let node = this._first;
    while (node !== Node.Undefined) {
      let nextNode = node.next;
      node.prev = Node.Undefined;
      node.next = Node.Undefined;
      node = nextNode;
    }
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  unshift(element) {
    return this._insert(element, false);
  }
  push(element) {
    return this._insert(element, true);
  }
  _insert(element, atEnd) {
    let newNode = new Node(element);
    if (this._first === Node.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atEnd) {
      let lastNode = this._last;
      this._last = newNode;
      newNode.prev = lastNode;
      lastNode.next = newNode;
    } else {
      let firstNode = this._first;
      this._first = newNode;
      newNode.next = firstNode;
      firstNode.prev = newNode;
    }
    this._size += 1;
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        this._remove(newNode);
      }
    }
  }
  shift() {
    if (this._first !== Node.Undefined) {
      let element = this._first.element;
      this._remove(this._first);
      return element;
    }
  }
  pop() {
    if (this._last !== Node.Undefined) {
      let element = this._last.element;
      this._remove(this._last);
      return element;
    }
  }
  _remove(node) {
    if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
      let prevNode = node.prev;
      prevNode.next = node.next;
      node.next.prev = prevNode;
    } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
    } else if (node.next === Node.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node.Undefined;
    } else if (node.prev === Node.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
}
var isPerformanceNowSupported = globalThis.performance && typeof globalThis.performance.now == 'function',
Stopwatch = class Stopwatch {
  static create(useDateNow) {
    return new Stopwatch(useDateNow)
  }
  constructor(useDateNow) {
    this._now = isPerformanceNowSupported && useDateNow === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
    this._startTime = this._now();
    this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now();
    this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var isDebugMode = false,
isSnapshotEmitterEnabled = false,
EventUtils
;(exports => {
  exports.None = () => Disposable.None
  function e(L) {
    if (isSnapshotEmitterEnabled) {
      let { onDidAddListener: S } = L,
        T = StackTrace.create(),
        A = 0
      L.onDidAddListener = () => {
        ++A === 2 &&
          (console.warn(
            'snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here'
          ),
          T.print()),
          S?.()
      }
    }
  }
  function defer(L, S) {
    return debounce(L, () => {}, 0, void 0, !0, void 0, S)
  }
  exports.defer = defer
  function once(L) {
    return (S, T = null, A) => {
      let X = !1,
        fe
      return (
        (fe = L(
          ce => {
            if (!X) return fe ? fe.dispose() : (X = !0), S.call(T, ce)
          },
          null,
          A
        )),
        X && fe.dispose(),
        fe
      )
    }
  }
  exports.once = once
  function map(L, S, T) {
    return u((A, X = null, fe) => L(ce => A.call(X, S(ce)), null, fe), T)
  }
  exports.map = map
  function forEach(L, S, T) {
    return u(
      (A, X = null, fe) =>
        L(
          ce => {
            S(ce), A.call(X, ce)
          },
          null,
          fe
        ),
      T
    )
  }
  exports.forEach = forEach
  function filter(L, S, T) {
    return u((A, X = null, fe) => L(ce => S(ce) && A.call(X, ce), null, fe), T)
  }
  exports.filter = filter
  function signal(L) {
    return L
  }
  exports.signal = signal
  function any(...L) {
    return (S, T = null, A) => {
      let X = disposeAll$(...L.map(fe => fe(ce => S.call(T, ce))))
      return p(X, A)
    }
  }
  exports.any = any
  function reduce(L, S, T, A) {
    let X = T
    return map(L, fe => ((X = S(X, fe)), X), A)
  }
  exports.reduce = reduce
  function u(L, S) {
    let T,
      A = {
        onWillAddFirstListener() {
          T = L(X.fire, X)
        },
        onDidRemoveLastListener() {
          T?.dispose()
        },
      }
    S || e(A)
    let X = new EventManager(A)
    return S?.add(X), X.event
  }
  function p(L, S) {
    return S instanceof Array ? S.push(L) : S && S.add(L), L
  }
  function debounce(L, S, T = 100, A = !1, X = !1, fe, ce) {
    let oe,
      ae,
      je,
      Ye = 0,
      Ze,
      ke = {
        leakWarningThreshold: fe,
        onWillAddFirstListener() {
          oe = L(tt => {
            Ye++,
              (ae = S(ae, tt)),
              A && !je && (st.fire(ae), (ae = void 0)),
              (Ze = () => {
                let ve = ae
                ;(ae = void 0), (je = void 0), (!A || Ye > 1) && st.fire(ve), (Ye = 0)
              }),
              typeof T == 'number'
                ? (clearTimeout(je), (je = setTimeout(Ze, T)))
                : je === void 0 && ((je = 0), queueMicrotask(Ze))
          })
        },
        onWillRemoveListener() {
          X && Ye > 0 && Ze?.()
        },
        onDidRemoveLastListener() {
          ;(Ze = void 0), oe.dispose()
        },
      }
    ce || e(ke)
    let st = new EventManager(ke)
    return ce?.add(st), st.event
  }
  exports.debounce = debounce
  function accumulate(L, S = 0, T) {
    return exports.debounce(L, (A, X) => (A ? (A.push(X), A) : [X]), S, void 0, !0, void 0, T)
  }
  exports.accumulate = accumulate
  function latch(L, S = (A, X) => A === X, T) {
    let A = !0,
      X
    return filter(
      L,
      fe => {
        let ce = A || !S(fe, X)
        return (A = !1), (X = fe), ce
      },
      T
    )
  }
  exports.latch = latch
  function split(L, S, T) {
    return [exports.filter(L, S, T), exports.filter(L, A => !S(A), T)]
  }
  exports.split = split
  function buffer(L, S = !1, T = [], A) {
    let X = T.slice(),
      fe = L(ae => {
        X ? X.push(ae) : oe.fire(ae)
      })
    A && A.add(fe)
    let ce = () => {
        X?.forEach(ae => oe.fire(ae)), (X = null)
      },
      oe = new EventManager({
        onWillAddFirstListener() {
          fe || ((fe = L(ae => oe.fire(ae))), A && A.add(fe))
        },
        onDidAddFirstListener() {
          X && (S ? setTimeout(ce) : ce())
        },
        onDidRemoveLastListener() {
          fe && fe.dispose(), (fe = null)
        },
      })
    return A && A.add(oe), oe.event
  }
  exports.buffer = buffer
  function chain(L, S) {
    return (A, X, fe) => {
      let ce = S(new y())
      return L(
        function (oe) {
          let ae = ce.evaluate(oe)
          ae !== _ && A.call(X, ae)
        },
        void 0,
        fe
      )
    }
  }
  exports.chain = chain
  let _ = Symbol('HaltChainable')
  class y {
    constructor() {
      this.steps = []
    }
    map(S) {
      return this.steps.push(S), this
    }
    forEach(S) {
      return this.steps.push(T => (S(T), T)), this
    }
    filter(S) {
      return this.steps.push(T => (S(T) ? T : _)), this
    }
    reduce(S, T) {
      let A = T
      return this.steps.push(X => ((A = S(A, X)), A)), this
    }
    latch(S = (T, A) => T === A) {
      let T = !0,
        A
      return (
        this.steps.push(X => {
          let fe = T || !S(X, A)
          return (T = !1), (A = X), fe ? X : _
        }),
        this
      )
    }
    evaluate(S) {
      for (let T of this.steps) if (((S = T(S)), S === _)) break
      return S
    }
  }
  function fromNodeEventEmitter(L, S, T = A => A) {
    let A = (...oe) => ce.fire(T(...oe)),
      X = () => L.on(S, A),
      fe = () => L.removeListener(S, A),
      ce = new EventManager({ onWillAddFirstListener: X, onDidRemoveLastListener: fe })
    return ce.event
  }
  exports.fromNodeEventEmitter = fromNodeEventEmitter
  function fromDOMEventEmitter(L, S, T = A => A) {
    let A = (...oe) => ce.fire(T(...oe)),
      X = () => L.addEventListener(S, A),
      fe = () => L.removeEventListener(S, A),
      ce = new EventManager({ onWillAddFirstListener: X, onDidRemoveLastListener: fe })
    return ce.event
  }
  exports.fromDOMEventEmitter = fromDOMEventEmitter
  function toPromise(L) {
    return new Promise(S => once(L)(S))
  }
  exports.toPromise = toPromise
  function fromPromise(L) {
    let S = new EventManager()
    return (
      L.then(
        T => {
          S.fire(T)
        },
        () => {
          S.fire(void 0)
        }
      ).finally(() => {
        S.dispose()
      }),
      S.event
    )
  }
  exports.fromPromise = fromPromise
  function runAndSubscribe(L, S, T) {
    return S(T), L(A => S(A))
  }
  exports.runAndSubscribe = runAndSubscribe
  function runAndSubscribeWithStorej(L, S) {
    let T = null
    function A(fe) {
      T?.dispose(), (T = new DisposableStore()), S(fe, T)
    }
    A(void 0)
    let X = L(fe => A(fe))
    return createDisposable(() => {
      X.dispose(), T?.dispose()
    })
  }
  exports.runAndSubscribeWithStore = runAndSubscribeWithStore
  class M {
    constructor(S, T) {
      this._observable = S
      this._counter = 0
      this._hasChanged = !1
      let A = {
        onWillAddFirstListener: () => {
          S.addObserver(this)
        },
        onDidRemoveLastListener: () => {
          S.removeObserver(this)
        },
      }
      T || e(A), (this.emitter = new EventManager(A)), T && T.add(this.emitter)
    }
    beginUpdate(S) {
      this._counter++
    }
    handlePossibleChange(S) {}
    handleChange(S, T) {
      this._hasChanged = !0
    }
    endUpdate(S) {
      this._counter--,
        this._counter === 0 &&
          (this._observable.reportChanges(),
          this._hasChanged && ((this._hasChanged = !1), this.emitter.fire(this._observable.get())))
    }
  }
  function fromObservable(L, S) {
    return new M(L, S).emitter.event
  }
  exports.fromObservable = fromObservable
  function fromObservableLight(L) {
    return (S, T, A) => {
      let X = 0,
        fe = !1,
        ce = {
          beginUpdate() {
            X++
          },
          endUpdate() {
            X--, X === 0 && (L.reportChanges(), fe && ((fe = !1), S.call(T)))
          },
          handlePossibleChange() {},
          handleChange() {
            fe = !0
          },
        }
      L.addObserver(ce), L.reportChanges()
      let oe = {
        dispose() {
          L.removeObserver(ce)
        },
      }
      return A instanceof DisposableStore ? A.add(oe) : Array.isArray(A) && A.push(oe), oe
    }
  }
  exports.fromObservableLight = fromObservableLight
})((EventUtils ||= {}))
var EventTracker = class EventTracker {
  constructor(eventName) {
    this.listenerCount = 0
    this.invocationCount = 0
    this.elapsedOverall = 0
    this.durations = []
    this.name = `${eventName}_${EventTracker._idPool++}`
    EventTracker.all.add(this)
  }
  static {
    this.all = new Set()
  }
  static {
    this._idPool = 0
  }
  start(listenerCount) {
    this._stopWatch = new Stopwatch()
    this.listenerCount = listenerCount
  }
  stop() {
    if (this._stopWatch) {
      let elapsed = this._stopWatch.elapsed()
      this.durations.push(elapsed)
      this.elapsedOverall += elapsed
      this.invocationCount += 1
      this._stopWatch = undefined
    }
  }
}
var PW = -1
var LeakDetector = class {
  constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
    this.threshold = threshold
    this.name = name
    this._warnCountdown = 0
  }
  dispose() {
    this._stacks?.clear()
  }
  check(stackTrace, listenerCount) {
    let threshold = this.threshold
    if (threshold <= 0 || listenerCount < threshold) return
    this._stacks || (this._stacks = new Map())
    let count = this._stacks.get(stackTrace.value) || 0
    if ((this._stacks.set(stackTrace.value, count + 1), (this._warnCountdown -= 1), this._warnCountdown <= 0)) {
      this._warnCountdown = threshold * 0.5
      let mostFrequent,
        maxCount = 0
      for (let [trace, count] of this._stacks) (!mostFrequent || maxCount < count) && ((mostFrequent = trace), (maxCount = count))
      console.warn(
        `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${maxCount}):`
      ),
        console.warn(mostFrequent)
    }
    return () => {
      let count = this._stacks.get(stackTrace.value) || 0
      this._stacks.set(stackTrace.value, count - 1)
    }
  }
}
var StackTrace = class StackTrace {
  constructor(value) {
    this.value = value
  }
  static create() {
    return new StackTrace(new Error().stack ?? '')
  }
  print() {
    console.warn(
      this.value
        .split(
          `
`
        )
        .slice(2).join(`
`)
    )
  }
}
var idCounter = 0
var TraceId = class {
  constructor(value) {
    this.value = value
    this.id = idCounter++
  }
}
var JTe = 2
var processTrace = (trace, callback) => {
    if (trace instanceof TraceId) callback(trace)
    else
      for (let i = 0; i < trace.length; i++) {
        let item = trace[i]
        item && callback(item)
      }
  },
var EventManager = class {
    constructor(e) {
      this._size = 0
      ;(this._options = e),
        (this._leakageMon =
          PW > 0 || this._options?.leakWarningThreshold ? new LeakDetector(this._options?.leakWarningThreshold ?? PW) : void 0),
        (this._perfMon = this._options?._profName ? new EventTracker(this._options._profName) : void 0),
        (this._deliveryQueue = this._options?.deliveryQueue)
    }
    dispose() {
      if (!this._disposed) {
        if (
          ((this._disposed = !0), this._deliveryQueue?.current === this && this._deliveryQueue.reset(), this._listeners)
        ) {
          if (isDebugMode) {
            let e = this._listeners
            queueMicrotask(() => {
              ZTe(e, r => r.stack?.print())
            })
          }
          ;(this._listeners = void 0), (this._size = 0)
        }
        this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose()
      }
    }
    get event() {
      return (
        (this._event ??= (e, r, n) => {
          if (this._leakageMon && this._size > this._leakageMon.threshold * 3)
            return (
              console.warn(
                `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`
              ),
              Disposable.None
            )
          if (this._disposed) return Disposable.None
          r && (e = e.bind(r))
          let i = new TraceId(e),
            o,
            s
          this._leakageMon &&
            this._size >= Math.ceil(this._leakageMon.threshold * 0.2) &&
            ((i.stack = StackTrace.create()), (o = this._leakageMon.check(i.stack, this._size + 1))),
            isDebugMode && (i.stack = s ?? StackTrace.create()),
            this._listeners
              ? this._listeners instanceof TraceId
                ? ((this._deliveryQueue ??= new Queue()), (this._listeners = [this._listeners, i]))
                : this._listeners.push(i)
              : (this._options?.onWillAddFirstListener?.(this),
                (this._listeners = i),
                this._options?.onDidAddFirstListener?.(this)),
            this._size++
          let a = createDisposable(() => {
            o?.(), this._removeListener(i)
          })
          return n instanceof DisposableStore ? n.add(a) : Array.isArray(n) && n.push(a), a
        }),
        this._event
      )
    }
    _removeListener(e) {
      if ((this._options?.onWillRemoveListener?.(this), !this._listeners)) return
      if (this._size === 1) {
        ;(this._listeners = void 0), this._options?.onDidRemoveLastListener?.(this), (this._size = 0)
        return
      }
      let r = this._listeners,
        n = r.indexOf(e)
      if (n === -1)
        throw (
          (console.log('disposed?', this._disposed),
          console.log('size?', this._size),
          console.log('arr?', JSON.stringify(this._listeners)),
          new Error('Attempted to dispose unknown listener'))
        )
      this._size--, (r[n] = void 0)
      let i = this._deliveryQueue.current === this
      if (this._size * JTe <= r.length) {
        let o = 0
        for (let s = 0; s < r.length; s++)
          r[s]
            ? (r[o++] = r[s])
            : i && (this._deliveryQueue.end--, o < this._deliveryQueue.i && this._deliveryQueue.i--)
        r.length = o
      }
    }
    _deliver(e, r) {
      if (!e) return
      let n = this._options?.onListenerError || handleUnexpectedError
      if (!n) {
        e.value(r)
        return
      }
      try {
        e.value(r)
      } catch (i) {
        n(i)
      }
    }
    _deliverQueue(e) {
      let r = e.current._listeners
      for (; e.i < e.end; ) this._deliver(r[e.i++], e.value)
      e.reset()
    }
    fire(e) {
      if (
        (this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()),
        this._perfMon?.start(this._size),
        this._listeners)
      )
        if (this._listeners instanceof TraceId) this._deliver(this._listeners, e)
        else {
          let r = this._deliveryQueue
          r.enqueue(this, e, this._listeners.length), this._deliverQueue(r)
        }
      this._perfMon?.stop()
    }
    hasListeners() {
      return this._size > 0
    }
  }
class Queue {
  constructor() {
    this.index = -1;
    this.end = 0;
  }
  enqueue(element, value, end) {
    this.index = 0;
    this.end = end;
    this.current = element;
    this.value = value;
  }
  reset() {
    this.index = this.end;
    this.current = undefined;
    this.value = undefined;
  }
}
const DelayedExecution = Object.freeze(function (callback, context) {
  let timeoutId = setTimeout(callback.bind(context), 0);
  return {
    dispose() {
      clearTimeout(timeoutId);
    },
  };
});
let CancellationToken;
((CancellationToken = {}) => {
  function isCancellationToken(i) {
    return i === CancellationToken.None || i === CancellationToken.Cancelled || i instanceof Cancellation
      ? true
      : !i || typeof i != 'object'
      ? false
      : typeof i.isCancellationRequested == 'boolean' && typeof i.onCancellationRequested == 'function';
  }
  CancellationToken.isCancellationToken = isCancellationToken;
  CancellationToken.None = Object.freeze({ isCancellationRequested: false, onCancellationRequested: EventUtils.None });
  CancellationToken.Cancelled = Object.freeze({ isCancellationRequested: true, onCancellationRequested: DelayedExecution });
})(CancellationToken || (CancellationToken = {}));
class Cancellation {
  constructor() {
    this._isCancelled = false;
    this._emitter = null;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(undefined);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? DelayedExecution : (this._emitter || (this._emitter = new EventManager()), this._emitter.event);
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
}
class CancellationSource {
  constructor(parent) {
    this._token = undefined;
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new Cancellation()), this._token;
  }
  cancel() {
    if (this._token) {
      if (this._token instanceof Cancellation) {
        this._token.cancel();
      }
    } else {
      this._token = CancellationToken.Cancelled;
    }
  }
  dispose(cancel = false) {
    if (cancel) {
      this.cancel();
    }
    this._parentListener?.dispose();
    if (this._token) {
      if (this._token instanceof Cancellation) {
        this._token.dispose();
      }
    } else {
      this._token = CancellationToken.None;
    }
  }
}
var Memoize = class {
  constructor(fn) {
    this.fn = fn;
    this.lastCache = undefined;
    this.lastArgKey = undefined;
  }
  get(arg) {
    let argKey = JSON.stringify(arg);
    if (this.lastArgKey !== argKey) {
      this.lastArgKey = argKey;
      this.lastCache = this.fn(arg);
    }
    return this.lastCache;
  }
}
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._didRun = false;
  }
  get hasValue() {
    return this._didRun;
  }
  get value() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (error) {
        this._error = error;
      } finally {
        this._didRun = true;
      }
    }
    if (this._error) throw this._error;
    return this._value;
  }
  get rawValue() {
    return this._value;
  }
}
function findFirstNonWhitespaceChar(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    let code = str.charCodeAt(i);
    if (code !== 32 && code !== 9) return i;
  }
  return -1;
}
function replaceAllWithPromise(str, regex, replacer) {
  let result = [],
    lastIndex = 0;
  for (let match of str.matchAll(regex)) {
    result.push(str.slice(lastIndex, match.index));
    if (match.index === undefined) throw new Error('match.index should be defined');
    lastIndex = match.index + match[0].length;
    result.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
  }
  result.push(str.slice(lastIndex));
  return Promise.all(result).then(parts => parts.join(''));
}
function compareNumbers(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function compareStrings(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let aCode = a.charCodeAt(aStart),
      bCode = b.charCodeAt(bStart);
    if (aCode < bCode) return -1;
    if (aCode > bCode) return 1;
  }
  let aLength = aEnd - aStart,
    bLength = bEnd - bStart;
  return aLength < bLength ? -1 : aLength > bLength ? 1 : 0;
}
function compareStringsIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
    let aCode = a.charCodeAt(aStart),
      bCode = b.charCodeAt(bStart);
    if (aCode === bCode) continue;
    if (aCode >= 128 || bCode >= 128) return compareStrings(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
    isLowerCase(aCode) && (aCode -= 32), isLowerCase(bCode) && (bCode -= 32);
    let diff = aCode - bCode;
    if (diff !== 0) return diff;
  }
  let aLength = aEnd - aStart,
    bLength = bEnd - bStart;
  return aLength < bLength ? -1 : aLength > bLength ? 1 : 0;
}
function isLowerCase(code) {
  return code >= 97 && code <= 122;
}
function equalsIgnoreCase(a, b) {
  return a.length === b.length && compareStringsIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, prefix) {
  let prefixLength = prefix.length;
  return prefix.length > str.length ? false : compareStringsIgnoreCase(str, prefix, 0, prefixLength) === 0;
}
var unicodeBOM = String.fromCharCode(65279);

var GraphemeBreakTypeGetter = class Singleton {
  static {
    this._INSTANCE = null;
  }
  static getInstance() {
    return Singleton._INSTANCE || (Singleton._INSTANCE = new Singleton()), Singleton._INSTANCE;
  }
  constructor() {
    this._data = getGraphemeBreakData();
  }
  getGraphemeBreakType(charCode) {
    if (charCode < 32) return charCode === 10 ? 3 : charCode === 13 ? 2 : 4;
    if (charCode < 127) return 0;
    let data = this._data,
      dataLength = data.length / 3,
      index = 1;
    for (; index <= dataLength; ) {
      if (charCode < data[3 * index]) index = 2 * index;
      else if (charCode > data[3 * index + 1]) index = 2 * index + 1;
      else return data[3 * index + 2];
    }
    return 0;
  }
}
function getGraphemeBreakData() {
  return JSON.parse(
    '[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]'
  )
}
class ConfusableCharacterHandler {
  constructor(dictionary) {
    this.confusableDictionary = dictionary;
  }
  static {
    this.ambiguousCharacterData = new Lazy(() =>
      JSON.parse('{common:[]}')
    );
  }
  static {
    this.cache = new Memoize(locales => {
      function createMapFromArray(array) {
        let map = new Map();
        for (let i = 0; i < array.length; i += 2) map.set(array[i], array[i + 1]);
        return map;
      }
      function mergeMaps(map1, map2) {
        let mergedMap = new Map(map1);
        for (let [key, value] of map2) mergedMap.set(key, value);
        return mergedMap;
      }
      function intersectMaps(map1, map2) {
        if (!map1) return map2;
        let intersectedMap = new Map();
        for (let [key, value] of map1) map2.has(key) && intersectedMap.set(key, value);
        return intersectedMap;
      }
      let data = this.ambiguousCharacterData.value,
        filteredLocales = locales.filter(locale => !locale.startsWith('_') && locale in data);
      filteredLocales.length === 0 && (filteredLocales = ['_default']);
      let intersectedMap;
      for (let locale of filteredLocales) {
        let map = createMapFromArray(data[locale]);
        intersectedMap = intersectMaps(intersectedMap, map);
      }
      let commonMap = createMapFromArray(data._common),
        mergedMap = mergeMaps(commonMap, intersectedMap);
      return new ConfusableCharacterHandler(mergedMap);
    });
  }
  static getInstance(locales) {
    return ConfusableCharacterHandler.cache.get(Array.from(locales));
  }
  static {
    this._locales = new Lazy(() => Object.keys(ConfusableCharacterHandler.ambiguousCharacterData.value).filter(locale => !locale.startsWith('_')));
  }
  static getLocales() {
    return ConfusableCharacterHandler._locales.value;
  }
  isAmbiguous(character) {
    return this.confusableDictionary.has(character);
  }
  getPrimaryConfusable(character) {
    return this.confusableDictionary.get(character);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
class InvisibleCharacterHandler {
  static getRawData() {
    return JSON.parse('[]');
  }
  static {
    this._data = undefined;
  }
  static getData() {
    return this._data || (this._data = new Set(InvisibleCharacterHandler.getRawData())), this._data;
  }
  static isInvisibleCharacter(character) {
    return InvisibleCharacterHandler.getData().has(character);
  }
  static get codePoints() {
    return InvisibleCharacterHandler.getData();
  }
};
function isPathSeparator(charCode) {
  return charCode === 47 || charCode === 92;
}
function replacePathSeparators(path) {
  return path.replace(/[\\/]/g, posixPathOperations.sep);
}

function normalizeWindowsPath(path) {
  if (path.indexOf('/') === -1) {
    path = replacePathSeparators(path);
  }
  if (/^[a-zA-Z]:(\/|$)/.test(path)) {
    path = '/' + path;
  }
  return path;
}

function getRoot(path, separator = posixPathOperations.sep) {
  if (!path) return '';
  let length = path.length,
    firstCharCode = path.charCodeAt(0);
  if (isPathSeparator(firstCharCode)) {
    if (isPathSeparator(path.charCodeAt(1)) && !isPathSeparator(path.charCodeAt(2))) {
      let index = 3,
        start = index;
      for (; index < length && !isPathSeparator(path.charCodeAt(index)); index++);
      if (start !== index && !isPathSeparator(path.charCodeAt(index + 1))) {
        for (index += 1; index < length; index++) if (isPathSeparator(path.charCodeAt(index))) return path.slice(0, index + 1).replace(/[\\/]/g, separator);
      }
    }
    return separator;
  } else if (isAlphabet(firstCharCode) && path.charCodeAt(1) === 58) return isPathSeparator(path.charCodeAt(2)) ? path.slice(0, 2) + separator : path.slice(0, 2);
  let protocolIndex = path.indexOf('://');
  if (protocolIndex !== -1) {
    for (protocolIndex += 3; protocolIndex < length; protocolIndex++) if (isPathSeparator(path.charCodeAt(protocolIndex))) return path.slice(0, protocolIndex + 1);
  }
  return '';
}

function startsWithFolder(path, folder, caseSensitive, separator = pathSeparator) {
  if (path === folder) return true;
  if (!path || !folder || folder.length > path.length) return false;
  if (caseSensitive) {
    if (!startsWithIgnoreCase(path, folder)) return false;
    if (folder.length === path.length) return true;
    let folderLength = folder.length;
    return folder.charAt(folder.length - 1) === separator && folderLength--, path.charAt(folderLength) === separator;
  }
  return folder.charAt(folder.length - 1) !== separator && (folder += separator), path.indexOf(folder) === 0;
}

function isAlphabet(charCode) {
  return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122);
}
var resourceTypes;
((T) => (
  (T.inMemory = 'inmemory'),
  (T.vscode = 'vscode'),
  (T.internal = 'private'),
  (T.walkThrough = 'walkThrough'),
  (T.walkThroughSnippet = 'walkThroughSnippet'),
  (T.http = 'http'),
  (T.https = 'https'),
  (T.file = 'file'),
  (T.mailto = 'mailto'),
  (T.untitled = 'untitled'),
  (T.data = 'data'),
  (T.command = 'command'),
  (T.vscodeRemote = 'vscode-remote'),
  (T.vscodeRemoteResource = 'vscode-remote-resource'),
  (T.vscodeManagedRemoteResource = 'vscode-managed-remote-resource'),
  (T.vscodeUserData = 'vscode-userdata'),
  (T.vscodeCustomEditor = 'vscode-custom-editor'),
  (T.vscodeNotebookCell = 'vscode-notebook-cell'),
  (T.vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata'),
  (T.vscodeNotebookCellOutput = 'vscode-notebook-cell-output'),
  (T.vscodeInteractiveInput = 'vscode-interactive-input'),
  (T.vscodeSettings = 'vscode-settings'),
  (T.vscodeWorkspaceTrust = 'vscode-workspace-trust'),
  (T.vscodeTerminal = 'vscode-terminal'),
  (T.vscodeChatSesssion = 'vscode-chat-editor'),
  (T.webviewPanel = 'webview-panel'),
  (T.vscodeWebview = 'vscode-webview'),
  (T.extension = 'extension'),
  (T.vscodeFileResource = 'vscode-file'),
  (T.tmp = 'tmp'),
  (T.vsls = 'vsls'),
  (T.vscodeSourceControl = 'vscode-scm')
))((resourceTypes ||= {}))
var tokenKey = 'tkn',
  ResourceRewriter = class {
    constructor() {
      this._hosts = Object.create(null)
      this._ports = Object.create(null)
      this._connectionTokens = Object.create(null)
      this._preferredWebSchema = 'http'
      this._delegate = null
      this._remoteResourcesPath = `/${resourceTypes.vscodeRemoteResource}`
    }
    setPreferredWebSchema(schema) {
      this._preferredWebSchema = schema
    }
    setDelegate(delegate) {
      this._delegate = delegate
    }
    setServerRootPath(rootPath) {
      this._remoteResourcesPath = `${rootPath}/${resourceTypes.vscodeRemoteResource}`
    }
    set(host, port, connectionToken) {
      this._hosts[host] = port
      this._ports[host] = connectionToken
    }
    setConnectionToken(host, token) {
      this._connectionTokens[host] = token
    }
    getPreferredWebSchema() {
      return this._preferredWebSchema
    }
    rewrite(uri) {
      if (this._delegate)
        try {
          return this._delegate(uri)
        } catch (error) {
          return handleUnexpectedError(error), uri
        }
      let authority = uri.authority,
        host = this._hosts[authority]
      host && host.indexOf(':') !== -1 && host.indexOf('[') === -1 && (host = `[${host}]`)
      let port = this._ports[authority],
        connectionToken = this._connectionTokens[authority],
        query = `path=${encodeURIComponent(uri.path)}`
      return (
        typeof connectionToken == 'string' && (query += `&${tokenKey}=${encodeURIComponent(connectionToken)}`),
        Uri.from({
          scheme: isBrowserFlag ? this._preferredWebSchema : resourceTypes.vscodeRemoteResource,
          authority: `${host}:${port}`,
          path: this._remoteResourcesPath,
          query: query,
        })
      )
    }
  },
  resourceRewriterInstance = new ResourceRewriter()
var fallbackAuthority = 'vscode-app',
  ResourceHandler = class ResourceHandlerClass {
    static {
      this.FALLBACK_AUTHORITY = fallbackAuthority
    }
    asBrowserUri(resource) {
      let uri = this.toUri(resource, require)
      return this.uriToBrowserUri(uri)
    }
    uriToBrowserUri(uri) {
      return uri.scheme === resourceTypes.vscodeRemote
        ? resourceRewriterInstance.rewrite(uri)
        : uri.scheme === resourceTypes.file && (isNodeFlag || globalOrigin === `${resourceTypes.vscodeFileResource}://${ResourceHandlerClass.FALLBACK_AUTHORITY}`)
        ? uri.with({
            scheme: resourceTypes.vscodeFileResource,
            authority: uri.authority || ResourceHandlerClass.FALLBACK_AUTHORITY,
            query: null,
            fragment: null,
          })
        : uri
    }
    asFileUri(resource) {
      let uri = this.toUri(resource, require)
      return this.uriToFileUri(uri)
    }
    uriToFileUri(uri) {
      return uri.scheme === resourceTypes.vscodeFileResource
        ? uri.with({
            scheme: resourceTypes.file,
            authority: uri.authority !== ResourceHandlerClass.FALLBACK_AUTHORITY ? uri.authority : null,
            query: null,
            fragment: null,
          })
        : uri
    }
    toUri(resource, requireFunction) {
      return Uri.isUri(resource) ? resource : Uri.parse(requireFunction.toUrl(resource))
    }
  },
  resourceHandlerInstance = new ResourceHandler(),
  crossOriginSettings
;(crossOrigin => {
  let policyMap = new Map([
    ['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],
    ['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],
    ['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],
  ])
  crossOrigin.CoopAndCoep = Object.freeze(policyMap.get('3'))
  let policyKey = 'vscode-coi'
  function getHeadersFromQuery(query) {
    let searchParams
    typeof query == 'string'
      ? (searchParams = new URL(query).searchParams)
      : query instanceof URL
      ? (searchParams = query.searchParams)
      : Uri.isUri(query) && (searchParams = new URL(query.toString(true)).searchParams)
    let policy = searchParams?.get(policyKey)
    if (policy) return policyMap.get(policy)
  }
  crossOrigin.getHeadersFromQuery = getHeadersFromQuery
  function addSearchParam(searchParams, coop, coep) {
    if (!globalThis.crossOriginIsolated) return
    let policy = coop && coep ? '3' : coep ? '2' : '1'
    searchParams instanceof URLSearchParams ? searchParams.set(policyKey, policy) : (searchParams[policyKey] = policy)
  }
  crossOrigin.addSearchParam = addSearchParam
})((crossOriginSettings ||= {}))
function getFilePathWithFlag(filePath, flag = true) {
  return getFilePath(filePath, flag);
}
var UriPathHandler = class {
  constructor(ignorePathCasing) {
    this._ignorePathCasing = ignorePathCasing;
  }

    compare(e, r, n = !1) {
      return e === r ? 0 : compareNumbers(this.getComparisonKey(e, n), this.getComparisonKey(r, n))
    }
    isEqual(e, r, n = !1) {
      return e === r ? !0 : !e || !r ? !1 : this.getComparisonKey(e, n) === this.getComparisonKey(r, n)
    }
    getComparisonKey(e, r = !1) {
      return e
        .with({ path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0, fragment: r ? null : void 0 })
        .toString()
    }
    ignorePathCasing(e) {
      return this._ignorePathCasing(e)
    }
    isEqualOrParent(e, r, n = !1) {
      if (e.scheme === r.scheme) {
        if (e.scheme === resourceTypes.file)
          return startsWithFolder(getFilePathWithFlag(e), getFilePathWithFlag(r), this._ignorePathCasing(e)) && e.query === r.query && (n || e.fragment === r.fragment)
        if (areAuthoritiesEqual(e.authority, r.authority))
          return (
            startsWithFolder(e.path, r.path, this._ignorePathCasing(e), '/') &&
            e.query === r.query &&
            (n || e.fragment === r.fragment)
          )
      }
      return !1
    }
    joinPath(e, ...r) {
      return Uri.joinPath(e, ...r)
    }
    basenameOrAuthority(e) {
      return getBasename(e) || e.authority
    }
    basename(e) {
      return posixPathOperations.basename(e.path)
    }
    extname(e) {
      return posixPathOperations.extname(e.path)
    }
    dirname(e) {
      if (e.path.length === 0) return e
      let r
      return (
        e.scheme === resourceTypes.file
          ? (r = Uri.file(dirname(getFilePathWithFlag(e))).path)
          : ((r = posixPathOperations.dirname(e.path)),
            e.authority &&
              r.length &&
              r.charCodeAt(0) !== 47 &&
              (console.error(`dirname("${e.toString})) resulted in a relative path`), (r = '/'))),
        e.with({ path: r })
      )
    }
    normalizePath(e) {
      if (!e.path.length) return e
      let r
      return e.scheme === resourceTypes.file ? (r = Uri.file(normalizePath(getFilePathWithFlag(e))).path) : (r = posixPathOperations.normalize(e.path)), e.with({ path: r })
    }
    relativePath(e, r) {
      if (e.scheme !== r.scheme || !areAuthoritiesEqual(e.authority, r.authority)) return
      if (e.scheme === resourceTypes.file) {
        let o = relativePath(getFilePathWithFlag(e), getFilePathWithFlag(r))
        return isWindowsFlag ? replacePathSeparators(o) : o
      }
      let n = e.path || '/',
        i = r.path || '/'
      if (this._ignorePathCasing(e)) {
        let o = 0
        for (
          let s = Math.min(n.length, i.length);
          o < s && !(n.charCodeAt(o) !== i.charCodeAt(o) && n.charAt(o).toLowerCase() !== i.charAt(o).toLowerCase());
          o++
        );
        n = i.substr(0, o) + n.substr(o)
      }
      return posixPathOperations.relative(n, i)
    }
    resolvePath(e, r) {
      if (e.scheme === resourceTypes.file) {
        let n = Uri.file(joinPath(getFilePathWithFlag(e), r))
        return e.with({ authority: n.authority, path: n.path })
      }
      return (r = normalizeWindowsPath(r)), e.with({ path: posixPathOperations.resolve(e.path, r) })
    }
    isAbsolutePath(e) {
      return !!e.path && e.path[0] === '/'
    }
    isEqualAuthority(e, r) {
      return e === r || (e !== void 0 && r !== void 0 && equalsIgnoreCase(e, r))
    }
    hasTrailingPathSeparator(e, r = pathSeparator) {
      if (e.scheme === resourceTypes.file) {
        let n = getFilePathWithFlag(e)
        return n.length > getRoot(n).length && n[n.length - 1] === r
      } else {
        let n = e.path
        return n.length > 1 && n.charCodeAt(n.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath)
      }
    }
    removeTrailingPathSeparator(e, r = pathSeparator) {
      return hasTrailingPathSeparator(e, r) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e
    }
    addTrailingPathSeparator(e, r = pathSeparator) {
      let n = !1
      if (e.scheme === resourceTypes.file) {
        let i = getFilePathWithFlag(e)
        n = i !== void 0 && i.length === getRoot(i).length && i[i.length - 1] === r
      } else {
        r = '/'
        let i = e.path
        n = i.length === 1 && i.charCodeAt(i.length - 1) === 47
      }
      return !n && !hasTrailingPathSeparator(e, r) ? e.with({ path: e.path + '/' }) : e
    }
  }
var defaultPathHandler = new UriPathHandler(() => false),
fileSystemPathHandler = new UriPathHandler(t => (t.scheme === resourceTypes.file ? !isLinuxFlag : !0)),
alwaysCaseSensitivePathHandler = new UriPathHandler(t => !0),
arePathsEqual = defaultPathHandler.isEqual.bind(defaultPathHandler),
isPathEqualOrParent = defaultPathHandler.isEqualOrParent.bind(defaultPathHandler),
getComparisonKey = defaultPathHandler.getComparisonKey.bind(defaultPathHandler),
getBasenameOrAuthority = defaultPathHandler.basenameOrAuthority.bind(defaultPathHandler),
getBasename = defaultPathHandler.basename.bind(defaultPathHandler),
getExtension = defaultPathHandler.extname.bind(defaultPathHandler),
getDirname = defaultPathHandler.dirname.bind(defaultPathHandler),
joinPaths = defaultPathHandler.joinPath.bind(defaultPathHandler),
normalizePath = defaultPathHandler.normalizePath.bind(defaultPathHandler),
getRelativePath = defaultPathHandler.relativePath.bind(defaultPathHandler),
resolvePath = defaultPathHandler.resolvePath.bind(defaultPathHandler),
isAbsolutePath = defaultPathHandler.isAbsolutePath.bind(defaultPathHandler),
areAuthoritiesEqual = defaultPathHandler.isEqualAuthority.bind(defaultPathHandler),
hasTrailingPathSeparator = defaultPathHandler.hasTrailingPathSeparator.bind(defaultPathHandler),
removeTrailingPathSeparator = defaultPathHandler.removeTrailingPathSeparator.bind(defaultPathHandler),
addTrailingPathSeparator = defaultPathHandler.addTrailingPathSeparator.bind(defaultPathHandler)
var metaData
;(metaDataObject => {
  ;(metaDataObject.META_DATA_LABEL = 'label'),
    (metaDataObject.META_DATA_DESCRIPTION = 'description'),
    (metaDataObject.META_DATA_SIZE = 'size'),
    (metaDataObject.META_DATA_MIME = 'mime')
  function parseMetaData(pathObject) {
    let metaDataMap = new Map()
    pathObject.path
      .substring(pathObject.path.indexOf(';') + 1, pathObject.path.lastIndexOf(';'))
      .split(';')
      .forEach(metaDataItem => {
        let [key, value] = metaDataItem.split(':')
        key && value && metaDataMap.set(key, value)
      })
    let mimeType = pathObject.path.substring(0, pathObject.path.indexOf(';'))
    return mimeType && metaDataMap.set(metaDataObject.META_DATA_MIME, mimeType), metaDataMap
  }
  metaDataObject.parseMetaData = parseMetaData
})((metaData ||= {}))
var microtaskDelaySymbol = Symbol('MicrotaskDelay')
function handleCancellation(promise, cancellationToken, cancellationValue) {
  return new Promise((resolve, reject) => {
    let cancellationDisposable = cancellationToken.onCancellationRequested(() => {
      cancellationDisposable.dispose(), resolve(cancellationValue)
    })
    promise.then(resolve, reject).finally(() => cancellationDisposable.dispose())
  })
}
function timeoutPromise(promise, timeout, onTimeout) {
  let timeoutCancel,
    timeoutId = setTimeout(() => {
      timeoutCancel?.(void 0), onTimeout?.()
    }, timeout)
  return Promise.race([promise.finally(() => clearTimeout(timeoutId)), new Promise(resolve => (timeoutCancel = resolve))])
}
var idleCallback, idleCallbackFunction
;(function () {
  typeof globalThis.requestIdleCallback != 'function' || typeof globalThis.cancelIdleCallback != 'function'
    ? (idleCallbackFunction = (callback, onTimeout) => {
      scheduleAsyncWork(() => {
          if (isDisposed) return
          let deadline = Date.now() + 15
          onTimeout(
            Object.freeze({
              didTimeout: true,
              timeRemaining() {
                return Math.max(0, deadline - Date.now())
              },
            })
          )
        })
        let isDisposed = false
        return {
          dispose() {
            isDisposed || (isDisposed = true)
          },
        }
      })
    : (idleCallbackFunction = (callback, onTimeout, timeout) => {
        let idleCallbackId = callback.requestIdleCallback(onTimeout, typeof timeout == 'number' ? { timeout: timeout } : void 0),
          isDisposed = false
        return {
          dispose() {
            isDisposed || ((isDisposed = true), callback.cancelIdleCallback(idleCallbackId))
          },
        }
      }),
    (idleCallback = callback => idleCallbackFunction(globalThis, callback))
})()
var PromiseOutcome = class {
  get isRejected() {
    return this.outcome?.outcome === 1
  }
  get isResolved() {
    return this.outcome?.outcome === 0
  }
  get isSettled() {
    return !!this.outcome
  }
  get value() {
    return this.outcome?.outcome === 0 ? this.outcome?.value : void 0
  }
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      ;(this.completeCallback = resolve), (this.errorCallback = reject)
    })
  }
  complete(value) {
    return new Promise(resolve => {
      this.completeCallback(value), (this.outcome = { outcome: 0, value: value }), resolve()
    })
  }
  error(value) {
    return new Promise(resolve => {
      this.errorCallback(value), (this.outcome = { outcome: 1, value: value }), resolve()
    })
  }
  cancel() {
    return this.error(new CancellationError())
  }
},
promiseUtils
;(utils => {
  async function settled(promises) {
    let error,
      results = await Promise.all(
        promises.map(promise =>
          promise.then(
            result => result,
            result => {
              error || (error = result)
            }
          )
        )
      )
    if (typeof error < 'u') throw error
    return results
  }
  utils.settled = settled
  function withAsyncBody(asyncFunction) {
    return new Promise(async (resolve, reject) => {
      try {
        await asyncFunction(resolve, reject)
      } catch (error) {
        reject(error)
      }
    })
  }
  utils.withAsyncBody = withAsyncBody
})((promiseUtils ||= {}))
class AsyncIterable {
  static fromArray(array) {
    return new AsyncIterable(emitter => {
      emitter.emitMany(array)
    })
  }
  static fromPromise(promise) {
    return new AsyncIterable(async emitter => {
      emitter.emitMany(await promise)
    })
  }
  static fromPromises(promises) {
    return new AsyncIterable(async emitter => {
      await Promise.all(promises.map(async promise => emitter.emitOne(await promise)))
    })
  }
  static merge(iterables) {
    return new AsyncIterable(async emitter => {
      await Promise.all(
        iterables.map(async iterable => {
          for await (let item of iterable) emitter.emitOne(item)
        })
      )
    })
  }
  static {
    this.EMPTY = AsyncIterable.fromArray([])
  }
  constructor(iterableFunction) {
    ;(this._state = 0),
      (this._results = []),
      (this._error = null),
      (this._onStateChanged = new EventManager()),
      queueMicrotask(async () => {
        let emitter = { emitOne: item => this.emitOne(item), emitMany: items => this.emitMany(items), reject: error => this.reject(error) }
        try {
          await Promise.resolve(iterableFunction(emitter)), this.resolve()
        } catch (error) {
          this.reject(error)
        } finally {
          ;(emitter.emitOne = void 0), (emitter.emitMany = void 0), (emitter.reject = void 0)
        }
      })
  }
  [Symbol.asyncIterator]() {
    let index = 0
    return {
      next: async () => {
        do {
          if (this._state === 2) throw this._error
          if (index < this._results.length) return { done: false, value: this._results[index++] }
          if (this._state === 1) return { done: true, value: void 0 }
          await EventUtils.toPromise(this._onStateChanged.event)
        } while (true)
      },
    }
  }
  static map(iterable, mapFunction) {
    return new AsyncIterable(async emitter => {
      for await (let item of iterable) emitter.emitOne(mapFunction(item))
    })
  }
  map(mapFunction) {
    return AsyncIterable.map(this, mapFunction)
  }
  static filter(iterable, filterFunction) {
    return new AsyncIterable(async emitter => {
      for await (let item of iterable) filterFunction(item) && emitter.emitOne(item)
    })
  }
  filter(filterFunction) {
    return AsyncIterable.filter(this, filterFunction)
  }
  static coalesce(iterable) {
    return AsyncIterable.filter(iterable, item => !!item)
  }
  coalesce() {
    return AsyncIterable.coalesce(this)
  }
  static async toPromise(iterable) {
    let results = []
    for await (let item of iterable) results.push(item)
    return results
  }
  toPromise() {
    return AsyncIterable.toPromise(this)
  }
  emitOne(item) {
    if (this._state === 0) {
      this._results.push(item)
      this._onStateChanged.fire()
    }
  }
  emitMany(items) {
    if (this._state === 0) {
      this._results = this._results.concat(items)
      this._onStateChanged.fire()
    }
  }
  resolve() {
    if (this._state === 0) {
      this._state = 1
      this._onStateChanged.fire()
    }
  }
  reject(error) {
    if (this._state === 0) {
      this._state = 2
      this._error = error
      this._onStateChanged.fire()
    }
  }
}
var DeferredAsyncIterable = class {
  constructor() {
    this._deferred = new PromiseOutcome()
    this._asyncIterable = new AsyncIterable(emitter => {
      if (error) {
        emitter.reject(error)
        return
      }
      return (
        items && emitter.emitMany(items),
        (this._errorFn = err => emitter.reject(err)),
        (this._emitFn = item => emitter.emitOne(item)),
        this._deferred.p
      )
    })
    let error, items
    ;(this._emitFn = item => {
      items || (items = []), items.push(item)
    }),
      (this._errorFn = err => {
        error || (error = err)
      })
  }
  get asyncIterable() {
    return this._asyncIterable
  }
  resolve() {
    this._deferred.complete()
  }
  reject(err) {
    this._errorFn(err), this._deferred.complete()
  }
  emitOne(item) {
    this._emitFn(item)
  }
}
var crypto = require('crypto')

function generateTelemetryEvent() {
  let id = (0, crypto.randomUUID)(),
    event = TelemetryEvent.createAndMarkAsIssued({ messageId: id })
  return new TelemetryEventWrapper(event)
}

var TelemetryEventWrapper = class {
  constructor(event) {
    this.raw = event
  }
  get properties() {
    return this.raw.properties
  }
  get measurements() {
    return this.raw.measurements
  }
  markAsDisplayed() {
    this.raw.markAsDisplayed()
  }
  extendedBy(properties, measurements) {
    let extendedEvent = this.raw.extendedBy(properties, measurements)
    return new TelemetryEventWrapper(extendedEvent)
  }
}

function extendTelemetryEventWithUserInput(conversation, conversationId, uiKind, message, promptTokenLen, suggestion, telemetryEvent) {
  let inputSources = conversation.turns[conversation.turns.length - 1].contextParts.map(part => part.kind).sort(),
    properties = {
      source: 'user',
      turnIndex: (conversation.turns.length - 1).toString(),
      conversationId: conversationId,
      uiKind: uiKind,
      inputSources: inputSources.join(','),
    },
    measurements = { promptTokenLen: promptTokenLen, messageCharLen: message.length }
  return suggestion && (properties.suggestion = suggestion), (telemetryEvent = telemetryEvent.extendedBy(properties, measurements)), telemetryEvent
}

function extendTelemetryEventWithOffTopicFlag(conversation, conversationId, uiKind, offTopicFlag, message, telemetryEvent) {
  offTopicFlag !== void 0 && (telemetryEvent = telemetryEvent.extendedBy({ offTopic: offTopicFlag.toString() })), sendTelemetryEvent(conversation, message, conversationId, uiKind, {}, {}, telemetryEvent)
}

function extendTelemetryEventWithModelOutput(conversation, conversationId, uiKind, message, headerRequestId, codeBlocks, telemetryEvent) {
  let codeBlockLanguages = extractCodeBlocks(codeBlocks)
  sendTelemetry(
    conversation,
    codeBlocks,
    uiKind,
    message,
    {
      source: 'model',
      turnIndex: conversation.turns.length.toString(),
      conversationId: conversationId,
      headerRequestId: headerRequestId,
      uiKind: uiKind,
      codeBlockLanguages: JSON.stringify({ ...codeBlockLanguages }),
    },
    { messageCharLen: message.length, numCodeBlocks: codeBlockLanguages.length },
    telemetryEvent
  )
}

function extendTelemetryEventWithOffTopicMessage(conversation, conversationId, uiKind, message, userMessageId, telemetryEvent) {
  sendTelemetry(
    conversation,
    telemetryEvent,
    uiKind,
    message,
    { source: 'offTopic', turnIndex: conversation.turns.length.toString(), conversationId: conversationId, userMessageId: userMessageId, uiKind: uiKind },
    { messageCharLen: message.length },
    telemetryEvent
  )
}
function sendTelemetryData(telemetryService, event, rawMessage, messageText, languageId, documentLength, extension) {
  let message = { ...(messageText ? { messageText: messageText } : {}), ...extension }
  if (languageId && documentLength) {
    extension.languageId = languageId;
    documentLength.documentLength = documentLength.getText().length;
  }
  let extendedByIO = extension.extendedBy(extension, documentLength),
    extendedByMessage = extension.extendedBy(message),
    conversationType = determineConversationType(event),
    telemetryServiceInstance = telemetryService.get(IGHTelemetryService)
  return telemetryServiceInstance.sendTelemetry(`${conversationType}.message`, extendedByIO.raw), telemetryServiceInstance.sendRestrictedTelemetry(`${conversationType}.messageText`, extendedByMessage.raw), extendedByIO.raw
}

function displaySuggestion(telemetryService, suggestion, messageId, suggestionId, extension) {
  return sendSuggestionTelemetry(telemetryService, extension, { suggestion: suggestion, messageId: messageId, suggestionId: suggestionId }, {}, 'conversation.suggestionShown')
}
function sendSuggestionTelemetry(telemetryService, languageId, documentLength, extension, event) {
  let telemetryEvent = TelemetryEvent.createAndMarkAsIssued()
  if (languageId && documentLength) {
    documentLength.languageId = languageId;
    documentLength.documentLength = documentLength.getText().length;
  }
  let extendedEvent = telemetryEvent.extendedBy(documentLength, extension)
  return telemetryService.get(IGHTelemetryService).sendTelemetry(event, extendedEvent), extendedEvent
}
async function sendEngineMessages(telemetryService, messages, extension) {
  let extendedEvent = extension.extendedBy({ messagesJson: JSON.stringify(messages) })
  await telemetryService.get(IGHTelemetryService).sendRestrictedTelemetry('engine.messages', extendedEvent)
}
function determineConversationType(event) {
  switch (event) {
    case 'conversationInline':
      return 'inlineConversation'
    case 'conversationPanel':
    default:
      return 'conversation'
  }
}
function extractCodeBlocks(text) {
  let lines = text.split(`\n`),
    codeBlocks = [],
    tempBlocks = []
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i]
    line.startsWith('```') && (tempBlocks.length > 0 && line === '```' ? codeBlocks.push(tempBlocks.pop()) : tempBlocks.length === 0 && tempBlocks.push(line.substring(3)))
  }
  return codeBlocks
}

function getGithubRepository(url) {
  if (url !== void 0 && url !== 0 && url.hostname === 'github.com') return url.owner + '/' + url.repo
}

function processIncomingMessage(telemetryService, message, tokens, choiceIndex, requestId, blockFinished, finishReason, extension) {
  sendEngineMessages(telemetryService, [message], extension)
  return {
    message: message,
    choiceIndex: choiceIndex,
    requestId: requestId,
    blockFinished: blockFinished,
    finishReason: finishReason,
    tokens: tokens.tokens,
    numTokens: tokens.tokens.length,
    telemetryData: extension,
  }
}

function processStreamedMessages(telemetryService, message, extension) {
  let logger = telemetryService.get(LoggerManager).getLogger('streamMessages'),
    messageText = message.solution.text.join(''),
    earlyFinish = false
  if (message.finishOffset !== void 0) {
    logger.debug(`message ${message.index}: early finish at offset ${message.finishOffset}`)
    messageText = messageText.substring(0, message.finishOffset)
    earlyFinish = true
  }
  logger.info(`message ${message.index} returned. finish reason: [${message.reason}]`)
  logger.debug(`message ${message.index} details: finishOffset: [${message.finishOffset}] completionId: [{${message.requestId.completionId}}] created: [{${message.requestId.created}}]`)
  let response = processResponse(telemetryService, message.solution),
    processedMessage = { role: 'assistant', content: messageText }
  return processIncomingMessage(telemetryService, processedMessage, response, message.index, message.requestId, earlyFinish, message.reason, extension)
}

async function handleChatRequest(context, engine, request, callback, input, cancellationToken, settings) {
  let logger = context.get(LoggerManager).getLogger('chat fetch'),
    requestPayload = prepareRequestPayload(context, request)
  if (cancellationToken?.isCancellationRequested) return { type: 'canceled', reason: 'before fetch request' }
  logger.info(`engine ${engine.engineUrl}`),
    logger.info(`modelMaxTokenWindow ${engine.modelMaxTokenWindow}`),
    logger.info(`chat model ${request.model}`),
    request.intent_model && logger.info(`intent model ${request.intent_model}`),
    request.intent_tokenizer && logger.info(`intent tokenizer ${request.intent_tokenizer}`),
    request.intent_threshold && logger.info(`intent threshold ${request.intent_threshold}`)
  let secretKey = request.secretKey ?? (await context.get(BaseTokenHandler).getCopilotToken(context)).token
  if (!secretKey)
    return (
      logger.error(`Failed to send request to ${engine.url} due to missing key`),
      logError(context.get(IGHTelemetryService), `Failed to send request to ${engine.url} due to missing key`),
      { type: 'failed', failKind: 'tokenExpiredOrInvalid', reason: 'key is missing' }
    )
  let response = await sendChatRequest(context, engine, request.ourRequestId, requestPayload, secretKey, request.location, cancellationToken, settings)
  if (cancellationToken?.isCancellationRequested) {
    let responseBody = await response.body()
    try {
      responseBody.destroy()
    } catch (error) {
      logger.exception(error, 'Error destroying stream'), context.get(IGHTelemetryService).sendExceptionTelemetry(error, 'Error destroying stream')
    }
    return { type: 'canceled', reason: 'after fetch request' }
  }
  if (response.status !== 200) {
    let telemetryEvent = createTelemetryEvent(engine, context, request.location, request.ourRequestId)
    return logger.info('Request ID for failed request: ', request.ourRequestId), handleErrorResponse(context, telemetryEvent, response)
  }
  let concurrency = request.postOptions?.n ?? 1,
    streamProcessor = (await StreamProcessor.create(context, concurrency, request.ourRequestId, response, callback, [], cancellationToken)).processSSE(input)
  return { type: 'success', chatCompletions: AsyncIterable.map(streamProcessor, message => processStreamedMessages(context, message, callback)), getProcessingTime: () => getProcessingTime(response) }
}

function createTelemetryEvent(engine, context, location, requestId) {
  return TelemetryEvent.createAndMarkAsIssued({ endpoint: engine.endpoint, engineName: engine.engineName, uiKind: getConversationType(location), headerRequestId: requestId })
}

function prepareRequestPayload(context, request) {
  let payload = { messages: request.messages, model: request.model }
  request.postOptions && Object.assign(payload, request.postOptions)
  let githubRepo = getGithubRepository(request.repoInfo)
  if (githubRepo !== void 0) payload.nwo = githubRepo
  if (request.intent) {
    payload.intent = request.intent
    if (request.intent_model) payload.intent_model = request.intent_model
    if (request.intent_tokenizer) payload.intent_tokenizer = request.intent_tokenizer
    if (request.intent_threshold) payload.intent_threshold = request.intent_threshold
  }
  return payload
}

async function handleErrorResponse(context, telemetryEvent, response) {
  let logger = context.get(LoggerManager).getLogger('chat fetch'),
    telemetryService = context.get(IGHTelemetryService)
  telemetryEvent.properties.error = `Response status was ${response.status}`
  telemetryEvent.properties.status = String(response.status)
  telemetryService.sendTelemetry('request.shownWarning', telemetryEvent)
  if (response.status === 401 || response.status === 403) {
    context.get(BaseTokenHandler).resetCopilotToken(context, response.status)
    return { type: 'failed', failKind: 'tokenExpiredOrInvalid', reason: `token expired or invalid: ${response.status}` }
  }
  if (response.status === 499) {
    logger.info('Cancelled by server')
    return { type: 'failed', failKind: 'serverCanceled', reason: 'canceled by server' }
  }
  let responseText = await response.text()
  if (response.status === 466) {
    logger.info(responseText)
    return { type: 'failed', failKind: 'clientNotSupported', reason: `client not supported: ${responseText}` }
  } else if (response.status === 400 && responseText.includes('off_topic')) {
    return { type: 'failed', failKind: 'offTopic', reason: 'filtered as off_topic by intent classifier: message was not programming related' }
  } else if (response.status === 429) {
    return { type: 'failed', failKind: 'rateLimited', reason: responseText }
  } else if (response.status >= 500 && response.status < 600) {
    return { type: 'failed', failKind: 'serverError', reason: `${response.status} ${responseText}` }
  } else if (response.status === 422) {
    return { type: 'failed', failKind: 'contentFilter', reason: 'Filtered by Responsible AI Service' }
  } else {
    logger.error('Unhandled status from server:', response.status, responseText)
    logError(telemetryService, 'Unhandled status from server: ' + response.status, responseText)
    return { type: 'failed', failKind: 'unknown', reason: `unhandled status from server: ${response.status} ${responseText}` }
  }
}

function sendChatRequest(context, engine, requestId, options, token, location, cancellationToken, telemetryProps) {
  let logger = context.get(LoggerManager).getLogger('chat fetch'),
    telemetryService = context.get(IGHTelemetryService),
    telemetryEvent = TelemetryEvent.createAndMarkAsIssued(
      { endpoint: engine.endpoint, engineName: engine.engineName, uiKind: getConversationType(location), ...telemetryProps },
      { maxTokenWindow: engine.modelMaxTokenWindow }
    )
  for (let [optionKey, optionValue] of Object.entries(options))
    optionKey !== 'messages' && (telemetryEvent.properties[`request.option.${optionKey}`] = JSON.stringify(optionValue) ?? 'undefined')
  telemetryEvent.properties.headerRequestId = requestId
  telemetryService.sendTelemetry('request.sent', telemetryEvent)
  let startTime = Date.now(),
    locationStr = getLocationStr(location)
  return sendRequest(context, engine, token, locationStr, requestId, options, cancellationToken)
    .then(response => {
      let responseMetadata = createResponseMetadata(response, void 0)
      telemetryEvent.extendWithRequestId(responseMetadata)
      let elapsedTime = Date.now() - startTime
      telemetryEvent.measurements.totalTimeMs = elapsedTime
      logger.info(`request.response: [${engine.url}], took ${elapsedTime} ms`)
      logger.debug('request.response properties', telemetryEvent.properties)
      logger.debug('request.response measurements', telemetryEvent.measurements)
      logger.debug(`messages: ${JSON.stringify(options.messages)}`)
      telemetryService.sendTelemetry('request.response', telemetryEvent)
      return response
    })
    .catch(error => {
      if (context.get(ConnectionSettings).isAbortError(error)) throw error
      let errorTelemetryEvent = telemetryEvent.extendedBy({ error: 'Network exception' })
      telemetryService.sendTelemetry('request.shownWarning', errorTelemetryEvent)
      telemetryEvent.properties.code = String(error.code ?? '')
      telemetryEvent.properties.errno = String(error.errno ?? '')
      telemetryEvent.properties.message = String(error.message ?? '')
      telemetryEvent.properties.type = String(error.type ?? '')
      let elapsedTime = Date.now() - startTime
      telemetryEvent.measurements.totalTimeMs = elapsedTime
      logger.debug(`request.response: [${engine.url}] took ${elapsedTime} ms`)
      logger.debug('request.error properties', telemetryEvent.properties)
      logger.debug('request.error measurements', telemetryEvent.measurements)
      telemetryService.sendTelemetry('request.error', telemetryEvent)
      throw error
    })
    .finally(() => {
      sendEngineMessages(context, options.messages, telemetryEvent)
    })
}

function getLocationStr(location) {
  switch (location) {
    case 2:
      return 'conversation-panel'
    case 1:
      return 'conversation-inline'
  }
}

class DataRetriever {
  async fetchOne(entity, resource, network, input, options, settings, abortToken, logProps) {
    let collection = await this.fetchMany(entity, resource, network, input, options, { ...settings, count: 1 }, abortToken, logProps)
    return collection.type === 'success' ? { ...collection, value: collection.value[0] } : collection
  }
}

class ChatMLFetcher extends DataRetriever {
  constructor(accessor) {
    super()
    this.accessor = accessor
    this.logger = accessor.get(LoggerManager).getPromptResponseLogger('ChatMLFetcher')
  }
  async fetchMany(entity, resource, network, input, options, settings, abortToken, logProps) {
    let messageId = abortToken?.messageId ?? Crypto.randomUUID(),
      tokenLength = calculateTokenLength(this.accessor, entity)
    settings = { max_tokens: Math.max(options.modelMaxTokenWindow - tokenLength, 1024), ...settings }
    let postOptions = ChatMLFetcher.preparePostOptions(settings),
      model = options.model
    if (logProps) {
      logProps.intent_model = await this.getOffTopicModelName()
      logProps.intent_tokenizer = await this.getOffTopicModelTokenizer()
      logProps.intent_threshold = await this.getOffTopicModelThreshold()
    }
    let requestParams = {
        messages: entity.filter(msg => msg.content && msg.content !== ''),
        model: model,
        repoInfo: void 0,
        ourRequestId: messageId,
        location: input,
        postOptions: postOptions,
        secretKey: settings.secretKey,
        ...logProps,
      },
      telemetryEvent = TelemetryEvent.createAndMarkAsIssued({ ...abortToken, uiKind: getConversationType(input) })
    try {
      let response = await handleChatRequest(this.accessor, options, requestParams, telemetryEvent, resource || (async () => {}), network, abortToken),
        result
      switch (response.type) {
        case 'success':
          return await this.processSuccessfulResponse(response, requestParams.ourRequestId, abortToken, options)
        case 'canceled':
          return this.processCanceledResponse(response, requestParams.ourRequestId)
        case 'failed':
          result = this.processFailedResponse(response, requestParams.ourRequestId)
          this.accessor
            .get(IMSTelemetryService)
            .sendTelemetryEvent(
              'response.error',
              { type: result.type, source: abortToken?.messageSource ?? 'unknown', requestId: requestParams.ourRequestId, model: options.model },
              { maxTokenCount: options.modelMaxTokenWindow ?? -1 }
            )
          return result
      }
    } catch (error) {
      return this.processError(error, requestParams.ourRequestId)
    }
  }

  static preparePostOptions(request) {
    return { ...request, stream: true };
  }
  async processSuccessfulResponse(response, requestId, message, model) {
    let choices = [];
    for await (let chatCompletion of response.chatCompletions) {
      this.serviceAccessor
        .get(IMSTelemetryService)
        .sendTelemetryEvent(
          'response.success',
          {
            reason: chatCompletion.finishReason,
            source: message?.messageSource ?? 'unknown',
            model: model?.model,
            requestId: requestId
          },
          {
            tokenCount: chatCompletion.numTokens,
            maxTokenCount: model?.modelMaxTokenWindow ?? -1,
            processingTime: response.getProcessingTime(),
          }
        );
      if (!this.isRepetitive(chatCompletion, message)) {
        choices.push(chatCompletion);
      }
    }
    this.logger.debug(`Received choices: ${JSON.stringify(choices, null, 2)}`);
    let successfulChoices = choices.filter(choice => choice.finishReason === 'stop' || choice.finishReason === 'client-trimmed');
    if (successfulChoices.length >= 1) {
      return { type: 'success', value: successfulChoices.map(choice => choice.message.content), requestId: requestId };
    }
    switch (choices[0]?.finishReason) {
      case 'content_filter':
        return { type: 'filtered', reason: 'Response got filtered.', requestId: requestId };
      case 'length':
        return { type: 'length', reason: 'Response too long.', requestId: requestId };
    }
    return { type: 'unknown', reason: 'Response contained no choices.', requestId: requestId };
  }

  async getOffTopicModelName() {
    let configName = this.serviceAccessor.get(ConfigManager).getConfig(settings.DebugOverrideChatOffTopicModel);
    if (configName) return configName;
    let experimentName = await this.serviceAccessor.get(ExperimentManager).chatOffTopicModel();
    return experimentName || '';
  }

  async getOffTopicModelTokenizer() {
    let configTokenizer = this.serviceAccessor.get(ConfigManager).getConfig(settings.DebugOverrideChatOffTopicModelTokenizer);
    if (configTokenizer) return configTokenizer;
    let experimentTokenizer = await this.serviceAccessor.get(ExperimentManager).chatOffTopicModelTokenizer();
    return experimentTokenizer || '';
  }
  async getOffTopicModelThreshold() {
    let configThreshold = this.serviceAccessor.get(ConfigManager).getConfig(settings.DebugOverrideChatOffTopicModelThreshold);
    if (configThreshold !== 0) return configThreshold;
    let experimentThreshold = await this.serviceAccessor.get(ExperimentManager).chatOffTopicModelThreshold();
    return experimentThreshold !== 0 ? experimentThreshold : 0;
  }
  isRepetitive(response, message) {
    let isRepetitive = isClientTokenSequenceRepetitive(response.tokens);
    if (isRepetitive) {
      let telemetryEvent = TelemetryEvent.createAndMarkAsIssued();
      telemetryEvent.extendWithRequestId(response.requestId);
      let extendedEvent = telemetryEvent.extendedBy(message);
      this.serviceAccessor.get(IGHTelemetryService).sendRestrictedTelemetry('conversation.repetition.detected', extendedEvent);
      this.logger.info('Filtered out repetitive conversation result');
    }
    return isRepetitive;
  }
  processCanceledResponse(response, requestId) {
    this.logger.debug('Cancelled after awaiting fetchConversation');
    return { type: 'canceled', reason: response.reason, requestId: requestId };
  }
  processFailedResponse(response, requestId) {
    let failKind = response.failKind;
    let reason = response.reason;
    let resultType = 'failed'; // default type

    if (failKind === 'rateLimited') {
      resultType = 'rateLimited';
    } else if (failKind === 'offTopic') {
      resultType = 'offTopic';
    } else if (
      failKind === 'tokenExpiredOrInvalid' ||
      failKind === 'clientNotSupported' ||
      reason.includes('Bad request: ')
    ) {
      resultType = 'badRequest';
    } else if (failKind === 'serverError') {
      resultType = 'failed';
    } else if (failKind === 'contentFilter') {
      resultType = 'filtered';
    }

    return { type: resultType, reason: reason, requestId: requestId };
  }

  processError(error, requestId) {
    let connectionSettings = this.serviceAccessor.get(ConnectionSettings);
    let resultType = 'failed'; // default type
    let reason = 'Error on conversation request. Check the log for more details.'; // default reason

    if (connectionSettings.isAbortError(error)) {
      resultType = 'canceled';
      reason = 'network request aborted';
    } else {
      this.serviceAccessor.get(LoggerManager).defaultLogger.exception(error, 'Error on conversation request');
      this.serviceAccessor.get(IGHTelemetryService).sendExceptionTelemetry(error, 'Error on conversation request');

      if (connectionSettings.isDNSLookupFailedError(error)) {
        reason = "It appears you're not connected to the internet, please check your network connection and try again.";
      } else if (connectionSettings.isFetcherError(error)) {
        reason = `Please check your firewall rules and network connection then try again. Error Code: ${error.code}.`;
      }
    }

    return { type: resultType, reason: reason, requestId: requestId };
  }
}
var GitContextModelIdentifier = createServiceIdentifier('IGitContextModel')
var vscode = handleDefaultExports(require('vscode')),
VscodePosition = vscode.Position,
VscodeRange = vscode.Range,
VscodeSelection = vscode.Selection,
VscodeEventEmitter = vscode.EventEmitter,
VscodeCancellationTokenSource = vscode.CancellationTokenSource
var VscodeTextEdit = vscode.TextEdit,
VscodeWorkspaceEdit = vscode.WorkspaceEdit,
VscodeUri = vscode.Uri,
VscodeMarkdownString = vscode.MarkdownString,
VscodeInteractiveEditorResponseFeedbackKind = vscode.InteractiveEditorResponseFeedbackKind
var VscodeDiagnosticSeverity = vscode.DiagnosticSeverity,
VscodeExtensionMode = vscode.ExtensionMode,
VscodeLocation = vscode.Location
var vscodeL10n = { t: vscode.l10n.t }
var path = handleDefaultExports(require('path'))
var workerThreads = require('worker_threads'),

class WorkerHandler {
  constructor(workerPath, logger) {
    this.logger = logger;
    this.handlers = new Map();
    this.nextId = 1;
    this.worker = new workerThreads.Worker(workerPath);

    this.worker.on('message', ({ id, err, res }) => {
      let handler = this.handlers.get(id);
      if (handler) {
        this.handlers.delete(id);
        err ? handler.reject(err) : handler.resolve(res);
      }
    });

    this.worker.on('error', error => this.handleError(error));
    this.worker.on('exit', exitCode => {
      if (exitCode !== 0) {
        this.handleError(new Error(`Worker thread exited with code ${exitCode}.`));
      }
    });
  }

  terminate() {
    this.worker.removeAllListeners();
    this.worker.terminate();
    this.handlers.clear();
  }

  handleError(error) {
    this.logger?.exception(error);
    for (let handler of this.handlers.values()) {
      handler.reject(error);
    }
    this.handlers.clear();
  }

  remoteCall(functionName, args) {
    let id = this.nextId++;
    let resolve, reject;
    let promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });

    this.handlers.set(id, { resolve, reject });
    this.worker.postMessage({ id, fn: functionName, args });
    return promise;
  }
}

class WorkerProxy {
  constructor(workerPath, logger) {
    this.workerHandler = new WorkerHandler(workerPath, logger);
    let handler = {
      get: (target, prop) => {
        if (typeof prop == 'string' && !target[prop]) {
          target[prop] = (...args) => {
            if (!this.workerHandler) throw new Error('Worker was terminated!');
            return this.workerHandler.remoteCall(prop, args);
          };
        }
        return target[prop];
      },
    };
    this.proxy = new Proxy(Object.create(null), handler);
  }

  terminate() {
    this.workerHandler.terminate();
  }
}
var TreeSitterUtils = {}
defineProperties(TreeSitterUtils, {
  TreeSitterOffsetRange: () => TreeSitterOffsetRange,
  _clean: () => cleanUp,
  _extractDoc: () => extractDoc,
  _getCallExpressions: () => getCallExpressions,
  _getClassDeclarations: () => getClassDeclarations,
  _getCoarseParentScope: () => getCoarseParentScope,
  _getDocumentableNodeIfOnIdentifier: () => getDocumentableNodeIfOnIdentifier,
  _getFixSelectionOfInterest: () => getFixSelectionOfInterest,
  _getFunctionBodies: () => getFunctionBodies,
  _getFunctionDefinitions: () => getFunctionDefinitions,
  _getFunctionPositions: () => getFunctionPositions,
  _getNewExpressions: () => getNewExpressions,
  _getNodeMatchingSelection: () => getNodeMatchingSelection,
  _getNodeToDocument: () => getNodeToDocument,
  _getSemanticChunkTree: () => getSemanticChunkTree,
  _getTypeDeclarations: () => getTypeDeclarations,
  _getTypeReferences: () => getTypeReferences,
  _parse: () => parseCode,
})

var path = handleDefaultExports(require('path')),
  QI = handleDefaultExports(eK());

function binarySearch(array, value, comparator) {
  let start = 0,
    end = array.length;
  while (start < end) {
    let mid = (start + end) >>> 1;
    comparator(array[mid], value) ? (start = mid + 1) : (end = mid);
  }
  return start;
}

function findMax(array, comparator) {
  if (array.length === 0) return;
  let maxElement = array[0];
  for (let i = 1; i < array.length; i++) {
    let currentElement = array[i];
    if (comparator(currentElement, maxElement) > 0) {
      maxElement = currentElement;
    }
  }
  return maxElement;
}
var LRUCache = class {
  constructor(cacheSize = 10) {
    this.values = new Map()
    this.lruKeys = []
    if (cacheSize < 1) throw new Error('Cache size must be at least 1')
    this.size = cacheSize
  }
  removeKeyFromLRU(key) {
    let index = this.lruKeys.indexOf(key)
    index !== -1 && this.lruKeys.splice(index, 1)
  }
  touchKeyInLRU(key) {
    this.removeKeyFromLRU(key), this.lruKeys.push(key)
  }
  clear() {
    this.values.clear(), (this.lruKeys = [])
  }
  deleteKey(key) {
    this.removeKeyFromLRU(key)
    let value = this.values.get(key)
    return value !== void 0 && this.values.delete(key), value
  }
  get(key) {
    if (this.values.has(key)) {
      let value = this.values.get(key)
      return this.touchKeyInLRU(key), value
    }
  }
  keys() {
    return this.lruKeys.slice()
  }
  getValues() {
    return this.values.values()
  }
  put(key, value) {
    let evicted
    if (!this.values.has(key) && this.lruKeys.length === this.size) {
      let evictedKey = this.lruKeys.shift(),
        evictedValue = this.deleteKey(evictedKey)
      evicted = [evictedKey, evictedValue]
    }
    return this.values.set(key, value), this.touchKeyInLRU(key), evicted
  }
}
var DisposableLRUCache = class {
  constructor(cacheSize) {
    this.actual = new LRUCache(cacheSize)
  }
  dispose() {
    this.clear()
  }
  clear() {
    let values = this.actual.getValues()
    for (let value of values) value.dispose()
    this.actual.clear()
  }
  deleteKey(key) {
    let value = this.actual.deleteKey(key)
    value && value.dispose()
  }
  get(key) {
    return this.actual.get(key)
  }
  keys() {
    return this.actual.keys()
  }
  getValues() {
    return this.actual.getValues()
  }
  put(key, value) {
    let evicted = this.actual.put(key, value)
    evicted && evicted[1].dispose()
  }
}
var TreeSitterOffsetRange = {
  doesContain: (range, target) => range.startIndex <= target.startIndex && target.endIndex <= range.endIndex,
  ofSyntaxNode: node => ({ startIndex: node.startIndex, endIndex: node.endIndex }),
  compare: (range1, range2) => range1.startIndex - range2.startIndex || range2.endIndex - range1.endIndex,
  doIntersect: (range1, range2) => {
    let maxStart = Math.max(range1.startIndex, range2.startIndex),
      minEnd = Math.min(range1.endIndex, range2.endIndex)
    return maxStart < minEnd
  },
  len: range => range.endIndex - range.startIndex,
  intersectionSize: (range1, range2) => {
    let maxStart = Math.max(range1.startIndex, range2.startIndex),
      minEnd = Math.min(range1.endIndex, range2.endIndex)
    return Math.max(minEnd - maxStart, 0)
  },
  isTreeSitterOffsetRange: range => typeof range.startIndex == 'number' && typeof range.endIndex == 'number',
  toTreeSitterOffsetRange: (range, converter) => {
    return { startIndex: converter.offsetAt(range.start), endIndex: converter.offsetAt(range.end) }
  },
},
PositionComparator = {
  isEqual: (pos1, pos2) => pos1.row === pos2.row && pos1.column === pos2.column,
  isBefore: (pos1, pos2) => pos1.row < pos2.row || (pos1.row === pos2.row && pos1.column < pos2.column),
  isAfter: (pos1, pos2) => PositionComparator.isBefore(pos2, pos1),
  isBeforeOrEqual: (pos1, pos2) => {
    let isBefore = PositionComparator.isBefore(pos1, pos2),
      isEqual = PositionComparator.isEqual(pos1, pos2)
    return !!(isBefore || isEqual)
  },
  equals: (pos1, pos2) => pos1.column === pos2.column && pos1.row === pos2.row,
  isAfterOrEqual: (pos1, pos2) => PositionComparator.isBeforeOrEqual(pos2, pos1),
  ofPoint: point => ({ row: point.row, column: point.column }),
},
RangeComparator = {
  doesContain: (range, target) =>
    PositionComparator.isBeforeOrEqual(range.startPosition, target.startPosition) && PositionComparator.isAfterOrEqual(range.endPosition, target.endPosition),
  equals: (range1, range2) => PositionComparator.equals(range1.startPosition, range2.startPosition) && PositionComparator.equals(range1.endPosition, range2.endPosition),
  ofSyntaxNode: node => ({ startPosition: node.startPosition, endPosition: node.endPosition }),
},
SyntaxNodeRange = { ofSyntaxNode: node => ({ type: node.type, startIndex: node.startIndex, endIndex: node.endIndex }) },
SyntaxNodeDetails = {
  ofSyntaxNode: node => ({ range: RangeComparator.ofSyntaxNode(node), startIndex: node.startIndex, text: node.text, endIndex: node.endIndex }),
}
var SyntaxTree = class {
  constructor(nodes, root) {
    this.syntaxTreeRoot = root
    this.roots = []
    this.formTree(nodes)
  }
  formTree(nodes) {
    nodes.sort((node1, node2) => node1.mainBlock.startIndex - node2.mainBlock.startIndex || node1.mainBlock.endIndex - node2.mainBlock.endIndex)
    let stack = [],
      peek = () => stack[stack.length - 1],
      isSameBlock = (node1, node2) => node1.mainBlock.startIndex === node2.mainBlock.startIndex && node1.mainBlock.endIndex === node2.mainBlock.endIndex
    for (let node of nodes) {
      let tree = { info: node, children: [] },
        top = peek()
      if (!top) {
        this.roots.push(tree), stack.push(tree)
        continue
      }
      if (!isSameBlock(top.info, node)) {
        for (; top && !TreeSitterOffsetRange.doesContain(top.info.mainBlock, node.mainBlock); ) stack.pop(), (top = peek())
        top ? top.children.push(tree) : this.roots.push(tree), stack.push(tree)
      }
    }
  }
}
var UnrecognizedLanguageError = class extends Error {
  constructor(language) {
    super(`Unrecognized language: ${language}`)
  }
}
var languageMap = {
  python: 'python',
  javascript: 'javascript',
  javascriptreact: 'javascript',
  jsx: 'javascript',
  typescript: 'typescript',
  tsx: 'tsx',
  go: 'go',
  ruby: 'ruby',
  csharp: 'csharp',
  cpp: 'cpp',
  java: 'java',
  rust: 'rust',
}
function isLanguageSupported(language) {
  return language in languageMap
}
function getLanguage(language) {
  if (isLanguageSupported(language)) return languageMap[language]
  throw new UnrecognizedLanguageError(language)
}
function mapToEntries(array, value) {
  return Object.fromEntries(array.map(item => [item, value]))
}
var languageQueryMap = {
    ...mapToEntries(
      ['javascript', 'typescript', 'tsx'],
      [
        [
          `[
				(call_expression
					function: (identifier) @identifier)
				(call_expression
					function: (member_expression
						(property_identifier) @identifier))
			] @call_expression`,
        ],
      ]
    ),
    python: [
      [
        `[
				(call
					function: (identifier) @identifier)
				(call
					function: (attribute
						attribute: (identifier) @identifier))
			] @call_expression`,
      ],
    ],
    csharp: [
      [
        `[
				(invocation_expression
					function: (identifier) @identifier)
				(invocation_expression
					function: (member_access_expression
						name: (identifier) @identifier))
			  ] @call_expression`,
      ],
    ],
    go: [
      [
        `[
				(call_expression
					((selector_expression
						(field_identifier) @identifier)))
				(call_expression
					(identifier) @identifier)
			] @call_expression`,
      ],
    ],
    java: [
      [
        `[
				(method_invocation
				  name: (identifier) @identifier)
			] @call_expression`,
      ],
    ],
    ruby: [
      [
        `[
				(call (identifier) @identifier
					(#not-match? @identifier "new|send|public_send|method"))
				(call
					receiver: (identifier)
					method: (identifier) @method
					(#match? @method "^(send|public_send|method)")
					arguments: (argument_list
						(simple_symbol) @symbol))
			] @call_expression`,
      ],
    ],
    cpp: [
      [
        `[
				(call_expression (identifier) @identifier)
				(call_expression
					(field_expression
						field: (field_identifier) @identifier))
				(call_expression
					(call_expression
						(primitive_type)
						(argument_list
							(pointer_expression
							(identifier) @identifier))))
			] @call_expression`,
      ],
    ],
    rust: [
      [
        `[
				(call_expression (identifier) @identifier)
				(call_expression (field_expression (identifier) (field_identifier) @identifier))
				(call_expression (scoped_identifier (identifier) (identifier) @identifier (#not-match? @identifier "new")))
			] @call_expression`,
      ],
    ],
  },
  classQueryMap = {
    ...mapToEntries(['javascript', 'typescript', 'tsx'], [['(class_declaration) @class_declaration']]),
    java: [['(class_declaration) @class_declaration']],
    csharp: [['(class_declaration) @class_declaration']],
    python: [['(class_definition) @class_declaration']],
    cpp: [['(class_specifier) @class_declaration']],
    ruby: [['(class) @class_declaration']],
    go: [
      [
        `(type_declaration
				(type_spec
					(type_identifier) @type_identifier)) @class_declaration`,
      ],
    ],
    rust: [['(impl_item (type_identifier) @type_identifier) @class_declaration']],
  },
  typeQueryMap = {
    typescript: [
      [
        `[
				(interface_declaration)
				(type_alias_declaration)
			] @type_declaration`,
      ],
    ],
    csharp: [
      [
        `(interface_declaration
				(identifier) @type_identifier) @type_declaration`,
      ],
    ],
    cpp: [
      [
        `[
				(struct_specifier
					(type_identifier) @type_identifier)
				(union_specifier
					(type_identifier) @type_identifier)
				(enum_specifier
					(type_identifier) @type_identifier)
			] @type_declaration`,
      ],
    ],
    java: [
      [
        `(interface_declaration
				(identifier) @type_identifier) @type_declaration`,
      ],
    ],
    go: [
      [
        `(type_declaration
				(type_spec
					(type_identifier) @type_identifier)) @type_declaration`,
      ],
    ],
    ruby: [['((constant) @type_identifier) @type_declaration']],
    python: [
      [
        `(class_definition
				(identifier) @type_identifier) @type_declaration`,
      ],
    ],
  },
  typeIdentifierQueryMap = {
    typescript: [['(type_identifier) @type_identifier']],
    go: [['(type_identifier) @type_identifier']],
    ruby: [['(constant) @type_identifier']],
    csharp: [
      [
        `[
				(base_list
					(identifier) @type_identifier)
				(variable_declaration
					(identifier) @type_identifier)
			]`,
      ],
    ],
    cpp: [['(type_identifier) @type_identifier']],
    java: [['(type_identifier) @type_identifier']],
    python: [
      [
        `[
				(type (identifier) @type_identifier)
				(argument_list
					(identifier) @type_identifier)
			]`,
      ],
    ],
  },
  newExpressionQueryMap = {
    ...mapToEntries(
      ['javascript', 'typescript', 'tsx'],
      [
        [
          `(new_expression
				constructor: (identifier) @new_expression)`,
        ],
      ]
    ),
    python: [
      [
        `(call
				function: (identifier) @new_expression)`,
      ],
    ],
    csharp: [
      [
        `(object_creation_expression
				(identifier) @new_expression)`,
      ],
    ],
    java: [
      [
        `(object_creation_expression
				(type_identifier) @new_expression)`,
      ],
    ],
    cpp: [
      [
        `(declaration
				(type_identifier) @new_expression)`,
      ],
    ],
    go: [['(composite_literal (type_identifier) @new_expression)']],
    ruby: [
      [
        `((call
				receiver: ((constant) @new_expression)
				method: (identifier) @method)
					(#eq? @method "new"))`,
      ],
    ],
    rust: [
      [
        `(call_expression
				(scoped_identifier
					(identifier) @new_expression
					(identifier) @identifier
					(#eq? @identifier "new")))`,
      ],
    ],
  },
  functionQueryMap = {
    python: [
      [
        `[
				(function_definition
					name: (identifier) @identifier
					body: (block
							(expression_statement (string))? @docstring) @body)
				(assignment
					left: (identifier) @identifier
					right: (lambda) @body)
			] @function`,
      ],
      ['(ERROR ("def" (identifier) (parameters))) @function'],
    ],
    ...mapToEntries(
      ['javascript', 'typescript', 'tsx'],
      [
        [
          `[
				(function
					name: (identifier)? @identifier
					body: (statement_block) @body)
				(function_declaration
					name: (identifier)? @identifier
					body: (statement_block) @body)
				(generator_function
					name: (identifier)? @identifier
					body: (statement_block) @body)
				(generator_function_declaration
					name: (identifier)? @identifier
					body: (statement_block) @body)
				(method_definition
					name: (property_identifier)? @identifier
					body: (statement_block) @body)
				(arrow_function
					body: (statement_block) @body)
			] @function`,
        ],
      ]
    ),
    go: [
      [
        `[
				(function_declaration
					name: (identifier) @identifier
					body: (block) @body)
				(method_declaration
					name: (field_identifier) @identifier
					body: (block) @body)
			] @function`,
      ],
    ],
    ruby: [
      [
        `[
				(method
					name: (_) @identifier
					parameters: (method_parameters)? @params
					[(_)+ "end"] @body)
				(singleton_method
					name: (_) @identifier
					parameters: (method_parameters)? @params
					[(_)+ "end"] @body)
			] @function`,
      ],
    ],
    csharp: [
      [
        `[
				(constructor_declaration
					(identifier) @identifier
					(block) @body)
				(destructor_declaration
					(identifier) @identifier
					(block) @body)
				(operator_declaration
					(block) @body)
				(method_declaration
					(identifier) @identifier
					(block) @body)
				(local_function_statement
					(identifier) @identifier
					(block) @body)
			] @function`,
      ],
    ],
    cpp: [
      [
        `(function_definition
					(_
					(identifier) @identifier)
				(compound_statement) @body) @function`,
      ],
    ],
    java: [
      [
        `[
				(constructor_declaration
					name: (identifier) @identifier
					body: (constructor_body) @body)
				(method_declaration
					name: (_) @identifier
					body: (block) @body)
				(lambda_expression
					body: (block) @body)
			] @function`,
      ],
    ],
    rust: [
      [
        `[
				(function_item (identifier) @identifier)
				(let_declaration (identifier) @identifier)
			] @function`,
      ],
    ],
  },
  docCommentQueryMap = {
    ...mapToEntries(
      ['javascript', 'typescript', 'tsx'],
      [
        [
          `((comment) @comment
			(#match? @comment "^\\\\/\\\\*\\\\*")) @docComment`,
        ],
      ]
    ),
    java: [
      [
        `((block_comment) @block_comment
			(#match? @block_comment "^\\\\/\\\\*\\\\*")) @docComment`,
      ],
    ],
    cpp: [
      [
        `((comment) @comment
			(#match? @comment "^\\\\/\\\\*\\\\*")) @docComment`,
      ],
    ],
    csharp: [
      [
        `(
			((comment) @c
				(#match? @c "^\\\\/\\\\/\\\\/"))+
		) @docComment`,
      ],
    ],
    rust: [
      [
        `((line_comment) @comment
			(#match? @comment "^///|^//!"))+ @docComment`,
      ],
    ],
    go: [['((comment)+) @docComment']],
    ruby: [['((comment)+) @docComment']],
    python: [
      [
        `(expression_statement
			(string) @docComment)`,
      ],
    ],
  },
  nodeTypeMap = {
    ...mapToEntries(
      ['typescript', 'tsx'],
      [
        'program',
        'interface_declaration',
        'class_declaration',
        'function_declaration',
        'function',
        'type_alias_declaration',
        'method_definition',
      ]
    ),
    javascript: ['program', 'class_declaration', 'function_declaration', 'function', 'method_definition'],
    java: ['program', 'class_declaration', 'interface_declaration', 'method_declaration'],
    cpp: ['translation_unit', 'class_declaration', 'function_definition'],
    csharp: ['compilation_unit', 'class_declaration', 'interface_declaration', 'method_declaration'],
    python: ['module', 'class_definition', 'function_definition'],
    go: ['source_file', 'type_declaration', 'function_declaration', 'method_declaration'],
    ruby: ['program', 'method', 'class', 'method'],
    rust: ['source_file', 'function_item', 'impl_item', 'let_declaration'],
  },
  languageElementMap = {
    typescript: [[generateScopeFor('typescript')]],
    tsx: [[generateScopeFor('tsx')]],
    javascript: [[generateScopeFor('javascript')]],
    java: [[generateScopeFor('java')]],
    cpp: [[generateScopeFor('cpp')]],
    csharp: [[generateScopeFor('csharp')]],
    python: [[generateScopeFor('python')]],
    go: [[generateScopeFor('go')]],
    ruby: [[generateScopeFor('ruby')]],
    rust: [[generateScopeFor('rust')]],
  },
  controlStructureMap = {
    ...mapToEntries(
      ['typescript', 'tsx', 'javascript'],
      [
        'for_in_statement',
        'for_statement',
        'if_statement',
        'while_statement',
        'do_statement',
        'try_statement',
        'switch_statement',
      ]
    ),
    java: [
      'for_statement',
      'enhanced_for_statement',
      'if_statement',
      'while_statement',
      'do_statement',
      'try_statement',
      'switch_expression',
    ],
    cpp: [
      'for_statement',
      'for_range_loop',
      'if_statement',
      'while_statement',
      'do_statement',
      'try_statement',
      'switch_statement',
    ],
    csharp: [
      'for_statement',
      'for_each_statement',
      'if_statement',
      'while_statement',
      'do_statement',
      'try_statement',
      'switch_expression',
    ],
    python: ['for_statement', 'if_statement', 'while_statement', 'try_statement'],
    go: ['for_statement', 'if_statement', 'type_switch_statement'],
    ruby: ['while', 'for', 'if', 'case'],
    rust: ['for_statement', 'if_statement', 'while_statement', 'loop_statement', 'match_expression'],
  },
  statementElementMap = {
    ...mapToEntries(['typescript', 'tsx'], ['lexical_declaration', 'expression_statement', 'public_field_definition']),
    javascript: ['call_expression', 'expression_statement', 'variable_declaration', 'public_field_definition'],
    java: ['expression_statement', 'local_variable_declaration', 'field_declaration'],
    cpp: ['field_declaration', 'expression_statement', 'declaration'],
    csharp: ['field_declaration', 'expression_statement'],
    python: ['expression_statement'],
    go: ['short_var_declaration', 'call_expression'],
    ruby: ['call', 'assignment'],
    rust: [
      'expression_statement',
      'let_declaration',
      'use_declaration',
      'assignment_expression',
      'macro_definition',
      'extern_crate_declaration',
    ],
  },
  declarationMap = {
    ...mapToEntries(
      ['typescript', 'tsx'],
      [
        'class_declaration',
        'function_declaration',
        'generator_function_declaration',
        'interface_declaration',
        'internal_module',
        'method_definition',
      ]
    ),
    javascript: ['class_declaration', 'function_declaration', 'generator_function_declaration', 'method_definition'],
    java: [
      'class_declaration',
      'constructor_declaration',
      'enum_declaration',
      'interface_declaration',
      'method_declaration',
      'module_declaration',
    ],
    cpp: ['class_specifier', 'function_definition', 'namespace_definition', 'struct_specifier'],
    csharp: [
      'class_declaration',
      'constructor_declaration',
      'destructor_declaration',
      'enum_declaration',
      'interface_declaration',
      'method_declaration',
      'namespace_declaration',
      'struct_declaration',
    ],
    python: ['function_definition', 'class_definition'],
    go: ['function_declaration', 'method_declaration'],
    ruby: ['class', 'method', 'module'],
    rust: ['function_item', 'impl_item', 'mod_item', 'struct_item', 'trait_item', 'union_item'],
  },
  languageTokenMap = {
    typescript: [[generateTokenFor('typescript')]],
    tsx: [[generateTokenFor('tsx')]],
    javascript: [[generateTokenFor('javascript')]],
    java: [[generateTokenFor('java')]],
    cpp: [[generateTokenFor('cpp')]],
    csharp: [[generateTokenFor('csharp')]],
    python: [[generateTokenFor('python')]],
    go: [[generateTokenFor('go')]],
    rust: [[generateTokenFor('rust')]],
    ruby: [[generateTokenFor('ruby')]],
  }
function generateScopeFor(language) {
  return nodeTypeMap[getLanguage(language)].map(nodeType => `(${nodeType}) @scope`).join(`
`)
}
function generateTokenFor(language) {
  return `[
		${declarationMap[getLanguage(language)].map(declaration => `(${declaration})`).join(`
`)}
	] @definition`
}
// Checks if a given type is a node type or control structure for a given language
function isNodeTypeOrControlStructure(language, type) {
  return nodeTypeMap[getLanguage(language)].includes(type) || controlStructureMap[getLanguage(language)].includes(type);
}
// Checks if a given type is a statement element for a given language
function isStatementElement(language, type) {
  return statementElementMap[getLanguage(language)].includes(type);
}
class LanguageLoader {
  constructor() {
      this.loadedLanguagesCache = new Map();
  }

  loadLanguage(language) {
      if (!this.loadedLanguagesCache.has(language)) {
          this.loadedLanguagesCache.set(language, this._loadLanguageFromFile(language));
      }
      return this.loadedLanguagesCache.get(language);
  }

  _loadLanguageFromFile(language) {
      let wasmFileName = `tree-sitter-${language === 'csharp' ? 'c-sharp' : language}.wasm`,
          wasmFilePath = ob.basename(__dirname) === 'dist' ? ob.resolve(__dirname, wasmFileName) : ob.resolve(__dirname, '../../../dist', wasmFileName);
      return QI.default.Language.load(wasmFilePath);
  }
}
function wrapTree(tree) {
  return { tree: tree, dispose: () => tree.delete() };
}
// Class for parsing and caching parse trees for different languages
var Parser = class {
  static {
      this.CACHE_SIZE_PER_LANGUAGE = 5;
  }
  constructor() {
      this.caches = new Map();
      this.languageLoader = new LanguageLoader();
      this._parser = null;
  }
  get parser() {
      return this._parser || (this._parser = new QI.default()), this._parser;
  }
  async parse(language, code) {
      await QI.default.init();
      let cache = this.getParseTreeCache(language),
          cachedTree = cache.get(code);
      if (cachedTree) return cachedTree.tree;
      let loadedLanguage = await this.languageLoader.loadLanguage(language);
      this.parser.setLanguage(loadedLanguage);
      let parseTree = this.parser.parse(code);
      cache.put(code, wrapTree(parseTree));
      return parseTree;
  }
  delete() {
      if (this._parser) {
          this.parser.delete();
          this._parser = null;
      }
      for (let cache of this.caches.values()) cache.dispose();
  }
  getParseTreeCache(language) {
      let cache = this.caches.get(language);
      if (!cache) {
          cache = new DisposableLRUCache(Parser.CACHE_SIZE_PER_LANGUAGE);
          this.caches.set(language, cache);
      }
      return cache;
  }
};
var parserInstance = new Parser();

function cleanUp() {
    parserInstance.delete();
}

function parseCode(language, code) {
    return parserInstance.parse(getLanguage(language), code);
}

function getQueryMatches(queries, parseTree) {
  let matches = [];
  for (let query of queries) {
      if (!query[1]) {
          let language = parseTree.tree.getLanguage();
          query[1] = language.query(query[0]);
      }
      matches.push(...query[1].matches(parseTree));
  }
  return matches;
}
// The following functions get query matches for different types of language elements
function getElementMatches(language, parseTree) {
  let queries = languageElementMap[getLanguage(language)];
  return getQueryMatches(queries, parseTree);
}

function getFunctionMatches(language, parseTree) {
    let queries = functionQueryMap[getLanguage(language)];
    return getQueryMatches(queries, parseTree);
}

function getLanguageMatches(language, parseTree) {
  let queries = languageQueryMap[getLanguage(language)];
  return queries ? getQueryMatches(queries, parseTree) : [];
}

function getClassMatches(language, parseTree) {
  let queries = classQueryMap[getLanguage(language)];
  return queries ? getQueryMatches(queries, parseTree) : [];
}

function getTypeMatches(language, parseTree) {
    let queries = typeQueryMap[getLanguage(language)];
    return queries ? getQueryMatches(queries, parseTree) : [];
}

function getTypeIdentifierMatches(language, parseTree) {
  let queries = typeIdentifierQueryMap[getLanguage(language)];
  return queries ? getQueryMatches(queries, parseTree) : [];
}

function getNewExpressionMatches(language, parseTree) {
    let queries = newExpressionQueryMap[getLanguage(language)];
    return queries ? getQueryMatches(queries, parseTree) : [];
}

function getTokenMatches(language, parseTree) {
  let queries = languageTokenMap[getLanguage(language)];
  return getQueryMatches(queries, parseTree);
}

async function getCallExpressions(language, code, range) {
  let parseTree = await parseCode(language, code)
  return getLanguageMatches(language, parseTree.rootNode).reduce((matches, capture) => {
    let callExpressionNode = capture.captures.find(c => c.name === 'call_expression').node
    if (TreeSitterOffsetRange.doIntersect(range, callExpressionNode)) {
      let identifierNode, identifierText
      if (language === 'ruby') {
        identifierNode = capture.captures.find(p => p.name === 'symbol')?.node
        identifierText = identifierNode?.text?.slice(1)
      }
      identifierNode ??= capture.captures.find(p => p.name === 'identifier')?.node
      identifierText ??= identifierNode?.text
      matches.push({
        identifier: identifierText ?? '',
        text: callExpressionNode.text,
        startIndex: (identifierNode ?? callExpressionNode).startIndex,
        endIndex: (identifierNode ?? callExpressionNode).endIndex
      })
    }
    return matches
  }, [])
}

async function getFunctionDefinitions(language, code) {
  let parseTree = await parseCode(language, code)
  return getFunctionMatches(language, parseTree.rootNode).map(match => {
    let functionNode = match.captures.find(capture => capture.name === 'function').node
    return {
      identifier: match.captures.find(capture => capture.name === 'identifier')?.node.text ?? '',
      text: functionNode.text,
      startIndex: functionNode.startIndex,
      endIndex: functionNode.endIndex,
    }
  })
}

async function getClassDeclarations(language, code) {
  let parseTree = await parseCode(language, code)
  return getClassMatches(language, parseTree.rootNode).map(match => {
    let classDeclarationNode = match.captures.find(capture => capture.name === 'class_declaration').node
    return {
      identifier:
        classDeclarationNode?.children.find(child => child.type === 'type_identifier' || child.type === 'identifier' || child.type === 'constant')?.text ??
        '',
      text: classDeclarationNode.text,
      startIndex: classDeclarationNode.startIndex,
      endIndex: classDeclarationNode.endIndex,
    }
  })
}

async function getTypeDeclarations(language, code) {
  let parseTree = await parseCode(language, code)
  return getTypeMatches(language, parseTree.rootNode).map(match => {
    let typeDeclarationNode = match.captures.find(capture => capture.name === 'type_declaration').node,
      typeIdentifierText = match.captures.find(capture => capture.name === 'type_identifier')?.node.text
    typeIdentifierText ||= typeDeclarationNode?.children.find(child => child.type === 'type_identifier')?.text
    return {
      identifier: typeIdentifierText ?? '',
      text: typeDeclarationNode.text,
      startIndex: typeDeclarationNode.startIndex,
      endIndex: typeDeclarationNode.endIndex
    }
  })
}

async function getTypeReferences(language, code, range) {
  let parseTree = await parseCode(language, code)
  return getTypeIdentifierMatches(language, parseTree.rootNode).reduce((matches, capture) => {
    let typeIdentifierNode = capture.captures.find(c => c.name === 'type_identifier').node
    if (TreeSitterOffsetRange.doIntersect(range, typeIdentifierNode)) {
      matches.push({
        identifier: typeIdentifierNode.text,
        text: typeIdentifierNode.text,
        startIndex: typeIdentifierNode.startIndex,
        endIndex: typeIdentifierNode.endIndex
      })
    }
    return matches
  }, [])
}

async function getNewExpressions(code, language, range) {
  let parsedCode = await parseCode(code, language)
  return getNewExpressionMatches(code, parsedCode.rootNode).reduce((expressions, match) => {
    let newExpressionNode = match.captures.find(capture => capture.name === 'new_expression').node
    if (TreeSitterOffsetRange.doIntersect(range, newExpressionNode)) {
      expressions.push({
        identifier: newExpressionNode.text,
        text: newExpressionNode.text,
        startIndex: newExpressionNode.startIndex,
        endIndex: newExpressionNode.endIndex
      })
    }
    return expressions
  }, [])
}

async function getSemanticChunkTree(code, language) {
  let parsedCode = await parseCode(code, language),
    tokenMatches = getTokenMatches(code, parsedCode.rootNode)
  return buildSyntaxTree(code, tokenMatches, parsedCode.rootNode)
}

async function getFunctionPositions(language, code) {
  let parseTree = await parseCode(language, code)
  return getFunctionMatches(language, parseTree.rootNode).map(match => {
    let functionNode = match.captures.find(capture => capture.name === 'function').node
    return { startIndex: functionNode.startIndex, endIndex: functionNode.endIndex }
  })
}

async function getFunctionBodies(language, code) {
  let parseTree = await parseCode(language, code)
  return getFunctionMatches(language, parseTree.rootNode).map(match => {
    let bodyNode = match.captures.find(capture => capture.name === 'body').node
    return { startIndex: bodyNode.startIndex, endIndex: bodyNode.endIndex }
  })
}

async function getCoarseParentScope(language, code, range) {
  let parseTree = await parseCode(language, code),
    elementMatches = getElementMatches(language, parseTree.rootNode),
    parentNode
  for (let match of elementMatches) {
    let node = match.captures[0].node,
      nodeRange = RangeComparator.ofSyntaxNode(node)
    if (RangeComparator.doesContain(nodeRange, range)) {
      parentNode = node
    }
    if (PositionComparator.isBefore(range.endPosition, nodeRange.startPosition)) break
  }
  if (parentNode) return RangeComparator.ofSyntaxNode(parentNode)
  throw new Error('No parent node found')
}

async function getFixSelectionOfInterest(language, code, range, threshold) {
  let rootNode = (await parseCode(language, code)).rootNode.descendantForPosition(range.startPosition, range.endPosition),
    initialRange = { startPosition: rootNode.startPosition, endPosition: rootNode.endPosition },
    adjustedRange = adjustRangeBasedOnThreshold(language, rootNode, threshold, range, true)
  return RangeComparator.equals(initialRange, adjustedRange) ? getAdjustedParentRange(language, rootNode) : adjustedRange
}

function getAdjustedParentRange(language, node) {
  let parentNode = node.parent,
    nodeRange = { startPosition: node.startPosition, endPosition: node.endPosition }
  if (isNodeTypeOrControlStructure(language, node) || !parentNode) return nodeRange
  let { filteredRanges: ranges, indexOfInterest: index } = getFilteredRangesAndIndex(language, parentNode.children, nodeRange, false)
  if (index - 1 >= 0 && index + 1 <= ranges.length - 1) {
    let previousRange = ranges[index - 1],
      nextRange = ranges[index + 1]
    return { startPosition: previousRange.startPosition, endPosition: nextRange.endPosition }
  }
  return getAdjustedParentRange(language, parentNode)
}
function adjustRangeBasedOnThreshold(language, node, threshold, range, isInitial) {
  let children = node.children
  if (node.endPosition.row - node.startPosition.row + 1 <= threshold) {
    let adjustedRange = isNodeTypeOrControlStructure(language, node) ? { startPosition: node.startPosition, endPosition: node.endPosition } : adjustRangeBasedOnChildren(language, children, threshold, range, isInitial),
      parentNode = node.parent
    return parentNode ? adjustRangeBasedOnThreshold(language, parentNode, threshold, adjustedRange, false) : adjustedRange
  }
  return adjustRangeBasedOnChildren(language, children, threshold, range, isInitial)
}

function getRowCount(rangeStart, rangeEnd) {
  return rangeEnd.endPosition.row - rangeStart.startPosition.row + 1
}

function adjustRangeBasedOnChildren(language, children, threshold, range, isInitial) {
  if (children.length === 0) return range
  let { filteredRanges: ranges, indexOfInterest: index } = getFilteredRangesAndIndex(language, children, range, isInitial),
    start = 0,
    end = ranges.length - 1,
    startRange = ranges[start],
    endRange = ranges[end]
  for (; getRowCount(startRange, endRange) > threshold && start !== end; ) index - start < end - index ? (end--, (endRange = ranges[end])) : (start++, (startRange = ranges[start]))
  return getRowCount(startRange, endRange) <= threshold ? { startPosition: startRange.startPosition, endPosition: endRange.endPosition } : range
}

function getFilteredRangesAndIndex(language, children, range, isInitial) {
  let filteredRanges, index
  if (
    (isInitial
      ? ((filteredRanges = children.filter(child => isNodeTypeOrControlStructure(language, child) || isStatementElement(language, child))),
        (index = binarySearch(filteredRanges, range, (child, range) => PositionComparator.isBefore(child.startPosition, range.startPosition))),
        filteredRanges.splice(index, 0, range))
      : ((filteredRanges = children.filter(child => RangeComparator.doesContain(child, range) || isNodeTypeOrControlStructure(language, child) || isStatementElement(language, child))),
        (index = filteredRanges.findIndex(child => RangeComparator.doesContain(child, range)))),
        index === -1)
  )
    throw new Error('Valid index not found')
  return { filteredRanges: filteredRanges, indexOfInterest: index }
}

function getNodeMatchingSelection(tree, range, language) {
  let nodes = [tree.rootNode],
    intersections = []
  for (;;) {
    let sortedIntersections = nodes
      .map(node => [node, TreeSitterOffsetRange.intersectionSize(node, range)])
      .filter(([node, intersectionSize]) => intersectionSize > 0)
      .sort(([node1, size1], [node2, size2]) => size2 - size1)
    if (sortedIntersections.length === 0) return intersections.length === 0 ? undefined : rK(intersections, ([node1, size1], [node2, size2]) => size1 - size2)[0]
    {
      let intersectionRatios = sortedIntersections.map(([node, intersectionSize]) => {
        let nodeLength = TreeSitterOffsetRange.len(node),
          difference = Math.abs(TreeSitterOffsetRange.len(range) - intersectionSize),
          ratio = (intersectionSize - difference) / nodeLength
        return [node, ratio]
      })
      intersections.push(...intersectionRatios.filter(([node, ratio]) => isNodeDocumentable(node, language))), (nodes = []), nodes.push(...intersectionRatios.flatMap(([node, ratio]) => node.children))
    }
  }
}

async function getDocumentableNodeIfOnIdentifier(language, code, range) {
  if (!isLanguageSupported(language)) return
  let node = (await parseCode(language, code)).rootNode.descendantForIndex(range.startIndex, range.endIndex)
  if (node.type.match(/identifier/) && (node.parent === null || isNodeDocumentable(node.parent, language))) {
    let parentNode = node.parent,
      parentRange = parentNode === null ? undefined : { startIndex: parentNode.startIndex, endIndex: parentNode.endIndex }
    return { identifier: node.text, nodeRange: parentRange }
  }
}

async function getNodeToDocument(language, code, range) {
  if (!isLanguageSupported(language)) return
  let tree = await parseCode(language, code),
    matchingNode = range.startIndex === range.endIndex ? undefined : getNodeMatchingSelection(tree, range, language)
  if (matchingNode) return { nodeIdentifier: getNodeIdentifier(matchingNode, language), nodeToDocument: SyntaxNodeRange.ofSyntaxNode(matchingNode), nodeSelectionBy: 'matchingSelection' }
  let node = tree.rootNode.descendantForIndex(range.startIndex, range.endIndex),
    expansionCount = 0
  for (; !isNodeDocumentable(node, language) && node.parent !== null; ) (node = node.parent), ++expansionCount
  return { nodeIdentifier: getNodeIdentifier(node, language), nodeToDocument: SyntaxNodeRange.ofSyntaxNode(node), nodeSelectionBy: 'expanding' }
}

function getNodeIdentifier(node, language) {
  switch (language) {
    case 'python':
    case 'csharp':
      return node.children.find(child => child.type.match(/identifier/))?.text
    case 'golang': {
      let identifierNode = node.children.find(child => child.type.match(/identifier/))
      return identifierNode
        ? identifierNode.text
        : node.children.find(child => child.type.match(/spec/))?.children.find(child => child.type.match(/identifier/))?.text
    }
    case 'javascript':
    case 'javascriptreact':
    case 'typescript':
    case 'typescriptreact':
    case 'cpp':
    case 'java': {
      let identifierNode = node.children.find(child => child.type.match(/identifier/))
      return identifierNode
        ? identifierNode.text
        : node.children.find(child => child.type.match(/declarator/))?.children.find(child => child.type.match(/identifier/))?.text
    }
    case 'ruby':
      return node.children.find(child => child.type.match(/constant|identifier/))?.text
    default:
      return node.children.find(child => child.type.match(/identifier/))?.text
  }
}

function isNodeDocumentable(node, language) {
  switch (language) {
    case 'typescript':
    case 'typescriptreact':
    case 'javascript':
    case 'javascriptreact':
      return node.type.match(/definition|declaration|declarator|export_statement/)
    case 'golang':
      return node.type.match(/definition|declaration|declarator|var_spec/)
    case 'cpp':
      return node.type.match(/definition|declaration|declarator|class_specifier/)
    case 'ruby':
      return node.type.match(/module|class|method|assignment/)
    default:
      return node.type.match(/definition|declaration|declarator/)
  }
}

async function extractDoc(language, code) {
  if (!new Set(['javascript', 'typescript', 'java', 'cpp', 'csharp', 'go', 'ruby']).has(language) || !isLanguageSupported(language)) return
  let parsedCode = await parseCode(language, code),
    docCommentQuery = docCommentQueryMap[getLanguage(language)],
    docComments = getQueryMatches(docCommentQuery, parsedCode.rootNode).flatMap(match => match.captures.filter(capture => capture.name === 'docComment')),
    filteredComments = filterComments(docComments)
  if (
    (filteredComments.length > 1 &&
      (filteredComments = filteredComments.filter(
        comment =>
          comment.includes(`
`) || !comment.match(/(code implementation|implementation details)/i)
      )),
    filteredComments.length === 1)
  )
    return filteredComments[0]
}

function filterComments(comments) {
  let filtered = []
  for (let i = 0; i < comments.length; ++i) {
    let commentLines = [comments[i].node.text]
    for (; i + 1 < comments.length && comments[i].node.endPosition.row + 1 === comments[i + 1].node.startPosition.row; )
      ++i, commentLines.push(comments[i].node.text)
    filtered.push(
      commentLines.join(`
`)
    )
  }
  return filtered
}

function buildSyntaxTree(language, matches, rootNode) {
  let parsedLanguage = getLanguage(language),
    syntaxDetails
  switch (parsedLanguage) {
    case 'python':
      syntaxDetails = processPythonMatches(matches)
      break
    case 'ruby':
      syntaxDetails = processRubyMatches(matches)
      break
    default: {
      syntaxDetails = processOtherMatches(matches, parsedLanguage)
      break
    }
  }
  return new SyntaxTree(syntaxDetails, SyntaxNodeDetails.ofSyntaxNode(rootNode))
}

function processOtherMatches(matches, language) {
  let syntaxMap = new Map()
  return (
    matches.forEach(match => {
      let definitionNode = match.captures.find(capture => capture.name === 'definition')?.node,
        bodyNode = definitionNode?.childForFieldName('body')
      if (definitionNode && bodyNode) {
        let comments
        switch (language) {
          case 'typescript':
          case 'javascript':
            comments = processJsTsComments(definitionNode)
            break
          case 'java':
          case 'rust':
            comments = processJavaRustComments(definitionNode)
            break
          default: {
            comments = processDefaultComments(definitionNode)
            break
          }
        }
        syntaxMap.get(definitionNode.id) ||
          syntaxMap.set(definitionNode.id, {
            mainBlock: SyntaxNodeDetails.ofSyntaxNode(definitionNode),
            detailBlocks: { comments: comments.map(c => SyntaxNodeDetails.ofSyntaxNode(c)), body: SyntaxNodeDetails.ofSyntaxNode(bodyNode) },
          })
      }
    }),
    Array.from(syntaxMap.values())
  )
}

function findNonParameterNode(nodes) {
  if (!(nodes.length < 2))
    for (let i = 1; i < nodes.length; i++) {
      let node = nodes[i]
      if (!node.type.includes('parameters')) return node
    }
}

function processRubyMatches(matches) {
  let syntaxMap = new Map()
  return (
    matches.forEach(match => {
      let definitionNode = match.captures.find(capture => capture.name === 'definition')?.node
      if (definitionNode) {
        let namedChildren = definitionNode.namedChildren,
          nonParameterNode = findNonParameterNode(namedChildren)
        if (nonParameterNode) {
          let lastChild = namedChildren[namedChildren.length - 1],
            bodyText = definitionNode.text.substring(nonParameterNode.startIndex - definitionNode.startIndex, lastChild.endIndex - definitionNode.startIndex),
            comments = processDefaultComments(definitionNode)
          syntaxMap.get(definitionNode.id) ||
            syntaxMap.set(definitionNode.id, {
              mainBlock: SyntaxNodeDetails.ofSyntaxNode(definitionNode),
              detailBlocks: {
                comments: comments.map(comment => SyntaxNodeDetails.ofSyntaxNode(comment)),
                body: {
                  range: {
                    startPosition: { row: nonParameterNode.startPosition.row, column: nonParameterNode.startPosition.column },
                    endPosition: { row: lastChild.endPosition.row, column: lastChild.endPosition.column },
                  },
                  startIndex: nonParameterNode.startIndex,
                  text: bodyText,
                  endIndex: lastChild.endIndex,
                },
              },
            })
        }
      }
    }),
    Array.from(syntaxMap.values())
  )
}
function processPythonMatches(matches) {
  let syntaxMap = new Map()
  return (
    matches.forEach(match => {
      let definitionNode = match.captures.find(capture => capture.name === 'definition')?.node,
        bodyNode = definitionNode?.childForFieldName('body')
      if (definitionNode && bodyNode) {
        let docstringNode = getDocstringNode(bodyNode),
          decoratorNode = getDecoratorNode(definitionNode)
        syntaxMap.set(definitionNode.id, {
          mainBlock: SyntaxNodeDetails.ofSyntaxNode(definitionNode),
          detailBlocks: {
            docstring: docstringNode ? SyntaxNodeDetails.ofSyntaxNode(docstringNode) : void 0,
            decorator: decoratorNode ? SyntaxNodeDetails.ofSyntaxNode(decoratorNode) : void 0,
            body: SyntaxNodeDetails.ofSyntaxNode(bodyNode),
          },
        })
        return
      }
    }),
    Array.from(syntaxMap.values())
  )
}

function getComments(node, commentTypes = ['comment']) {
  let comments = [],
    previousSibling = node.previousNamedSibling
  for (; previousSibling && commentTypes.some(type => type === previousSibling?.type); ) {
    comments.push(previousSibling),
    (previousSibling = previousSibling.previousNamedSibling)
  }
  return comments.reverse()
}

function processJavaRustComments(node) {
  return getComments(node, ['block_comment', 'line_comment'])
}

function processJavaRustComments(t) {
  return getComments(t, ['block_comment', 'line_comment'])
}

function getDecoratorNode(node) {
  let previousSibling = node.previousNamedSibling
  return previousSibling?.type === 'decorator' ? previousSibling : void 0
}

function getDocstringNode(node) {
  let firstChild = node.firstChild
  if (!firstChild || firstChild.type !== 'expression_statement') return
  let grandChild = firstChild.firstChild
  return grandChild?.type === 'string' ? grandChild : void 0
}

var workerPath = path.join(__dirname, 'worker2.js'),
worker = null,
treeSitterUtils = TreeSitterUtils

function initializeWorker(isWorkerRequired, workerOptions) {
  if (isWorkerRequired) {
    worker = new WorkerProxy(workerPath, workerOptions);
    treeSitterUtils = worker.proxy;
  }
}

function terminateWorker() {
  if (worker) {
    worker.terminate();
    worker = null;
    treeSitterUtils = TreeSitterUtils;
    cleanUp();
  }
}

async function getFunctionPositions(code, language) {
  return treeSitterUtils._getFunctionPositions(code, language);
}

async function getFunctionBodies(code, language) {
  return treeSitterUtils._getFunctionBodies(code, language);
}

async function getCoarseParentScope(code, language, range) {
  return treeSitterUtils._getCoarseParentScope(code, language, range);
}

async function getFixSelectionOfInterest(code, language, range, threshold) {
  return treeSitterUtils._getFixSelectionOfInterest(code, language, range, threshold);
}

async function getCallExpressions(code, language, range) {
  return treeSitterUtils._getCallExpressions(code, language, range);
}

async function getFunctionDefinitions(code, language) {
  return treeSitterUtils._getFunctionDefinitions(code, language);
}

async function getNewExpressions(code, language, range) {
  return treeSitterUtils._getNewExpressions(code, language, range);
}

async function getClassDeclarations(code, language) {
  return treeSitterUtils._getClassDeclarations(code, language);
}

async function getTypeDeclarations(code, language) {
  return treeSitterUtils._getTypeDeclarations(code, language);
}

async function getTypeReferences(code, language, range) {
  return treeSitterUtils._getTypeReferences(code, language, range);
}

async function getSemanticChunkTree(code, language) {
  return treeSitterUtils._getSemanticChunkTree(code, language);
}

async function getDocumentableNodeIfOnIdentifier(code, language, position) {
  return treeSitterUtils._getDocumentableNodeIfOnIdentifier(code, language, position);
}

async function getNodeToDocument(code, language, range) {
  return treeSitterUtils._getNodeToDocument(code, language, range);
}

async function extractDoc(code, language) {
  return treeSitterUtils._extractDoc(code, language);
}

var conversationOptions = createServiceIdentifier('ConversationOptions')

var Anchor = class {
  constructor(anchor) {
    this.anchor = anchor;
  }
};

var Session = class {
  constructor(request, sessionId) {
    this.request = request;
    this.sessionId = sessionId;
    this.status = 'in-progress';
    this.contextParts = [];
    this.references = [];
  }
};

var ShortMessageSession = class extends Session {
  constructor(request, getShorterMessage) {
    super(request);
    this._getShorterMessage = getShorterMessage;
  }
  getShorterMessage() {
    return this._getShorterMessage();
  }
};

var Conversation = class {
  constructor(turns = []) {
    this.turns = turns;
  }
  copy() {
    let turnsCopy = JSON.parse(JSON.stringify(this.turns));
    return new Conversation(turnsCopy);
  }
  getLatestTurn() {
    return this.turns[this.turns.length - 1];
  }
  addTurn(turn) {
    this.turns.forEach(turn => (turn.chatMessages = []));
    this.turns.push(turn);
  }
  removeTurn(requestId) {
    let index = this.turns.findIndex(turn => turn.requestId === requestId);
    if (index !== -1) return this.turns.splice(index, 1)[0];
  }
  insertBeforeLatestTurn(turns) {
    this.turns.splice(this.turns.length - 1, 0, ...turns);
  }
  getState() {
    return { turns: this.turns };
  }
};

var BaseSymbolProvider = class {}
function isObjectWithTargetUri(obj) {
  return typeof obj == 'object' && obj !== null && 'targetUri' in obj
}
var WorkspaceClass = class {
  getWorkspaceFolder(uri) {
    return this.getWorkspaceFolders().find(
      folder => folder.scheme === uri.scheme && folder.authority === uri.authority && uri.fsPath.startsWith(folder.fsPath)
    )
  }
}
var extensionContext = class {}
var CommentSymbols = {
  abap: { start: '"', end: '' },
  bat: { start: 'REM', end: '' },
  bibtex: { start: '%', end: '' },
  blade: { start: '#', end: '' },
  c: { start: '//', end: '' },
  clojure: { start: ';', end: '' },
  coffeescript: { start: '//', end: '' },
  cpp: { start: '//', end: '' },
  csharp: { start: '//', end: '' },
  css: { start: '/*', end: '*/' },
  dart: { start: '//', end: '' },
  dockerfile: { start: '#', end: '' },
  elixir: { start: '#', end: '' },
  erb: { start: '<%#', end: '%>' },
  erlang: { start: '%', end: '' },
  fsharp: { start: '//', end: '' },
  go: { start: '//', end: '' },
  groovy: { start: '//', end: '' },
  haml: { start: '-#', end: '' },
  handlebars: { start: '{{!', end: '}}' },
  haskell: { start: '--', end: '' },
  html: { start: '<!--', end: '-->' },
  ini: { start: ';', end: '' },
  java: { start: '//', end: '' },
  javascript: { start: '//', end: '' },
  javascriptreact: { start: '//', end: '' },
  jsonc: { start: '//', end: '' },
  jsx: { start: '//', end: '' },
  julia: { start: '#', end: '' },
  kotlin: { start: '//', end: '' },
  latex: { start: '%', end: '' },
  less: { start: '//', end: '' },
  lua: { start: '--', end: '' },
  makefile: { start: '#', end: '' },
  markdown: { start: '[]: #', end: '' },
  'objective-c': { start: '//', end: '' },
  'objective-cpp': { start: '//', end: '' },
  perl: { start: '#', end: '' },
  php: { start: '//', end: '' },
  powershell: { start: '#', end: '' },
  pug: { start: '//', end: '' },
  python: { start: '#', end: '' },
  ql: { start: '//', end: '' },
  r: { start: '#', end: '' },
  razor: { start: '<!--', end: '-->' },
  ruby: { start: '#', end: '' },
  rust: { start: '//', end: '' },
  sass: { start: '//', end: '' },
  scala: { start: '//', end: '' },
  scss: { start: '//', end: '' },
  shellscript: { start: '#', end: '' },
  slim: { start: '/', end: '' },
  solidity: { start: '//', end: '' },
  sql: { start: '--', end: '' },
  stylus: { start: '//', end: '' },
  svelte: { start: '<!--', end: '-->' },
  swift: { start: '//', end: '' },
  terraform: { start: '#', end: '' },
  tex: { start: '%', end: '' },
  typescript: { start: '//', end: '' },
  typescriptreact: { start: '//', end: '' },
  vb: { start: "'", end: '' },
  verilog: { start: '//', end: '' },
  'vue-html': { start: '<!--', end: '-->' },
  vue: { start: '//', end: '' },
  xml: { start: '<!--', end: '-->' },
  xsl: { start: '<!--', end: '-->' },
  yaml: { start: '#', end: '' },
}

function compareLineDistance(range1, range2) {
  let startLineDistance = Math.abs(range1.start.line - range2.start.line),
    endLineDistance = Math.abs(range1.end.line - range2.end.line)
  return startLineDistance + endLineDistance > 30 ? range1 : range2
}

function adjustRange(document, ranges, range) {
  let startRange = getRangeAtOffset(document, ranges, range.start),
    endRange = getRangeAtOffset(document, ranges, range.end),
    startOffset = document.offsetAt(range.start),
    endOffset = document.offsetAt(range.end)
  if (startRange) {
    startOffset = Math.min(startOffset, startRange.startIndex)
    endOffset = Math.max(endOffset, startRange.endIndex)
  }
  if (endRange) {
    startOffset = Math.min(startOffset, endRange.startIndex)
    endOffset = Math.max(endOffset, endRange.endIndex)
  }
  return new VscodeRange(document.positionAt(startOffset), document.positionAt(endOffset))
}

async function getFunctionReferences(service, document, range, timeout) {
  let treeSitterRange = TreeSitterOffsetRange.toTreeSitterOffsetRange(range, document),
    callExpressions = await computeAsync(service, document, timeout, () => getCallExpressions(document.languageId, document.getText(), treeSitterRange), []),
    definitions = await computeAsync(
      service,
      document,
      timeout * 3,
      async () =>
        await Promise.all(
          callExpressions.map(async expression => {
            let position = document.positionAt(expression.startIndex),
              languageService = service.get(LanguageService)
            try {
              let implementations = await languageService.getImplementations(document.uri, position)
              return implementations.length ? implementations : await languageService.getDefinitions(document.uri, position)
            } catch {
              return []
            }
          })
        ),
      []
    ),
    functionReferences = []
  for (let i = 0; i < definitions.length; i++) {
    let expression = callExpressions[i],
      definition = definitions[i]
    for (let item of definition) {
      let { uri, range } = isObjectWithTargetUri(item) ? { uri: item.targetUri, range: item.targetRange } : item,
        targetDocument = await service.get(WorkspaceClass).openTextDocument(uri),
        functionDefinition = (await getFunctionDefinitions(targetDocument.languageId, targetDocument.getText())).find(def => def.identifier === expression.identifier)
      if (functionDefinition) {
        let targetRange = TreeSitterOffsetRange.toTreeSitterOffsetRange(range, targetDocument)
        functionReferences.push({
          uri,
          range,
          version: targetDocument.version,
          identifier: expression.identifier,
          startIndex: targetRange.startIndex,
          endIndex: targetRange.endIndex,
          text: functionDefinition.text,
        })
      }
    }
  }
  if (functionReferences.length !== 0) return functionReferences
  let text = document.getText(),
    functionDefinitions = await computeAsync(service, document, timeout, () => getFunctionDefinitions(document.languageId, text), []),
    matchedFunctions = []
  for (let definition of functionDefinitions)
    for (let expression of callExpressions)
      if (definition.identifier === expression.identifier)
        matchedFunctions.push(definition)
  return matchedFunctions.sort((a, b) => a.startIndex - b.startIndex)
}

async function getClassReferences(service, document, range, timeout) {
  let treeSitterRange = TreeSitterOffsetRange.toTreeSitterOffsetRange(range, document),
    newExpressions = await computeAsync(service, document, timeout, () => getNewExpressions(document.languageId, document.getText(), treeSitterRange), []),
    definitions = await computeAsync(
      service,
      document,
      timeout * 3,
      async () =>
        await Promise.all(
          newExpressions.map(async expression => {
            try {
              let position = document.positionAt(expression.startIndex),
                languageService = service.get(LanguageService),
                implementations = await languageService.getImplementations(document.uri, position)
              return implementations.length ? implementations : await languageService.getDefinitions(document.uri, position)
            } catch {
              return []
            }
          })
        ),
      []
    ),
    classReferences = []
  for (let i = 0; i < definitions.length; i++) {
    let expression = newExpressions[i],
      definition = definitions[i]
    for (let item of definition) {
      let { uri, range } = isObjectWithTargetUri(item) ? { uri: item.targetUri, range: item.targetRange } : item,
        targetDocument = await service.get(WorkspaceClass).openTextDocument(uri),
        classDeclaration = (await getClassDeclarations(targetDocument.languageId, targetDocument.getText())).find(def => def.identifier === expression.identifier)
      if (classDeclaration) {
        let targetRange = TreeSitterOffsetRange.toTreeSitterOffsetRange(range, targetDocument)
        classReferences.push({
          uri,
          range,
          version: targetDocument.version,
          identifier: expression.identifier,
          startIndex: targetRange.startIndex,
          endIndex: targetRange.endIndex,
          text: classDeclaration.text,
        })
      }
    }
  }
  if (classReferences.length !== 0) return classReferences
  let text = document.getText(),
    classDeclarations = await computeAsync(service, document, timeout, () => getClassDeclarations(document.languageId, text), []),
    matchedClasses = []
  for (let declaration of classDeclarations)
    for (let expression of newExpressions)
      if (declaration.identifier === expression.identifier)
        matchedClasses.push(declaration)
  return matchedClasses.sort((a, b) => a.startIndex - b.startIndex)
}

async function getSortedTypeReferences(service, document, range, timeout) {
  let treeSitterRange = TreeSitterOffsetRange.toTreeSitterOffsetRange(range, document),
    typeReferences = await computeAsync(service, document, timeout, () => getTypeReferences(document.languageId, document.getText(), treeSitterRange), []),
    text = document.getText(),
    typeDeclarations = await computeAsync(service, document, timeout, () => getTypeDeclarations(document.languageId, text), []),
    matchedTypes = []
  for (let declaration of typeDeclarations)
    for (let reference of typeReferences)
      if (declaration.identifier === reference.identifier)
        matchedTypes.push(declaration)
  return matchedTypes.sort((a, b) => a.startIndex - b.startIndex)
}

function getRangeAtOffset(document, ranges, offset) {
  let position = document.offsetAt(offset),
    range = null
  for (let item of ranges)
    if (!(item.endIndex < position)) {
      if (item.startIndex > position) break
      range = item
    }
  return range
}

function promiseWithTimeout(promise, timeout) {
  return timeout === 0
    ? promise.then(result => ({ type: 'success', value: result }))
    : new Promise((resolve, reject) => {
        let timer = setTimeout(() => resolve({ type: 'timeout' }), timeout)
        promise.then(result => {
          clearTimeout(timer), resolve({ type: 'success', value: result })
        }).catch(error => {
          clearTimeout(timer), reject(error)
        })
      })
}

async function getSortedFunctionPositions(service, document, timeout) {
  let functionPositions = await computeAsync(service, document, timeout, () => getFunctionPositions(document.languageId, document.getText()), [])
  return functionPositions.sort((a, b) => a.startIndex - b.startIndex), functionPositions
}

async function getSortedFunctionBodies(service, document, timeout) {
  let functionBodies = await computeAsync(service, document, timeout, () => getFunctionBodies(document.languageId, document.getText()), [])
  return functionBodies.sort((a, b) => a.startIndex - b.startIndex), removeNestedRanges(functionBodies)
}

function removeNestedRanges(ranges) {
  ranges.sort((a, b) => a.startIndex - b.startIndex || b.endIndex - a.endIndex)
  let result = []
  for (let i = 0, length = ranges.length; i < length; ) {
    result.push(ranges[i])
    let j = i + 1
    for (; j < ranges.length && TreeSitterOffsetRange.doesContain(ranges[i], ranges[j]); ) ++j
    i = j
  }
  return result
}

async function computeAsync(service, document, timeout, computation, defaultValue) {
  let logger = service.get(LoggerManager).getLogger('asyncCompute')
  try {
    let result = await promiseWithTimeout(retryIfVersionChanged(document, computation, defaultValue), timeout)
    return result.type === 'success' ? result.value : (logger.info(`Computing async parser based result took longer than ${timeout}ms`), defaultValue)
  } catch (error) {
    return (
      error instanceof UnrecognizedLanguageError ||
        (logger.exception(error, 'Failed to compute async parser based result'),
        service.get(IGHTelemetryService).sendExceptionTelemetry(error, 'Failed to compute async parser based result')),
      defaultValue
    )
  }
}

async function retryIfVersionChanged(document, computation, defaultValue, retryCount = 0) {
  let initialVersion = document.version,
    result = await computation()
  return document.version !== initialVersion ? (retryCount < 3 ? retryIfVersionChanged(document, computation, defaultValue, retryCount + 1) : defaultValue) : result
}

function getCommentSymbol(document) {
  let commentSymbols = CommentSymbols[document.languageId]
  return commentSymbols
    ? commentSymbols.end
      ? { languageId: document.languageId, lineCommentToken: '//' }
      : { languageId: document.languageId, lineCommentToken: commentSymbols.start }
    : { languageId: document.languageId, lineCommentToken: '//' }
}

var FilePathComment = class {
  static forDocument(language, document) {
    return this.forUri(language, document.uri)
  }
  static forUri(language, uri) {
    return `${this.forLanguage(language)}: ${uri.path}`
  }
  static forLanguage(language) {
    return `${language.lineCommentToken} FILEPATH`
  }
  static testLine(language, line) {
    let comment = FilePathComment.forLanguage(language)
    return line.trimStart().startsWith(comment)
  }
}

var BlockComment = class {
  static begin(language, identifier) {
    return typeof identifier > 'u' ? `${language.lineCommentToken} BEGIN:` : `${language.lineCommentToken} BEGIN: ${identifier}`
  }
  static end(language, identifier) {
    return typeof identifier > 'u' ? `${language.lineCommentToken} END:` : `${language.lineCommentToken} END: ${identifier}`
  }
}

function isCodeBlock(text) {
  return /```[\s\S]+\n```/m.test(text)
}

var analysisConfig = { analysisTimeoutMs: 100 }

async function analyzeDocument(service, document, range) {
  let timeout = service.get(extensionContext).extensionMode === VscodeExtensionMode.Test ? 0 : analysisConfig.analysisTimeoutMs,
    startTime = Date.now(),
    functionPositions = await getSortedFunctionPositions(service, document, timeout),
    elapsedTime = Date.now() - startTime,
    remainingTime = timeout === 0 ? 0 : Math.max(10, timeout - elapsedTime),
    functionBodies = await getSortedFunctionBodies(service, document, remainingTime),
    adjustedRange = adjustRange(document, functionPositions, range)
  return { expandedRange: document.validateRange(compareLineDistance(range, adjustedRange)), rangeExpandedToFunction: adjustedRange, functionBodies: functionBodies }
}
var contextInfo
;(context => {
  function isContextInfoAvailable(context) {
    return context && context.expandedRange && context.contextInfo
  }
  context.is = isContextInfoAvailable
})((contextInfo ||= {}))

var CharacterCounter = class {
  constructor(limit) {
    this.charLimit = limit
    this._totalChars = 0
  }
  get totalChars() {
    return this._totalChars
  }
  addLine(line) {
    this._totalChars += line.length + 1
  }
  lineWouldFit(line) {
    return this._totalChars + line.length + 1 < this.charLimit
  }
}
var CodeBlock = class CodeBlock {
  constructor(tracker, document, language, kindOrUniqueStr) {
    this.tracker = tracker
    this.document = document
    this.language = language
    this.kindOrUniqueStr = kindOrUniqueStr
    this.lines = []
    this.firstLineIndex = this.document.lineCount
    this.lastLineIndex = -1
    this.isComplete = false
    this.nonTrimWhitespaceCharCount = 0
    this._startMarker = BlockComment.begin(language, kindOrUniqueStr)
    this._endMarker = BlockComment.end(language, kindOrUniqueStr)
  }
  get startMarker() {
    return this._startMarker
  }
  get endMarker() {
    return this._endMarker
  }
  get lineCount() {
    return this.lines.length
  }
  get isVerySmallOrEmpty() {
    return this.nonTrimWhitespaceCharCount < 10
  }
  get hasContent() {
    return this.lines.length === 0 || this.nonTrimWhitespaceCharCount === 0 ? false : this.lines.length > 0
  }
  clone() {
    let clone = new CodeBlock(this.tracker, this.document, this.language, this.kindOrUniqueStr)
    clone._startMarker = this.startMarker
    clone._endMarker = this.endMarker
    clone.lines.push(...this.lines)
    clone.firstLineIndex = this.firstLineIndex
    clone.lastLineIndex = this.lastLineIndex
    clone.nonTrimWhitespaceCharCount = this.nonTrimWhitespaceCharCount
    return clone
  }
  clear() {
    this.lines.length = 0
    this.firstLineIndex = this.document.lineCount
    this.lastLineIndex = -1
    this.nonTrimWhitespaceCharCount = 0
  }
  generatePrompt(includeMarkers) {
    if (!this.hasContent) return []
    let prompt = []
    prompt.push('```' + this.language.languageId)
    prompt.push(FilePathComment.forDocument(this.language, this.document))
    if (includeMarkers) {
      prompt.push(`${this.startMarker}`)
      prompt.push(...this.lines)
      prompt.push(`${this.endMarker}`)
    }
    prompt.push('```')
    return prompt
  }
  prependLine(lineIndex) {
    let lineText = this.document.lineAt(lineIndex).text
    if (this.tracker.lineWouldFit(lineText)) {
      this.firstLineIndex = Math.min(this.firstLineIndex, lineIndex)
      this.lastLineIndex = Math.max(this.lastLineIndex, lineIndex)
      this.lines.unshift(lineText)
      this.tracker.addLine(lineText)
      this.nonTrimWhitespaceCharCount += lineText.trim().length
      return true
    }
    return false
  }
  appendLine(lineIndex) {
    let lineText = this.document.lineAt(lineIndex).text
    if (this.tracker.lineWouldFit(lineText)) {
      this.firstLineIndex = Math.min(this.firstLineIndex, lineIndex)
      this.lastLineIndex = Math.max(this.lastLineIndex, lineIndex)
      this.lines.push(lineText)
      this.tracker.addLine(lineText)
      this.nonTrimWhitespaceCharCount += lineText.trim().length
      return true
    }
    return false
  }
  trim(range) {
    let lastLineIndex = range ? Math.min(this.lastLineIndex, range.start.line) : this.lastLineIndex
    while (this.firstLineIndex < lastLineIndex && this.lines.length > 0 && this.lines[0].trim().length === 0) {
      this.firstLineIndex++
      this.lines.shift()
    }
    let firstLineIndex = range ? Math.max(this.firstLineIndex, range.end.line) : this.firstLineIndex
    while (firstLineIndex < this.lastLineIndex && this.lines.length > 0 && this.lines[this.lines.length - 1].trim().length === 0) {
      this.lastLineIndex--
      this.lines.pop()
    }
  }
  removeFirstNLines(numLines) {
    if (numLines >= this.lineCount) {
      let linesCopy = this.lines.slice(0),
        nonTrimWhitespaceCharCountCopy = this.nonTrimWhitespaceCharCount
      this.clear()
      return { lines: linesCopy, nonTrimWhitespaceCharCount: nonTrimWhitespaceCharCountCopy }
    }
    let removedLines = this.lines.splice(0, numLines),
      nonTrimWhitespaceCharCount = 0
    for (let line of removedLines) nonTrimWhitespaceCharCount += line.trim().length
    this.firstLineIndex += numLines
    this.nonTrimWhitespaceCharCount -= nonTrimWhitespaceCharCount
    return { lines: removedLines, nonTrimWhitespaceCharCount: nonTrimWhitespaceCharCount }
  }
  removeLastNLines(numLines) {
    if (numLines >= this.lineCount) {
      let linesCopy = this.lines.slice(0),
        nonTrimWhitespaceCharCountCopy = this.nonTrimWhitespaceCharCount
      this.clear()
      return { lines: linesCopy, nonTrimWhitespaceCharCount: nonTrimWhitespaceCharCountCopy }
    }
    let removedLines = this.lines.splice(this.lines.length - numLines, numLines),
      nonTrimWhitespaceCharCount = 0
    for (let line of removedLines) nonTrimWhitespaceCharCount += line.trim().length
    this.lastLineIndex -= numLines
    this.nonTrimWhitespaceCharCount -= nonTrimWhitespaceCharCount
    return { lines: removedLines, nonTrimWhitespaceCharCount: nonTrimWhitespaceCharCount }
  }
  takeFromAbove(codeBlock, numLines) {
    let { lines: removedLines, nonTrimWhitespaceCharCount } = codeBlock.removeLastNLines(numLines)
    this.lines.unshift(...removedLines)
    this.firstLineIndex -= removedLines.length
    this.nonTrimWhitespaceCharCount += nonTrimWhitespaceCharCount
  }
  takeFromBelow(codeBlock, numLines) {
    let { lines: removedLines, nonTrimWhitespaceCharCount } = codeBlock.removeFirstNLines(numLines)
    this.lines.push(...removedLines)
    this.lastLineIndex += removedLines.length
    this.nonTrimWhitespaceCharCount += nonTrimWhitespaceCharCount
  }  mergeFromAbove(codeBlock) {
    if (codeBlock.hasContent) {
      this.lines.unshift(...codeBlock.lines)
      this.firstLineIndex = codeBlock.firstLineIndex
      this.nonTrimWhitespaceCharCount += codeBlock.nonTrimWhitespaceCharCount
      codeBlock.clear()
    }
  }
  mergeFromBelow(codeBlock) {
    if (codeBlock.hasContent) {
      this.lines.push(...codeBlock.lines)
      this.lastLineIndex = codeBlock.lastLineIndex
      this.nonTrimWhitespaceCharCount += codeBlock.nonTrimWhitespaceCharCount
      codeBlock.clear()
    }
  }
  toRange() {
    try {
      let lastLineIndex = this.lastLineIndex === -1 ? this.document.lineCount - 1 : this.lastLineIndex,
        range = new VscodeRange(this.firstLineIndex, 0, lastLineIndex, this.document.lineAt(lastLineIndex).text.length)
      if (this.document.validateRange(range) === range) return range
    } catch {
      return
    }
  }
  toString() {
    return `{${this.firstLineIndex} -> ${this.lastLineIndex}}`
  }
}

var ContextResolverRegistry = new (class {
  constructor() {
    this._contextResolvers = new Map()
  }
  get contextResolvers() {
    return this._contextResolvers.values()
  }
  getContextResolver(type) {
    return this._contextResolvers.get(type)
  }
  register(resolver) {
    return this._contextResolvers.set(resolver.kind, resolver), resolver
  }
})()

var DocumentSelectionResolver = class {
  constructor(nodeToDocumentMapper = void 0) {
    this.nodeToDocumentMapper = nodeToDocumentMapper
    this.kind = 'doc-selection'
  }
  async resolveContext(service, context, options) {
    let documentContext = context.documentContext
    if (!documentContext) return
    let wholeRange = documentContext.wholeRange,
      nodeToDocument = this.nodeToDocumentMapper ?? (await DocumentSelectionResolver.determineNodeToDocument(service, documentContext)),
      docContext = await DocumentSelectionResolver.generateDocContext(context.endpoint, documentContext, nodeToDocument),
      userMessages = []
    {
      let messageParts = []
      messageParts.push('I have the following code in the selection:'),
        messageParts.push(...docContext.range.generatePrompt(false)),
        userMessages.push(
          messageParts.join(`
`)
        )
    }
    let usedContext = [{ uri: documentContext.document.uri, version: documentContext.document.version, ranges: filterTruthyValues([docContext.range.toRange()]) }]
    return { kind: this.kind, userMessages: userMessages, usedContext: usedContext, metadata: { expandedRange: wholeRange, contextInfo: docContext } }
  }
  static async determineNodeToDocument(service, context) {
    let selectionOffsetRange = DocumentSelectionResolver.toTreeSitterOffsetRange(context.selection, context.document),
      startTime = Date.now(),
      nodeToDocument = await getNodeToDocument(context.language.languageId, context.document.getText(), selectionOffsetRange),
      timeSpent = Date.now() - startTime
    if (nodeToDocument) {
      let wholeRangeOffsetRange = DocumentSelectionResolver.toTreeSitterOffsetRange(context.wholeRange, context.document)
      DocumentSelectionResolver.sendNodeToDocumentTelemetry(service, selectionOffsetRange, wholeRangeOffsetRange, nodeToDocument, context.document.languageId, timeSpent)
      let vscodeRange = new VscodeRange(
        context.document.positionAt(nodeToDocument.nodeToDocument.startIndex),
        context.document.positionAt(nodeToDocument.nodeToDocument.endIndex)
      )
      return { identifier: nodeToDocument.nodeIdentifier, range: vscodeRange }
    } else return { range: context.wholeRange }
  }
  static toTreeSitterOffsetRange(range, document) {
    return { startIndex: document.offsetAt(range.start), endIndex: document.offsetAt(range.end) }
  }
  static async generateDocContext(endpoint, context, nodeToDocument) {
    let { range: selectedRange } = nodeToDocument,
      characterCounter = new CharacterCounter((endpoint.modelMaxTokenWindow * 4) / 3),
      selectedCodeBlock = new CodeBlock(characterCounter, context.document, context.language, 'ed8c6549bwf9'),
      aboveCodeBlock = new CodeBlock(new CharacterCounter(0), context.document, context.language, 'abpxx6d04wxr'),
      belowCodeBlock = new CodeBlock(new CharacterCounter(0), context.document, context.language, 'be15d9bcejpp')
    for (
      let line = selectedRange.start.line, endLine = selectedRange.end.line;
      line <= endLine && !((line === endLine && selectedRange.end.character === 0) || !selectedCodeBlock.appendLine(line));
      ++line
    );
    return (
      selectedCodeBlock.trim(context.selection), { language: context.language, above: aboveCodeBlock, range: selectedCodeBlock, below: belowCodeBlock, outlineAbove: '', outlineBelow: '' }
    )
  }
  static sendNodeToDocumentTelemetry(service, selectionOffsetRange, wholeRangeOffsetRange, nodeToDocument, languageId, timeSpent) {
    service.get(IMSTelemetryService).sendTelemetryEvent(
      'getNodeToDocument',
      {
        languageId: languageId,
        typeOfNodeToDocument: nodeToDocument.nodeToDocument.type,
        nodeToDocumentStart: nodeToDocument.nodeToDocument.startIndex.toString(),
        nodeToDocumentEnd: nodeToDocument.nodeToDocument.endIndex.toString(),
        selectionOffsetRangeStart: selectionOffsetRange.startIndex.toString(),
        selectionOffsetRangeEnd: selectionOffsetRange.endIndex.toString(),
        wholeRangeOffsetRangeStart: wholeRangeOffsetRange.startIndex.toString(),
        wholeRangeOffsetRangeEnd: wholeRangeOffsetRange.endIndex.toString(),
      },
      { timeSpentMs: timeSpent }
    )
  }
}



var documentSelectionResolverInstance = ContextResolverRegistry.register(new DocumentSelectionResolver())
var util = require('util')
var BaseFileSystemOperations = class {}
var IgnoreServiceIdentifier = createServiceIdentifier('IIgnoreService')
var FileFinder = class {
  constructor(accessor) {
    this._accessor = accessor
  }
  async findFilesWithDefaultExcludes(includePattern, maxResults, progress) {
    let excludePattern = this._accessor?.safeGet(IgnoreServiceIdentifier)?.asMinimatchPattern({ includeCopilotIgnore: !0, includeGitIgnore: !1 }),
      searchOptions = { include: includePattern, maxResults: maxResults, exclude: excludePattern, useDefaultExcludes: !0 },
      foundFiles = [],
      progressReporter = {
        report(file) {
          foundFiles.push(file.uri)
        },
      }
    await this.findTextInFiles({ pattern: '.', isRegExp: !0 }, searchOptions, progressReporter, progress)
    return maxResults === 1 ? foundFiles[0] : foundFiles
  }
}
var BaseTabManager = class {}
var patternMatcher = handleDefaultExports(patternMatcherModule())
function isPathMatch(file, pattern) {
  return typeof pattern == 'string'
    ? patternMatcher.default.isMatch(file.fsPath, pattern, { dot: true })
    : patternMatcher.default.isMatch(file.fsPath, pattern.pattern, { dot: true })
}
var defaultNamingConvention = {
    location: 'sameFolder',
    prefix: 'test_',
    suffixes: ['.test', '.spec', '_test', 'Test', '_spec', '_test', 'Tests', '.Tests', 'Spec'],
  },
  languageSpecificNamingConvention = {
    csharp: { suffixes: ['Test'], location: 'testFolder' },
    dart: { suffixes: ['_test'], location: 'testFolder' },
    go: { suffixes: ['_test'], location: 'sameFolder' },
    java: { suffixes: ['Test'], location: 'testFolder' },
    javascript: { suffixes: ['.test', '.spec'], location: 'sameFolder' },
    kotlin: { suffixes: ['Test'], location: 'testFolder' },
    php: { suffixes: ['Test'], location: 'testFolder' },
    powershell: { suffixes: ['.Tests'], location: 'testFolder' },
    python: { prefix: 'test_', location: 'testFolder' },
    ruby: { suffixes: ['_test', '_spec'], location: 'testFolder' },
    rust: { suffixes: [''], location: 'testFolder' },
    swift: { suffixes: ['Tests'], location: 'testFolder' },
    typescript: { suffixes: ['.test', '.spec'], location: 'sameFolder' },
  },
  fileExtensionToLanguageMapping = {
    cs: 'csharp',
    dart: 'dart',
    go: 'go',
    java: 'java',
    js: 'javascript',
    kt: 'kotlin',
    php: 'php',
    ps1: 'powershell',
    py: 'python',
    rb: 'ruby',
    rs: 'rust',
    swift: 'swift',
    ts: 'typescript',
  },
  languageSpecificNamingByExtension = (function () {
    let mapping = {}
    for (let [extension, language] of Object.entries(fileExtensionToLanguageMapping))
      mapping[extension] = languageSpecificNamingConvention[language]
    return mapping
  })(),
  TestFileManager = class {
    constructor(search, tabs) {
      this._search = search
      this._tabs = tabs
    }
    _findTabMatchingPattern(pattern) {
      return this._tabs.tabs.find(tab => tab.uri && tab.uri.scheme !== resourceTypes.untitled && isPathMatch(tab.uri, pattern))?.uri
    }
    async findTestFileForSourceFile(sourceFile, token) {
      if (sourceFile.isUntitled) return
      let baseName = getBasename(sourceFile.uri),
        extension = getExtension(sourceFile.uri),
        namingConvention = languageSpecificNamingConvention[sourceFile.languageId] ?? defaultNamingConvention,
        potentialNames = []
      if ((namingConvention.prefix && potentialNames.push(namingConvention.prefix + baseName), namingConvention.suffixes))
        for (let suffix of namingConvention.suffixes ?? []) {
          let potentialName = baseName.replace(`${extension}`, `${suffix}${extension}`)
          potentialNames.push(potentialName)
        }
      let pattern = `**/{${potentialNames.join(',')}}`,
        matchingUri = this._findTabMatchingPattern(pattern)
      return matchingUri || (matchingUri = await this._search.findFilesWithDefaultExcludes(pattern, 1, token)), matchingUri
    }
    async findAnyTestFileForSourceFile(sourceFile, token) {
      let namingConvention = languageSpecificNamingConvention[sourceFile.languageId] ?? defaultNamingConvention,
        potentialPatterns = []
      if ((namingConvention.prefix && potentialPatterns.push(`${namingConvention.prefix}*`), namingConvention.suffixes)) {
        let extension = getExtension(sourceFile.uri)
        for (let suffix of namingConvention.suffixes ?? []) potentialPatterns.push(`*${suffix}${extension}`)
      }
      let pattern = `**/{${potentialPatterns.join(',')}}`,
        matchingUri = this._findTabMatchingPattern(pattern)
      return matchingUri || (matchingUri = await this._search.findFilesWithDefaultExcludes(pattern, 1, token)), matchingUri
    }
    async findSourceFileForTestFile(testFile, token) {
      let namingConvention = languageSpecificNamingConvention[testFile.languageId] ?? defaultNamingConvention,
        baseName = getBasename(testFile.uri),
        potentialPatterns = []
      namingConvention.suffixes && potentialPatterns.splice(0, 0, ...namingConvention.suffixes), namingConvention.prefix && potentialPatterns.splice(0, 0, namingConvention.prefix)
      for (let pattern of potentialPatterns) {
        let potentialName = baseName.replace(pattern, '')
        if (potentialName !== baseName) {
          let searchPattern = `**/${potentialName}`,
            matchingUri = this._findTabMatchingPattern(searchPattern)
          if ((matchingUri || (matchingUri = await this._search.findFilesWithDefaultExcludes(searchPattern, 1, token)), matchingUri)) return matchingUri
        }
      }
    }
  }

function isTestFile(uri) {
  let namingConvention
  Uri.isUri(uri) || ((namingConvention = languageSpecificNamingConvention[uri.languageId]), (uri = uri.uri))
  let baseName = getBasename(uri),
    extension = getExtension(uri)
  namingConvention ??= languageSpecificNamingByExtension[extension.replace('.', '')]
  return namingConvention
    ? !((namingConvention.suffixes && !namingConvention.suffixes.some(suffix => baseName.endsWith(suffix + extension))) || (namingConvention.prefix && !baseName.startsWith(namingConvention.prefix)))
    : !!(defaultNamingConvention.suffixes.some(suffix => baseName.endsWith(suffix + extension)) || baseName.startsWith(defaultNamingConvention.prefix))
}

function generateTestFileName(sourceFile) {
  let namingConvention = languageSpecificNamingConvention[sourceFile.languageId] ?? defaultNamingConvention,
    baseName = getBasename(sourceFile.uri)
  if (namingConvention.prefix) return namingConvention.prefix + baseName
  let extension = getExtension(sourceFile.uri),
    suffix = namingConvention.suffixes && namingConvention.suffixes.length > 0 ? namingConvention.suffixes[0] : '.test'
  return baseName.replace(`${extension}`, `${suffix}${extension}`)
}

var notebookCellScheme = 'vscode-notebook-cell'

function isNotebookCell(uri) {
  return uri.scheme === notebookCellScheme
}
var BaseVSCodeInfoProvider = class {}
var CommandManager = new (class {
  constructor() {
    this.commands = new Set()
  }
  registerCommand(command) {
    this.commands.add(command)
  }
  getCommand(commandId, location) {
    return this.getCommands(location).find(command => command.commandId === commandId)
  }
  getCommands(location) {
    return Array.from(this.commands.values()).filter(command => command.locations.includes(location))
  }
})()

var commandCategories = {
  workspace: ['explain', 'tests', 'fix', 'new', 'newNotebook'],
  vscode: ['search', 'api'],
  terminal: []
}

function getCommandCategory(command) {
  if (Object.keys(commandCategories).includes(command))
    return { category: command }

  for (let [category, commands] of Object.entries(commandCategories))
    if (commands.includes(command))
      return { category: category, specificCommand: command }
}

function getAssistantIntroduction() {
  return `
You are an AI programming assistant.
`.trim()
}
function getAssistantIdentity() {
  return `
When asked for your name, you must respond with "GitHub Copilot".
Follow the user's requirements carefully & to the letter.`.trim()
}
function getAssistantExpertise() {
  return `
Your expertise is strictly limited to software development topics.
Follow Microsoft content policies.
Avoid content that violates copyrights.
For questions not related to software development, simply give a reminder that you are an AI programming assistant.
Keep your answers short and impersonal.`.trim()
}
async function getAssistantCapabilities(commandManager, commandContext, modelInfo) {
  let capabilitiesDescription = Object.entries(commandCategories).reduce((description, [category, commands]) => {
    let categoryDescription = commandManager.getCommand(category, commandContext)?.intent?.description
    description += `
* ${categoryDescription}`
    for (let command of commands) {
      let commandDescription = commandManager.getCommand(command, commandContext)?.intent?.description
      description += `
* ${commandDescription}`
    }
    return description
  }, 'You can answer general programming questions and perform the following tasks:')
  try {
    capabilitiesDescription += `
You use the ${modelInfo.model.toUpperCase()} version of OpenAI's GPT models.`
  } catch {}
  return capabilitiesDescription
}
function getDevelopmentProcess() {
  return `
First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.
Then output the code in a single code block.
Minimize any other prose.
`.trim()
}
function getFormattingGuidelines() {
  return `
Use Markdown formatting in your answers.
Make sure to include the programming language name at the start of the Markdown code blocks.
Avoid wrapping the whole response in triple backticks.
The user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.
The active document is the source code the user is looking at right now.
You can only give one reply for each conversation turn.
`.trim()
}
async function generateAssistantMessage(t, e, r, n = { includeCodeGenerationRules: !0, includeCapabilities: !1 }) {
  let i = `
${n.roleplay ?? getAssistantIntroduction()}
${getAssistantIdentity()}
${getAssistantExpertise()}
`
  return (
    n.roleplay ||
      (i += `
${(await getAssistantCapabilities(t, e, r)).trim()}
`),
    (i += `
${n.includeCodeGenerationRules ? getDevelopmentProcess() : ''}
${getFormattingGuidelines()}
${getLocaleResponse(t)}
`.trim()),
    i
  )
}
var supportedLocales = ['auto', 'en', 'fr', 'it', 'de', 'es', 'ru', 'zh-CN', 'zh-TW', 'ja', 'ko', 'cs', 'pt-br', 'tr', 'pl']

function getLocaleResponse(t) {
  let locale = t.get(ConfigManager).getConfig(settings.LocaleOverride)
  if (!supportedLocales.find(i => locale === i)) return ''
  let language = locale !== 'auto' ? locale : t.get(BaseVSCodeInfoProvider).language
  return language === 'en' ? '' : `Respond in the following locale: ${language}`
}

function vscpp(type, props, ...children) {
  return { ctor: type, props: props, children: children.flat() }
}
function vscppf() {
  throw new Error('This should not be invoked!')
}
vscppf.isFragment = true
globalThis.vscpp = vscpp
globalThis.vscppf = vscppf

var BaseComponent = class {
  get priority() {
    return this.props.priority ?? 0
  }
  get supportsResizing() {
    return false
  }
  constructor(props, accessor) {
    this.props = props
    this.accessor = accessor
  }
}
var FragmentComponent = class extends BaseComponent {
    render() {
      return vscpp(vscppf, null, this.props.children)
    }
  }

var SystemComponent = class extends FragmentComponent {
  constructor(props, accessor) {
    props.role = 'system'
    super(props, accessor)
  }
}

var UserComponent = class extends FragmentComponent {
  constructor(props, accessor) {
    props.role = 'user'
    super(props, accessor)
  }
}

var ExpertiseComponent = class extends BaseComponent {
  render() {
    return vscpp(vscppf, null, getAssistantExpertise())
  }
}
var Renderer = class {
  constructor(accessor, tokenBudget, endpoint) {
    this._accessor = accessor
    this._tokenBudget = tokenBudget
    this._endpoint = endpoint
    this._meta = new Map()
    this._usedContext = []
  }
  getAllMeta() {
    return this._meta
  }
  getMeta(key) {
    return this._meta.get(key)
  }
  getUsedContext() {
    return this._usedContext
  }
  async render(element, props) {
    let environment = { tokenBudget: this._tokenBudget, zoomLevel: 0, endpoint: this._endpoint },
    rootNode = new Node(),
    renderQueue = [{ kind: 'obj', node: rootNode, minp: 0, maxp: 1e3, ctor: element, props: props, children: void 0 }],
    sortQueue = () => {
      renderQueue.sort((a, b) => b.maxp - a.maxp)
    },
    intrinsicElements = {
        meta: (node, props) => {
          this._addMeta(props.key, props.value)
        },
        br: (node, props) => {
          node.appendLineBreak()
        },
        usedContext: (node, props) => {
          this._addUsedContext(props.value)
        },
      },
      hasIntrinsicElement = element => intrinsicElements.hasOwnProperty(element),
      handleIntrinsicElement = (node, element, props) => {
        if (!hasIntrinsicElement(element)) throw new Error(`Unknown intrinsic element ${element}!`)
        return intrinsicElements[element](node, props)
      }
    for (; renderQueue.length > 0; ) {
      let current = renderQueue.shift()
      if (current.kind === 'obj') {
        Array.isArray(current.children) && ((current.props = current.props ?? {}), (current.props.children = current.children))
        let instance = new current.ctor(current.props, this._accessor)
        current.node.setObj(instance)
        let state = await instance.prepare?.()
        current.node.setState(state)
        let result = instance.render(current.node.getState(), environment)
        if (!result) continue
        if (isFragment(result)) {
          let flattenChildren = children =>
          children.reduce(
                (flat, child) =>
                  typeof child > 'u' || typeof child == 'boolean'
                    ? flat
                    : typeof child == 'string' || typeof child == 'number'
                    ? (flat.push(String(child)), flat)
                    : (isFragment(child) ? flat.push(...flattenChildren(child.children)) : flat.push(child), flat),
                []
              ),
            flatChildren = flattenChildren(result.children)
          for (let child of flatChildren) {
            if (typeof child == 'string') {
              current.node.appendStringChild(child)
              continue
            }
            if (typeof child.ctor == 'string') {
              handleIntrinsicElement(current.node, child.ctor, child.props)
              continue
            }
            if (typeof child.ctor > 'u') throw new Error('Unexpected result from render(), unexpected child!')
            let childNode = current.node.createChild()
            renderQueue.push({ kind: 'obj', node: childNode, minp: 0, maxp: 1e3, ctor: child.ctor, props: child.props, children: child.children })
          }
        } else {
          if (typeof result.ctor == 'string') {
            handleIntrinsicElement(current.node, result.ctor, result.props)
            continue
          }
          if (typeof result.ctor > 'u') throw new Error('Unexpected result from render() invocation!')
          let childNode = current.node.createChild()
          renderQueue.push({ kind: 'obj', node: childNode, minp: 0, maxp: 1e3, ctor: result.ctor, props: result.props, children: result.children })
        }
        sortQueue()
      }
    }
    return rootNode.materialize()
  }
  _addUsedContext(context) {
    this._usedContext.push(...context)
  }
  _addMeta(key, value) {
    if (this._meta.has(key)) throw new Error(`Duplicate meta key ${key}!`)
    this._meta.set(key, value)
  }
}

async function renderWithMetadata(accessor, endpoint, element, props) {
  let renderer = new Renderer(accessor, 8192, endpoint),
    messages = await renderer.render(element, props),
    metadatas = renderer.getAllMetaData(),
    usedContext = renderer.getUsedContext()
  return { messages: messages, metadatas: metadatas, usedContext: usedContext }
}

class Node {
  constructor(parent = null) {
    this.parent = parent;
    this.kind = 0;
    this._obj = null
    this._state = undefined;
    this._children = []
  }
  setObj(object) {
    this._obj = object
  }
  setState(state) {
    this._state = state
  }
  getState() {
    return this._state
  }

  createChild() {
    let child = new Node(this);
    this._children.push(child);
    return child;
  }

  appendStringChild(string) {
    this._children.push(new TextNode(this, string))
  }

  appendLineBreak() {
    this._children.push(new LineBreakNode(this, !0))
  }

  materialize() {
    let result = [];
    this._materialize(result);
    return result;
  }

  _materialize(e) {
    if (this._obj instanceof FragmentComponent) {
      if (!this._obj.props.role) throw new Error('Invalid ChatMessage!')
      let leafs = []
      for (let childi of this._children) child.collectLeafs(leafs)
      let content = []
      for (let leaf of leafs)
      leaf.kind === 1
          ? content.push(leaf.text)
          : (leaf.isExplicit ||
              (content.length > 0 &&
                content[content.length - 1] !==
                  `
`)) &&
            content.push(`
`)
      e.push({ role: this._obj.props.role, content: content.join('') })
    } else
      for (let child of this._children) {
        if (child.kind === 1 || child.kind === 2)
          throw new Error('Cannot have a text node or line break node outside a ChatMessage!')
          child._materialize(e)
      }
  }

  collectLeafs(result) {
    if (this._obj instanceof FragmentComponent) throw new Error('Cannot have a ChatMessage nested inside a ChatMessage!')
    result.push(new LineBreakNode(this, !1))
    for (let child of this._children) child.collectLeafs(result)
  }
}

class TextNode {
  constructor(parent, text) {
    this.parent = parent;
    this.text = text;
    this.kind = 1;
  }

  collectLeafs(tree) {
    tree.push(this);
  }
}


class LineBreakNode {
  constructor(parent, isExplicit) {
    this.parent = parent;
    this.isExplicit = isExplicit;
    this.kind = 2;
  }

  collectLeafs(tree) {
    tree.push(this);
  }
}

function isFragment(node) {
  return (typeof node.ctor == 'function' && node.ctor.isFragment) ?? false
}

var CodeRenderer = class extends BaseComponent {
  render() {
    return vscpp(
      vscppf,
      null,
      '```',
      this.props.language.languageId,
      vscpp('br', null),
      this.props.document &&
        vscpp(vscppf, null, FilePathComment.forDocument(this.props.language, this.props.document), vscpp('br', null)),
      this.props.code && vscpp(vscppf, null, this.props.code, vscpp('br', null)),
      '```'
    )
  }
}
var CodeRegionRenderer = class extends BaseComponent {
  render() {
    if (!this.props.codeRegion.hasContent) return
    let lines = []
    return (
      this.props.useMarkers && lines.push(this.props.codeRegion.startMarker),
      lines.push(...this.props.codeRegion.lines),
      this.props.useMarkers && lines.push(this.props.codeRegion.endMarker),
      vscpp(CodeRenderer, {
        language: this.props.codeRegion.language,
        document: this.props.codeRegion.document,
        code: lines.join(`
`),
      })
    )
  }
}
var InlineNotebookSelection = class extends BaseComponent {
  static {
    this.METADATA_ID = 'inlineNotebookSelection'
  }
  async prepare() {
    return await analyzeDocument(this.accessor, this.props.documentContext.document, this.props.documentContext.wholeRange)
  }
  render(e, r) {
    if (!isNotebookCell(this.props.documentContext.document.uri))
      throw throwIllegalArgumentError('InlineChatNotebookSelection should be used only with a notebook!')
    let { expandedRange: n } = e,
      i = processCodeAndCells(this.accessor, r.endpoint, this.props.documentContext, n, void 0),
      o = this.props.documentContext.document,
      s = { expandedRange: n, contextInfo: i },
      a = [{ uri: o.uri, version: o.version, ranges: filterTruthyValues([i.range.toRange(), i.above.toRange(), i.below.toRange()]) }]
    return vscpp(
      vscppf,
      null,
      vscpp('usedContext', { value: a }),
      vscpp('meta', { key: InlineNotebookSelection.METADATA_ID, value: s }),
      vscpp(NotebookRenderer, {
        documentContext: this.props.documentContext,
        above: i.above,
        range: i.range,
        below: i.below,
        aboveCells: i.aboveCells,
        belowCells: i.belowCells,
      })
    )
  }
}
var NotebookRenderer = class extends BaseComponent {
    static {
      this.METADATA_ID = 'inlineNotebookSelection'
    }
    render(props, state) {
      if (!isNotebookCell(this.props.documentContext.document.uri))
        throw throwIllegalArgumentError('InlineChatNotebookSelectionRenderer should be used only with a notebook!')
      let includeDelimeters = this.props.includeDelimeters ?? false,
        { below: belowCells, above: aboveCells, range: range, aboveCells: cellsAbove_, belowCells: cellsBelow_ } = this.props,
        cellsAbove = cellsAbove_ || [],
        cellsBelow = cellsBelow_ || [],
        language = this.props.documentContext.language
      return vscpp(
        vscppf,
        null,
        (cellsAbove.length > 0 || cellsBelow.length > 0) &&
          vscpp(
            UserComponent,
            null,
            'I am working on a Jupyter notebook.',
            vscpp('br', null),
            'This Jupyter Notebook already contains multiple cells.',
            vscpp('br', null),
            'The content of cells are listed below, each cell starts with CELL INDEX and a code block started with ```',
            language.languageId,
            vscpp('br', null),
            'Each cell is a block of code that can be executed independently.',
            vscpp('br', null),
            'Since it is Jupyter Notebook, if a module is already imported in a cell, it can be used in other cells as well.',
            vscpp('br', null),
            'For the same reason, if a variable is defined in a cell, it can be used in other cells as well.',
            vscpp('br', null),
            'We should not repeat the same import or variable definition in multiple cells, unless we want to overwrite the previous definition.',
            vscpp('br', null),
            'Do not generate CELL INDEX in your answer, it is only used to help you understand the context.',
            vscpp('br', null),
            vscpp('br', null),
            'Below you will find a set of examples of what you should respond with. Please follow the exmaples on how to avoid repeating code.',
            vscpp('br', null),
            '## Examples starts here',
            vscpp('br', null),
            'Here are the cells in this Jupyter Notebook:',
            vscpp('br', null),
            '`CELL INDEX: 0',
            vscpp('br', null),
            '```python',
            vscpp('br', null),
            'import pandas as pd',
            vscpp('br', null),
            vscpp('br', null),
            '# create a dataframe with sample data',
            vscpp('br', null),
            "df = pd.DataFrame({'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35], 'Gender': ['F', 'M', 'M']})",
            vscpp('br', null),
            'print(df)',
            vscpp('br', null),
            '```',
            vscpp('br', null),
            '---------------------------------',
            vscpp('br', null),
            'USER:',
            vscpp('br', null),
            'Now I create a new cell in this Jupyter Notebook document at index 1.',
            vscpp('br', null),
            'In this new cell, I am working with the following code:',
            vscpp('br', null),
            '```python',
            vscpp('br', null),
            '```',
            vscpp('br', null),
            '---------------------------------',
            vscpp('br', null),
            'USER:',
            vscpp('br', null),
            'plot the data frame',
            vscpp('br', null),
            vscpp('br', null),
            '---------------------------------',
            vscpp('br', null),
            'ChatGPT Answer',
            vscpp('br', null),
            '---------------------------------',
            vscpp('br', null),
            "To plot the dataframe, we can use the `plot()` method of pandas dataframe. Here's the code:",
            vscpp('br', null),
            vscpp('br', null),
            '```python',
            vscpp('br', null),
            "df.plot(x='Name', y='Age', kind='bar')",
            vscpp('br', null),
            '```',
            vscpp('br', null),
            '## Example ends here',
            vscpp('br', null),
            cellsAbove.length > 0 &&
              vscpp(CellGroupRenderer, {
                cells: cellsAbove,
                title: `Here are the cells in this Jupyter Notebook:
`,
              }),
              cellsBelow.length > 0 &&
              vscpp(CellGroupRenderer, {
                cells: cellsBelow,
                cellIndexDelta: cellsAbove.length + 1,
                title: `Here are the cells below the current cell that I am editing in this Jupyter Notebook:
`,
              })
          ),
          language.languageId === 'markdown'
          ? vscpp(MarkdownCellRenderer, { cellIndex: cellsAbove.length, selected: range, above: aboveCells, below: belowCells, includeDelimeters: includeDelimeters })
          : vscpp(NewCellRenderer, { cellIndex: cellsAbove.length, selected: range, above: aboveCells, below: belowCells, includeDelimeters: includeDelimeters })
      )
    }
  },
  MarkdownCellRenderer = class extends BaseComponent {
    render() {
      let includeDelimeters = this.props.includeDelimeters ?? (this.props.above.hasContent || this.props.below.hasContent)
      return vscpp(
        vscppf,
        null,
        vscpp(
          UserComponent,
          null,
          'Now I create a new cell in this Jupyter Notebook document at index ',
          this.props.cellIndex,
          '.',
          vscpp('br', null),
          'This is a markdown cell. Markdown cell is used to describte and document your workflow.',
          vscpp('br', null),
          this.props.selected.hasContent
            ? vscpp(
                vscppf,
                null,
                'I have the following content in the selection:',
                vscpp(CodeRegionRenderer, { codeRegion: this.props.selected, useMarkers: includeDelimeters })
              )
            : vscpp(
                vscppf,
                null,
                'In this new cell, I am working with the following content:',
                vscpp(CodeRenderer, { language: this.props.selected.language, code: '' })
              )
        ),
        this.props.above.hasContent &&
          vscpp(
            UserComponent,
            null,
            'In this new cell, I have the following markdown content above the selection:',
            vscpp(CodeRegionRenderer, { codeRegion: this.props.above, useMarkers: this.props.includeDelimeters })
          ),
        this.props.below.hasContent &&
          vscpp(
            UserComponent,
            null,
            'In this new cell, I have the following markdown content below the selection:',
            vscpp(CodeRegionRenderer, { codeRegion: this.props.below, useMarkers: this.props.includeDelimeters })
          )
      )
    }
  },
  NewCellRenderer = class extends BaseComponent {
    // render() {
    //   let includeDelimeters = this.props.includeDelimeters ?? (this.props.above.hasContent || this.props.below.hasContent);
    //   return vscpp(
    //       vscppf,
    //       null,
    //       this.renderUserComponent(includeDelimeters),
    //       this.props.above.hasContent && this.renderAboveContent(),
    //       this.props.below.hasContent && this.renderBelowContent()
    //   );
    // }

    // renderUserComponent(includeDelimeters) {
    //     return vscpp(
    //         UserComponent,
    //         null,
    //         'Now I create a new cell in this Jupyter Notebook document at index ',
    //         this.props.cellIndex,
    //         '.',
    //         vscpp('br', null),
    //         'This is a markdown cell. Markdown cell is used to describe and document your workflow.',
    //         vscpp('br', null),
    //         this.props.selected.hasContent
    //             ? this.renderSelectedContent(includeDelimeters)
    //             : this.renderEmptyContent()
    //     );
    // }

    // renderSelectedContent(includeDelimeters) {
    //     return vscpp(
    //         vscppf,
    //         null,
    //         'I have the following content in the selection:',
    //         vscpp(CodeRegionRenderer, { codeRegion: this.props.selected, useMarkers: includeDelimeters })
    //     );
    // }

    // renderEmptyContent() {
    //     return vscpp(
    //         vscppf,
    //         null,
    //         'In this new cell, I am working with the following content:',
    //         vscpp(CodeRenderer, { language: this.props.selected.language, code: '' })
    //     );
    // }

    // renderAboveContent() {
    //     return vscpp(
    //         UserComponent,
    //         null,
    //         'In this new cell, I have the following markdown content above the selection:',
    //         vscpp(CodeRegionRenderer, { codeRegion: this.props.above, useMarkers: this.props.includeDelimeters })
    //     );
    // }

    // renderBelowContent() {
    //     return vscpp(
    //         UserComponent,
    //         null,
    //         'In this new cell, I have the following markdown content below the selection:',
    //         vscpp(CodeRegionRenderer, { codeRegion: this.props.below, useMarkers: this.props.includeDelimeters })
    //     );
    // }

    render() {
      let includeDelimeters = this.props.includeDelimeters ?? (this.props.above.hasContent || this.props.below.hasContent)
      return vscpp(
        vscppf,
        null,
        vscpp(
          UserComponent,
          null,
          'Now I create a new cell in this Jupyter Notebook document at index ',
          this.props.cellIndex,
          '.',
          vscpp('br', null),
          this.props.selected.hasContent
            ? vscpp(
                vscppf,
                null,
                'I have the following code in the selection:',
                vscpp(CodeRegionRenderer, { codeRegion: this.props.selected, useMarkers: includeDelimeters })
              )
            : vscpp(
                vscppf,
                null,
                'In this new cell, I am working with the following code:',
                vscpp(CodeRenderer, { language: this.props.selected.language, code: '' })
              )
        ),
        this.props.above.hasContent &&
          vscpp(
            UserComponent,
            null,
            'In this new cell, I have the following code above the selection:',
            vscpp(CodeRegionRenderer, { codeRegion: this.props.above, useMarkers: this.props.includeDelimeters })
          ),
        this.props.below.hasContent &&
          vscpp(
            UserComponent,
            null,
            'In this new cell, I have the following code below the selection:',
            vscpp(CodeRegionRenderer, { codeRegion: this.props.below, useMarkers: this.props.includeDelimeters })
          )
      )
    }
  },
  CellGroupRenderer = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        this.props.title,
        vscpp('br', null),
        this.props.cells.map((cell, index) => vscpp(CellRenderer, { index: index + (this.props.cellIndexDelta ?? 0), cell: cell }))
      )
    }
  },
  CellRenderer = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        'CELL INDEX: ',
        this.props.index,
        vscpp('br', null),
        '```',
        this.props.cell.language.languageId,
        vscpp('br', null),
        this.props.cell.lines.join(`
`),
        vscpp('br', null),
        '```'
      )
    }
  }
function processCodeAndCells(workspaceService, config, context, codeBlockResult, maxTokenCount) {
  // If maxTokenCount is not provided, calculate it based on the modelMaxTokenWindow configuration
  maxTokenCount = maxTokenCount ?? (config.modelMaxTokenWindow * 4) / 3;

  let characterCounter = new CharacterCounter(maxTokenCount),
    processedCodeBlock = handleCodeBlock(context.document, context.selection, codeBlockResult, new VscodeRange(0, 0, context.document.lineCount, 0), context.language, characterCounter);

  // Process the cells in the notebook document that matches the context document
  return processNotebookCells(workspaceService.get(WorkspaceClass), context, processedCodeBlock, characterCounter);
}
var InlineChatSelection = class extends BaseComponent {
  static {
    this.METADATA_ID = 'inlineDocumentSelection'
  }
  async prepare() {
    return await analyzeDocument(this.accessor, this.props.documentContext.document, this.props.documentContext.wholeRange)
  }
  render(renderProps, renderContext) {
    if (isNotebookCell(this.props.documentContext.document.uri)) throw throwIllegalArgumentError('InlineChatSelection should not be used with a notebook!')

    let { expandedRange, rangeExpandedToFunction, functionBodies } = renderProps,
      processedCodeBlock = processCodeBlock(this.accessor, renderContext.endpoint, this.props.documentContext, expandedRange, rangeExpandedToFunction, functionBodies, undefined),
      document = this.props.documentContext.document,
      language = this.props.documentContext.language,
      metadata = { expandedRange, contextInfo: processedCodeBlock },
      usedContext = [{ uri: document.uri, version: document.version, ranges: filterTruthyValues([processedCodeBlock.range.toRange(), processedCodeBlock.above.toRange(), processedCodeBlock.below.toRange()]) }],
      hasContent = processedCodeBlock.above.hasContent || processedCodeBlock.below.hasContent || processedCodeBlock.outlineAbove.length > 0 || processedCodeBlock.outlineBelow.length > 0;

    return vscpp(
      vscppf,
      null,
      vscpp('usedContext', { value: usedContext }),
      vscpp('meta', { key: InlineChatSelection.METADATA_ID, value: metadata }),
      processedCodeBlock.outlineAbove.length > 0 &&
        vscpp(
          UserComponent,
          null,
          'I have the following code above:',
          vscpp(CodeRenderer, { language, document, code: processedCodeBlock.outlineAbove })
        ),
      processedCodeBlock.above.hasContent &&
        vscpp(
          UserComponent,
          null,
          'I have the following code above the selection:',
          vscpp(CodeRegionRenderer, { codeRegion: processedCodeBlock.above, useMarkers: hasContent })
        ),
      processedCodeBlock.below.hasContent &&
        vscpp(
          UserComponent,
          null,
          'I have the following code below the selection:',
          vscpp(CodeRegionRenderer, { codeRegion: processedCodeBlock.below, useMarkers: hasContent })
        ),
      processedCodeBlock.outlineBelow.length > 0 &&
        vscpp(
          UserComponent,
          null,
          'I have the following code below:',
          vscpp(CodeRenderer, { language, document, code: processedCodeBlock.outlineBelow })
        ),
      processedCodeBlock.range.hasContent &&
        vscpp(
          UserComponent,
          null,
          'I have the following code in the selection:',
          vscpp(CodeRegionRenderer, { codeRegion: processedCodeBlock.range, useMarkers: hasContent })
        ),
      !processedCodeBlock.range.hasContent &&
        !hasContent &&
        vscpp(UserComponent, null, 'I am in an empty file:', vscpp(CodeRenderer, { language, document, code: '' }))
    )
  }
}

function processCodeBlock(workspaceService, config, context, codeBlockResult, selectionRange, functionBodies, maxTokenCount) {
  // If maxTokenCount is not provided, calculate it based on the modelMaxTokenWindow configuration
  maxTokenCount = maxTokenCount ?? (config.modelMaxTokenWindow * 4) / 3;

  let characterCounter = new CharacterCounter(maxTokenCount),
    processedCodeBlock = handleCodeBlock(context.document, context.selection, codeBlockResult, new VscodeRange(0, 0, context.document.lineCount, 0), context.language, characterCounter);

  // If the above part of the code block has no content or is complete, return the processed code block without outlines
  if (!(processedCodeBlock.above.hasContent && !processedCodeBlock.above.isComplete))
    return { language: processedCodeBlock.language, above: processedCodeBlock.above, range: processedCodeBlock.range, below: processedCodeBlock.below, outlineAbove: '', outlineBelow: '' };

  let outlineCharacterCounter = new CharacterCounter(maxTokenCount),
    expandedSelectionRange = new VscodeRange(selectionRange.start.line, 0, selectionRange.end.line, context.document.lineAt(selectionRange.end.line).range.end.character),
    expandedProcessedCodeBlock = handleCodeBlock(context.document, context.selection, codeBlockResult, expandedSelectionRange, context.language, outlineCharacterCounter),
    outlineAbove = '',
    outlineBelow = '';

  // If the above and below parts of the expanded code block are complete, generate and split the outlines
  if (expandedProcessedCodeBlock.above.isComplete && expandedProcessedCodeBlock.below.isComplete) {
    let outline = generateOutline({ document: context.document, functionBodies: functionBodies, rangeExpandedToFunctionWholeLines: expandedSelectionRange }),
      splitOutline = splitOutlines(outline, outlineCharacterCounter);
    outlineAbove = splitOutline.outlineAbove;
    outlineBelow = splitOutline.outlineBelow;
  }

  return { language: expandedProcessedCodeBlock.language, above: expandedProcessedCodeBlock.above, range: expandedProcessedCodeBlock.range, below: expandedProcessedCodeBlock.below, outlineAbove: outlineAbove, outlineBelow: outlineBelow };
}

var InlineChatContextResolver = class {
  constructor() {
    this.kind = 'inline-chat-selection'
  }
  async resolveContext(extension, request, next) {
    let documentContext = request.documentContext
    if (!documentContext) return
    let selectionComponent = isNotebookCell(documentContext.document.uri) ? InlineNotebookSelection : InlineChatSelection,
      { messages, metadatas, usedContext } = await renderWithMetadata(extension, request.endpoint, selectionComponent, { documentContext }),
      metadata = metadatas.get(InlineChatSelection.METADATA_ID) || metadatas.get(InlineNotebookSelection.METADATA_ID)
    return { kind: this.kind, userMessages: messages.map(message => message.content), usedContext, metadata }
  }
},
  contextResolverRegistration = ContextResolverRegistry.register(new InlineChatContextResolver())
function handleCodeBlock(document, range, selection, viewport, language, editor) {
  let rangeBlock = new CodeBlock(editor, document, language, 'ed8c6549bwf9'),
    aboveBlock = new CodeBlock(editor, document, language, 'abpxx6d04wxr'),
    belowBlock = new CodeBlock(editor, document, language, 'be15d9bcejpp'),
    createResult = () => {
      aboveBlock.trim();
      rangeBlock.trim(range);
      belowBlock.trim();
      return { language: language, above: aboveBlock, range: rangeBlock, below: belowBlock };
    };

  // Prepend lines from the end of the selection to the start
  for (let lineIndex = selection.end.line; lineIndex >= selection.start.line; lineIndex--) {
    if (!rangeBlock.prependLine(lineIndex)) return createResult();
  }

  let lineIndices = {
    aboveLineIndex: selection.start.line - 1,
    belowLineIndex: selection.end.line + 1,
    minimumLineIndex: Math.max(0, viewport.start.line),
    maximumLineIndex: Math.min(document.lineCount - 1, viewport.end.line),
  };

  appendAndPrependLines(lineIndices, aboveBlock, belowBlock);
  return createResult();
}

function appendAndPrependLines(lineIndices, aboveBlock, belowBlock) {
  let aboveLineIndex = lineIndices.aboveLineIndex,
    canPrepend = true,
    belowLineIndex = lineIndices.belowLineIndex,
    canAppend = true;

  // Try to append and prepend lines until we reach the limits or we've tried 100 times
  for (let attempt = 0; attempt < 100 && (canPrepend || canAppend); attempt++) {
    if (!canPrepend || (canAppend && attempt % 4 === 3)) {
      if (belowLineIndex <= lineIndices.maximumLineIndex && belowBlock.appendLine(belowLineIndex)) {
        belowLineIndex++;
      } else {
        canAppend = false;
      }
    } else if (aboveLineIndex >= lineIndices.minimumLineIndex && aboveBlock.prependLine(aboveLineIndex)) {
      aboveLineIndex--;
    } else {
      canPrepend = false;
    }
  }

  aboveBlock.isComplete = aboveLineIndex < lineIndices.minimumLineIndex;
  belowBlock.isComplete = belowLineIndex > lineIndices.maximumLineIndex;
}
function generateOutline({ document, functionBodies, rangeExpandedToFunctionWholeLines }) {
  let endStatement = '';
  document.languageId === 'typescript' && (endStatement = ';');

  let isInRange = body => {
    let bodyRange = new VscodeRange(document.positionAt(body.startIndex), document.positionAt(body.endIndex));
    return bodyRange.end.line < rangeExpandedToFunctionWholeLines.start.line
      ? rangeExpandedToFunctionWholeLines.start.line - bodyRange.start.line > 50
      : bodyRange.start.line > rangeExpandedToFunctionWholeLines.end.line
      ? bodyRange.end.line - rangeExpandedToFunctionWholeLines.end.line > 50
      : true;
  };

  let bodiesInRange = functionBodies.filter(isInRange);
  let startOffset = document.offsetAt(rangeExpandedToFunctionWholeLines.start);
  let endOffset = document.offsetAt(rangeExpandedToFunctionWholeLines.end);
  let rangeOffsets = { startOffset, endOffset };

  let { outlineAbove, outlineBelow } = createOutlines(document.getText(), bodiesInRange, rangeOffsets, endStatement);

  return { outlineAboveRange: outlineAbove, outlineBelowRange: outlineBelow };
}

function createOutlines(text, bodies, rangeOffsets, endStatement) {
  let currentIndex = 0;
  let outlineAbove = '';
  let endOffset = rangeOffsets.endOffset;
  let outlineBelow = '';

  for (let body of bodies) {
    if (body.endIndex < rangeOffsets.startOffset) {
      outlineAbove += text.substring(currentIndex, body.startIndex);
      outlineAbove += endStatement;
      currentIndex = body.endIndex;
    } else if (body.startIndex > rangeOffsets.endOffset) {
      outlineBelow += text.substring(endOffset, body.startIndex);
      outlineBelow += endStatement;
      endOffset = body.endIndex;
    } else {
      continue;
    }
  }

  outlineAbove += text.substring(currentIndex, rangeOffsets.startOffset);
  outlineBelow += text.substring(endOffset, text.length);

  return { outlineAbove, outlineBelow };
}

function splitOutlines(outline, lineCounter) {
  let lineBreakPattern = /\r\n|\r|\n/g;
  let outlineAboveLines = outline.outlineAboveRange === '' ? [] : outline.outlineAboveRange.split(lineBreakPattern);
  let outlineBelowLines = outline.outlineBelowRange === '' ? [] : outline.outlineBelowRange.split(lineBreakPattern);
  let aboveLines = [];
  let belowLines = [];

  let addAboveLine = line => (lineCounter.lineWouldFit(line) ? (lineCounter.addLine(line), aboveLines.unshift(line), true) : false);
  let addBelowLine = line => (lineCounter.lineWouldFit(line) ? (lineCounter.addLine(line), belowLines.push(line), true) : false);

  let aboveLineIndex = outlineAboveLines.length - 1;
  let canAddAbove = true;
  let belowLineIndex = 0;
  let canAddBelow = true;

  for (let i = 0; i < 100 && (canAddAbove || canAddBelow); i++) {
    if (!canAddAbove || (canAddBelow && i % 4 === 3)) {
      if (belowLineIndex < outlineBelowLines.length && addBelowLine(outlineBelowLines[belowLineIndex])) {
        belowLineIndex++;
      } else {
        canAddBelow = false;
      }
    } else if (aboveLineIndex >= 0 && addAboveLine(outlineAboveLines[aboveLineIndex])) {
      aboveLineIndex--;
    } else {
      canAddAbove = false;
    }
  }

  return {
    outlineAbove: aboveLines.join('\n'),
    outlineBelow: belowLines.join('\n'),
  };
}

function processNotebookCells(notebookService, context, codeBlockResult, characterCounter) {
  // Find the notebook document that matches the context document
  let notebookDocument = notebookService.notebookDocuments.find(
    notebook => notebook.uri.fsPath === context.document.uri.fsPath && notebook.getCells().find(cell => cell.document === context.document)
  );

  // If no matching notebook document is found, return the codeBlockResult with empty outlines and cells
  if (!notebookDocument) return { ...codeBlockResult, outlineAbove: '', outlineBelow: '', aboveCells: [], belowCells: [] };

  let { language, above: aboveBlock, range: rangeBlock, below: belowBlock } = codeBlockResult,
    totalLines = aboveBlock.lines.length + rangeBlock.lines.length + belowBlock.lines.length,
    contextCellIndex = notebookDocument.getCells().findIndex(cell => cell.document === context.document),
    aboveCells = [],
    belowCells = [],
    createResult = () => (
      aboveCells.forEach(cell => cell.trim()),
      belowCells.forEach(cell => cell.trim()),
      { language, above: aboveBlock, range: rangeBlock, below: belowBlock, outlineAbove: '', outlineBelow: '', aboveCells, belowCells }
    ),
    canProcessAbove = true,
    canProcessBelow = true,
    aboveCellIndex = contextCellIndex - 1,
    belowCellIndex = contextCellIndex + 1;

  // Process cells above and below the context cell until we reach the limits or we've processed 100 lines
  for (let lineCount = totalLines; lineCount < 100 && (canProcessAbove || canProcessBelow); lineCount++) {
    if (canProcessAbove) {
      if (aboveCellIndex >= 0) {
        let cellDocument = notebookDocument.cellAt(aboveCellIndex).document,
          cellBlock = new CodeBlock(characterCounter, cellDocument, context.language, 'CELL:' + cellDocument.uri.fragment);
        for (let lineIndex = 0; lineIndex < cellDocument.lineCount; lineIndex++) cellBlock.appendLine(lineIndex);
        aboveCells.unshift(cellBlock);
        aboveCellIndex--;
      } else {
        canProcessAbove = false;
      }
    } else if (belowCellIndex < notebookDocument.cellCount) {
      let cellDocument = notebookDocument.cellAt(belowCellIndex).document,
        cellBlock = new CodeBlock(characterCounter, cellDocument, context.language, 'CELL:' + cellDocument.uri.fragment);
      for (let lineIndex = 0; lineIndex < cellDocument.lineCount; lineIndex++) cellBlock.appendLine(lineIndex);
      belowCells.push(cellBlock);
      belowCellIndex++;
    } else {
      canProcessBelow = false;
    }
  }

  return createResult();
}
var TestFileContextResolver = class {
  constructor() {
    this.kind = 'tests/impl2test'
    this._onDidFindCandidate = new VscodeEventEmitter()
    this.onDidFindCandidate = this._onDidFindCandidate.event
    this.metaContextResolverInfo = { description: 'Information about existing or related files containing tests.' }
    this._decoder = new util.TextDecoder()
  }

  async resolveContext(serviceProvider, request, cancellationToken) {
    let documentContext = request.documentContext
    if (!documentContext || isTestFile(documentContext.document)) return

    let fileSystemOperations = serviceProvider.get(BaseFileSystemOperations)
    let testFileManager = new TestFileManager(serviceProvider.get(FileFinder), serviceProvider.get(BaseTabManager))
    let maxTokenWindow = (request.endpoint.modelMaxTokenWindow * 4) / 3

    let readFileExcerpt = async (filePath, length = maxTokenWindow) => {
      let fileContent = this._decoder.decode(await fileSystemOperations.readFile(filePath)).substring(0, length)
      return `${FilePathComment.forUri(documentContext.language, filePath)}\n${fileContent}`
    }

    let testFile = await testFileManager.findTestFileForSourceFile(documentContext.document, cancellationToken)
    if (testFile) {
      this._onDidFindCandidate.fire(testFile)
      let markdownString = new VscodeMarkdownString()
      markdownString.appendMarkdown(`\nExcerpt of the existing test file:\n`)
      markdownString.appendCodeblock(await readFileExcerpt(testFile), documentContext.document.languageId)
      markdownString.appendMarkdown(`\nBecause a test file exists:\n- Do not generate preambles, like imports, copyright headers etc.\n- Do generate code that can be appended to the existing test file.`)
      return { kind: this.kind, userMessages: [markdownString.value], references: [new Anchor(testFile)] }
    }

    let anyTestFile = await testFileManager.findAnyTestFileForSourceFile(documentContext.document, cancellationToken)
    if (!anyTestFile) return
    let markdownString = new VscodeMarkdownString(`This is sample test file:\n`)
    markdownString.appendCodeblock(await readFileExcerpt(anyTestFile), documentContext.document.languageId)
    return { kind: this.kind, userMessages: [markdownString.value], references: [new Anchor(anyTestFile)] }
  }
}
var TestToImplContextResolver = class {
  constructor() {
    this.kind = 'tests/test2impl'
    this.metaContextResolverInfo = { description: 'Information about existing or related files containing tests.' }
    this._decoder = new util.TextDecoder()
  }

  async resolveContext(serviceProvider, request, cancellationToken) {
    let documentContext = request.documentContext
    if (!documentContext || !isTestFile(documentContext.document)) return

    let fileSystemOperations = serviceProvider.get(BaseFileSystemOperations)
    let testFileManager = new TestFileManager(serviceProvider.get(FileFinder), serviceProvider.get(BaseTabManager))
    let maxTokenWindow = (request.endpoint.modelMaxTokenWindow * 4) / 3

    let createFileExcerpt = (filePath, fileContent, length = maxTokenWindow) => {
      return `${FilePathComment.forUri(documentContext.language, filePath)}\n${fileContent.substring(0, length)}`
    }

    let readFileContent = async filePath => {
      let fileContent = this._decoder.decode(await fileSystemOperations.readFile(filePath))
      return createFileExcerpt(filePath, fileContent)
    }

    let implFile = await testFileManager.findFileForTestFile(documentContext.document, cancellationToken)
    if (!implFile) return

    let markdownString
    try {
      let document = await serviceProvider.get(WorkspaceClass).openTextDocument(implFile)
      let fileContent = document.getText()
      let functionBodies = await getSortedFunctionBodies(serviceProvider, document, 100)
      let { outlineAbove, outlineBelow } = createOutlines(fileContent, functionBodies, { startOffset: fileContent.length, endOffset: fileContent.length }, '')
      let outline = `${outlineAbove}\n${outlineBelow}`

      markdownString = new VscodeMarkdownString(`\nThis is an excerpt of the file that this test is covering:\n`)
      markdownString.appendCodeblock(createFileExcerpt(implFile, outline), documentContext.document.languageId)
    } catch {}

    if (!markdownString) {
      markdownString = new VscodeMarkdownString(`\nThis is an excerpt of the file that this test is covering:\n`)
      markdownString.appendCodeblock(await readFileContent(implFile), documentContext.document.languageId)
    }

    return { kind: this.kind, userMessages: [markdownString.value], references: [new Anchor(implFile)] }
  }
}
var Knt = ContextResolverRegistry.register(new TestFileContextResolver()),
var _Y = ContextResolverRegistry.register(new TestToImplContextResolver())
var path = require('path'),
var ActiveEditorContextResolver = class {
  constructor() {
    this.kind = 'current-editor'
    this.variableInfo = { name: 'editor', description: 'The source code in the active editor', defaultEnablement: false }
    this.metaContextResolverInfo = { description: 'Source code in the active document.' }
  }

  async resolveContext(serviceProvider, request) {
    let activeEditor = serviceProvider.get(BaseTabManager).activeTextEditor
    let visibleRange = activeEditor?.visibleRanges[0]

    if (visibleRange) {
      if (!activeEditor.selection.isEmpty) return

      let cursorLineInfo = ''
      if (activeEditor.selection.isSingleLine) {
        cursorLineInfo = `The cursor is on line: ${activeEditor.selection.start.line}`
      }

      let excerpt = 'Excerpt from active file ' +
        path.basename(activeEditor.document.uri.path) +
        ', lines ' +
        (visibleRange.start.line + 1) +
        ' to ' +
        (visibleRange.end.line + 1) +
        ':\n```' +
        activeEditor.document.languageId +
        '\n' +
        activeEditor.document.getText(visibleRange) +
        '\n```\n\n' +
        cursorLineInfo

      let usedContext = [{ uri: activeEditor.document.uri, version: activeEditor.document.version, ranges: [visibleRange] }]

      return {
        kind: this.kind,
        userMessages: [excerpt],
        usedContext: usedContext,
        references: [new Anchor({ uri: activeEditor.document.uri, range: visibleRange })],
      }
    }
  }
}
var activeEditorContextResolver = ContextResolverRegistry.register(new ActiveEditorContextResolver())
var path = handleDefaultExports(require('path'))
var CurrentSelectionContextResolver = class {
  constructor() {
    this.kind = 'current-selection'
    this.variableInfo = { name: 'selection', description: 'The current selection' }
    this.metaContextResolverInfo = { description: 'Active selection.' }
  }

  async resolveContext(serviceProvider, request) {
    let currentSelection = CurrentSelectionContextResolver.getCurrentSelection(serviceProvider.get(BaseTabManager))
    if (currentSelection) {
      let formattedSelection = CurrentSelectionContextResolver.formatSelection(currentSelection)
      let usedContext = [{ uri: currentSelection.activeDocument.uri, version: currentSelection.activeDocument.version, ranges: [currentSelection.range] }]

      return {
        kind: this.kind,
        userMessages: [
          `Active selection:\n${formattedSelection}`,
        ],
        usedContext: usedContext,
        references: [new Anchor(new VscodeLocation(currentSelection.activeDocument.uri, currentSelection.range))],
      }
    } else {
      return new ActiveEditorContextResolver().resolveContext(serviceProvider, request)
    }
  }

  static formatSelection(selection) {
    return `\n${
      selection.fileName
        ? `From the file: ${path.basename(selection.fileName)}\n`
        : ''
    }\`\`\`${selection.languageId}\n${selection.selectedText}\n\`\`\`\n`
  }

  static getCurrentSelection(tabManager) {
    let activeEditor = tabManager.activeTextEditor
    let activeDocument = activeEditor?.document
    if (activeDocument) {
      let selection = activeEditor.selection
      if (selection && !selection.isEmpty) {
        let languageId = activeDocument.languageId
        let selectedText = activeDocument.getText(selection)
        return { languageId: languageId, selectedText: selectedText, activeDocument: activeDocument, range: selection, fileName: activeDocument.fileName }
      }
    }
  }
},
var currentSelectionContextResolver = ContextResolverRegistry.register(new CurrentSelectionContextResolver())
var CurrentSelectionImplementationsResolver = class {
  constructor() {
    this.kind = 'current-selection-implementations'
    this.metaContextResolverInfo = { description: 'Relevant implementations referenced in active selection.' }
  }

  async resolveContext(serviceProvider, request, thirdParam, fourthParam) {
    let currentSelection = CurrentSelectionContextResolver.getCurrentSelection(serviceProvider.get(BaseTabManager))
    if (!currentSelection) return

    let activeDocument = currentSelection.activeDocument
    let delay = serviceProvider.get(extensionContext).extensionMode === VscodeExtensionMode.Test ? 0 : 200
    let userMessages = []
    let references = []
    let usedContext = []

    for (let { header, findImpls } of [
      { header: 'Relevant function implementations', findImpls: getFunctionReferences },
      { header: 'Relevant class declarations', findImpls: getClassReferences },
      { header: 'Relevant type declarations', findImpls: getSortedTypeReferences },
    ]) {
      let implementations = await findImpls(serviceProvider, activeDocument, currentSelection.range, delay)
      if (!implementations.length) continue

      let { references: implReferences, usedContext: implUsedContext, text: implText } = formatImplementations(activeDocument, implementations)
      let message = `${header}:\n\n${implText.map(text => `\`\`\`${currentSelection.languageId}\n${text}\n\`\`\``).join('\n\n')}\n`

      userMessages.push(message)
      references.push(...implReferences)
      usedContext.push(...implUsedContext)
    }

    return { kind: this.kind, references: references, userMessages: userMessages, usedContext: usedContext }
  }
}

function formatImplementations(document, implementations) {
  let references = []
  let contextMap = new Map()
  let seenSet = new Set()
  let text = []

  for (let impl of implementations) {
    let uri = impl.uri ?? document.uri
    let range = impl.range ?? new VscodeRange(document.positionAt(impl.startIndex), document.positionAt(impl.endIndex))
    let key = `${uri.toString()}-${range.start.line}-${range.start.character}-${range.end.line}-${range.end.character}`

    if (seenSet.has(key)) continue

    seenSet.add(key)
    references.push(new Anchor(new VscodeLocation(uri, range)))
    text.push(impl.text)

    let [version, ranges] = contextMap.get(uri) ?? [impl.version ?? document.version, []]
    ranges.push(range)
    contextMap.set(uri, [version, ranges])
  }

  return {
    references: references,
    usedContext: [...contextMap.entries()].map(([uri, [version, ranges]]) => ({ uri: uri, version: version, ranges: ranges })),
    text: text,
  }
}

var bY = ContextResolverRegistry.register(new CurrentSelectionImplementationsResolver())
var DisposableClass = class extends Disposable {}
var DebugConsoleOutputResolver = class {
  constructor() {
    this.kind = 'debug-console-output'
    this.variableInfo = {
      name: 'debugConsole',
      description: 'The output in the debug console',
      defaultEnablement: false,
    }
    this.metaContextResolverInfo = { description: 'Debug console output.' }
  }

  async resolveContext(serviceProvider) {
    return {
      kind: this.kind,
      userMessages: [
        `Debug console output:\n` + serviceProvider.get(DisposableClass).consoleOutput,
      ],
    }
  }
}
var Sit = ContextResolverRegistry.register(new DebugConsoleOutputResolver())
var DiagnosticWaiter = class {
  waitForNewDiagnostics(uri, cancellationToken, timeout = 5000) {
    let cancellationDisposable, diagnosticChangeDisposable, timeoutId

    return new Promise(resolve => {
      cancellationDisposable = cancellationToken.onCancellationRequested(() => resolve([]))
      timeoutId = setTimeout(() => resolve(this.getDiagnostics(uri)), timeout)
      diagnosticChangeDisposable = this.onDidChangeDiagnostics(diagnosticChangeEvent => {
        for (let changedUri of diagnosticChangeEvent.uris)
          if (arePathsEqual(changedUri, uri)) {
            resolve(this.getDiagnostics(uri))
            break
          }
      })
    }).finally(() => {
      cancellationDisposable.dispose()
      diagnosticChangeDisposable.dispose()
      clearTimeout(timeoutId)
    })
  }
}

function unionRanges(ranges) {
  return ranges.map(range => range.range).reduce((union, range) => union.union(range))
}

function isErrorDiagnostic(diagnostic) {
  return diagnostic.severity === VscodeDiagnosticSeverity.Error
}

var IY = handleDefaultExports(CY())

function wrapCodeWithBackticks(code, content) {
  let matches = content.matchAll(/^\s*(```+)/gm),
    backtickCount = Math.max(3, ...Array.from(matches, match => match[1].length + 1)),
    backticks = '`'.repeat(backtickCount)
  return `${backticks}${code}
${content.trim()}
${backticks}`
}

function extractCodeBlocks(content) {
  if (!content) return []
  let tokens = IY.marked.lexer(content)
  return flattenTokens(tokens).filter(token => token.type === 'code')
}

function flattenTokens(tokens) {
  let flattened = []
  for (let token of tokens) {
    if (token.type === 'list') {
      flattened.push(...flattenTokens(token.items.map(item => item.tokens).flat()))
    }
    flattened.push(token)
  }
  return flattened
}

var maxTokenCount = 15
var FixSelectionResolver = class {
  constructor() {
    this.kind = 'fix-selection'
  }
  async resolveContext(serviceProvider, request, cancellationToken) {
    let documentContext = request.documentContext
    if (!documentContext) return
    if (!isLanguageSupported(documentContext.language.languageId)) return contextResolverRegistration.resolveContext(serviceProvider, request, cancellationToken)
    let diagnostic = await getDiagnosticRange(serviceProvider.get(DiagnosticWaiter), request.message, documentContext.document, documentContext.wholeRange),
      endpoint = request.endpoint,
      contextInfo,
      prompts
      isNotebookCell(documentContext.document.uri)
      ? ((contextInfo = await this.generateFixContextInNotebook(serviceProvider, endpoint, documentContext, diagnostic)),
        (prompts = await this.generateFixContextPromptsForNotebook(serviceProvider, endpoint, documentContext, contextInfo)))
      : (({ contextInfo } = await this.generateFixContext(serviceProvider, endpoint, documentContext, diagnostic)), (prompts = this.generateFixContextPrompts(contextInfo)))
    let document = documentContext.document,
      usedContext = [{ uri: document.uri, version: document.version, ranges: filterTruthyValues([contextInfo.range.toRange(), contextInfo.above.toRange(), contextInfo.below.toRange()]) }]
    return { kind: this.kind, userMessages: prompts, usedContext: usedContext, metadata: { expandedRange: diagnostic.range, contextInfo: contextInfo } }
  }
  async generateFixContext(serviceProvider, endpoint, documentContext, diagnostic) {
    let maxTokenWindow = (endpoint.modelMaxTokenWindow * 4) / 3,
      characterCounter = new CharacterCounter(maxTokenWindow),
      document = documentContext.document,
      language = documentContext.language,
      rangeBlock = new CodeBlock(characterCounter, document, language, 'ed8c6549bwf9'),
      aboveBlock = new CodeBlock(characterCounter, document, language, 'abpxx6d04wxr'),
      belowBlock = new CodeBlock(characterCounter, document, language, 'be15d9bcejpp'),
      createContextInfo = () => (
        aboveBlock.trim(),
        rangeBlock.trim(),
        belowBlock.trim(),
        { contextInfo: { language: language, above: aboveBlock, range: rangeBlock, below: belowBlock, outlineAbove: '', outlineBelow: '' }, tracker: characterCounter }
      )
    if (!expandRangeToInterest(rangeBlock, diagnostic)) return createContextInfo()
    let lineIndices = {
      aboveLineIndex: diagnostic.rangeOfInterest.start.line - 1,
      belowLineIndex: diagnostic.rangeOfInterest.end.line + 1,
      minimumLineIndex: 0,
      maximumLineIndex: document.lineCount - 1,
    }
    return appendAndPrependLines(lineIndices, aboveBlock, belowBlock), createContextInfo()
  }
  generateFixContextPrompts(contextInfo) {
    let prompts = []
    if (contextInfo.above.hasContent) {
      let prompt = []
      prompt.push('I have the following code above the selection:'),
        prompt.push(...contextInfo.above.generatePrompt(!0)),
        prompts.push(
          prompt.join(`
`)
        )
    }
    if (contextInfo.below.hasContent) {
      let prompt = []
      prompt.push('I have the following code below the selection:'),
        prompt.push(...contextInfo.below.generatePrompt(!0)),
        prompts.push(
          prompt.join(`
`)
        )
    }
    if (contextInfo.range.hasContent) {
      let prompt = []
      prompt.push('I have the following code in the selection:'),
        prompt.push(...contextInfo.range.generatePrompt(!0)),
        prompts.push(
          prompt.join(`
`)
        )
    } else prompts.push('There is no code in the selection.')
    return (
      prompts.push(
        [
          `Only change the code inside of the selection, delimited by markers '${contextInfo.range.startMarker}' and '${contextInfo.range.endMarker}'. The code block with the suggested changes should also contain the markers.`,
        ].join(`
`)
      ),
      prompts
    )
  }
  async generateFixContextInNotebook(serviceProvider, endpoint, documentContext, diagnostic) {
    let { contextInfo, tracker } = await this.generateFixContext(serviceProvider, endpoint, documentContext, diagnostic)
    return processNotebookCells(serviceProvider.get(WorkspaceClass), documentContext, contextInfo, tracker)
  }
  async generateFixContextPromptsForNotebook(serviceProvider, endpoint, documentContext, contextInfo) {
    let renderOptions = { ...contextInfo, documentContext: documentContext, includeDelimeters: true },
      { messages: renderedMessages } = await renderWithMetadata(serviceProvider, endpoint, NotebookRenderer, renderOptions)
    return renderedMessages.map(message => message.content)
  }
}
var fixSelectionResolver = ContextResolverRegistry.register(new FixSelectionResolver())

function expandRangeToInterest(textEditor, rangeInfo) {
  let currentRange = rangeInfo.range,
    rangeOfInterest = rangeInfo.rangeOfInterest,
    middleLine = Math.floor((currentRange.start.line + currentRange.end.line) / 2),
    maxDistance = Math.max(middleLine - rangeOfInterest.start.line, rangeOfInterest.end.line - middleLine);

  textEditor.appendLine(middleLine);

  for (let distance = 1; distance <= maxDistance; distance++) {
    let lineAbove = middleLine - distance,
      lineBelow = middleLine + distance;

    if ((lineAbove >= rangeOfInterest.start.line && !textEditor.prependLine(lineAbove)) ||
        (lineBelow <= rangeOfInterest.end.line && !textEditor.appendLine(lineBelow)))
      return false;
  }

  return true;
}

async function getDiagnosticRange(textEditor, filterMessages, document, maxTokenCount) {
  let filteredDiagnostics = await filterDiagnostics(textEditor.getDiagnostics(document.uri), filterMessages, maxTokenCount),
    rangeOfInterest = isLanguageSupported(document.languageId) ?
                      await getRangeOfInterest(filteredDiagnostics, document, maxTokenCount) :
                      filteredDiagnostics.range;

  return { range: filteredDiagnostics.range, rangeOfInterest: rangeOfInterest };
}

async function filterDiagnostics(diagnostics, filterMessages, range) {
  let intersectingDiagnostics = diagnostics.filter(diagnostic => !!diagnostic.range.intersection(range));

  if (filterMessages) {
    let matchingDiagnostics = intersectingDiagnostics.filter(diagnostic => filterMessages.includes(diagnostic.message));
    intersectingDiagnostics = matchingDiagnostics.length > 0 ? matchingDiagnostics : intersectingDiagnostics;
  }

  return { range: intersectingDiagnostics.length > 0 ? unionRanges(intersectingDiagnostics) : range,
           diagnostics: intersectingDiagnostics };
}

async function getRangeOfInterest(diagnostic, document, maxTokenCount) {
  let diagnosticRange = diagnostic.range,
    lines = convertRangeToLines(diagnosticRange),
    maxLines = Math.max(maxTokenCount, diagnosticRange.end.line - diagnosticRange.start.line + maxTokenCount),
    fixSelection = await getFixSelectionOfInterest(document.languageId, document.getText(), lines, maxLines);

  return convertLinesToRange(fixSelection);
}

function convertRangeToLines(range) {
  return {
    startPosition: { row: range.start.line, column: range.start.character },
    endPosition: { row: range.end.line, column: range.end.character },
  };
}

function convertLinesToRange(lines) {
  return new VscodeRange(lines.startPosition.row, lines.startPosition.column, lines.endPosition.row, lines.endPosition.column);
}

var DiagnosticResolver = class {
  constructor() {
    this.kind = 'diagnostics';
    this.metaContextResolverInfo = { description: 'Diagnostics in the active editor.' };
  }
  async resolveContext(serviceProvider, context, unused) {
    let documentContext = context.documentContext;
    if (!documentContext) return;
    let { diagnostics } = await filterDiagnostics(serviceProvider.get(DiagnosticWaiter).getDiagnostics(documentContext.document.uri), context.message, documentContext.wholeRange),
      userMessages = await this.getDiagnosticsContextPrompts(serviceProvider.get(WorkspaceClass), diagnostics, documentContext.document);
    return { kind: this.kind, userMessages: userMessages };
  }
  async getRelatedInfo(serviceProvider, diagnostic) {
    if (diagnostic.relatedInformation) {
      let relatedInfo = [];
      for (let info of diagnostic.relatedInformation)
        try {
          let location = info.location,
            document = await serviceProvider.openTextDocument(location.uri),
            range = location.range,
            isSupported = isLanguageSupported(document.languageId),
            lines = convertRangeToLines(range),
            parentScope = isSupported ? await getCoarseParentScope(document.languageId, document.getText(), lines) : lines,
            text = document.getText(convertLinesToRange(parentScope));
          relatedInfo.push(wrapCodeWithBackticks('', text));
        } catch {}
      return relatedInfo.join('\n');
    }
  }
  async getDiagnosticsContextPrompts(serviceProvider, diagnostics, document) {
    let prompts = [];
    if (diagnostics.length > 0) {
      let source = diagnostics[0].source;
      prompts.push(`The code has the following ${source ? source + ' ' : ''}problems`);
      for (let i = 0; i < diagnostics.length; i++) {
        prompts.push(`Problem ${i + 1}:`);
        let diagnostic = diagnostics[i],
          code = document.getText(new VscodeRange(diagnostic.range.start.line, 0, diagnostic.range.end.line + 1, 0)).trim();
        if (code.length > 0 && code.length < 200) {
          prompts.push('This code', wrapCodeWithBackticks('', code), 'has the problem reported:');
          prompts.push(wrapCodeWithBackticks('', `${diagnostic.message}`));
          let relatedInfo = await this.getRelatedInfo(serviceProvider, diagnostic);
          if (relatedInfo) {
            prompts.push('This diagnostic has some related code:', `${relatedInfo}`);
          }
        }
      }
    }
    return prompts.length > 0 ? [prompts.join('\n')] : [];
  }
  },
  diagnosticResolver = ContextResolverRegistry.register(new DiagnosticResolver())
var EmbeddingsComputer = createServiceIdentifier('IEmbeddingsComputer')
var similarityThreshold = 0.72;

// Search function that returns the most matching embeddings
function searchEmbeddings(queryVector, embeddings, numResults, threshold = similarityThreshold) {
  return embeddings
    .flatMap(embedding => {
      let maxScore = 0;
      for (let vector of queryVector) {
        let score = embedding.embedding.reduce((sum, value, index) => sum + value * vector[index], 0);
        maxScore = Math.max(maxScore, score);
      }
      return { score: maxScore, item: embedding };
    })
    .filter(item => item.score > threshold)
    .sort((a, b) => b.score - a.score)
    .slice(0, numResults)
    .map(item => item.item);
}

// Function that calculates the cosine similarity between two vectors
function cosineSimilarity(vector1, vector2) {
  let dotProduct = vector1.reduce((sum, value, index) => sum + value * vector2[index], 0),
    magnitude1 = Math.sqrt(vector1.reduce((sum, value) => sum + value * value, 0)),
    magnitude2 = Math.sqrt(vector2.reduce((sum, value) => sum + value * value, 0));
  return dotProduct / (magnitude1 * magnitude2);
}

var CacheManager = class {
  constructor(accessor, cacheType, cacheKey, cacheVersion) {
    this.accessor = accessor;
    this.cacheType = cacheType;
    this.cacheKey = cacheKey;
    this.cacheVersion = cacheVersion;
    this.cacheVersionKey = `${cacheKey}-version`;
    this.fileSystem = accessor.get(BaseFileSystemOperations);
  }
  get cacheStorageUri() {
    return this.cacheType === 2 ? this.accessor.get(extensionContext).storageUri : this.accessor.get(extensionContext).globalStorageUri;
  }
  get cacheVersionMementoStorage() {
    return this.cacheType === 2 ? this.accessor.get(extensionContext).workspaceState : this.accessor.get(extensionContext).globalState;
  }
  async updateCache(data) {
    if (!this.cacheStorageUri || !this.fileSystem.isWritableFileSystem(this.cacheStorageUri.scheme)) return;
    try {
      await this.fileSystem.stat(this.cacheStorageUri);
    } catch {
      await this.fileSystem.createDirectory(this.cacheStorageUri);
    }
    await this.cacheVersionMementoStorage.update(this.cacheVersionKey, this.cacheVersion);
    if (this.cacheVersionMementoStorage.get(this.cacheKey)) {
      await this.cacheVersionMementoStorage.update(this.cacheKey, undefined);
    }
    let cacheFilePath = Uri.joinPath(this.cacheStorageUri, `${this.cacheKey}.json`);
    try {
      if (data === undefined) {
        await this.fileSystem.delete(cacheFilePath, { useTrash: false });
      } else {
        await this.fileSystem.writeFile(cacheFilePath, Buffer.from(JSON.stringify(data)));
      }
    } catch {
      if (data !== undefined) {
        console.error(`Failed to write cache to ${cacheFilePath}`);
      }
    }
  }
  async getCache() {
    if (!this.cacheStorageUri || this.cacheVersionMementoStorage.get(this.cacheVersionKey) !== this.cacheVersion) return;
    try {
      let cacheData = await this.fileSystem.readFile(Uri.joinPath(this.cacheStorageUri, `${this.cacheKey}.json`));
      return JSON.parse(cacheData.toString());
    } catch {
      return;
    }
  }
  async clearCache() {
    return this.updateCache(undefined);
  }
}
var RemoteCacheManager = class extends CacheManager {
  constructor(accessor, cacheType, cacheKey, cacheVersion, remotePath) {
    super(accessor, cacheType, cacheKey, cacheVersion);
    this.fetcher = accessor.get(ConnectionSettings);
    this.remoteCacheVersionKey = `${cacheKey}-version-remote`;
    this.remoteCacheURL = RemoteCacheManager.calculateRemoteCDNURL(remotePath, cacheVersion);
    this.remoteCacheLatestUpdateURL = RemoteCacheManager.calculateRemoteCDNLatestURL(remotePath, cacheVersion);
  }
  async fetchRemoteCache() {
    if (this._remoteCache) return this._remoteCache;
    try {
      let response = await this.fetcher.fetch(this.remoteCacheURL, { method: 'GET' });
      if (response.ok) {
        this._remoteCache = await response.json();
        return this._remoteCache;
      }
      console.error(`Failed to fetch remote cache from ${this.remoteCacheURL}`);
    } catch {
      console.error(`Failed to fetch remote cache from ${this.remoteCacheURL}`);
    }
  }
  async fetchRemoteCacheLatest() {
    try {
      let response = await this.fetcher.fetch(this.remoteCacheLatestUpdateURL, { method: 'GET' });
      if (response.ok) return response.text();
      console.error(`Failed to fetch remote cache from ${this.remoteCacheLatestUpdateURL}`);
    } catch {
      console.error(`Failed to fetch remote cache from ${this.remoteCacheLatestUpdateURL}`);
    }
  }
  async getCache() {
    let latestVersion = await this.fetchRemoteCacheLatest();
    let cache = await super.getCache();
    if (cache && latestVersion === this.cacheVersionMementoStorage.get(this.remoteCacheVersionKey)) return cache;
    let remoteCache = await this.fetchRemoteCache();
    await this.cacheVersionMementoStorage.update(this.remoteCacheVersionKey, latestVersion);
    await this.updateCache(remoteCache);
    return remoteCache;
  }
  async updateCache(data, forceUpdate) {
    if (data === undefined) return super.updateCache(data);
    if (!(await super.getCache()) || forceUpdate) return super.updateCache(data);
  }
  static calculateRemoteCDNURL(remotePath, version) {
    return `https://embeddings.vscode-cdn.net/embeddings/v${version}/${remotePath}/core.json`;
  }
  static calculateRemoteCDNLatestURL(remotePath, version) {
    return `https://embeddings.vscode-cdn.net/embeddings/v${version}/${remotePath}/latest.txt`;
  }
}
var ExtensionCacheManager = class extends RemoteCacheManager {
  constructor(accessor, cacheType, cacheKey, cacheVersion, remotePath) {
    super(accessor, cacheType, cacheKey, cacheVersion, remotePath);
    this._wasRemoteExtensionCacheUpdated = false;
    this.baseExtensionCDNURL = ExtensionCacheManager.calculateBaseRemoteExtensionCDNURL(remotePath, cacheVersion);
  }
  constructExposedCache() {
    if (!this._remoteExtensionCache) return;
    let cache = { ...this._remoteExtensionCache.core };
    for (let extension in this._remoteExtensionCache.extensions) {
      let extensionData = this._remoteExtensionCache.extensions[extension];
      for (let key in extensionData) cache[key] = extensionData[key];
    }
    return cache;
  }
  async fetchRemoteExtensionCache(extensionId) {
    let url = `${this.baseExtensionCDNURL}/${extensionId}.json`;
    try {
      let response = await this.fetcher.fetch(url, { method: 'GET' });
      if (response.ok) return await response.json();
      if (response.status === 404) return {};
      console.error(`Failed to fetch remote cache from ${url}`);
    } catch {
      console.error(`Failed to fetch remote cache from ${url}`);
    }
  }
  async getCache() {
    let cache = await super.getCache();
    if (cache === undefined) return;
    let newCache = { core: {}, extensions: {} };
    cache && ExtensionCacheManager.isEmbeddingsCacheEntriesWithExtensions(cache) ? (newCache = cache) : (newCache = { core: cache, extensions: {} });
    let installedExtensions = ExtensionCacheManager.getInstalledExtensionIds(this.accessor);
    let wasUpdated = false;
    for (let extension in newCache.extensions) {
      if (!installedExtensions.includes(extension)) {
        delete newCache.extensions[extension];
        wasUpdated = true;
      }
    }
    let missingExtensions = installedExtensions.filter(extension => !(extension in newCache.extensions) || newCache.extensions[extension] === undefined);
    for (let extension of missingExtensions) {
      let extensionData = await this.fetchRemoteExtensionCache(extension);
      if (extensionData) newCache.extensions[extension] = extensionData;
    }
    this._remoteExtensionCache = newCache;
    this._wasRemoteExtensionCacheUpdated = missingExtensions.length > 0 || wasUpdated;
    return this.constructExposedCache();
  }
  async updateCache(data, forceUpdate) {
    let updatedCache = data
      ? super.updateCache(this._remoteExtensionCache, forceUpdate || this._wasRemoteExtensionCacheUpdated)
      : super.updateCache(data, forceUpdate || this._wasRemoteExtensionCacheUpdated);
    this._wasRemoteExtensionCacheUpdated = false;
    return updatedCache;
  }
  static isEmbeddingsCacheEntriesWithExtensions(cache) {
    return 'core' in cache && 'extensions' in cache;
  }
  static getInstalledExtensionIds(accessor) {
    return accessor
      .get(BaseVSCodeInfoProvider)
      .getAllExtensions()
      .filter(extension => !extension.id.startsWith('vscode'))
      .map(extension => extension.id);
  }
  static calculateBaseRemoteExtensionCDNURL(remotePath, version) {
    return `https://embeddings.vscode-cdn.net/embeddings/v${version}/${remotePath}`;
  }
};
var EmbeddingsManager = class {
  constructor(loggerManager, cacheType, cacheKey, cacheVersion, embeddingsComputer, cacheConfig) {
    this.cacheKey = cacheKey;
    this.embeddingsComputer = embeddingsComputer;
    this._isIndexLoaded = false;
    this._logger = loggerManager.get(LoggerManager).getPromptResponseLogger(loggerManager);
    this._items = new Map();

    if (cacheConfig?.type && !cacheConfig.supportsExtensions) {
      this._embeddingsCache = new RemoteCacheManager(loggerManager, cacheType, cacheKey, cacheVersion, cacheConfig.type);
    } else if (cacheConfig?.type && cacheConfig.supportsExtensions) {
      this._embeddingsCache = new ExtensionCacheManager(loggerManager, cacheType, cacheKey, cacheVersion, cacheConfig.type);
    } else {
      this._embeddingsCache = new CacheManager(loggerManager, cacheType, cacheKey, cacheVersion);
    }
  }

  get isIndexLoaded() {
    return this._isIndexLoaded;
  }

  set isIndexLoaded(value) {
    this._isIndexLoaded = value;
  }

  async rebuildCache() {
    await this._embeddingsCache.clearCache();
    this._items.clear();
    return this.calculateEmbeddings();
  }

  nClosestValues(queryVector, numResults) {
    let items = Array.from(this._items.values()).map(item => {
      if (!item.embedding) return { item: item, similarity: 0 };
      let similarity = cosineSimilarity(queryVector, item.embedding);
      return { item: item, similarity: similarity };
    });

    items = items.filter(item => item.similarity > 0);
    items.sort((a, b) => b.similarity - a.similarity);
    return items.slice(0, numResults).map(item => item.item);
  }

  hasItem(key) {
    return this._items.has(key);
  }

  getItem(key) {
    return this._items.get(key);
  }

  async calculateEmbeddings() {
    if (this._calculationPromise) return this._calculationPromise;

    this._calculationPromise = this._calculateEmbeddings();
    this._calculationPromise.then(() => (this._calculationPromise = undefined));
    return this._calculationPromise;
  }

  async _calculateEmbeddings() {
    let startTime = Date.now();
    let latestItems = await this.getLatestItems();
    let cache = await this._embeddingsCache.getCache();
    let newItems = new Map();

    for (let item of latestItems) {
      let newItem = item;
      let existingItem = this._items.get(item.key);

      if (existingItem?.embedding) {
        newItem = existingItem;
      } else if (cache && cache[item.key]) {
        newItem = { ...item, ...cache[item.key] };
      }

      newItems.set(item.key, newItem);
    }

    this._items = newItems;
    await this._embeddingsCache.updateCache(cache);
    this._logger.debug(`Embeddings for ${this.cacheKey} calculated in ${Date.now() - startTime}ms`);
    this.isIndexLoaded = true;
  }

  async fetchEmbeddingsForItems(items) {
    return this.embeddingsComputer.computeEmbeddings(
      items.map(item => this.getEmbeddingQueryString(item)),
      undefined
    );
  }
};
function getMajorMinorVersion(versionString) {
  let versionParts = versionString.split('.')
  return `${versionParts[0]}.${versionParts[1]}`
}
var APIEmbeddingsManager = class {
  constructor(buildInfo) {
    let version = getMajorMinorVersion(buildInfo.get(BuildInfo).getEditorInfo().version)
    this.embeddingsCache = new RemoteCacheManager(buildInfo, 1, 'api', version, 'api')
  }

  async updateIndex() {
    this.apiChunks = await this.embeddingsCache.getCache()
  }

  nClosestValues(queryVector, numResults, minSimilarity = 0) {
    if (!this.apiChunks) return []
    let items = this.apiChunks.map(chunk => {
      if (!chunk.embedding) return { text: chunk.text, similarity: 0 }
      let similarity = cosineSimilarity(queryVector, chunk.embedding)
      return { text: this.toContextString(chunk), similarity: similarity }
    })

    items = items.filter(item => item.similarity > minSimilarity)
    items.sort((a, b) => b.similarity - a.similarity)
    return items.slice(0, numResults).map(item => item.text)
  }

  toContextString(chunk) {
    if (chunk.type === 'code') {
      return `Snippet from vscode.d.ts:\n${wrapCodeWithBackticks(chunk.lang, chunk.text)}`
    } else if (chunk.type === 'command') {
      return `${chunk.text}`
    } else if (chunk.type === 'documentationCodeBlock') {
      return `Example code from documentation:\n${wrapCodeWithBackticks(chunk.lang, chunk.text)}`
    } else {
      return ''
    }
  }
}
var ExtensionAPIContextResolver = class {
  constructor() {
    this.kind = 'extension-api'
  }

  async resolveContext(serviceProvider, request, cancellationToken) {
    this.embeddingComputer = this.embeddingComputer ?? serviceProvider.get(EmbeddingsComputer)
    let message = request.message

    if (!message || cancellationToken.isCancellationRequested) return

    this.apiEmbeddingsIndex = this.apiEmbeddingsIndex || new APIEmbeddingsManager(serviceProvider)
    await this.apiEmbeddingsIndex.updateIndex()

    let embeddings = await this.embeddingComputer?.computeEmbeddings([message], cancellationToken)

    if (!cancellationToken.isCancellationRequested && embeddings && embeddings.length > 0) {
      let closestValues = this.apiEmbeddingsIndex.nClosestValues(embeddings[0], 5, 0.7)
      if (closestValues.length) {
        let userMessage = [
          'Below are some potentially relevant code samples related to VS Code extension development. You may use information from these samples to help you answer the question if you believe it is relevant:',
          closestValues.join(`\n\n`),
        ].join(`\n`)
        return { kind: this.kind, userMessages: [userMessage] }
      }
    }
  }
}
var extensionAPIContextResolver = ContextResolverRegistry.register(new ExtensionAPIContextResolver())
var ExtensionEmbeddingsManager = class {
  constructor(buildInfo) {
    let version = getMajorMinorVersion(buildInfo.get(BuildInfo).getEditorInfo().version)
    this.embeddingsCache = new RemoteCacheManager(buildInfo, 1, 'extensionEmbeddings', version, 'extensions')
  }

  async updateIndex() {
    this._embeddings = await this.embeddingsCache.getCache()
  }

  nClosestValues(queryVector, numResults, minSimilarity = 0) {
    if (!this._embeddings) return []
    let items = Object.entries(this._embeddings).map(([key, value]) => {
      if (!value.embedding) return { key: `${value.name}(${key})`, similarity: 0 }
      let similarity = cosineSimilarity(queryVector, value.embedding)
      return { key: `${value.name}(${key})`, similarity: similarity }
    })

    items = items.filter(item => item.similarity > minSimilarity)
    items.sort((a, b) => b.similarity - a.similarity)
    return items.slice(0, numResults).map(item => item.key)
  }
}
var extensionInstructions = `
The current question is related to VS Code extensions. The application is currently open.
If an extension is not a valid answer, but it still relates to VS Code, please still respond.
Please do not guess a response and instead just respond with a polite apology if you are unsure.
If you believe the given context given to you is incorrect or not relevant you may ignore it.
At the end of your response, you must include a section wrapped with [COMMANDS START] and [COMMANDS END] that lists all extension IDs you referenced in your response.
The user cannot see the context you are given, so you must not mention it. If you want to refer to it, you must include it in your reply.
`.trimStart()
var ExtensionContextResolver = class {
  constructor() {
    this.kind = 'extensions'
  }

  async resolveContext(serviceProvider, request, cancellationToken) {
    let userMessage = extensionInstructions + `\n`

    this.embeddingComputer = this.embeddingComputer ?? serviceProvider.get(EmbeddingsComputer)
    let message = request.message

    if (!message || cancellationToken.isCancellationRequested) return

    this.extensionsIndex = this.extensionsIndex || new ExtensionEmbeddingsManager(serviceProvider)
    await this.extensionsIndex.updateIndex()

    let embeddings = await this.embeddingComputer?.computeEmbeddings([message], cancellationToken)

    if (!cancellationToken.isCancellationRequested && embeddings && embeddings.length > 0) {
      let closestValues = this.extensionsIndex.nClosestValues(embeddings[0], 5)
      if (closestValues.length) {
        userMessage += `Here are some possible extensions:\n`
        userMessage += closestValues.join(`\n\n`)
        return {
          kind: this.kind,
          userMessages: [
            `Relevant information about extensions for VS Code:\n` + userMessage,
          ],
        }
      }
    }
  }
}

var Lot = ContextResolverRegistry.register(new ExtensionContextResolver())
var path = handleDefaultExports(require('path'))
var BaseGitRepositoryManager = class {}
var GitMetadataContextResolver = class {
  constructor() {
    this.kind = 'git-metadata'
    this.variableInfo = { name: 'git', description: 'Information about the current git repository' }
    this.metaContextResolverInfo = { description: 'Metadata about the current git repository.' }
  }

  async resolveContext(serviceProvider, request, cancellationToken) {
    let workspace = serviceProvider.get(WorkspaceClass)
    let repositories = serviceProvider.get(BaseGitRepositoryManager).repositories
    let workspaceFolders = workspace.getWorkspaceFolders()

    if (!repositories || !workspaceFolders) return

    if (workspaceFolders.length > 1) {
      let documentUri = request.documentContext?.document.uri ?? serviceProvider.get(BaseTabManager).activeTextEditor?.document.uri
      if (documentUri) {
        let workspaceFolder = workspace.getWorkspaceFolder(documentUri)
        if (workspaceFolder) {
          let index = workspaceFolders.findIndex(folder => folder.toString() === workspaceFolder.toString())
          if (index !== -1) {
            repositories = [repositories[index]]
            workspaceFolders = [workspaceFolders[index]]
          }
        }
      }
    }

    let gitMetadata = []
    for (let i = 0; i < repositories.length; i++) {
      if (cancellationToken.isCancellationRequested) return
      let repository = repositories[i]
      let workspaceFolder = workspaceFolders[i]
      if (!repository) continue
      let metadata = []
      metadata.push(`Workspace Folder: ${path.basename(workspaceFolder.path)}`)
      metadata.push('```')
      if (repository.headBranchName) {
        metadata.push(`Current Branch name: ${repository.headBranchName}`)
        metadata.push(`Upstream: ${repository.upstreamBranchName ? repository.upstreamBranchName : 'none'}`)
      } else {
        metadata.push('Detached HEAD?: yes')
      }
      metadata.push(`Is currently rebasing?: ${repository.isRebasing ? 'yes' : 'no'}`)
      metadata.push(`Remotes: ${(repository.remotes ?? []).join(', ')}`)
      metadata.push('```')
      gitMetadata.push(metadata.join(`\n`))
    }

    return {
      kind: this.kind,
      userMessages: [
        `Metadata about the current git repository:\n` + gitMetadata.join(`\n`),
      ],
    }
  }
}
var gitMetadataContextResolver = ContextResolverRegistry.register(new GitMetadataContextResolver())
var BaseTerminalInfoProvider = class extends Disposable {}
var TerminalBufferResolver = class {
  constructor() {
    this.kind = 'terminal-buffer';
    this.variableInfo = { name: 'terminalBuffer', description: "The active terminal's buffer", defaultEnablement: false };
    this.metaContextResolverInfo = { description: "The active terminal's buffer." };
  }
  async resolveContext(serviceProvider) {
    let terminalBuffer = serviceProvider.get(BaseTerminalInfoProvider).terminalBuffer;
    return {
      kind: this.kind,
      userMessages: [
        `The active terminal's buffer:\n` + terminalBuffer,
      ],
    };
  }
};
var terminalBufferResolver = ContextResolverRegistry.register(new TerminalBufferResolver())
var TerminalLastCommandResolver = class {
  constructor() {
    this.kind = 'terminal-last-command';
    this.variableInfo = {
      name: 'terminalLastCommand',
      description: "The active terminal's last run command",
      defaultEnablement: true,
    };
    this.metaContextResolverInfo = { description: "The active terminal's last run command." };
  }
  async resolveContext(serviceProvider) {
    let lastCommand = serviceProvider.get(BaseTerminalInfoProvider).terminalLastCommand;
    if (!lastCommand) return;
    let messages = [];
    if (lastCommand.commandLine) {
      messages.push('The following is the last command run in the terminal:');
      messages.push(lastCommand.commandLine);
    }
    if (lastCommand.cwd) {
      messages.push('It was run in the directory:');
      messages.push(typeof lastCommand.cwd == 'object' ? lastCommand.cwd.toString() : lastCommand.cwd);
    }
    if (lastCommand.output) {
      messages.push('It has the following output:');
      messages.push(lastCommand.output);
    }
    let formattedMessages = messages.join('\n');
    return {
      kind: this.kind,
      userMessages: [
        `The active terminal's last run command:\n` + formattedMessages,
      ],
    };
  }
};
var terminalLastCommandResolver = ContextResolverRegistry.register(new TerminalLastCommandResolver())
var TerminalSelectionResolver = class {
  constructor() {
    this.kind = 'terminal-selection';
    this.variableInfo = {
      name: 'terminalSelection',
      description: "The active terminal's selection",
      defaultEnablement: true,
    };
    this.metaContextResolverInfo = { description: "The active terminal's selection." };
  }
  async resolveContext(serviceProvider) {
    let terminalSelection = serviceProvider.get(BaseTerminalInfoProvider).terminalSelection;
    return {
      kind: this.kind,
      userMessages: [
        `The active terminal's selection:\n` + terminalSelection,
      ],
    };
  }
};
var terminalSelectionResolver = ContextResolverRegistry.register(new TerminalSelectionResolver())
var TerminalShellTypeResolver = class {
  constructor() {
    this.kind = 'terminal-shell-type';
    this.variableInfo = { name: 'terminalShellType' };
  }
  async resolveContext(serviceProvider) {
    let terminalShellType = serviceProvider.get(BaseTerminalInfoProvider).terminalShellType;
    return {
      kind: this.kind,
      userMessages: [
        `The active terminal's shell type:\n` + terminalShellType,
      ],
    };
  }
};
var terminalShellTypeResolver = ContextResolverRegistry.register(new TerminalShellTypeResolver())
var requestLight = handleDefaultExports(requestLight())
var util = handleDefaultExports(require('util'))
var ExperimentationServiceIdentifier = createServiceIdentifier('IExperimentationService'),
  ExperimentationService = class {
    constructor() {
      this.initializePromise = Promise.resolve()
      this.initialFetch = Promise.resolve()
    }
    isFlightEnabled(feature) {
      return false
    }
    isCachedFlightEnabled(feature) {
      return Promise.resolve(false)
    }
    isFlightEnabledAsync(feature) {
      return Promise.resolve(false)
    }
    getTreatmentVariable(feature, variable) {}
    getTreatmentVariableAsync(feature, variable) {
      return Promise.resolve(undefined)
    }
  }
var EnvironmentFlags = class Flags {
  constructor(flags) {
    this.flags = flags
  }
  static fromEnvironment(environment) {
    return new Flags({
      debug: isDebugMode(process.argv, process.env),
      telemetryLogging: isTelemetryLogging(process.env),
      testMode: environment,
      recordInput: isRecordMode(process.argv, process.env),
    })
  }
}
function isTestMode(context) {
  return context.get(EnvironmentFlags).flags.testMode
}
function isDebugMode(args, env) {
  return args.includes('--debug') || isFlagEnabled(env, 'GITHUB_COPILOT_DEBUG')
}
function isTelemetryLogging(env) {
  return isFlagEnabled(env, 'COPILOT_LOG_TELEMETRY')
}
function isRecordMode(args, env) {
  return args.includes('--record') || isFlagEnabled(env, 'GITHUB_COPILOT_RECORD')
}
function isFlagEnabled(env, flag) {
  if (flag in env) {
    let value = env[flag]
    return value === '1' || value?.toLowerCase() === 'true'
  }
  return false
}
async function getProxyUrl(context) {
  let configManager = context.get(ConfigManager),
    testOverrideUrl = configManager.getConfig(settings.DebugTestOverrideProxyUrl)
  return isTestMode(context) && testOverrideUrl.length > 0 ? testOverrideUrl : configManager.getConfig(settings.DebugChatOverrideProxyUrl) ?? configManager.getConfig(settings.DebugOverrideProxyUrl)
}
async function getApiUrl(context, path) {
  let url = await getProxyUrl(context)
  return url.length === 0 ? ((url = 'https://api.githubcopilot.com'), `${url}${path}`) : url
}
async function getChatUrl(context) {
  return getApiUrl(context, '/chat')
}
async function getEmbeddingsUrl(t) {
  return 'https://api.githubcopilot.com/embeddings'
}
async function getChatEndpointInfo(context, type, action, model) {
  let experimentationService = context.get(IExperimentationService),
    modelType
  if (model) modelType = model
  else if (type === 2) (await experimentationService.getTreatmentVariableAsync('vscode', 'copilotchat.panelGpt4', true)) !== false && (modelType = 'gpt-4')
  else if (type === 1 && action === 'fix') {
    let useGpt4InChat = context.get(ConfigManager).getConfig(settings.FixUseGPT4InInlineChat)
    ;((await experimentationService.getTreatmentVariableAsync('vscode', 'copilotchat.fixInlineGpt4', true)) || useGpt4InChat) && (modelType = 'gpt-4')
  }
  return context.get(EndpointManager).getChatEndpointInfo(modelType)
}
async function getDefaultChatEndpointInfo(context) {
  return context.get(EndpointManager).getChatEndpointInfo(undefined)
}
async function getMaxTokenNum(context, model) {
  let tokenHandler = await context.get(BaseTokenHandler).getCopilotToken(context),
    maxTokenNum = tokenHandler.isInternal ? context.get(ConfigManager).getConfig(settings.DebugOverrideChatMaxTokenNum) : 0
  if (maxTokenNum > 0) return maxTokenNum
  let gpt4Context = await context.get(IExperimentationService).getTreatmentVariableAsync('vscode', 'copilotchat.panelGpt4Context', true)
  switch (model) {
    case 'gpt-3.5-turbo':
      return 8192
    case 'gpt-4':
      return gpt4Context || 4096
    default:
      return 8192
  }
}
var EndpointManager = class {
  constructor(accessor) {
    this.accessor = accessor
    this._chatEndpoints = new Map()
  }
  async getChatEndpointInfo(model) {
    let isInternal = (await this.accessor.get(BaseTokenHandler).getCopilotToken(this.accessor)).isInternal
    this._defaultModel ??= isInternal ? this.accessor.get(ConfigManager).getConfig(settings.DebugOverrideChatEngine) : 'gpt-3.5-turbo'
    let selectedModel = model ?? this._defaultModel,
      endpointInfo = this._chatEndpoints.get(selectedModel)
    if (endpointInfo) return endpointInfo
    let chatUrl = await getChatUrl(this.accessor),
      maxTokenNum = await getMaxTokenNum(this.accessor, selectedModel),
      disableSnippy = await this.shouldDisableSnippy()
    return (endpointInfo = new EngineService(chatUrl, 'completions', selectedModel, maxTokenNum, disableSnippy)), this._chatEndpoints.set(selectedModel, endpointInfo), endpointInfo
  }
  async shouldDisableSnippy() {
    let token = await this.accessor.get(BaseTokenHandler).getCopilotToken(this.accessor),
      isDevelopmentMode = this.accessor.get(extensionContext).extensionMode === VscodeExtensionMode.Development
    return token.isInternal && isDevelopmentMode
  }
  async getEmbeddingsEndpointInfo() {
    if (this._embeddingsEndpoint) return this._embeddingsEndpoint
    let disableSnippy = await this.shouldDisableSnippy(),
      embeddingsUrl = await getEmbeddingsUrl(this.accessor)
    return (this._embeddingsEndpoint = new ChatService(embeddingsUrl, 16, disableSnippy)), this._embeddingsEndpoint
  }
}
var EngineService = class {
    constructor(engineUrl, endpoint, model, maxTokens, disableSnippy) {
      this.engineUrl = engineUrl
      this.endpoint = endpoint
      this.disableSnippy = disableSnippy
      this._maxTokens = maxTokens
      this.model = model
    }
    get modelMaxTokenWindow() {
      return this._maxTokens
    }
    get engineName() {
      let lastPartOfUrl = this.engineUrl.split('/').pop()
      return lastPartOfUrl || this.engineUrl
    }
    get url() {
      return util.format('%s/%s', this.engineUrl, this.endpoint)
    }
    interceptBody(body) {
      if (body && this.disableSnippy) {
        body.snippy = { enabled: false }
        Object.keys(body).forEach(key => {
          if (key.startsWith('intent')) delete body[key]
        })
      }
    }
    getExtraHeaders() {
      let headers = {}
      if (this.disableSnippy) {
        headers['Editor-Plugin-Version'] = 'simulation-tests-plugin/2'
        headers['Editor-Version'] = 'simulation-tests-editor/1.85'
      }
      return {
        'Openai-Organization': 'github-copilot',
        'Copilot-Integration-Id': this.disableSnippy ? 'vscode-chat-dev' : 'vscode-chat',
        ...headers,
      }
    }
  }
var ChatService = class {
  constructor(url, maxBatchSize = 1, isDev) {
    this.url = url
    this.maxBatchSize = maxBatchSize
    this.isDev = isDev
    this.modelMaxTokenWindow = 8192
  }
  getExtraHeaders() {
    return {
      'Openai-Organization': 'github-copilot',
      'Copilot-Integration-Id': this.isDev ? 'vscode-chat-dev' : 'vscode-chat',
    }
  }
}
var requestLight = handleDefaultExports(requestLight()),
path = handleDefaultExports(require('path'))
var requestLight = handleDefaultExports(requestLight())
var MissingRepoOrgError = class extends Error {
  constructor() {
    super(...arguments)
    this.name = 'ERROR_TYPE_MISSING_INACCESSIBLE_REPO_ORG'
  }
}
var EmbeddingsUnavailableError = class extends Error {
  constructor() {
    super(...arguments)
    this.name = 'ERROR_TYPE_DOCS_EMBEDDINGS_UNAVAILABLE'
  }
}
var  MaxRetriesExceededError = class extends Error {
  constructor() {
    super(...arguments)
    this.name = 'ERROR_TYPE_MAX_RETRIES_EXCEEDED'
  }
}
var NoAccessToEndpointError = class extends Error {
  constructor() {
    super(...arguments)
    this.name = 'ERROR_TYPE_NO_ACCESS_TO_ENDPOINT'
  }
}
function createError({ error: errorType, message: errorMessage }) {
  switch (errorType) {
    case 'ERROR_TYPE_MISSING_INACCESSIBLE_REPO_ORG':
      return new MissingRepoOrgError(errorMessage)
    case 'ERROR_TYPE_DOCS_EMBEDDINGS_UNAVAILABLE':
      return new EmbeddingsUnavailableError(errorMessage)
    case 'ERROR_TYPE_MAX_RETRIES_EXCEEDED':
      return new MaxRetriesExceededError(errorMessage)
    case 'ERROR_TYPE_NO_ACCESS_TO_ENDPOINT':
      return new NoAccessToEndpointError(errorMessage)
    default:
      return new Error(errorMessage)
  }
}
function generateSearchQuery(queryParams) {
  let queryParts = [`repo:${queryParams.repo}`]
  if (queryParams.lang) queryParts.push(`(lang:${queryParams.lang.join(' OR lang:')})`)
  if (queryParams.notLang) queryParts.push(`NOT (lang:${queryParams.notLang.join(' OR lang:')})`)
  if (queryParams.path) queryParts.push(`(path:${queryParams.path.join(' OR path:')})`)
  if (queryParams.notPath) queryParts.push(`NOT (path:${queryParams.notPath.join(' OR path:')})`)
  return queryParts.join(' ')
}
function parseGithubUrl(url) {
  url = url.replace(/^git@/, '')
  url = url.replace(/\.git$/, '')
  try {
    let parsedUrl = Uri.parse(url)
    if (parsedUrl.authority !== 'github.com' && parsedUrl.scheme !== 'github.com') return
    return parsedUrl.path.replace(/^\//, '')
  } catch {
    return
  }
}
var SearchClient = class {
  constructor(accessor) {
    this.accessor = accessor
    this._logger = this.accessor.get(LoggerManager).getLogger('CodeOrDocsSearchClient')
    this._configurationService = this.accessor.get(ConfigManager)
  }
  async isAvailable() {
    try {
      this._logger.debug('Trying to use API to see if it is available')
      await this.search('the', { repo: 'microsoft/vscode' }, 1, 0.1, void 0)
      return true
    } catch {
      return false
    }
  }
  async search(query, scope, limit = 6, similarity = 0.766, options) {
    let tokenHandler = this.accessor.get(BaseTokenHandler),
      token = (await tokenHandler.getPermissiveGitHubToken({ silent: true })) ?? (await tokenHandler.getBasicGitHubToken()),
      url = `${this._configurationService.getConfig(settings.AgentsEndpointUrl)}/search/${this.slug}`,
      maxRetries = 5,
      retryCount = 0,
      errorMessages = new Set(),
      error
    while (retryCount < maxRetries) {
      try {
        let requestConfig = {
            url: url,
            modelMaxTokenWindow: 0,
            getExtraHeaders() {
              return { Accept: 'application/json', 'Copilot-Integration-Id': 'vscode-chat' }
            },
          },
          response = await sendRequest(
            this.accessor,
            requestConfig,
            token ?? '',
            void 0,
            generateUUID(),
            { query: query, scopingQuery: generateSearchQuery(scope), similarity: similarity, limit: limit },
            options
          ),
          responseText = await response.text()
        if (response.status === 404 || (response.status === 400 && responseText.includes('unknown integration'))) {
          error = createError({ error: 'ERROR_TYPE_NO_ACCESS_TO_ENDPOINT', message: `${this.slug}: ${responseText}` })
          break
        }
        let parsedResponse
        try {
          parsedResponse = JSON.parse(responseText)
        } catch {
          throw new Error(`Status: ${response.status}. Error: ${responseText}`)
        }
        if (!parsedResponse) {
          this._logger.debug(`[repo:${scope.repo}] Got 0 results from ${this.slug} search for query: ${query}`)
          return []
        }
        if (Array.isArray(parsedResponse)) {
          this._logger.debug(`[repo:${scope.repo}] Got ${parsedResponse.length} results from ${this.slug} search for query: ${query}`)
          return parsedResponse
        }
        this._logger.debug(`[repo:${scope.repo}] Error thrown when querying '${query}': ${responseText}`)
        error = createError(parsedResponse)
        break
      } catch (fetchError) {
        retryCount++
        let delay = retryCount * 1000
        errorMessages.add(`Error fetching ${this.slug} search. ${fetchError.message ?? fetchError}`)
        this._logger.warn(
          `[repo:${scope.repo}] Error fetching ${this.slug} search. Retrying in ${retryCount} seconds. Query: ${query}`
        )
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
    if (retryCount >= maxRetries) {
      this._logger.warn(`[repo:${scope.repo}] Max Retry Error thrown while querying '${query}'`)
      error = createError({
        error: 'ERROR_TYPE_MAX_RETRIES_EXCEEDED',
        message: `${this.slug} search timed out after ${maxRetries} retries. ${Array.from(errorMessages).join('\n')}`,
      })
    }
    throw error
  }
},
  CodeSearchClient = class extends SearchClient {
    constructor() {
      super(...arguments)
      this.slug = 'code'
    }
  },
  DocsSearchClient = class extends SearchClient {
    constructor() {
      super(...arguments)
      this.slug = 'docs'
    }
  }
var debounceDelay = 250
function toVscodePosition(position) {
  return new VscodePosition(position.row, position.column)
}
function toVscodeRange(range) {
  return new VscodeRange(toVscodePosition(range.startPosition), toVscodePosition(range.endPosition))
}
function trimTrailingSpaces(text) {
  return text.replace(/\s+$/, '')
}
function truncateText(text, maxLength = 20000) {
  return text.length > maxLength ? text.slice(0, maxLength) : text
}
var TextChunker = class {
  constructor(accessor) {
    this._accessor = accessor
  }
  genericWholeFileChunking({ text, maxTokenLength = debounceDelay, removeEmptyLines = true }) {
    let lines = text.split(/\n/),
      startPos = new VscodePosition(0, 0),
      chunks = [],
      currentLines = [],
      currentTokenCount = 0,
      commonLeadingWhitespace,
      updateCommonLeadingWhitespace = () => {
        let result = this._trimCommonLeadingWhitespace(currentLines)
        commonLeadingWhitespace = result.shortestLeadingCommonWhitespace
        currentLines = result.trimmedLines
      },
      addLine = (line, tokenCount) => {
        currentLines.push(line)
        currentTokenCount += tokenCount
      },
      getTokenCount = () => currentTokenCount,
      createChunk = lineNum => {
        let chunkLines = currentLines.map(
          line =>
            line ||
            `
`
        )
        if (chunkLines.length === 1) chunkLines[0] = chunkLines[0]?.trim()
        else if (chunkLines.length === 0) return
        let endPos = new VscodePosition(lineNum, chunkLines[chunkLines.length - 1].length),
          range = new VscodeRange(startPos, endPos)
        chunks.push({ text: chunkLines.reduce((acc, line) => acc + line, ''), range: range }),
          (currentLines = []),
          (currentTokenCount = 0),
          (startPos = new VscodePosition(endPos.line + 1, 0)),
          (commonLeadingWhitespace = void 0)
      },
      fullRange = new VscodeRange(0, 0, lines.length - 1, lines[lines.length - 1].length)
    this._processLinesIntoChunks(lines, fullRange, maxTokenLength, '', createChunk, updateCommonLeadingWhitespace, addLine, getTokenCount, () => commonLeadingWhitespace, removeEmptyLines)
    if (currentLines) {
      if (commonLeadingWhitespace === void 0) updateCommonLeadingWhitespace()
      createChunk(fullRange.end.line)
    }
    return chunks.filter(chunk => !removeEmptyLines || (chunk.text.length && /[\w\d]{2}/.test(chunk.text)))
  }
  _processLinesIntoChunks(lines, range, maxTokenLength, prefix, createChunk, updateCommonLeadingWhitespace, addLine, getTokenCount, getCommonLeadingWhitespace, removeEmptyLines, isStartOfChunk = () => !1, numTokensInEllipsis = 0) {
    let tokenizer = this._accessor.get(Tokenizer),
      startLine = range.start.line,
      processLine = (line, lineNum) => {
        let remainingTokens = maxTokenLength - (isStartOfChunk() ? numTokensInEllipsis : 0),
          commonLeadingWhitespace = getCommonLeadingWhitespace(),
          trimmedLine = truncateText(line)
        trimmedLine = trimTrailingSpaces(trimmedLine)
        if (commonLeadingWhitespace !== void 0) {
          trimmedLine.startsWith(commonLeadingWhitespace) ? (trimmedLine = prefix + trimmedLine.substring(commonLeadingWhitespace.length)) : createChunk(startLine + lineNum)
        }
        let currentTokenCount = getTokenCount(),
          lineTokenCount = tokenizer.tokenLength(trimmedLine)
        if (currentTokenCount + lineTokenCount > remainingTokens) {
          if (commonLeadingWhitespace === void 0 && updateCommonLeadingWhitespace) {
            updateCommonLeadingWhitespace()
            processLine(trimmedLine, lineNum)
          } else {
            createChunk(startLine + lineNum)
            if (trimmedLine.length) processLine(tokenizer.leadingString(trimmedLine, remainingTokens), lineNum)
          }
        } else if (trimmedLine.length) {
          addLine(
            trimmedLine +
              (lineNum === lines.length - 1
                ? ''
                : `
`),
            lineTokenCount
          )
        }
      },
      remainingLine = ''
    for (let i = 0; i < lines.length; i++) {
      let line = trimTrailingSpaces(lines[i])
      if (line.length === 0 && i !== lines.length - 1) {
        if (!removeEmptyLines) addLine(void 0, 1)
        continue
      }
      processLine(remainingLine + line, i)
      remainingLine = ''
    }
  }
  genericChunking({
    lineRangeText: text,
    maxTokenLength: maxLength = debounceDelay,
    removeEmptyLines: removeEmpty = true,
    extraLineRangeSeparator: extraSeparator = '',
    numTokensInEllipsis: tokensInEllipsis = 0,
  }) {
    let isStartOfChunk = true
    if (maxLength < 0) throw Error('Cannot chunk text, not enough chunk room')
    if (text.length === 0) return []
    let startPos = text[0].range.start,
      chunks = [],
      tokenizer = this._accessor.get(Tokenizer),
      separatorTokenLength = tokenizer.tokenLength(extraSeparator),
      currentLines = [],
      currentTokenCount = 0,
      addLine = (line, tokenCount) => {
        currentLines.push(line), (currentTokenCount += tokenCount)
      },
      getTokenCount = () => currentTokenCount,
      createChunk = lineNum => {
        isStartOfChunk = false
        let chunkLines = currentLines.map(
          line =>
            line ||
            `
`
        )
        if (chunkLines.length === 0) {
          currentLines = [], currentTokenCount = 0
          return
        }
        let endPos = new VscodePosition(lineNum, chunkLines[chunkLines.length - 1].length),
          range = new VscodeRange(startPos, endPos)
        chunks.push({ text: trimTrailingSpaces(chunkLines.reduce((acc, line) => acc + line, '')), range: range }),
          (currentLines = []),
          (currentTokenCount = 0),
          chunkLines[chunkLines.length - 1].endsWith(`
`)
            ? (startPos = new VscodePosition(endPos.line + 1, 0))
            : (startPos = new VscodePosition(endPos.line, chunkLines[chunkLines.length - 1].length))
      }
    for (let i = 0; i < text.length; i++) {
      let lineRange = text[i]
      if (currentTokenCount > 0 && i > 0) {
        let remainingTokens = maxLength - currentTokenCount
        lineRange.text.length > 2e4 || tokenizer.tokenLength(lineRange.text) > remainingTokens ? (addLine(extraSeparator, separatorTokenLength), createChunk(text[i - 1].range.end.line)) : separatorTokenLength > 0 && addLine(extraSeparator, separatorTokenLength)
      }
      this._processLinesIntoChunks(
        lineRange.text.split(/\n/),
        lineRange.range,
        maxLength,
        '',
        createChunk,
        void 0,
        addLine,
        getTokenCount,
        () => {},
        removeEmpty,
        () => isStartOfChunk,
        tokensInEllipsis
      )
    }
    currentLines && createChunk(text[text.length - 1].range.end.line)
    let lastChunk = chunks[chunks.length - 1]
    chunks.pop(),
    this._processLinesIntoChunks(
      lastChunk.text.split(/\n/),
      lastChunk.range,
      maxLength - tokensInEllipsis,
      '',
      createChunk,
      void 0,
      addLine,
      getTokenCount,
      () => {},
      removeEmpty,
      () => isStartOfChunk,
      tokensInEllipsis
    ),
    currentLines && createChunk(text[text.length - 1].range.end.line)
    return chunks.filter(chunk => !removeEmpty || (chunk.text.length && /[^\s]/.test(chunk.text)))
  }
  _trimCommonLeadingWhitespace(lines) {
    let lineInfo = lines.map(line => {
        if (!line) return
        let leadingWhitespaceMatch = line.match(/^\s+/),
          leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[0] : '',
          trimmedLine = line.substring(leadingWhitespace?.length)
        return [leadingWhitespace, trimmedLine]
      }),
      nonEmptyLines = lineInfo.filter(line => !!line),
      commonLeadingWhitespace = this._getCommonLeadingWhitespace(nonEmptyLines) ?? '',
      commonWhitespaceLength = commonLeadingWhitespace.length
    return { trimmedLines: lineInfo.map(line => (line ? line[0].substring(commonWhitespaceLength) + line[1] : void 0)), shortestLeadingCommonWhitespace: commonLeadingWhitespace }
  }
  _getCommonLeadingWhitespace(lines) {
    let commonLeadingWhitespace
    for (let line of lines) {
      if (commonLeadingWhitespace === undefined) {
        commonLeadingWhitespace = line[0]
        continue
      }
      commonLeadingWhitespace = this._commonLeadingStr(commonLeadingWhitespace, line[0])
    }
    return commonLeadingWhitespace ?? ''
  }
  _commonLeadingStr(str1, str2) {
    let shorterStr = str1.length < str2.length ? str1 : str2
    if (shorterStr.length === 0) return ''
    for (let i = 1; i < shorterStr.length; i++)
      if (str1.substring(0, i) !== str2.substring(0, i))
        return shorterStr.substring(0, i - 1)
    return shorterStr
  }
}
var TextParser = class {
  constructor(e, r, n) {
    this._queryTree = e
    this.accessor = r
    this._naiveChunker = new TextChunker(r)
    let i = this.accessor.get(Tokenizer)
    ;(this._inlineComment = n?.blockWrap ?? { start: '', end: '' }),
      (this._elipsisPlaceholder = n?.elipsisPlaceholder ?? '...'),
      (this._lookForIndentInHeader = n?.lookForIndentInHeader ?? !0),
      (this._numTokensInEllipsis = i.tokenLength(this._elipsisPlaceholder) + 1)
  }
  get _summaryPlaceHolder() {
    return this._inlineComment.start + this._elipsisPlaceholder + this._inlineComment.end
  }
  async parse(e, r) {
    let n = await this._queryTree,
      i = this._parseBlocks(n.roots, '', e, r),
      o = i.content.flat(),
      s = i.outline ?? [],
      a = this.createOutlineSummary(
        '',
        '',
        e,
        { text: n.syntaxTreeRoot.text, range: toVscodeRange(n.syntaxTreeRoot) },
        s,
        new VscodeRange(0, 0, n.syntaxTreeRoot.range.endPosition.row, n.syntaxTreeRoot.range.endPosition.column),
        ''
      )
    return a.length === 1 && (a[0] = { ...a[0], isFullFile: !0 }), o.push(...a), o
  }
  _parseBlocks(e, r, n, i) {
    return this._parseSemanticStructure(e, r, n, i, (o, s, a, l) => {
      let c = l + s.text,
        u = () => {
          if (c.trim().length === 0) return { content: { text: [], isFull: !0 } }
          let h
          try {
            h = this._naiveChunker.genericChunking({
              lineRangeText: [{ range: s.range, text: c }],
              maxTokenLength: a,
              numTokensInEllipsis: this._numTokensInEllipsis,
            })
          } catch {
            return { content: { text: [], isFull: !1 }, outline: [] }
          }
          return { content: { text: h, isFull: !0 } }
        }
      if (this.accessor.get(Tokenizer).tokenLength(c) <= a)
        return { content: { text: [{ range: s.range, text: c.replace(/(^\s*\n)|(\n\s*$)/g, '') }], isFull: !0 } }
      if (o.length === 0) return u()
      let d = this._parseBlocks(o, l, a, i),
        f = d.content,
        m = d.outline
      return { content: { text: f, isFull: !1 }, outline: m }
    })
  }
  _parseSemanticStructure(e, r, n, i, o) {
    return { outline: void 0, content: [] }
  }
  _createOutlineBody(e, r, n) {
    let i = (n + e.text).split(`
`),
      o = e.range.start,
      s = [],
      a = o,
      l = d => {
        let f = d.line - o.line,
          m = d.character
        return o.line === d.line && (m = d.character - o.character), new VscodePosition(f, m)
      },
      c = d => {
        let f = d.character === i[d.line - o.line].length - 1
        return { newPosition: new VscodePosition(d.line, d.character + 1), isNewLine: f }
      },
      u = (d, f) => {
        let m = [],
          h = l(d),
          g = l(f),
          v = i[h.line].substring(h.character)
        if (h.line === g.line) {
          let y = v.substring(0, g.character - h.character),
            b = c(f)
          ;(a = b.newPosition),
            b.isNewLine &&
              (y += `
`),
            m.push(y)
        } else {
          let y = i[g.line].substring(0, g.character)
          y = y.replace(new RegExp(`${n}$`), '')
          let b = c(f)
          ;(a = b.newPosition),
            b.isNewLine &&
              (y += `
`),
            m.push(
              v +
                `
`
            )
          for (let x = h.line + 1; x < g.line; x++)
            m.push(
              i[x] +
                `
`
            )
          m.push(y)
        }
        let _ = m.join('')
        s.push({ text: _.replace(/(^\s+\n)/, ''), range: new VscodeRange(d, f) })
      },
      p = d => {
        s.push({
          text:
            d.summary +
            `

`,
          range: d.range,
        })
      }
    return (
      r.sort((d, f) => d.range.start.line - f.range.start.line || d.range.end.line - f.range.end.line),
      r.forEach(d => {
        u(a, d.range.start), p(d), (a = c(d.range.end).newPosition)
      }),
      u(a, e.range.end),
      s
    )
  }
  createOutlineSummary(e, r, n, i, o, s, a) {
    let l = this._createOutlineBody(
        i,
        o.map(u => ({ summary: trimTrailingSpaces(u.summary), range: u.range })),
        a
      ),
      c
    try {
      c = this._naiveChunker.genericChunking({
        lineRangeText: l,
        removeEmptyLines: !1,
        maxTokenLength: n,
        numTokensInEllipsis: this._numTokensInEllipsis,
      })
    } catch {
      return []
    }
    return this._createSummary(e, r, c, s, a)
  }
  _createSummary(e, r, n, i, o) {
    return n.length === 0
      ? []
      : filterTruthyValues(
          n.map((s, a) => {
            let l = e.length === 0 ? '' : `${e}`
            a !== 0 &&
              (l += `${o}${this._elipsisPlaceholder}
`)
            let c = ''
            if (
              (a !== n.length - 1 &&
                (c += `
${o}${this._elipsisPlaceholder}`),
              r.length > 0 && (c += r),
              Array.isArray(s))
            )
              return filterTruthyValues(
                s.map(u => {
                  if (u.text.trim().length !== 0) return { range: u.range, text: l + u.text + c }
                })
              )
            if (s.text.trim().length !== 0)
              return { range: new VscodeRange(a === 0 ? i.start : s.range.start, s.range.end), text: l + s.text + c }
          })
        ).flat()
  }
  findNewIndent(e, r, n) {
    let o = (this._lookForIndentInHeader ? r.text.substring(0, n.startIndex - r.startIndex) : n.text).match(
      new RegExp(`\\n+(\\s*)${e}${this._lookForIndentInHeader ? '$' : ''}`)
    )
    return o && o.length > 1 ? o[1] : ''
  }
}
var SemanticTextParser = class extends TextParser {
  _parseSemanticStructure(nodes, indent, maxTokenCount, maxLineCount, createSummary) {
    let outlines = [],
      parseNode = node => {
        let summaries = [],
          info = node.info,
          mainBlock = info.mainBlock,
          comments = info.detailBlocks.comments,
          body = info.detailBlocks.body,
          innerLineRangeText = this._getInnerLineRangeText({ text: body.text, range: toVscodeRange(body) }),
          bodyStartIndex = body.startIndex - mainBlock.startIndex + innerLineRangeText.prefix.length,
          newIndent = this.findNewIndent(indent, mainBlock, body),
          commentText = ''
        for (let comment of comments)
          commentText +=
            indent +
            comment.text +
            `
`
        let mainText = indent + mainBlock.text.substring(0, bodyStartIndex),
          summaryText = commentText + mainText,
          mainRange = toVscodeRange(mainBlock)
        if (comments.length > 0) {
          mainRange = mainRange.with(toVscodePosition(comments[0].range.startPosition))
        }
        let tokenizer = this.accessor.get(Tokenizer),
          maxTokens = maxLineCount * maxTokenCount,
          trimmedSummaryText = summaryText.replace(
            /(\n*)(\n\s*)$/g,
            `
`
          ),
          tokenCount = tokenizer.tokenLength(trimmedSummaryText)
        if (tokenCount > maxTokens) {
          trimmedSummaryText = mainText;
          tokenCount = tokenizer.tokenLength(mainText);
          if (tokenCount > maxTokens) {
            trimmedSummaryText = '';
            tokenCount = 0;
          }
        }
        let suffix = innerLineRangeText.suffix + mainBlock.text.substring(body.endIndex - mainBlock.startIndex),
          totalTokenCount = tokenizer.tokenLength(
            trimmedSummaryText +
              `
` +
              suffix
          ),
          remainingTokens = maxTokenCount - totalTokenCount,
          summary = createSummary(node.children, innerLineRangeText.body, remainingTokens, indent + newIndent)
        mainRange = new VscodeRange(mainRange.start, toVscodePosition(mainBlock.range.endPosition));
        summaries.push(...this._createSummary(trimmedSummaryText, suffix, summary.content.text, mainRange, indent + newIndent));
        let trimmedCommentText = trimTrailingSpaces(commentText + indent + mainBlock.text.substring(0, body.startIndex - mainBlock.startIndex));
        outlines.push({ summary: trimmedCommentText + ' ' + this._summaryPlaceHolder, range: mainRange });
        if (summary.outline !== void 0) {
          summaries.push(...this.createOutlineSummary(trimmedSummaryText, suffix, remainingTokens, innerLineRangeText.body, summary.outline, mainRange, indent + newIndent));
        }
        return summaries;
      },
      content = nodes.map(node => parseNode(node))
    return { outline: outlines, content: content }
  }
  _getInnerLineRangeText(rangeInfo) {
    let text = rangeInfo.text.replace(/(^\s*\{\s*)|(\s*\}\s*$)/g, ''),
      textStartIndex = rangeInfo.text.indexOf(text),
      prefix = rangeInfo.text.substring(0, textStartIndex),
      suffix = rangeInfo.text.substring(textStartIndex + text.length),
      prefixLineCount = (prefix.match(/\n/g) || []).length,
      prefixLastLineLength = prefix.match(/\n(.*)$/g)?.length ?? 0,
      textLineCount = (text.match(/\n/g) || []).length,
      textLastLineLength = text.match(/\n(.*)$/g)?.length ?? 0,
      start = new VscodePosition(rangeInfo.range.start.line + prefixLineCount, prefixLineCount === 0 ? rangeInfo.range.start.character + prefixLastLineLength : prefixLastLineLength),
      end = new VscodePosition(rangeInfo.range.start.line + textLineCount, textLineCount === 0 ? rangeInfo.range.start.character + textLastLineLength : textLastLineLength),
      trimmedPrefix = prefix.replace(/\{[^\S\r\n]*/g, '{'),
      trimmedSuffix = suffix.replace(/\}[^\S\r\n]*/g, '}')
    return { prefix: trimmedPrefix, body: { text: text, range: new VscodeRange(start, end) }, suffix: trimmedSuffix }
  }
}
var MdTextParser = class {
  constructor(text, accessor) {
    this._text = text;
    this.accessor = accessor;
    this.naiveChunker = new TextChunker(accessor);
  }
  parse(maxTokenLength) {
    let lineRangeText = this._getLineRangeText();
    return this.naiveChunker.genericChunking({
      lineRangeText: lineRangeText,
      maxTokenLength: maxTokenLength,
      extraLineRangeSeparator: `

`,
    });
  }
  _getLineRangeText() {
    let lines = this._text.split(`
`),
      currentLines = [],
      startPosition = new VscodePosition(0, 0),
      lineRanges = [];
    for (let i = 0; i < lines.length; i++)
      if (lines[i].trim().length === 0) {
        if (currentLines.length > 0) {
          lineRanges.push({
            text: currentLines.join(`
`),
            range: new VscodeRange(startPosition, new VscodePosition(i, lines[i].length)),
          });
          currentLines.length = 0;
          startPosition = new VscodePosition(i + 1, 0);
        }
        continue;
      } else currentLines.push(lines[i]);
    if (currentLines.length > 0) {
      lineRanges.push({
        text: currentLines.join(`
`),
        range: new VscodeRange(startPosition, new VscodePosition(lines.length - 1, lines[lines.length - 1].length - 1)),
      });
    }
    return lineRanges;
  }
}

var PythonSemanticTextParser = class extends TextParser {
  _parseSemanticStructure(nodes, indent, maxTokenCount, maxLineCount, createSummary) {
    let outlines = [],
      parseNode = node => {
        let parsedNodes = [],
          nodeInfo = node.info,
          mainBlock = nodeInfo.mainBlock,
          decorator = nodeInfo.detailBlocks.decorator,
          docstring = nodeInfo.detailBlocks.docstring,
          body = nodeInfo.detailBlocks.body,
          endIndex = mainBlock.text.length - 1;
        docstring ? (endIndex = docstring.endIndex - mainBlock.startIndex) : body && (endIndex = body.startIndex - mainBlock.startIndex);
        let newIndent = this.findNewIndent(indent, mainBlock, body),
          decoratorText = decorator
            ? indent +
              decorator.text +
              `
`
            : '',
          mainBlockText = indent + mainBlock.text.substring(0, endIndex),
          combinedText =
            decoratorText +
            mainBlockText +
            `
`,
          range = toVscodeRange(mainBlock);
        decorator && (range = range.with(toVscodePosition(decorator.range.startPosition)));
        let tokenizer = this.accessor.get(Tokenizer),
          maxTokenLength = maxLineCount * maxTokenCount,
          trimmedText = combinedText.replace(
            /\n+\s*$/g,
            `
`
          ),
          trimmedSpaces = trimTrailingSpaces(combinedText),
          tokenLength = tokenizer.tokenLength(trimmedText);
        if (tokenLength > maxTokenLength) {
          trimmedText = indent + combinedText.substring(0, body.startIndex - mainBlock.startIndex);
          tokenLength = tokenizer.tokenLength(trimmedText);
          if (tokenLength > maxTokenLength) {
            trimmedText = '';
            tokenLength = 0;
          }
        }
        range = new VscodeRange(range.start, toVscodePosition(mainBlock.range.endPosition));
        outlines.push({
          summary: docstring
            ? trimmedSpaces +
              `
${newIndent}` +
              this._summaryPlaceHolder
            : trimmedSpaces + ' ' + this._summaryPlaceHolder,
          range: range,
        });
        let bodyInfo = { text: body.text, range: toVscodeRange(body) },
          summary = createSummary(node.children, bodyInfo, maxTokenCount - tokenLength, indent + newIndent),
          mainBlockWithoutBody =
            indent +
            mainBlock.text.substring(0, body.startIndex - mainBlock.startIndex).replace(
              /\n+\s*$/g,
              `
`
            );
        if (summary.content.isFull) {
          trimmedText = mainBlockWithoutBody;
        }
        parsedNodes.push(...this._createSummary(trimmedText, '', summary.content.text, range, indent + newIndent));
        if (summary.outline !== void 0) {
          parsedNodes.push(...this.createOutlineSummary(mainBlockWithoutBody, '', maxTokenCount - tokenLength, bodyInfo, summary.outline, range, indent + newIndent));
        }
        return parsedNodes;
      },
      content = nodes.map(node => parseNode(node));
    return { outline: outlines, content: content };
  }
}

// 定义最大标题长度因子
var maxHeaderLengthFactor = 0.6;

// 获取语言配置的函数
function getConfigurationForLanguage(language) {
  // 如果语言不是Python和Ruby
  if (language !== 'python' && language !== 'ruby') {
    // 返回一个具有特定属性的对象
    return {
      elipsisPlaceholder: '/*...*/',
      blockWrap: { start: '{', end: '}' },
      lookForIndentInHeader: false
    };
  } else {
    // 对于Python和Ruby，返回一个空对象
    return {};
  }
}

var languageParsers = [
  {
    supportedExtensions: ['ts', 'mts', 'cts'],
    parse: (file, config, context) =>
      new SemanticTextParser(getSemanticChunkTreeAsync(file, 'typescript'), context, getConfigurationForLanguage('typescript')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['tsx'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'tsx'), context, getConfigurationForLanguage('tsx')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['js', 'mjs', 'cjs', 'jsx'],
    parse: (file, config, context) =>
      new SemanticTextParser(getSemanticChunkTreeAsync(file, 'javascript'), context, getConfigurationForLanguage('javascript')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['py'],
    parse: (file, config, context) => new PySemanticTextParser(getSemanticChunkTreeAsync(file, 'python'), context, getConfigurationForLanguage('python')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['java'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'java'), context, getConfigurationForLanguage('java')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['cpp', 'cc', 'c++', 'cp', 'cxx', 'cppm', 'hpp', 'h', 'c'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'cpp'), context, getConfigurationForLanguage('cpp')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['cs'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'csharp'), context, getConfigurationForLanguage('csharp')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['go'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'go'), context, getConfigurationForLanguage('go')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['md'],
    parse: (file, config, context) => Promise.resolve(new MdTextParser(file, context).parse(config.maxTokenLength))
  },
  {
    supportedExtensions: ['rb'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'ruby'), context, getConfigurationForLanguage('ruby')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
  {
    supportedExtensions: ['rs'],
    parse: (file, config, context) => new SemanticTextParser(getSemanticChunkTreeAsync(file, 'rust'), context, getConfigurationForLanguage('rust')).parse(config.maxTokenLength, config.maxHeaderLengthFactor),
  },
]

// 根据文件扩展名查找解析器
function findParserByFileExtension(file) {
  // 获取文件扩展名，转换为小写，并移除点
  let extension = getExtension(file).toLowerCase().replace(/\./, '');

  // 在解析器列表中查找是否有支持该扩展名的解析器
  return languageParsers.find(parser => parser.fileExtensions.includes(extension));
}

// 检查是否存在支持给定扩展名的解析器
function hasParserForExtension(extension) {
  // 如果能找到解析器，返回true，否则返回false
  return !!findParserByFileExtension(extension);
}

// 保存获取语义块树的Promise
var semanticChunkTreePromise;

// 获取语义块树的函数
async function getSemanticChunkTreeAsync(param1, param2) {
  // 如果已经有一个获取语义块树的Promise正在进行，那么在该Promise完成后执行
  // 如果没有正在进行的Promise，那么立即开始获取语义块树
  semanticChunkTreePromise = semanticChunkTreePromise?.then(async () => await getSemanticChunkTree(param2, param1)) ?? getSemanticChunkTree(param2, param1);

  // 等待获取语义块树的Promise完成，并返回结果
  return await semanticChunkTreePromise;
}

async function parseText({
  text: inputText,
  accessor: accessor,
  maxTokenLength: maxTokenLength = debounceDelay,
  uri: fileUri,
  maxHeaderLengthFactor: maxHeaderLengthFactor = maxHeaderLengthFactor,
  shouldSemanticChunk: shouldSemanticChunk = false,
}) {
  let chunks = []
  try {
    if (shouldSemanticChunk) {
      let parsedChunks = await findParserByFileExtension(fileUri)?.parse(inputText, { maxTokenLength: maxTokenLength, maxHeaderLengthFactor: maxHeaderLengthFactor }, accessor)
      if (parsedChunks) {
        chunks.push(...parsedChunks.map(chunk => ({ file: fileUri, text: chunk.text, range: chunk.range, isFullFile: chunk.isFullFile })))
      }
    }
  } catch (error) {
    let logger = accessor.get(LoggerManager).getLogger('WorkspaceChunkSearch')
    logger.error('Error parsing semantic chunks for the following file: ' + fileUri.fsPath), logger.error(error), (chunks = [])
  }
  if (!chunks.length) {
    let genericChunks = new TextChunker(accessor).genericWholeFileChunking({ text: inputText, maxTokenLength: maxTokenLength })
    chunks.push(...genericChunks.map(chunk => ({ file: fileUri, text: chunk.text, range: chunk.range, isFullFile: genericChunks.length === 1 })))
  }
  return chunks.filter(chunk => chunk.text)
}

var crypto = require('crypto'),
  WY = handleDefaultExports(zY()),
  util = require('util')

// 定义一个名为BaseUriPattern的类
var BaseUriPattern = class {
  // 构造函数接收两个参数：baseUri和pattern
  constructor(baseUri, pattern) {
    this.baseUri = baseUri;
    this.pattern = pattern;
  }

  // 定义一个名为base的getter方法，该方法抛出一个"Not implemented"的错误
  get base() {
    throw new Error('Not implemented');
  }
}
var ignoredExtensions = new Set([
    'jpg',
    'jpeg',
    'jpe',
    'png',
    'gif',
    'bmp',
    'tif',
    'tiff',
    'tga',
    'ico',
    'webp',
    'svg',
    'eps',
    'heif',
    'heic',
    'pdf',
    'raw',
    'mp4',
    'm4v',
    'mkv',
    'webm',
    'mov',
    'avi',
    'wmv',
    'flv',
    'mp3',
    'wav',
    'm4a',
    'flac',
    'ogg',
    'wma',
    'weba',
    'aac',
    '7z',
    'bz2',
    'gz',
    'gz',
    'rar',
    'tar',
    'xz',
    'zip',
    'vsix',
    'db',
    'bin',
    'dat',
    'hex',
    'map',
    'wasm',
    'pyc',
    'pdb',
    'sym',
    'git',
  ]),
  ignoredFolders = ['node_modules', 'out', 'dist', '.git', '.yarn', '.npm', '.venv', 'foo.asar', '.vscode-test'],
  ignoredFiles = ['.DS_Store', 'Thumbs.db', 'package-lock.json', 'yarn.lock'],
  ignoredSchemes = ['vscode', 'vscode-userdata', 'output', 'inmemory', 'private', 'git']

// 定义一个函数，用于检查给定的URI是否应被忽略
function shouldIgnore(uri, workspace) {
  if (
    ignoredSchemes.includes(uri.scheme) ||
    (workspace && !['file', 'untitled'].includes(uri.scheme) && !workspace.getWorkspaceFolders().some(folder => uri.scheme === folder.scheme))
  )
    return false;
  let extension = getExtension(uri).replace(/\./, '').toLowerCase();
  return !(
    ignoredExtensions.has(extension) ||
    ignoredFiles.includes(getBasename(uri).toLowerCase()) ||
    uri.fsPath
      .toLowerCase()
      .split(/[/\\]/g)
      .some(folder => ignoredFolders.includes(folder))
  );
}

// 定义一个函数，用于在工作区中查找文件
async function findFilesInWorkspace(serviceContainer, maxFiles = 1e5, cancellationToken) {
  let workspace = serviceContainer.get(WorkspaceClass),
    fileFinder = serviceContainer.get(FileFinder),
    ignoreService = serviceContainer.get(IgnoreServiceIdentifier);
  if ((await ignoreService.init(), cancellationToken?.isCancellationRequested)) return [];
  let resourceMap = new ResourceMap();
  for (let workspaceFolder of workspace.getWorkspaceFolders() ?? []) {
    if (resourceMap.size >= maxFiles) break;
    let files = await fileFinder.findFiles(new BaseUriPattern(workspaceFolder, '**/*'), undefined, maxFiles - resourceMap.size);
    if (cancellationToken?.isCancellationRequested) return [];
    for (let file of files) shouldIgnore(file, workspace) && !ignoreService.isIgnored(file) && resourceMap.set(file);
  }
  return resourceMap.keys();
}

var TextChunker1 = class {
  constructor(uri, accessor) {
    this._uri = uri;
    this._accessor = accessor;
    this._isDisposed = false;
    this._disposedCts = new VscodeCancellationTokenSource();
  }
  dispose() {
    this._isDisposed = true;
    this._disposedCts.cancel();
    this._disposedCts.dispose();
  }
  get uri() {
    return this._uri;
  }
  async getHash(cancellationToken) {
    if (this._hash === undefined) {
      let text = await this.getText(cancellationToken);
      if (text !== undefined) {
        this._hash = crypto.createHash('sha256').update(text).digest('hex');
      }
    }
    return this._hash;
  }
  async getBasicChunks(cancellationToken) {
    this._basicChunks ??= this.getText(this._disposedCts.token).then(text =>
      this._isDisposed ? [] : parseText({ text: text, accessor: this._accessor, uri: this._uri, shouldSemanticChunk: false })
    );
    return (await handleCancellation(this._basicChunks, cancellationToken)) ?? [];
  }
  async getSemanticChunks(cancellationToken) {
    if (hasParserForExtension(this.uri)) {
      this._semanticChunks ??= this.getText(this._disposedCts.token).then(text =>
        this._isDisposed ? [] : parseText({ text: text, accessor: this._accessor, uri: this._uri, shouldSemanticChunk: true })
      );
      return (await handleCancellation(this._semanticChunks, cancellationToken)) ?? [];
    } else {
      return this.getBasicChunks(cancellationToken);
    }
  }
  },
  FileSystemTextChunker = class extends TextChunker1 {
    constructor(uri, accessor, fileSystem) {
      super(uri, accessor);
      this._fileSystem = fileSystem;
    }
    async getText(cancellationToken) {
      this._text ??= this._fileSystem.readFile(this.uri).then(
        async fileContent =>
          this._isDisposed || (await WY.isBinaryFile(Buffer.from(fileContent))) || this._isDisposed
            ? ''
            : new util.TextDecoder().decode(fileContent),
        error => ''
      );
      return (await handleCancellation(this._text, cancellationToken)) ?? '';
    }
  },
  DocumentTextChunker = class extends TextChunker1 {
    constructor(textDocument, accessor) {
      super(textDocument.uri, accessor);
      this._textDocument = textDocument;
    }
    async getText(cancellationToken) {
      return this._textDocument.getText();
    }
  },
  FileResourceTracker = class {
    constructor(accessor) {
      this._textDocumentFiles = new ResourceMap();
      this._fsFiles = new ResourceMap();
      this._disposables = [];
      this._listeners = new Set();
      this._accessor = accessor;
      this._fileSystem = accessor.get(BaseFileSystemOperations);
    }
    get size() {
      return this._fsFiles.size;
    }
    dispose() {
      this._disposables.forEach(disposable => disposable.dispose());
      for (let file of this._fsFiles.values()) file.dispose();
      this._fsFiles.clear();
      for (let file of this._textDocumentFiles.values()) file.dispose();
      this._textDocumentFiles.clear();
    }
    get(resource) {
      return this._textDocumentFiles.get(resource) || this._fsFiles.get(resource);
    }
    *entries() {
      let resourceMap = new ResourceMap();
      for (let [key, value] of this._textDocumentFiles.entries()) {
        yield [key, value];
        resourceMap.set(key);
      }
      for (let [key, value] of this._fsFiles.entries()) {
        if (!resourceMap.has(key)) {
          resourceMap.set(key);
          yield [key, value];
        }
      }
    }
    *keys() {
      for (let [key] of this.entries()) yield key;
    }
    *values() {
      for (let [, value] of this.entries()) yield value;
    }
    addListener(listener) {
      return this._listeners.has(listener)
        ? { dispose: () => {} }
        : (this._listeners.add(listener),
          {
            dispose: () => {
              this._listeners.delete(listener);
            },
          });
    }

    registerListeners() {
      let workspace = this._accessor.get(WorkspaceClass),
        fileSystemOperations = this._accessor.get(BaseFileSystemOperations),
        workspaceClass = this._accessor.get(WorkspaceClass),
        handleDocumentChange = document => {
          if (!shouldIgnore(document.uri, workspaceClass)) return;
          let textDocumentFile = this._textDocumentFiles.get(document.uri),
            fsFile = this._fsFiles.get(document.uri);
          if (textDocumentFile) {
            textDocumentFile.dispose();
          }
          this._textDocumentFiles.set(document.uri, new DocumentTextChunker(document, this._accessor));
          if (!textDocumentFile && !fsFile) {
            this._listeners.forEach(listener => listener.onDidCreateFile?.(document.uri));
          } else {
            this._listeners.forEach(listener => listener.onDidChangeFile?.(document.uri));
          }
        };
      this._disposables.push(workspace.onDidOpenTextDocument(handleDocumentChange)),
      this._disposables.push(workspace.onDidChangeTextDocument(event => handleDocumentChange(event.document))),
      this._disposables.push(
        workspace.onDidCloseTextDocument(document => {
          let textDocumentFile = this._textDocumentFiles.get(document.uri);
          if (!textDocumentFile) return;
          this._textDocumentFiles.delete(document.uri),
          textDocumentFile.dispose();
          if (this._fsFiles.get(document.uri)) {
            this._listeners.forEach(listener => listener.onDidChangeFile?.(document.uri));
          } else {
            this._listeners.forEach(listener => listener.onDidDeleteFile?.(document.uri));
          }
        })
      );
      let watcher = fileSystemOperations.createFileSystemWatcher('**/*');
      this._disposables.push(watcher),
      this._disposables.push(
        watcher.onDidChange(uri => {
          if (!shouldIgnore(uri, workspaceClass)) return;
          let exists = this._fsFiles.has(uri);
          this.createOrUpdateFsEntry(uri);
          if (exists) {
            this._listeners.forEach(listener => listener.onDidChangeFile?.(uri));
          } else {
            this._listeners.forEach(listener => listener.onDidCreateFile?.(uri));
          }
        })
      ),
      this._disposables.push(
        watcher.onDidCreate(uri => {
          if (shouldIgnore(uri, workspaceClass) && !this._fsFiles.has(uri)) {
            this.createOrUpdateFsEntry(uri);
            this._listeners.forEach(listener => listener.onDidCreateFile?.(uri));
          }
        })
      ),
      this._disposables.push(
        watcher.onDidDelete(uri => {
          let fsFile = this._fsFiles.get(uri);
          if (fsFile) {
            fsFile.dispose();
            this._fsFiles.delete(uri);
            this._listeners.forEach(listener => listener.onDidDeleteFile?.(uri));
          }
        })
      );
    }
    initialize() {
      return (
        (this._initializedWorkspacePromise ??= (async () => {
          this.registerListeners();
          let workspace = this._accessor.get(WorkspaceClass);
          for (let document of workspace.textDocuments) {
            if (shouldIgnore(document.uri, workspace)) {
              this._textDocumentFiles.set(document.uri, new DocumentTextChunker(document, this._accessor));
            }
          }
          let filesInWorkspace = await findFilesInWorkspace(this._accessor);
          for (let file of filesInWorkspace) {
            this.createOrUpdateFsEntry(file);
          }
        })()),
        this._initializedWorkspacePromise
      );
    }
    createOrUpdateFsEntry(resource) {
      let fsFile = this._fsFiles.get(resource);
      if (fsFile) fsFile.dispose();
      let newFsFile = new FileSystemTextChunker(resource, this._accessor, this._fileSystem);
      this._fsFiles.set(resource, newFsFile);
    }
  }
var SemanticChunker = class {
  constructor(accessor) {
    this._accessor = accessor;
    this.disposables = new Array();
  }
  dispose() {
    while (this.disposables.length) {
      this.disposables.pop()?.dispose();
    }
  }
  _register(resource) {
    this.disposables.push(resource);
    return resource;
  }
  async toSemanticChunks(input, cancellationToken) {
    let fileResourceTracker = this._accessor.get(FileResourceTracker),
      resourceMap = new ResourceMap();
    for (let item of input) {
      let existing = resourceMap.get(item.file);
      existing ? existing.push(item) : resourceMap.set(item.file, [item]);
    }
    let chunks = await Promise.all(
      Array.from(resourceMap, async ([file, items]) => {
        let resource = fileResourceTracker.get(file);
        if (resource && hasParserForExtension(file)) {
          let semanticChunks = await resource.getSemanticChunks(cancellationToken);
          if (cancellationToken.isCancellationRequested) return [];
          let resultSet = new Set();
          for (let item of items) {
            let intersected = false;
            for (let chunk of semanticChunks) {
              if (chunk.range.intersection(item.range)) {
                resultSet.add(chunk);
                intersected = true;
              }
            }
            if (!intersected) resultSet.add(item);
          }
          return Array.from(resultSet);
        } else return items;
      })
    );
    return Array.from(new Set(chunks.flat()));
  }
}
var path = require('path')
var cacheVersion = '1.0.8',
EmbeddingsIndex = class {
  constructor(accessor) {
      this._accessor = accessor;
      this._embeddingsMemoryCache = new Map();
      this.shouldSearchTimeout = true;
      this._embeddingsComputer = accessor.get(EmbeddingsComputer);
      this._workspaceIndex = accessor.get(FileResourceTracker);
      this._embeddingsStorageCache = new CacheManager(accessor, 2, 'workspaceEmbeddingsCache', version);
      this._logger = accessor.get(LoggerManager).getLogger('WorkspaceChunkEmbeddingsIndex');
      this.loadCacheFromStorage();
    }
    static {
      this._MAX_EMBEDDINGS_COMPUTATION_TIME = 10000;
    }
    static {
      this._MAX_CHUNK_LENGTH = 2000;
    }
    get size() {
      return this._workspaceIndex.size;
    }
    workspaceEmbeddingsInitialized() {
      this._initializedWorkspacePromise = this._initializedWorkspacePromise || this._workspaceIndex.initialize();
      return this._initializedWorkspacePromise;
    }
    async triggerIndexing(cancellationToken) {
      let workspaceValues = Array.from(this._workspaceIndex.values()),
        chunks = [];
      for (let value of workspaceValues) {
        let semanticChunks = await value.getSemanticChunks(cancellationToken);
        semanticChunks = semanticChunks.filter(chunk => chunk.text.length < EmbeddingsIndex._MAX_CHUNK_LENGTH);
        chunks.push(...semanticChunks);
      }
      if (cancellationToken.isCancellationRequested) return;
      let embeddings = await this.getEmbeddings(chunks, cancellationToken);
      this._logger.debug(`Indexed ${embeddings.length} chunks`);
    }
    async searchFileChunks(query, numResults, cancellationToken, chunks) {
      if (!chunks) {
        chunks = [];
        let workspaceChunks = (await Promise.all(Array.from(this._workspaceIndex.values(), value => value.getSemanticChunks(cancellationToken)))).flat();
        if (cancellationToken.isCancellationRequested) return [];
        chunks.push(...workspaceChunks);
      }
      chunks = chunks.filter(chunk => chunk.text.length < EmbeddingsIndex._MAX_CHUNK_LENGTH);
      let embeddings = this.shouldSearchTimeout
        ? await timeoutPromise(this.getEmbeddings(chunks, cancellationToken), EmbeddingsIndex._MAX_EMBEDDINGS_COMPUTATION_TIME)
        : await this.getEmbeddings(chunks, cancellationToken);
      if (!embeddings) throw new Error('Timeout computing embeddings');
      return searchEmbeddings(query, embeddings, numResults);
    }
    async loadCacheFromStorage() {
      let cache = await this._embeddingsStorageCache.getCache();
      if (!cache) await this._embeddingsStorageCache.clearCache();
      this._embeddingsMemoryCache.clear();
      for (let [key, value] of Object.entries(cache ?? {})) this._embeddingsMemoryCache.set(key, value);
    }
    async getEmbeddings(chunks, cancellationToken) {
      let toCompute = [];
      for (let chunk of chunks) {
        let embedding = this._embeddingsMemoryCache.get(chunk.text);
        if (embedding) {
          chunk.embedding = embedding;
        } else {
          toCompute.push(chunk);
        }
      }
      if (toCompute.length === 0) return chunks;
      let inputs = toCompute.map(chunk => {
          let workspaceFolder = this._accessor.get(WorkspaceClass).getWorkspaceFolder(chunk.file),
            relativePath = workspaceFolder ? path.relative(workspaceFolder.path, chunk.file.path) : chunk.file.fsPath;
          return formatFileContent(chunk, relativePath);
        }),
        embeddings = await this.computeEmbeddingsWithRetry(inputs, cancellationToken);
      for (let i = 0; i < toCompute.length; i++) {
        let chunk = toCompute[i];
        chunk.embedding = embeddings[i];
        this._embeddingsMemoryCache.set(chunk.text, chunk.embedding);
      }
      return chunks;
    }
    async computeEmbeddingsWithRetry(inputs, cancellationToken) {
      let attempts = 0,
        embeddings;
      while (attempts < 3) {
        try {
          embeddings = await this._embeddingsComputer.computeEmbeddings(inputs, cancellationToken);
          if (!embeddings) throw new Error('Failed to compute embeddings');
          return embeddings;
        } catch (error) {
          attempts++;
          if (attempts === 3) throw error;
          if (cancellationToken.isCancellationRequested) throw new Error('Cancelled computing embeddings');
          this._logger.warn(`Error computing embeddings. Retrying in ${attempts} seconds. Error: ${error}`);
          await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
        }
      }
      throw new Error('Failed to compute embeddings');
    }
  }
function formatFileContent(fileContent, fileName) {
  return `File: \`${fileName}\`
\`\`\`${getExtension(fileContent.file).replace('.', '')}
${fileContent.text}
\`\`\``
}
var CodeSearchChunkSearch = class extends SemanticChunker {
  constructor(serviceAccessor, throwOnCodeSearchError = false) {
    super(serviceAccessor)
    this._throwOnCodeSearchError = throwOnCodeSearchError
    this.id = 'codesearch'
    this._codeSearchClient = serviceAccessor.get(CodeSearchClient)
    this._workspaceChunkIndex = serviceAccessor.get(FileResourceTracker)
    this._embeddingsIndex = serviceAccessor.get(EmbeddingsIndex)
    this._logger = serviceAccessor.get(LoggerManager).getLogger('CodeSearchChunkSearch')
  }

  async searchFileChunks(fileChunks, searchParams, cancellationToken) {
    if (!fileChunks.length || cancellationToken.isCancellationRequested) return []
    if ((await this.initialized(), cancellationToken.isCancellationRequested)) return []
    this._logger.debug('Fetching related workspace chunks in repository...')
    let similarFiles = await this.getSimilarFilesFromCodeSearch(fileChunks)
    return similarFiles ? (this._logger.debug('Remapping chunks to semantic chunks...'), await this.toSemanticChunks(similarFiles, cancellationToken)) : []
  }

  async isAvailable() {
    let codeSearchEnabled = this._accessor.get(ConfigManager).getConfig(settings.WorkspaceCodeSearchEnabled)
    return codeSearchEnabled === false ||
      (codeSearchEnabled === void 0 &&
        (await this._accessor.get(IExperimentationService).getTreatmentVariableAsync('vscode', 'copilotchat.useCodeSearch', true)) !== true)
      ? false
      : (this._isAvailable === void 0 && (this._isAvailable = this._codeSearchClient.isAvailable()), this._isAvailable)
  }

  initialized() {
    return this._embeddingsIndex.workspaceEmbeddingsInitialized()
  }

  async getSimilarFilesFromCodeSearch(fileChunks) {
    let workspaceFolders = this._accessor.get(WorkspaceClass).getWorkspaceFolders(),
      gitRepositories = this._accessor.safeGet(BaseGitRepositoryManager)?.repositories
    if (!workspaceFolders.length || !gitRepositories) return
    let searchPromises = []
    for (let repoIndex = 0; repoIndex < gitRepositories.length; repoIndex++) {
      let gitRepo = gitRepositories[repoIndex]
      if (!gitRepo) continue
      let workspaceFolder = workspaceFolders[repoIndex],
        repoNames = this.getRepoNamesFromContext(gitRepo)
      for (let fileChunk of fileChunks) for (let repoName of repoNames) searchPromises.push(this.doCodeSearch(fileChunk.fullText, workspaceFolder, { repo: repoName }))
    }
    let searchResults = await Promise.allSettled(searchPromises),
      fulfilledResults = new Array()
    for (let result of searchResults)
      if (result.status === 'fulfilled') fulfilledResults.push(...result.value)
      else {
        if (result.reason instanceof MissingRepoOrgError) throw result.reason
        if (this._throwOnCodeSearchError)
          throw (
            (this._logger.exception(result.reason),
            this._accessor.get(IGHTelemetryService).sendExceptionTelemetry(result.reason, 'Error'),
            result.reason)
          )
      }
    return fulfilledResults.sort((a, b) => b.score - a.score)
  }

  async doCodeSearch(searchText, workspaceFolder, searchOptions) {
    return (await this._codeSearchClient.search(searchText, searchOptions))
      .map(searchResult => {
        let workspaceChunk = this._workspaceChunkIndex.get(Uri.joinPath(workspaceFolder, searchResult.path))
        if (workspaceChunk)
          return { file: workspaceChunk.uri, score: searchResult.score, text: searchResult.contents, range: new VscodeRange(searchResult.range.start, 0, searchResult.range.end + 1, 0) }
      })
      .filter(searchResult => !!searchResult)
  }

  getRepoNamesFromContext(gitRepo) {
    return gitRepo.remoteFetchUrls
      ? gitRepo.remoteFetchUrls
          .filter(url => !!url)
          .map(url => parseGithubUrl(url))
          .filter(parsedUrl => !!parsedUrl)
      : []
  }
}
var EmbeddingsCacheChunkSearch = class extends SemanticChunker {
  constructor(serviceAccessor, inTests = false) {
    super(serviceAccessor)
    this._inTests = inTests
    this.id = 'ada'
    this._embeddingsComputer = serviceAccessor.get(EmbeddingsComputer)
    this._embeddingsIndex = serviceAccessor.get(EmbeddingsIndex)
    this._logger = serviceAccessor.get(LoggerManager).getLogger('EmbeddingsCacheChunkSearch')
    inTests && (this._embeddingsIndex.shouldSearchTimeout = false)
  }
  static {
    this.FILE_CAP = 200
  }
  async searchFileChunks(fileChunks, searchParams, cancellationToken) {
    if (!fileChunks.length || cancellationToken.isCancellationRequested) return []
    this._logger.debug('Computing embeddings for query...')
    let embeddings = await this._embeddingsComputer.computeEmbeddings(
      fileChunks.map(chunk => chunk.fullText),
      cancellationToken
    )
    if (!embeddings) {
      if (this._inTests) throw new Error('Failed to compute query embeddings')
      return []
    }
    return cancellationToken.isCancellationRequested
      ? []
      : (await this.initialized(),
        cancellationToken.isCancellationRequested
          ? []
          : (this._logger.debug('Fetching related workspace chunks in repository...'),
            await this._embeddingsIndex.searchFileChunks(embeddings, searchParams, cancellationToken)))
  }
  async isAvailable() {
    return this._isAvailable === undefined && (this._isAvailable = this.doIsAvailable()), this._isAvailable
  }
  async doIsAvailable() {
    await this.initialized()
    if (this._embeddingsIndex.size < EmbeddingsCacheChunkSearch.FILE_CAP) {
      this.triggerIndexing()
    }
    return false
  }
  initialized() {
    return this._embeddingsIndex.workspaceEmbeddingsInitialized()
  }
  triggerIndexing() {
    if (!this._initializedWorkspacePromise) {
      this._initializedWorkspacePromise = this._embeddingsIndex
        .triggerIndexing(CancellationToken.None)
        .then(() => {
          this._isAvailable = Promise.resolve(true)
          this._logger.debug('Workspace Chunk Embeddings Index initialized.')
        })
        .catch(error => {
          this._logger.warn(`Failed to index workspace: ${error}`)
          this._initializedWorkspacePromise = undefined
        })
    }
  }
}
var ConcurrencyModule = handleDefaultExports(ConcurrencyModule()),
var path = handleDefaultExports(require('path'))

function deepMap(object, transformFunc) {
  if (!object) return object
  if (Array.isArray(object)) return object.map(element => deepMap(element, transformFunc))
  if (typeof object == 'object') {
    let transformed = transformFunc(object)
    if (transformed) return transformed
    let newObject = {}
    for (let key in object) newObject[key] = deepMap(object[key], transformFunc)
    return newObject
  }
  return object
}

var tfidfWorkerPath = path.default.join(__dirname, 'tfidfWorker.js'),
  TfidfWorkerClass = class {
    constructor(fileResourceTracker) {
      this.id = 'tfidf'
      this._disposables = []
      this._tfIdfWorker = new Lazy(() => new WorkerProxy(tfidfWorkerPath))
      let handleFileChange = file => {
        let fileIndex = this._workspaceIndex.get(file)
        fileIndex && this.addOrUpdateTfidfEntries([fileIndex])
      }
      ;(this._workspaceIndex = fileResourceTracker.get(FileResourceTracker)),
        this._disposables.push(
          this._workspaceIndex.addListener({
            onDidChangeFile: handleFileChange,
            onDidCreateFile: handleFileChange,
            onDidDeleteFile: file => {
              this._tfIdfWorker.value.proxy.delete(file)
            },
          })
        )
    }
    dispose() {
      this._disposables.forEach(disposable => disposable.dispose()), this._tfIdfWorker.hasValue && this._tfIdfWorker.value.terminate()
    }
    initialized() {
      return (this._initializePromise ??= this._initializeWorkspaceFiles()), this._initializePromise
    }
    async searchFileChunks(fileChunks, searchParams, cancellationToken) {
      if ((await this.initialized(), cancellationToken.isCancellationRequested)) return []
      let searchResults = await this._tfIdfWorker.value.proxy.search(
        fileChunks.map(chunk => chunk.keywords.join(', ')),
        searchParams,
        -1 / 0
      )
      return convertToVscodeObjects(searchResults)
    }
    async isAvailable() {
      return true
    }
    async _initializeWorkspaceFiles() {
      await this._workspaceIndex.initialize(), await this.addOrUpdateTfidfEntries(this._workspaceIndex.values())
    }
    async addOrUpdateTfidfEntries(fileIndices) {
      let concurrencyLimit = (0, ConcurrencyModule.default)(20)
      this._tfIdfWorker.value.proxy.addOrUpdate(
        convertToSerializableObjects(
          await Promise.all(
            Array.from(fileIndices, fileIndex =>
              concurrencyLimit(async () => ({ uri: fileIndex.uri, text: await fileIndex.getText(CancellationToken.None), chunks: await fileIndex.getBasicChunks(CancellationToken.None) }))
            )
          )
        )
      )
    }
  }
function convertToSerializableObjects(object) {
  return deepMap(object, element => {
    if (Uri.isUri(element)) return { $mid: 'uri', ...element }
    if (element instanceof VscodeRange)
      return {
        $mid: 'range',
        start: { line: element.start.line, character: element.start.character },
        end: { line: element.end.line, character: element.end.character },
      }
  })
}
function convertToVscodeObjects(object) {
  return deepMap(object, element => {
    if (element.$mid === 'range') return new VscodeRange(element.start.line, element.start.character, element.end.line, element.end.character)
    if (element.$mid === 'uri') return Uri.revive(element)
  })
}

var TfIdfWithSemanticChunkSearch = class extends SemanticChunker {
  constructor(serviceAccessor) {
    super(serviceAccessor)
    this.id = 'tfidf'
    ;(this._tfidfWorker = this._register(new TfidfWorkerClass(serviceAccessor))),
    (this._logger = serviceAccessor.get(LoggerManager).getLogger('TfIdfWithRerankChunkSearch'))
  }
  async searchFileChunks(fileChunks, searchParams, cancellationToken) {
    this._logger.debug('Performing full workspace search for chunks...')
    let searchResults = await this._tfidfWorker.searchFileChunks(fileChunks, searchParams * 2, cancellationToken)
    if (cancellationToken.isCancellationRequested || !searchResults.length) return []
    this._logger.debug('Remapping chunks to semantic chunks...')
    let semanticChunks = await this.toSemanticChunks(searchResults, cancellationToken)
    return cancellationToken.isCancellationRequested || !semanticChunks.length ? [] : semanticChunks
  }
  isAvailable() {
    return Promise.resolve(true)
  }
}

var WorkspaceChunkSearch = class {
  constructor(serviceAccessor, forcedChunkSearchStrategy) {
    this._accessor = serviceAccessor
    this._forcedChunkSearchStrategy = forcedChunkSearchStrategy
    this._workspaceChunkEmbeddingsIndex = this._accessor.get(EmbeddingsIndex)
    this._embeddingsComputer = this._accessor.get(EmbeddingsComputer)
    this._logger = this._accessor.get(LoggerManager).getLogger('WorkspaceChunkSearch')
    this._inTests = !!this._forcedChunkSearchStrategy
    this._embeddingsCacheChunkSearch = new EmbeddingsCacheChunkSearch(serviceAccessor, this._inTests)
    this._codeSearchChunkSearch = new CodeSearchChunkSearch(serviceAccessor, this._inTests)
    this._tfIdfWithSemanticChunkSearch = new TfIdfWithSemanticChunkSearch(serviceAccessor)
  }
  static {
    this.ADDITIONAL_RESULTS_TIMEOUT = 5000
  }
  dispose() {
    this._embeddingsCacheChunkSearch.dispose()
    this._codeSearchChunkSearch.dispose()
    this._tfIdfWithSemanticChunkSearch.dispose()
  }
  async searchFileChunks(fileChunks, searchParams, cancellationToken) {
    let strategies = await this.getStrategies()
    if (cancellationToken.isCancellationRequested) return []
    let promiseOutcomes = strategies.map(() => new PromiseOutcome())
    for (let index = 0; index < strategies.length; index++) {
      let strategy = strategies[index]
      let promiseOutcome = promiseOutcomes[index]
      strategy.searchFileChunks(fileChunks, searchParams, cancellationToken)
        .then(result => {
          if (!promiseOutcome.isSettled) promiseOutcome.complete(result)
        })
        .catch(error => {
          if (!promiseOutcome.isSettled) promiseOutcome.error(error)
        })
    }
    let promises = promiseOutcomes.map(outcome => outcome.promise)
    try {
      await Promise.any(promises)
    } catch (error) {
      let promiseError = error
      throw promiseError.errors.length === 1 ? promiseError.errors[0] : error
    }
    if (cancellationToken.isCancellationRequested) return []
    let settledPromises = await timeoutPromise(Promise.allSettled(promises), WorkspaceChunkSearch.ADDITIONAL_RESULTS_TIMEOUT)
    if (cancellationToken.isCancellationRequested) return []
    if (!settledPromises) {
      for (let outcome of promiseOutcomes) if (!outcome.isSettled) await outcome.cancel()
      settledPromises = await Promise.allSettled(promises)
    }
    if (cancellationToken.isCancellationRequested) return []
    let results = new Array()
    let successfulStrategyId
    for (let index = 0; index < settledPromises.length; index++) {
      let settledPromise = settledPromises[index]
      let strategy = strategies[index]
      if (settledPromise.status === 'fulfilled') {
        if (!successfulStrategyId) successfulStrategyId = strategy.id
        results.push(...settledPromise.value)
        continue
      }
      if (settledPromise.reason instanceof MissingRepoOrgError && strategy instanceof CodeSearchChunkSearch)
        try {
          if (await this._accessor.get(BaseTokenHandler).getPermissiveGitHubToken({ silent: true })) continue
          if (
            await this._accessor
              .get(BaseTokenHandler)
              .getPermissiveGitHubToken({
                forceNewSession: { detail: requestLight.t('More permissions are required to search private repositories') },
              })
          ) {
            let additionalResults = await strategy.searchFileChunks(fileChunks, searchParams, cancellationToken)
            successfulStrategyId = strategy.id
            results.unshift(...additionalResults)
          }
        } catch {}
    }
    return this.reportTopSuccessfulFlow(successfulStrategyId), this.rerankChunks(fileChunks, results, searchParams, cancellationToken)
  }
  async rerankChunks(chunks, results, limit, cancellationToken) {
    if (!(await this.getShouldUseAda())) return results.slice(0, limit)
    if (cancellationToken.isCancellationRequested) return []
    let embeddings = await this._embeddingsComputer.computeEmbeddings(
      chunks.map(chunk => chunk.fullText),
      cancellationToken
    )
    if (cancellationToken.isCancellationRequested) return []
    if (!embeddings) {
      if (this._inTests) {
        let error = new Error('Failed to compute query embeddings')
        throw (this._logger.exception(error), this._accessor.get(IGHTelemetryService).sendExceptionTelemetry(error, 'Error'), error)
      }
      return this._logger.warn('Failed to compute query embeddings'), results.slice(0, limit)
    }
    try {
      return await this._workspaceChunkEmbeddingsIndex.searchFileChunks(embeddings, limit, cancellationToken, results)
    } catch (error) {
      return this._logger.warn('Failed to search chunk embeddings index: ', error), results.slice(0, limit)
    }
  }
  async getStrategies() {
    let strategies = new Array()
    switch (this._forcedChunkSearchStrategy) {
      case 'codesearch':
        strategies.push(this._codeSearchChunkSearch)
        break
      case 'ada':
        strategies.push(this._embeddingsCacheChunkSearch)
        break
      case 'tfidf':
        strategies.push(this._tfIdfWithSemanticChunkSearch)
        break
      default:
        ;(await this._codeSearchChunkSearch.isAvailable()) && strategies.push(this._codeSearchChunkSearch),
          (await this.getShouldUseAda()) &&
            (await this._embeddingsCacheChunkSearch.isAvailable()) &&
            strategies.push(this._embeddingsCacheChunkSearch),
          strategies.push(this._tfIdfWithSemanticChunkSearch)
        break
    }
    return this._logger.debug(`Using ${strategies.map(strategy => strategy.id).join(', ')} for chunk search`), strategies
  }
  async getShouldUseAda() {
    let useAda = this._accessor.get(ConfigManager).getConfig(settings.WorkspaceUseAdaEnabled)
    return useAda !== void 0
      ? useAda
      : (await this._accessor.get(IExperimentationService).getTreatmentVariableAsync('vscode', 'copilotchat.workspaceUseAda', true)) ?? true
  }
  reportTopSuccessfulFlow(strategyId) {
    this._logger.debug(`'${strategyId}' was the top working workspace chunk search strategy`),
      this._accessor.get(IMSTelemetryService).sendTelemetryEvent('workspaceChunkSearchStrategy', { strategy: strategyId ?? 'none' })
  }
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max)
}
function calculateLength(chunks) {
  return chunks.reduce((total, chunk) => total + chunk.value.length, 0) + Math.max(0, chunks.length - 1)
}
async function formatDirectoryTree(chunks, limit = Infinity, cancellationToken) {
  let formattedChunks = formatChunks(0, chunks, limit),
    remainingSpace = limit - calculateLength(formattedChunks)
  for (;;) {
    let hasMoreChunks = false,
      newChunks = []
    for (let chunk of formattedChunks)
      if (chunk.type === 'text') newChunks.push(chunk)
      else if (chunk.type === 'dir') {
        newChunks.push({ type: 'text', value: chunk.value })
        let children = await chunk.getChildren()
        if (cancellationToken?.isCancellationRequested) return ''
        let childChunks = formatChunks(chunk.level + 1, children, remainingSpace - 1)
        if (childChunks.length) {
          hasMoreChunks = true
          remainingSpace -= calculateLength(childChunks) + 1
          newChunks.push(...childChunks)
        }
      }
    if (((formattedChunks = newChunks), !hasMoreChunks)) break
  }
  return formattedChunks.map(chunk => chunk.value).join('\n')
}
function formatChunks(level, chunks, limit) {
  let indent = '\t'.repeat(level),
    formattedChunks = [],
    remainingSpace = limit
  for (let index = 0; index < chunks.length; ++index) {
    let chunk = chunks[index],
      line = indent + chunk.name + (chunk.type === 2 ? '/' : '')
    if (line.length > remainingSpace) {
      let ellipsis = indent + '...'
      while (ellipsis.length > remainingSpace && formattedChunks.length > 0) remainingSpace += formattedChunks.pop().value.length + 1
      if (ellipsis.length <= remainingSpace) formattedChunks.push({ type: 'text', value: ellipsis })
      break
    }
    chunk.type === 2
      ? formattedChunks.push({ type: 'dir', level: level, value: line, getChildren: chunk.getChildren })
      : formattedChunks.push({ type: 'text', value: line })
    remainingSpace -= line.length
    if (index !== chunks.length - 1) remainingSpace -= 1
  }
  return formattedChunks
}

async function formatDirectoryTree(serviceAccessor, directoryUri, limit, cancellationToken) {
  let fileSystemOperations = serviceAccessor.get(BaseFileSystemOperations),
    ignoreService = serviceAccessor.get(IgnoreServiceIdentifier)
  async function getChildren(directory) {
    let entries
    try {
      entries = await fileSystemOperations.readDirectory(directory)
    } catch (error) {
      console.error(error)
      return []
    }
    if (cancellationToken.isCancellationRequested) return []
    return entries
      .filter(entry => {
        let path = Uri.joinPath(directory, entry[0])
        return shouldIgnore(path) && !ignoreService.isIgnored(path)
      })
      .map(entry =>
        entry[1] === 2 ? { type: 2, name: entry[0], getChildren: () => getChildren(Uri.joinPath(directory, entry[0])) } : { type: 1, name: entry[0] }
      )
  }
  await ignoreService.init()
  if (cancellationToken.isCancellationRequested) return ''
  let chunks = await getChildren(directoryUri)
  return cancellationToken.isCancellationRequested ? '' : formatDirectoryTree(chunks, limit, cancellationToken)
}

var WorkspaceResolver = class {
  constructor() {
    this.kind = 'workspace'
    this.keywordLineRegexp = /^[\*\-]\s*(.+)/m
  }
  async resolveContext(context, request, cancellationToken, progress) {
    let message = request.message
    if (!message) return
    let dataRetriever = context.get(DataRetriever)
    this.logger || (this.logger = context.get(LoggerManager).getLogger('workspaceResolver')),
      this.logger.debug('Collecting workspace structure...'),
      progress.report({ message: requestLight.t('Collecting workspace structure') })
    let workspaceStructure = await getWorkspaceStructure(context, 1e3, cancellationToken)
    if (cancellationToken.isCancellationRequested) return
    this.logger.debug('Asking the model to update the user question and provide queries...'),
      progress.report({ message: requestLight.t('Deciding which workspace information to collect') })
    let modelResponse = await dataRetriever.fetchOne(
      filterTruthyValues([
        ...this.getHistory(request.conversation),
        { role: 'system', content: codingAssistantInstructions },
        workspaceStructure ? { role: 'user', content: workspaceStructure } : void 0,
        { role: 'user', content: message },
      ]),
      async () => {},
      cancellationToken,
      2,
      request.endpoint,
      { temperature: 0.1, top_p: 1, stop: ['dontStopBelieving'] },
      { messageSource: 'workspaceIntent' }
    )
    if (cancellationToken.isCancellationRequested) return
    if (modelResponse.type !== 'success')
      throw new Error(requestLight.t('Encountered an error while deciding what workspace information to collect: {0}', modelResponse.type))
    let parsedResponse = this.parseMetaPromptResponse(message, modelResponse.value)
    return (
      this.logger.debug('Running all tools...'),
      progress.report({ message: requestLight.t('Collecting workspace info') }),
      this.runTools(context, parsedResponse, cancellationToken)
    )
  }
  getHistory(conversation) {
    return conversation
      ? conversation.turns
          .slice(0, -1)
          .flatMap(turn =>
            turn.request.type === 'user'
              ? filterTruthyValues([
                  { role: 'user', content: turn.request.message },
                  turn.response ? { role: 'assistant', content: turn.response.message } : void 0,
                ])
              : []
          )
      : []
  }
  parseMetaPromptResponse(message, response) {
    let lines = response.trim().split(`
`),
      keywordLinesCount = 0,
      keywords = []
    for (let line of Array.from(lines).reverse()) {
      let match = line.match(this.keywordLineRegexp)
      if (match) {
        let keywordVariations = match[1].split(/,/g).map(keyword => keyword.trim())
        keywordVariations.length && keywords.unshift({ keyword: keywordVariations[0], variations: keywordVariations.slice(1) })
      } else if (keywords.length) break
      keywordLinesCount++
    }
    return {
      rephrasedQuestion:
        lines
          .slice(0, -keywordLinesCount)
          .join(
            `
`
          )
          .trim() || message.trim(),
      keywords: keywords,
    }
  }
  async runTools(context, parsedResponse, cancellationToken) {
    let request = { kind: this.kind, fullQuestionText: parsedResponse.rephrasedQuestion, keywords: parsedResponse.keywords }
    return (
      await Promise.all([
        getWorkspaceStructure(context, 500, cancellationToken).then(workspaceStructure => (workspaceStructure ? { kind: this.kind, userMessages: [workspaceStructure] } : void 0)),
        ...registeredResolvers.map(resolvers => resolvers.resolve(context, request, cancellationToken)),
      ])
    ).reduce(
      (result, toolResult) => ({
        kind: this.kind,
        userMessages: [...result.userMessages, ...(toolResult?.userMessages ?? [])],
        references: [...(result.references ?? []), ...(toolResult?.references ?? [])],
        usedContext: [...(result.usedContext ?? []), ...(toolResult?.usedContext ?? [])],
      }),
      { kind: this.kind, userMessages: [] }
    )
  }
}

async function getWorkspaceStructure(context, timeout = 500, cancellationToken) {
  let workspaceFolder = context.get(WorkspaceClass).getWorkspaceFolders().at(0)
  if (!workspaceFolder) return
  let directoryTree = await formatDirectoryTree(context, workspaceFolder, timeout, cancellationToken)
  return joinLines('I am working in a workspace that has the following structure:', '', wrapCodeWithBackticks('', directoryTree))
}

var codingAssistantInstructions = `
You are a coding assistant who help the user answer questions about code in their workspace by providing a list of relevant keywords they can search for to answer the question.
The user will provide you with potentially relevant information from the workspace. This information may be incomplete.
DO NOT ask the user for additional information or clarification.
DO NOT try to answer the user's question directly.

# Additional Rules

Think step by step:
1. Read the user's question to understand what they are asking about their workspace.

2. If there are pronouns in the question, such as 'it', 'that', 'this', try to understand what they refer to by looking at the rest of the question and the conversation history.

3. Output a precise version of question that resolves all pronouns to the nouns they stand for. Be sure to preserve the exact meaning of the question by only changing ambiguous pronouns.

4. Then output a short markdown list of up to 8 relevant keywords that user could try searching for to answer their question. These keywords could used as file name, symbol names, abbreviations, or comments in the relevant code. Put the keywords most relevant to the question first. Do not include overly generic keywords. Do not repeat keywords.

5. For each keyword in the markdown list of related keywords, if applicable add a comma separated list of variations after it. For example: for 'encode' possible variations include 'encoding', 'encoded', 'encoder', 'encoders'. Consider synonyms and plural forms. Do not repeat variations.

# Examples

User: Where's the code for base64 encoding?

Response:

Where's the code for base64 encoding?

- base64 encoding, base64 encoder, base64 encode
- base64, base 64
- encode, encoded, encoder, encoders
`.trim()
var SymbolResolver = new (class {
  constructor() {
    this.timeout = 15000
  }
  async resolve(accessor, query, cancellationToken) {
    let workspace = accessor.get(WorkspaceClass),
      tokenWindow = await calculateTokenWindow(accessor, { valueFor4096: 8, maxMultiplier: 4 })
    if (cancellationToken.isCancellationRequested) return
    let symbols = await this.getSymbols(accessor, query)
    if (!(symbols.length === 0 || cancellationToken.isCancellationRequested))
      return {
        kind: query.kind,
        userMessages: [
          joinLines(
            'Here are some potentially relevant symbols from the current workspace:',
            '',
            ...uniqueValues(symbols.map(symbol => `- ${symbol.name} \u2014 ${getRelativePath(workspace, symbol.location.uri)}`)).slice(0, tokenWindow)
          ),
        ],
      }
  }
  async getSymbols(accessor, query) {
    let ignoreService = accessor.get(IgnoreServiceIdentifier),
      foundSymbols = await Promise.all(
        query.keywords
          .flatMap(keyword => [keyword.keyword, ...keyword.variations])
          .map(keyword => timeoutPromise(accessor.get(BaseSymbolProvider).getWorkspaceSymbols(keyword), this.timeout))
      )
    return filterTruthyValues(foundSymbols.flat()).filter(symbol => !ignoreService.isIgnored(symbol.location.uri))
  }
})(),
  FileResolver = new (class {
    constructor() {
      this.timeout = 15000
    }
    async resolve(accessor, query, cancellationToken) {
      let workspace = accessor.get(WorkspaceClass),
        tokenWindow = await calculateTokenWindow(accessor, { valueFor4096: 8, maxMultiplier: 4 })
      if (cancellationToken.isCancellationRequested) return
      let foundFiles = await this.findFiles(accessor, query, tokenWindow, cancellationToken)
      if (!(foundFiles.length === 0 || cancellationToken.isCancellationRequested))
        return {
          kind: query.kind,
          userMessages: [
            joinLines(
              'Here are some potentially relevant file names from the workspace:',
              '',
              ...uniqueValues(foundFiles.map(file => `- ${getRelativePath(workspace, file)}`)).slice(0, tokenWindow)
            ),
          ],
        }
    }
    async findFiles(accessor, query, maxResults, cancellationToken) {
      let ignoreService = accessor.get(IgnoreServiceIdentifier),
        fileFinder = accessor.get(FileFinder),
        foundFiles = await Promise.all(
          query.keywords
            .flatMap(keyword => [keyword.keyword, ...keyword.variations])
            .map(keyword => timeoutPromise(Promise.resolve(fileFinder.findFiles(`**/*${keyword}*`, '**/node_modules/**', maxResults, cancellationToken)), this.timeout))
        )
      return filterTruthyValues(foundFiles.flat()).filter(file => !ignoreService.isIgnored(file))
    }
  })(),
  CodeExcerptResolver = new (class {
    async resolve(accessor, query, cancellationToken) {
      let workspace = accessor.get(WorkspaceClass),
        chunkSearch = accessor.get(WorkspaceChunkSearch),
        tokenWindow = await calculateTokenWindow(accessor, { valueFor4096: 8, maxMultiplier: 4 })
      if (cancellationToken.isCancellationRequested) return
      let searchCriteria = { fullText: query.fullQuestionText, keywords: query.keywords.flatMap(keyword => [keyword.keyword, ...keyword.variations]) },
        foundChunks = (await chunkSearch.searchFileChunks([searchCriteria], tokenWindow, cancellationToken)).slice(0, tokenWindow)
      if (cancellationToken.isCancellationRequested || !foundChunks.length) return
      let anchors = foundChunks
        .sort(
          (chunk1, chunk2) =>
            chunk1.file.fsPath.localeCompare(chunk2.file.fsPath) ||
            chunk1.range.start.compareTo(chunk2.range.start) ||
            chunk1.range.end.compareTo(chunk2.range.end)
        )
        .filter((chunk, index) => {
          for (let [otherIndex, otherChunk] of foundChunks.entries())
            if (
              index !== otherIndex &&
              chunk.file.fsPath === otherChunk.file.fsPath &&
              (otherChunk.isFullFile || chunk.range === otherChunk.range || otherChunk.range.contains(chunk.range))
            )
              return false
          return true
        })
        .map(chunk => new Anchor(chunk.isFullFile ? chunk.file : new VscodeLocation(chunk.file, chunk.range)))
      return {
        kind: query.kind,
        userMessages: [
          joinLines(
            'Here are some potentially relevant code excerpts from the workspace:',
            '',
            foundChunks.map(chunk => {
              let relativePath = getRelativePath(workspace, chunk.file)
              return joinLines(`\`${relativePath}\``, wrapCodeWithBackticks(getExtension(chunk.file).replace(/\./g, ''), chunk.text))
            }).join(`

`)
          ),
        ],
        references: anchors,
      }
    }
  })(),
  registeredResolvers = [SymbolResolver, FileResolver, CodeExcerptResolver]

function getRelativePath(workspace, file) {
  let folder = workspace.getWorkspaceFolder(file)
  return folder ? path.relative(folder.path, file.path) : file.fsPath
}

function uniqueValues(array) {
  return [...new Set(array)]
}

function joinLines(...lines) {
  return lines.join(`
`)
}

async function calculateTokenWindow(serviceAccessor, tokenConfig) {
  let maxTokenWindow = (await serviceAccessor.get(EndpointManager).getChatEndpointInfo()).modelMaxTokenWindow / 4096
  return clamp(Math.round(tokenConfig.valueFor4096 * maxTokenWindow), tokenConfig.valueFor4096, tokenConfig.valueFor4096 * tokenConfig.maxMultiplier)
}

var workspaceResolver = ContextResolverRegistry.register(new WorkspaceResolver())

var TerminalWorkspaceResolver = class {
  constructor() {
    this.kind = 'terminal-workspace'
  }
  async resolveContext(context, request, cancellationToken, progress) {
    let message = request.message
    if (!message) return
    let dataRetriever = context.get(DataRetriever)
    this.logger || (this.logger = context.get(LoggerManager).getLogger('workspaceResolver')),
      this.logger.debug('Determining whether workspace info is needed...'),
      progress.report({ message: requestLight.t('Determining whether to fetch info on the workspace') })
    let modelResponse = await dataRetriever.fetchOne(
      filterTruthyValues([
        { role: 'system', content: workspaceKnowledgeRules },
        { role: 'user', content: message },
      ]),
      async () => {},
      cancellationToken,
      2,
      await getDefaultChatEndpointInfo(context),
      { temperature: 0.1, top_p: 1, stop: ['dontStopBelieving'] },
      { messageSource: 'workspaceIntent' }
    )
    if (!cancellationToken.isCancellationRequested) {
      if (modelResponse.type !== 'success')
        throw new Error(
          requestLight.t('Encountered an error while deciding what workspace information to collect: {0}', modelResponse.type)
        )
      return modelResponse.value.trim() !== '0' ? workspaceResolver.resolveContext(context, request, cancellationToken, progress) : { kind: this.kind, userMessages: [] }
    }
  }
},
  workspaceKnowledgeRules = `
# Additional Rules

Think step by step:
1. Read the user's question to understand whether the question likely requires knowledge of the workspace.

2. Respond with 0 for general terminal questions unrelated to the workspace, or respond with 1 if workspace knowledge is required. If unsure, respond with 1.

# Examples

User: build the project

Response:

1

User: print hello world

Response:

0`.trim(),
terminalWorkspaceResolver = ContextResolverRegistry.register(new TerminalWorkspaceResolver())
function createScanner(input, e = !1) {
  let r = input.length,
    n = 0,
    i = '',
    o = 0,
    s = 16,
    a = 0,
    l = 0,
    c = 0,
    u = 0,
    p = 0
  function d(y, b) {
    let x = 0,
      P = 0
    for (; x < y || !b; ) {
      let U = input.charCodeAt(n)
      if (U >= 48 && U <= 57) P = P * 16 + U - 48
      else if (U >= 65 && U <= 70) P = P * 16 + U - 65 + 10
      else if (U >= 97 && U <= 102) P = P * 16 + U - 97 + 10
      else break
      n++, x++
    }
    return x < y && (P = -1), P
  }
  function setPosition(y) {
    ;(n = y), (i = ''), (o = 0), (s = 16), (p = 0)
  }
  function m() {
    let y = n
    if (input.charCodeAt(n) === 48) n++
    else for (n++; n < input.length && isDigit(input.charCodeAt(n)); ) n++
    if (n < input.length && input.charCodeAt(n) === 46)
      if ((n++, n < input.length && isDigit(input.charCodeAt(n)))) for (n++; n < input.length && isDigit(input.charCodeAt(n)); ) n++
      else return (p = 3), input.substring(y, n)
    let b = n
    if (n < input.length && (input.charCodeAt(n) === 69 || input.charCodeAt(n) === 101))
      if (
        (n++,
        ((n < input.length && input.charCodeAt(n) === 43) || input.charCodeAt(n) === 45) && n++,
        n < input.length && isDigit(input.charCodeAt(n)))
      ) {
        for (n++; n < input.length && isDigit(input.charCodeAt(n)); ) n++
        b = n
      } else p = 3
    return input.substring(y, b)
  }
  function h() {
    let y = '',
      b = n
    for (;;) {
      if (n >= r) {
        ;(y += input.substring(b, n)), (p = 2)
        break
      }
      let x = input.charCodeAt(n)
      if (x === 34) {
        ;(y += input.substring(b, n)), n++
        break
      }
      if (x === 92) {
        if (((y += input.substring(b, n)), n++, n >= r)) {
          p = 2
          break
        }
        switch (input.charCodeAt(n++)) {
          case 34:
            y += '"'
            break
          case 92:
            y += '\\'
            break
          case 47:
            y += '/'
            break
          case 98:
            y += '\b'
            break
          case 102:
            y += '\f'
            break
          case 110:
            y += `
`
            break
          case 114:
            y += '\r'
            break
          case 116:
            y += '	'
            break
          case 117:
            let U = d(4, !0)
            U >= 0 ? (y += String.fromCharCode(U)) : (p = 4)
            break
          default:
            p = 5
        }
        b = n
        continue
      }
      if (x >= 0 && x <= 31)
        if (isLineFeedOrCarriageReturn(x)) {
          ;(y += input.substring(b, n)), (p = 2)
          break
        } else p = 6
      n++
    }
    return y
  }
  function g() {
    if (((i = ''), (p = 0), (o = n), (l = a), (u = c), n >= r)) return (o = r), (s = 17)
    let y = input.charCodeAt(n)
    if (isSpaceOrTab(y)) {
      do n++, (i += String.fromCharCode(y)), (y = input.charCodeAt(n))
      while (isSpaceOrTab(y))
      return (s = 15)
    }
    if (isLineFeedOrCarriageReturn(y))
      return (
        n++,
        (i += String.fromCharCode(y)),
        y === 13 &&
        input.charCodeAt(n) === 10 &&
          (n++,
          (i += `
`)),
        a++,
        (c = n),
        (s = 14)
      )
    switch (y) {
      case 123:
        return n++, (s = 1)
      case 125:
        return n++, (s = 2)
      case 91:
        return n++, (s = 3)
      case 93:
        return n++, (s = 4)
      case 58:
        return n++, (s = 6)
      case 44:
        return n++, (s = 5)
      case 34:
        return n++, (i = h()), (s = 10)
      case 47:
        let b = n - 1
        if (input.charCodeAt(n + 1) === 47) {
          for (n += 2; n < r && !isLineFeedOrCarriageReturn(input.charCodeAt(n)); ) n++
          return (i = input.substring(b, n)), (s = 12)
        }
        if (input.charCodeAt(n + 1) === 42) {
          n += 2
          let x = r - 1,
            P = !1
          for (; n < x; ) {
            let U = input.charCodeAt(n)
            if (U === 42 && input.charCodeAt(n + 1) === 47) {
              ;(n += 2), (P = !0)
              break
            }
            n++, isLineFeedOrCarriageReturn(U) && (U === 13 && input.charCodeAt(n) === 10 && n++, a++, (c = n))
          }
          return P || (n++, (p = 1)), (i = input.substring(b, n)), (s = 13)
        }
        return (i += String.fromCharCode(y)), n++, (s = 16)
      case 45:
        if (((i += String.fromCharCode(y)), n++, n === r || !isDigit(input.charCodeAt(n)))) return (s = 16)
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return (i += m()), (s = 11)
      default:
        for (; n < r && v(y); ) n++, (y = input.charCodeAt(n))
        if (o !== n) {
          switch (((i = input.substring(o, n)), i)) {
            case 'true':
              return (s = 8)
            case 'false':
              return (s = 9)
            case 'null':
              return (s = 7)
          }
          return (s = 16)
        }
        return (i += String.fromCharCode(y)), n++, (s = 16)
    }
  }
  function v(y) {
    if (isSpaceOrTab(y) || isLineFeedOrCarriageReturn(y)) return !1
    switch (y) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return !1
    }
    return !0
  }
  function _() {
    let y
    do y = g()
    while (y >= 12 && y <= 15)
    return y
  }
  return {
    setPosition: setPosition,
    getPosition: () => n,
    scan: e ? _ : g,
    getToken: () => s,
    getTokenValue: () => i,
    getTokenOffset: () => o,
    getTokenLength: () => n - o,
    getTokenStartLine: () => l,
    getTokenStartCharacter: () => o - u,
    getTokenError: () => p,
  }
}
function isSpaceOrTab(character) {
  return character === 32 || character === 9
}
function isLineFeedOrCarriageReturn(character) {
  return character === 10 || character === 13
}
function isDigit(character) {
  return character >= 48 && character <= 57
}

var charCodes
;(function (charMap) {
  ;(charMap[(charMap.lineFeed = 10)] = 'lineFeed'),
    (charMap[(charMap.carriageReturn = 13)] = 'carriageReturn'),
    (charMap[(charMap.space = 32)] = 'space'),
    (charMap[(charMap._0 = 48)] = '_0'),
    (charMap[(charMap._1 = 49)] = '_1'),
    (charMap[(charMap._2 = 50)] = '_2'),
    (charMap[(charMap._3 = 51)] = '_3'),
    (charMap[(charMap._4 = 52)] = '_4'),
    (charMap[(charMap._5 = 53)] = '_5'),
    (charMap[(charMap._6 = 54)] = '_6'),
    (charMap[(charMap._7 = 55)] = '_7'),
    (charMap[(charMap._8 = 56)] = '_8'),
    (charMap[(charMap._9 = 57)] = '_9'),
    (charMap[(charMap.a = 97)] = 'a'),
    (charMap[(charMap.b = 98)] = 'b'),
    (charMap[(charMap.c = 99)] = 'c'),
    (charMap[(charMap.d = 100)] = 'd'),
    (charMap[(charMap.e = 101)] = 'e'),
    (charMap[(charMap.f = 102)] = 'f'),
    (charMap[(charMap.g = 103)] = 'g'),
    (charMap[(charMap.h = 104)] = 'h'),
    (charMap[(charMap.i = 105)] = 'i'),
    (charMap[(charMap.j = 106)] = 'j'),
    (charMap[(charMap.k = 107)] = 'k'),
    (charMap[(charMap.l = 108)] = 'l'),
    (charMap[(charMap.m = 109)] = 'm'),
    (charMap[(charMap.n = 110)] = 'n'),
    (charMap[(charMap.o = 111)] = 'o'),
    (charMap[(charMap.p = 112)] = 'p'),
    (charMap[(charMap.q = 113)] = 'q'),
    (charMap[(charMap.r = 114)] = 'r'),
    (charMap[(charMap.s = 115)] = 's'),
    (charMap[(charMap.t = 116)] = 't'),
    (charMap[(charMap.u = 117)] = 'u'),
    (charMap[(charMap.v = 118)] = 'v'),
    (charMap[(charMap.w = 119)] = 'w'),
    (charMap[(charMap.x = 120)] = 'x'),
    (charMap[(charMap.y = 121)] = 'y'),
    (charMap[(charMap.z = 122)] = 'z'),
    (charMap[(charMap.A = 65)] = 'A'),
    (charMap[(charMap.B = 66)] = 'B'),
    (charMap[(charMap.C = 67)] = 'C'),
    (charMap[(charMap.D = 68)] = 'D'),
    (charMap[(charMap.E = 69)] = 'E'),
    (charMap[(charMap.F = 70)] = 'F'),
    (charMap[(charMap.G = 71)] = 'G'),
    (charMap[(charMap.H = 72)] = 'H'),
    (charMap[(charMap.I = 73)] = 'I'),
    (charMap[(charMap.J = 74)] = 'J'),
    (charMap[(charMap.K = 75)] = 'K'),
    (charMap[(charMap.L = 76)] = 'L'),
    (charMap[(charMap.M = 77)] = 'M'),
    (charMap[(charMap.N = 78)] = 'N'),
    (charMap[(charMap.O = 79)] = 'O'),
    (charMap[(charMap.P = 80)] = 'P'),
    (charMap[(charMap.Q = 81)] = 'Q'),
    (charMap[(charMap.R = 82)] = 'R'),
    (charMap[(charMap.S = 83)] = 'S'),
    (charMap[(charMap.T = 84)] = 'T'),
    (charMap[(charMap.U = 85)] = 'U'),
    (charMap[(charMap.V = 86)] = 'V'),
    (charMap[(charMap.W = 87)] = 'W'),
    (charMap[(charMap.X = 88)] = 'X'),
    (charMap[(charMap.Y = 89)] = 'Y'),
    (charMap[(charMap.Z = 90)] = 'Z'),
    (charMap[(charMap.asterisk = 42)] = 'asterisk'),
    (charMap[(charMap.backslash = 92)] = 'backslash'),
    (charMap[(charMap.closeBrace = 125)] = 'closeBrace'),
    (charMap[(charMap.closeBracket = 93)] = 'closeBracket'),
    (charMap[(charMap.colon = 58)] = 'colon'),
    (charMap[(charMap.comma = 44)] = 'comma'),
    (charMap[(charMap.dot = 46)] = 'dot'),
    (charMap[(charMap.doubleQuote = 34)] = 'doubleQuote'),
    (charMap[(charMap.minus = 45)] = 'minus'),
    (charMap[(charMap.openBrace = 123)] = 'openBrace'),
    (charMap[(charMap.openBracket = 91)] = 'openBracket'),
    (charMap[(charMap.plus = 43)] = 'plus'),
    (charMap[(charMap.slash = 47)] = 'slash'),
    (charMap[(charMap.formFeed = 12)] = 'formFeed'),
    (charMap[(charMap.tab = 9)] = 'tab')
})(charCodes || (charCodes = {}))
var JsonParserSettings;
(function (settings) {
  settings.DEFAULT = { allowTrailingComma: false };
})(JsonParserSettings || (JsonParserSettings = {}));

function parseJson(jsonString, errors = [], settings = JsonParserSettings.DEFAULT) {
  let currentKey = null,
      currentObjectOrArray = [],
      objectOrArrayStack = [];

  function addValue(value) {
    Array.isArray(currentObjectOrArray) ? currentObjectOrArray.push(value) : currentKey !== null && (currentObjectOrArray[currentKey] = value);
  }

  return (
    parseJson1(
      jsonString,
      {
        onObjectBegin: () => {
          let newObject = {};
          addValue(newObject), objectOrArrayStack.push(currentObjectOrArray), (currentObjectOrArray = newObject), (currentKey = null);
        },
        onObjectProperty: key => {
          currentKey = key;
        },
        onObjectEnd: () => {
          currentObjectOrArray = objectOrArrayStack.pop();
        },
        onArrayBegin: () => {
          let newArray = [];
          addValue(newArray), objectOrArrayStack.push(currentObjectOrArray), (currentObjectOrArray = newArray), (currentKey = null);
        },
        onArrayEnd: () => {
          currentObjectOrArray = objectOrArrayStack.pop();
        },
        onLiteralValue: addValue,
        onError: (error, offset, length) => {
          errors.push({ error: error, offset: offset, length: length });
        },
      },
      settings
    ),
    currentObjectOrArray[0]
  );
}
function parseJson1(t, e, r = JsonParserSettings.DEFAULT) {
  let n = createScanner(t, !1),
    i = []
  function o(z) {
    return z
      ? () => z(n.getTokenOffset(), n.getTokenLength(), n.getTokenStartLine(), n.getTokenStartCharacter())
      : () => !0
  }
  function s(z) {
    return z
      ? () =>
          z(n.getTokenOffset(), n.getTokenLength(), n.getTokenStartLine(), n.getTokenStartCharacter(), () => i.slice())
      : () => !0
  }
  function a(z) {
    return z
      ? q => z(q, n.getTokenOffset(), n.getTokenLength(), n.getTokenStartLine(), n.getTokenStartCharacter())
      : () => !0
  }
  function l(z) {
    return z
      ? q =>
          z(q, n.getTokenOffset(), n.getTokenLength(), n.getTokenStartLine(), n.getTokenStartCharacter(), () =>
            i.slice()
          )
      : () => !0
  }
  let c = s(e.onObjectBegin),
    u = l(e.onObjectProperty),
    p = o(e.onObjectEnd),
    d = s(e.onArrayBegin),
    f = o(e.onArrayEnd),
    m = l(e.onLiteralValue),
    h = a(e.onSeparator),
    g = o(e.onComment),
    v = a(e.onError),
    _ = r && r.disallowComments,
    y = r && r.allowTrailingComma
  function b() {
    for (;;) {
      let z = n.scan()
      switch (n.getTokenError()) {
        case 4:
          x(14)
          break
        case 5:
          x(15)
          break
        case 3:
          x(13)
          break
        case 1:
          _ || x(11)
          break
        case 2:
          x(12)
          break
        case 6:
          x(16)
          break
      }
      switch (z) {
        case 12:
        case 13:
          _ ? x(10) : g()
          break
        case 16:
          x(1)
          break
        case 15:
        case 14:
          break
        default:
          return z
      }
    }
  }
  function x(z, q = [], L = []) {
    if ((v(z), q.length + L.length > 0)) {
      let S = n.getToken()
      for (; S !== 17; ) {
        if (q.indexOf(S) !== -1) {
          b()
          break
        } else if (L.indexOf(S) !== -1) break
        S = b()
      }
    }
  }
  function P(z) {
    let q = n.getTokenValue()
    return z ? m(q) : (u(q), i.push(q)), b(), !0
  }
  function U() {
    switch (n.getToken()) {
      case 11:
        let z = n.getTokenValue(),
          q = Number(z)
        isNaN(q) && (x(2), (q = 0)), m(q)
        break
      case 7:
        m(null)
        break
      case 8:
        m(!0)
        break
      case 9:
        m(!1)
        break
      default:
        return !1
    }
    return b(), !0
  }
  function H() {
    return n.getToken() !== 10
      ? (x(3, [], [2, 5]), !1)
      : (P(!1), n.getToken() === 6 ? (h(':'), b(), F() || x(4, [], [2, 5])) : x(5, [], [2, 5]), i.pop(), !0)
  }
  function j() {
    c(), b()
    let z = !1
    for (; n.getToken() !== 2 && n.getToken() !== 17; ) {
      if (n.getToken() === 5) {
        if ((z || x(4, [], []), h(','), b(), n.getToken() === 2 && y)) break
      } else z && x(6, [], [])
      H() || x(4, [], [2, 5]), (z = !0)
    }
    return p(), n.getToken() !== 2 ? x(7, [2], []) : b(), !0
  }
  function M() {
    d(), b()
    let z = !0,
      q = !1
    for (; n.getToken() !== 4 && n.getToken() !== 17; ) {
      if (n.getToken() === 5) {
        if ((q || x(4, [], []), h(','), b(), n.getToken() === 4 && y)) break
      } else q && x(6, [], [])
      z ? (i.push(0), (z = !1)) : i[i.length - 1]++, F() || x(4, [], [4, 5]), (q = !0)
    }
    return f(), z || i.pop(), n.getToken() !== 4 ? x(8, [4], []) : b(), !0
  }
  function F() {
    switch (n.getToken()) {
      case 3:
        return M()
      case 1:
        return j()
      case 10:
        return P(!0)
      default:
        return U()
    }
  }
  return (
    b(),
    n.getToken() === 17
      ? r.allowEmptyContent
        ? !0
        : (x(4, [], []), !1)
      : F()
      ? (n.getToken() !== 17 && x(9, [], []), !0)
      : (x(4, [], []), !1)
  )
}
var ParseError
;(function (error) {
  error[(error.None = 0)] = 'None';
  error[(error.UnexpectedEndOfComment = 1)] = 'UnexpectedEndOfComment';
  error[(error.UnexpectedEndOfString = 2)] = 'UnexpectedEndOfString';
  error[(error.UnexpectedEndOfNumber = 3)] = 'UnexpectedEndOfNumber';
  error[(error.InvalidUnicode = 4)] = 'InvalidUnicode';
  error[(error.InvalidEscapeCharacter = 5)] = 'InvalidEscapeCharacter';
  error[(error.InvalidCharacter = 6)] = 'InvalidCharacter';
})(ParseError || (ParseError = {}));

var TokenType
;(function (type) {
  type[(type.OpenBraceToken = 1)] = 'OpenBraceToken';
  type[(type.CloseBraceToken = 2)] = 'CloseBraceToken';
  type[(type.OpenBracketToken = 3)] = 'OpenBracketToken';
  type[(type.CloseBracketToken = 4)] = 'CloseBracketToken';
  type[(type.CommaToken = 5)] = 'CommaToken';
  type[(type.ColonToken = 6)] = 'ColonToken';
  type[(type.NullKeyword = 7)] = 'NullKeyword';
  type[(type.TrueKeyword = 8)] = 'TrueKeyword';
  type[(type.FalseKeyword = 9)] = 'FalseKeyword';
  type[(type.StringLiteral = 10)] = 'StringLiteral';
  type[(type.NumericLiteral = 11)] = 'NumericLiteral';
  type[(type.LineCommentTrivia = 12)] = 'LineCommentTrivia';
  type[(type.BlockCommentTrivia = 13)] = 'BlockCommentTrivia';
  type[(type.LineBreakTrivia = 14)] = 'LineBreakTrivia';
  type[(type.Trivia = 15)] = 'Trivia';
  type[(type.Unknown = 16)] = 'Unknown';
  type[(type.EOF = 17)] = 'EOF';
})(TokenType || (TokenType = {}));

var parseJson = parseJson;

var SyntaxError
;(function (error) {
  error[(error.InvalidSymbol = 1)] = 'InvalidSymbol';
  error[(error.InvalidNumberFormat = 2)] = 'InvalidNumberFormat';
  error[(error.PropertyNameExpected = 3)] = 'PropertyNameExpected';
  error[(error.ValueExpected = 4)] = 'ValueExpected';
  error[(error.ColonExpected = 5)] = 'ColonExpected';
  error[(error.CommaExpected = 6)] = 'CommaExpected';
  error[(error.CloseBraceExpected = 7)] = 'CloseBraceExpected';
  error[(error.CloseBracketExpected = 8)] = 'CloseBracketExpected';
  error[(error.EndOfFileExpected = 9)] = 'EndOfFileExpected';
  error[(error.InvalidCommentToken = 10)] = 'InvalidCommentToken';
  error[(error.UnexpectedEndOfComment = 11)] = 'UnexpectedEndOfComment';
  error[(error.UnexpectedEndOfString = 12)] = 'UnexpectedEndOfString';
  error[(error.UnexpectedEndOfNumber = 13)] = 'UnexpectedEndOfNumber';
  error[(error.InvalidUnicode = 14)] = 'InvalidUnicode';
  error[(error.InvalidEscapeCharacter = 15)] = 'InvalidEscapeCharacter';
  error[(error.InvalidCharacter = 16)] = 'InvalidCharacter';
})(SyntaxError || (SyntaxError = {}));

async function reportProgressAfterDelay(progress, message, promise, delay) {
  let timeoutId = null,
    isDone = false;
  timeoutId = setTimeout(() => {
    if (!isDone) {
      progress.report(message);
    }
  }, delay);
  try {
    let result = await promise;
    isDone = true;
    return result;
  } finally {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
}

function generateSettingDescription(setting) {
  let description = `Setting Id: ${setting.key}
`;
  description += `Type: ${setting.type}
`;
  description += `Description: ${setting.description ?? setting.markdownDescription ?? ''}
`;
  if (setting.enum) {
    description += `Possible values:
`;
    for (let i = 0; i < setting.enum.length; i++) {
      description += ` - ${setting.enum[i]} - ${setting.enumDescriptions?.[i] ?? ''}
`;
    }
  }
  description += `
`;
  return description;
}

var RelatedInformationProvider = class extends EmbeddingsManager {
  constructor(logger, embeddingsComputer, items, relatedInformationConfig, ...args) {
    super(...args);
    this.relatedInformationConfig = relatedInformationConfig;
    this.isIndexLoaded = false;
  }
  async provideRelatedInformation(request, cancellationToken) {
    let startTime = Date.now();
    if (!this.isIndexLoaded) {
      this.calculateEmbeddings();
      this.logger.debug(`Related Information: Index not loaded yet triggering background calculation, returning ${Date.now() - startTime}ms`);
      return [];
    }
    if (cancellationToken.isCancellationRequested) {
      this.logger.debug(`Related Information: Request cancelled, returning ${Date.now() - startTime}ms`);
      return [];
    }
    let computationStartTime = Date.now();
    let embeddings = await this.embeddingsComputer.computeEmbeddings([request], cancellationToken);
    if (cancellationToken.isCancellationRequested || !embeddings || !embeddings[0]) {
      this.logger.debug(`Related Information: Request cancelled or no match found, returning ${Date.now() - startTime}ms`);
      return [];
    }
    let relatedInformation = [];
    for (let item of this.items.values()) {
      if (cancellationToken.isCancellationRequested) {
        this.logger.debug(`Related Information: Request cancelled, returning ${Date.now() - startTime}ms`);
        break;
      }
      if (item.embedding) {
        let similarity = cosineSimilarity(embeddings[0], item.embedding);
        if (similarity > this.relatedInformationConfig.threshold) {
          relatedInformation.push(this.toRelatedInformation(item, similarity));
        }
      }
    }
    this.logger.debug(`Related Information: Successfully Calculated, returning ${Date.now() - startTime}ms`);
    return relatedInformation.sort((a, b) => b.weight - a.weight).slice(0, this.relatedInformationConfig.maxResults);
  }
},
var CommandRelatedInfoProvider = class extends RelatedInformationProvider {
  constructor(accessor, buildInfo) {
    super(
      'CommandIdIndex',
      accessor,
      1,
      'commandEmbeddings',
      getMajorMinorVersion(accessor.get(buildInfo).getEditorInfo().version),
      buildInfo,
      { type: 2, threshold: 0.7, maxResults: 100 },
      { type: 'commands', supportsExtensions: true }
    )
    this.accessor = accessor
  }
  async getLatestItems() {
    let commands = await this.accessor.get(BaseVSCodeInfoProvider).getAllCommands()
    commands.push({
        label: 'Extensions: Search the marketplace for extensions',
        command: 'workbench.extensions.search',
        keybinding: 'Not set',
    });
    commands.push({
        label: 'Extensions: Install extension from marketplace',
        command: 'workbench.extensions.installExtension',
        keybinding: 'Not set',
    });
    return commands.map(command => ({
        key: command.command,
        label: command.label.replace('View: Toggle', 'View: Toggle or Show or Hide'),
        originalLabel: command.label,
        keybinding: command.keybinding ?? 'Not set',
    }));
  }
  getEmbeddingQueryString(command) {
    return `${command.label} - ${command.key}`
  }
  toRelatedInformation(command, weight) {
    return { type: 2, weight: weight, command: command.key }
  }
},
var SettingsRelatedInfoProvider = class extends RelatedInformationProvider {
  constructor(accessor, buildInfo) {
    super(
      'SettingsIndex',
      accessor,
      1,
      'settingEmbeddings',
      getMajorMinorVersion(accessor.get(buildInfo).getEditorInfo().version),
      buildInfo,
      { type: 4, threshold: 0.7, maxResults: 100 },
      { type: 'settings', supportsExtensions: true }
    )
    this.accessor = accessor;
    this.isIndexLoaded = false;
  }
  async getLatestItems() {
    let settings = await this.accessor.get(BaseVSCodeInfoProvider).getAllSettings();
    let nonDeprecatedSettings = [];
    for (let key of Object.keys(settings)) {
      let setting = settings[key];
      if (!setting.deprecationMessage && !setting.markdownDeprecationMessage) {
        nonDeprecatedSettings.push({ ...setting, key: key });
      }
    }
    return nonDeprecatedSettings;
  }
  getEmbeddingQueryString(setting) {
    return generateSettingDescription(setting);
  }
  toRelatedInformation(setting, weight) {
    return { type: 4, weight: weight, setting: setting.key };
  }
};
var IndexLoader = class {
  constructor(provider) {
    this._commandIdIndex = provider.get(CommandRelatedInfoProvider);
    this._settingsIndex = provider.get(SettingsRelatedInfoProvider);
  }
  async loadIndexes() {
    await Promise.all([
      this._commandIdIndex.isIndexLoaded ? Promise.resolve() : this._commandIdIndex.calculateEmbeddings(),
      this._settingsIndex.isIndexLoaded ? Promise.resolve() : this._settingsIndex.calculateEmbeddings(),
    ]);
  }
  async getClosestValues(query, numResults) {
    await this.loadIndexes();
    return {
      commands: this._commandIdIndex.getClosestValues(query, numResults),
      settings: this._settingsIndex.getClosestValues(query, numResults)
    };
  }
  hasSetting(settingKey) {
    return this._settingsIndex.hasItem(settingKey);
  }
  hasCommand(commandKey) {
    return this._commandIdIndex.hasItem(commandKey);
  }
  getSetting(settingKey) {
    return this._settingsIndex.getItem(settingKey);
  }
  getCommand(commandKey) {
    return this._commandIdIndex.getItem(commandKey);
  }
}

async function loadAndProcessIndexes(container, response) {
  let indexLoader = container.get(IndexLoader);
  await indexLoader.loadIndexes();
  let processedData = processResponse1(indexLoader, response.response?.message ?? '');
  return generateCommands(indexLoader, processedData.settings, processedData.commands);
}

function processResponse1(extension, response) {
  let settings = []
  response = response.replace(/\n/g, '')
  let jsonPattern = /```(json)?\s*([\s\S]+?)\s*```/g,
    jsonMatches = response.match(jsonPattern)
  for (let jsonMatch of jsonMatches ?? []) {
    let json = jsonMatch.replace(/```(json)?\s*|\s*```/g, ''),
      parsedJson
    try {
      parsedJson = parseJson(json)
    } catch {}
    parsedJson && !Array.isArray(parsedJson) && settings.push(parsedJson)
  }
  let commands = [],
    commandPattern = /\[COMMANDS START\]```(?:json)?(.+)\[COMMANDS END\]/g,
    commandMatch
  for (commandMatch of response.matchAll(commandPattern)) {
    let commandJson = commandMatch[1].trim(),
      parsedCommandJson
    try {
      parsedCommandJson = parseJson(commandJson)
    } catch {}
    parsedCommandJson && Array.isArray(parsedCommandJson) && commands.push(...parsedCommandJson)
  }
  let settingsValidationFailed = settings
      .map(setting => {
        for (let key of Object.keys(setting)) if (!extension.hasSetting(key)) return false
        return true
      })
      .some(result => result === false),
    commandsValidationFailed = commands
      .map(command => {
        if (command.command && !extension.hasCommand(command.command)) return false
      })
      .some(result => result === false)
  return { settings: settings, commands: commands, validationFailed: settingsValidationFailed || commandsValidationFailed }
}

async function generateCommands(extension, settings, commands) {
  let generatedCommands = [],
    commandCount = commands.length
  for (let setting of settings) {
    let args = ''
    for (let key of Object.keys(setting))
      generatedCommands.some(cmd => cmd.args && cmd.args[0].includes(`@id:${key}`)) || (extension.hasSetting(key) && (args += `@id:${key} `))
    args = args.trimEnd(),
      args && generatedCommands.push({ commandId: 'workbench.action.openSettings', args: [args], title: 'Show in Settings Editor' })
  }
  for (let command of commands)
    if (command.command === 'workbench.extensions.search' || command.command === 'workbench.extensions.installExtension') {
      let args = (Array.isArray(command.args) ? command.args : [command.args]).filter(arg => typeof arg == 'string')
      if (args.length === 1) {
        let categories = [
          'featured',
          'popular',
          'recentlyPublished',
          'recommended',
          'updates',
          'builtin',
          'enabled',
          'disabled',
          'installed',
          'workspaceUnsupported',
        ]
        args[0].includes(':') && !args[0].startsWith('@') ? (args[0] = `@${args[0]}`) : categories.includes(args[0]) && (args[0] = `@${args[0]}`)
      }
      generatedCommands.push({ commandId: 'workbench.extensions.search', args: args, title: 'Search Extension Marketplace' })
    } else {
      let cmd = extension.getCommand(command.command)
      if (!cmd) continue
      generatedCommands.push({
        commandId: 'workbench.action.quickOpen',
        args: [`>${cmd.originalLabel}`],
        title: commandCount > 1 ? `Show "${cmd.originalLabel}"` : 'Show in Command Palette',
      })
    }
  return generatedCommands
}

var vscodeContextMessage = `
The current question is related to VS Code. The application is currently open.
If a command or setting is not a valid answer, but it still relates to VS Code, please still respond.
Please do not guess a response and instead just respond with a polite apology if you are unsure.
If you believe the given context given to you is incorrect or not relevant you may ignore it.
At the end of your response, if you reference a command, you must include a section wrapped with [COMMANDS START] and [COMMANDS END] that lists all commands you referenced in your response.
The user cannot see the context you are given, so you must not mention it. If you want to refer to it, you must include it in your reply.
`.trimStart()
var VSCodeContextResolver = class {
  constructor() {
    this.kind = 'vscode'
    this.metaContextResolverInfo = { description: 'Relevant information about VS Code.' }
    this._docsSearchAvailable = false
  }
  async searchDocsForContext(serviceLocator, query, limit, cancellationToken) {
    this._docsSearchClient ||
      ((this._docsSearchClient = serviceLocator.get(DocsSearchClient)), (this._docsSearchAvailable = await this._docsSearchClient.isAvailable()))
    let docsContext = `

Below is a list of information from the VS Code documentation which might be relevant to the question. Feel free to use this context to help you formulate your response, but you are not required to.
`
    if (this._docsSearchAvailable) {
      let searchResults = await this._docsSearchClient.search(query, { repo: 'microsoft/vscode-docs' }, limit, 0.75, cancellationToken)
      for (let result of searchResults)
        docsContext += `
##${result?.title?.trim()} - ${result.path}
${result.contents}`
    }
  }
  async resolveContext(serviceLocator, context, cancellationToken, progress) {
    let vscodeContextMessage = vscodeContextMessage + `

`
    this._embeddingCompute ??= serviceLocator.get(EmbeddingsComputer)
    let message = context.message
    if (!message || !progress) return
    let docsSearch = await reportProgressAfterDelay(progress, { message: 'Searching doc index....' }, this.searchDocsForContext(serviceLocator, message, 10, cancellationToken), 1000)
    this._commandsAndSettingsIndex || (this._commandsAndSettingsIndex = serviceLocator.get(IndexLoader))
    let embeddings = await this._embeddingCompute?.computeEmbeddings([message], cancellationToken)
    if (!embeddings || cancellationToken.isCancellationRequested) return
    vscodeContextMessage +=
      'Below is a list of commands and settings we found which might be relevant to the question. For view related commands "Toggle" often means Show or Hide. A setting may reference another setting, that will appear as `#setting.id#`, you must return the referenced setting as well. You may use this context to help you formulate your response, but are not required to.'
    let closestValues = await reportProgressAfterDelay(
      progress,
      { message: 'Searching command and setting index....' },
      this._commandsAndSettingsIndex.nClosestValues(embeddings[0], 5),
      500
    )
    return (
      closestValues.commands.length &&
        ((vscodeContextMessage += `Here are some possible commands:
`),
        (vscodeContextMessage += closestValues.commands.map(command => `- ${command.label} ("${command.key}") (Keybinding: "${command.keybinding}")`).join(`
`))),
      closestValues.settings.length &&
        (closestValues.commands.length &&
          (vscodeContextMessage += `

`),
        (vscodeContextMessage += `Here are some possible settings:
`),
        (vscodeContextMessage += closestValues.settings.map(setting => generateSettingDescription(setting)).join(`
`))),
      this._docsSearchAvailable && (vscodeContextMessage += docsSearch),
      {
        kind: this.kind,
        userMessages: [
          `Relevant information about VS Code:
` + vscodeContextMessage,
        ],
      }
    )
  }
}
var vSCodeContextResolver = ContextResolverRegistry.register(new VSCodeContextResolver())
var util = require('util')
class WorkspaceLabelCollector {
  constructor() {
    this.indicators = new Map();
    this.contentIndicators = new Map();
    this._labels = [];
    this.initIndicators();
  }

  get labels() {
    if (this._labels.includes('javascript') && this._labels.includes('typescript')) {
      let index = this._labels.indexOf('javascript');
      this._labels.splice(index, 1);
    }
    return this._labels;
  }

  async collectContext(workspace) {
    let folders = workspace.get(WorkspaceClass).getWorkspaceFolders();
    if (folders) {
      for (let i = 0; i < folders.length; i++) {
        await this.addContextForFolders(workspace, folders[i]);
      }
    }
  }

  async addContextForFolders(workspace, folder) {
    for (let [indicator, labels] of this.indicators.entries()) {
      await this.addLabelIfApplicable(workspace, folder, indicator, labels);
    }
  }

  async addLabelIfApplicable(workspace, folder, indicator, labels) {
    let path = VscodeUri.joinPath(folder, indicator);
    try {
      await workspace.get(BaseFileSystemOperations).stat(path);
      labels.forEach(label => this._labels.push(label));
      let contentIndicator = this.contentIndicators.get(indicator);
      if (contentIndicator) {
        let content = await workspace.get(BaseFileSystemOperations).readFile(path);
        try {
          contentIndicator(new util.TextDecoder().decode(content)).forEach(label => this._labels.push(label));
        } catch {}
      }
    } catch {}
  }

  initIndicators() {
    this.addIndicator('package.json', 'javascript', 'npm');
    this.addIndicator('tsconfig.json', 'typescript');
    this.addIndicator('pom.xml', 'java', 'maven');
    this.addIndicator('build.gradle', 'java', 'gradle');
    this.addIndicator('requirements.txt', 'python', 'pip');
    this.addIndicator('Pipfile', 'python', 'pip');
    this.addIndicator('Cargo.toml', 'rust', 'cargo');
    this.addIndicator('go.mod', 'go', 'go.mod');
    this.addIndicator('pubspec.yaml', 'dart', 'pub');
    this.addIndicator('build.sbt', 'scala', 'sbt');
    this.addIndicator('build.boot', 'clojure', 'boot');
    this.addIndicator('project.clj', 'clojure', 'lein');
    this.addIndicator('mix.exs', 'elixir', 'mix');
    this.addIndicator('composer.json', 'php', 'composer');
    this.addIndicator('Gemfile', 'ruby', 'bundler');
    this.addIndicator('build.xml', 'java', 'ant');
    this.addIndicator('build.gradle.kts', 'java', 'gradle');
    this.addIndicator('yarn.lock', 'yarn');
    this.addContentIndicator('package.json', this.collectPackageJsonIndicators);
  }

  addIndicator(indicator, ...labels) {
    this.indicators.set(indicator, labels);
  }

  addContentIndicator(indicator, contentIndicator) {
    this.contentIndicators.set(indicator, contentIndicator);
  }

  collectPackageJsonIndicators(content) {
    let labels = [];
    let json = JSON.parse(content);
    let dependencies = json.dependencies;
    let devDependencies = json.devDependencies;
    if (dependencies) {
      if (dependencies['@angular/core']) labels.push('angular');
      if (dependencies.react) labels.push('react');
      if (dependencies.vue) labels.push('vue');
    }
    if (devDependencies && devDependencies.typescript) labels.push('typescript');
    let engines = json.engines;
    if (engines) {
      if (engines.node) labels.push('node');
      if (engines.vscode) labels.push('vscode extension');
    }
    return labels;
  }
}
class ProjectLabelResolver {
  constructor(workspaceLabelCollector) {
    this.workspaceLabels = workspaceLabelCollector;
    this.kind = 'project-labels';
  }

  async resolveContext(workspace, context) {
    await this.workspaceLabels.collectContext(workspace);
    if (this.workspaceLabels.labels.length > 0) {
      let labels = [...new Set(this.workspaceLabels.labels)]
        .sort()
        .reduce((accumulator, label) => `${accumulator}\n- ${label}`, '')
        .trim();
      return {
        kind: this.kind,
        userMessages: [
          `I am working on a project of the following nature:\n` + labels,
        ],
      };
    }
  }
}
var workspaceLabelCollector = new WorkspaceLabelCollector(),
var contextResolverRegistry = ContextResolverRegistry.register(new ProjectLabelResolver(workspaceLabelCollector))
var Reporter = class {
  async reportInline(e, r, n) {}
  async reportChat(e) {}
}
var requestLight = handleDefaultExports(requestLight())
class TextApplier {
  constructor(deltaApplier) {
    this.deltaApplier = deltaApplier;
    this._appliedLength = 0;
    this._appliedText = '';
  }

  get appliedText() {
    return Promise.resolve(this._appliedText);
  }

  apply(text) {
    let remainingText = text.substring(this._appliedLength, text.length);
    this.append(remainingText);
  }

  async append(text) {
    this.deltaApplier(text);
    this._appliedLength += text.length;
    this._appliedText += text;
  }
}
class AsyncIterableTextApplier extends TextApplier {
  constructor() {
    super(delta => this._source.emitOne(delta));
    this._source = new DeferredAsyncIterable();
  }

  get asyncIterable() {
    return this._source.asyncIterable;
  }

  finish() {
    this._source.resolve();
  }
}
var requestLight = handleDefaultExports(requestLight())
class TextDiff {
  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
    this.originalStart = originalStart;
    this.originalLength = originalLength;
    this.modifiedStart = modifiedStart;
    this.modifiedLength = modifiedLength;
  }

  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }

  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}


class LineOperator {
  constructor(lines) {
    this.lines = lines;
  }

  getElements() {
    let elements = [];
    for (let index = 0, length = this.lines.length; index < length; index++) {
      elements[index] = this.lines[index].trim();
    }
    return elements;
  }

  getCharCount() {
    let count = 0;
    for (let line of this.lines) {
      count += line.length;
    }
    return count;
  }
}

class Assert {
  static Assert(condition, message) {
    if (!condition) throw new Error(message);
  }
}

class ArrayCopy {
  static Copy(source, sourceIndex, destination, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destination[destinationIndex + i] = source[sourceIndex + i];
    }
  }

  static Copy2(source, sourceIndex, destination, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destination[destinationIndex + i] = source[sourceIndex + i];
    }
  }
}

class TextChangeTracker {
  constructor() {
    this.changes = [];
    this.originalStart = Number.MAX_SAFE_INTEGER;
    this.modifiedStart = Number.MAX_SAFE_INTEGER;
    this.originalCount = 0;
    this.modifiedCount = 0;
  }

  markNextChange() {
    if (this.originalCount > 0 || this.modifiedCount > 0) {
      this.changes.push(
        new TextDiff(this.originalStart, this.originalCount, this.modifiedStart, this.modifiedCount)
      );
    }
    this.originalCount = 0;
    this.modifiedCount = 0;
    this.originalStart = Number.MAX_SAFE_INTEGER;
    this.modifiedStart = Number.MAX_SAFE_INTEGER;
  }

  addOriginalElement(originalIndex, modifiedIndex) {
    this.originalStart = Math.min(this.originalStart, originalIndex);
    this.modifiedStart = Math.min(this.modifiedStart, modifiedIndex);
    this.originalCount++;
  }

  addModifiedElement(originalIndex, modifiedIndex) {
    this.originalStart = Math.min(this.originalStart, originalIndex);
    this.modifiedStart = Math.min(this.modifiedStart, modifiedIndex);
    this.modifiedCount++;
  }

  getChanges() {
    if (this.originalCount > 0 || this.modifiedCount > 0) {
      this.markNextChange();
    }
    return this.changes;
  }

  getReverseChanges() {
    if (this.originalCount > 0 || this.modifiedCount > 0) {
      this.markNextChange();
    }
    this.changes.reverse();
    return this.changes;
  }
}
var DiffAlgorithm = class {
  constructor(original, modified) {
    let [originalStrings, originalHash] = DiffAlgorithm._getElements(original),
      [modifiedStrings, modifiedHash] = DiffAlgorithm._getElements(modified)
    this._originalStringElements = originalStrings
    this._originalElementsOrHash = originalHash
    this._modifiedStringElements = modifiedStrings
    this._modifiedElementsOrHash = modifiedHash
    this.forwardHistory = []
    this.reverseHistory = []
  }
  static _getElements(element) {
    let elements = element.getElements(),
      hashArray = new Int32Array(elements.length)
    for (let i = 0, length = elements.length; i < length; i++)
      hashArray[i] = this._stringHash(elements[i], 0)
    return [elements, hashArray]
  }
  static _numberHash(number, hash) {
    return ((hash << 5) - hash + number) | 0
  }
  static _stringHash(string, hash) {
    hash = this._numberHash(149417, hash)
    for (let index = 0, length = string.length; index < length; index++)
      hash = this._numberHash(string.charCodeAt(index), hash)
    return hash
  }
  elementsAreEqual(originalIndex, modifiedIndex) {
    return this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[modifiedIndex]
      ? false
      : this._originalStringElements[originalIndex] === this._modifiedStringElements[modifiedIndex]
  }
  computeDiff() {
    return this._computeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1)
  }
  _computeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd) {
    return this.computeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd)
  }
  computeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd) {
    // Trim common elements from the start
    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.elementsAreEqual(originalStart, modifiedStart)) {
      originalStart++
      modifiedStart++
    }

    // Trim common elements from the end
    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.elementsAreEqual(originalEnd, modifiedEnd)) {
      originalEnd--
      modifiedEnd--
    }

    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
      let diffResult
      if (modifiedStart <= modifiedEnd) {
        Assert.assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd')
        diffResult = [new TextDiff(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)]
      } else if (originalStart <= originalEnd) {
        Assert.assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd')
        diffResult = [new TextDiff(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)]
      } else {
        Assert.assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd')
        Assert.assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd')
        diffResult = []
      }
      return diffResult
    }

    let midOriginal = [0],
      midModified = [0]
    let recursionPoint = this.computeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginal, midModified)
    if (recursionPoint !== null) return recursionPoint

    let diffResult1 = this.computeDiffRecursive(originalStart, midOriginal[0], modifiedStart, midModified[0])
    let diffResult2 = this.computeDiffRecursive(midOriginal[0] + 1, originalEnd, midModified[0] + 1, modifiedEnd)
    return this.concatenateChanges(diffResult1, diffResult2)
  }
    WALKTRACE(e, r, n, i, o, s, a, l, c, u, p, d, f, m, h, g, v) {
      let _ = null,
        y = null,
        b = new TextChangeTracker(),
        x = r,
        P = n,
        U = f[0] - g[0] - i,
        H = -1073741824,
        j = this.m_forwardHistory.length - 1
      do {
        let M = U + e
        M === x || (M < P && c[M - 1] < c[M + 1])
          ? ((p = c[M + 1]),
            (m = p - U - i),
            p < H && b.MarkNextChange(),
            (H = p),
            b.AddModifiedElement(p + 1, m),
            (U = M + 1 - e))
          : ((p = c[M - 1] + 1),
            (m = p - U - i),
            p < H && b.MarkNextChange(),
            (H = p - 1),
            b.AddOriginalElement(p, m + 1),
            (U = M - 1 - e)),
          j >= 0 && ((c = this.m_forwardHistory[j]), (e = c[0]), (x = 1), (P = c.length - 1))
      } while (--j >= -1)
      ;(_ = b.getReverseChanges()),
        (b = new TextChangeTracker()),
        (x = s),
        (P = a),
        (U = f[0] - g[0] - l),
        (H = 1073741824),
        (j = v ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2)
      do {
        let M = U + o
        M === x || (M < P && u[M - 1] >= u[M + 1])
          ? ((p = u[M + 1] - 1),
            (m = p - U - l),
            p > H && b.MarkNextChange(),
            (H = p + 1),
            b.AddOriginalElement(p + 1, m + 1),
            (U = M + 1 - o))
          : ((p = u[M - 1]),
            (m = p - U - l),
            p > H && b.MarkNextChange(),
            (H = p),
            b.AddModifiedElement(p + 1, m + 1),
            (U = M - 1 - o)),
          j >= 0 && ((u = this.m_reverseHistory[j]), (o = u[0]), (x = 1), (P = u.length - 1))
      } while (--j >= -1)
      return (y = b.getChanges()), this.ConcatenateChanges(_, y)
    }
    ComputeRecursionPoint(e, r, n, i, o, s) {
      let a = 0,
        l = 0,
        c = 0,
        u = 0,
        p = 0,
        d = 0
      e--, n--, (o[0] = 0), (s[0] = 0), (this.m_forwardHistory = []), (this.m_reverseHistory = [])
      let f = r - e + (i - n),
        m = f + 1,
        h = new Int32Array(m),
        g = new Int32Array(m),
        v = i - n,
        _ = r - e,
        y = e - n,
        b = r - i,
        P = (_ - v) % 2 === 0
      ;(h[v] = e), (g[_] = r)
      for (let U = 1; U <= f / 2 + 1; U++) {
        let H = 0,
          j = 0
        ;(c = this.ClipDiagonalBound(v - U, U, v, m)), (u = this.ClipDiagonalBound(v + U, U, v, m))
        for (let M = c; M <= u; M += 2) {
          M === c || (M < u && h[M - 1] < h[M + 1]) ? (a = h[M + 1]) : (a = h[M - 1] + 1), (l = a - (M - v) - y)
          let F = a
          for (; a < r && l < i && this.ElementsAreEqual(a + 1, l + 1); ) a++, l++
          if (((h[M] = a), a + l > H + j && ((H = a), (j = l)), !P && Math.abs(M - _) <= U - 1 && a >= g[M]))
            return (
              (o[0] = a),
              (s[0] = l),
              F <= g[M] && 1447 > 0 && U <= 1447 + 1
                ? this.WALKTRACE(v, c, u, y, _, p, d, b, h, g, a, r, o, l, i, s, P)
                : null
            )
        }
        ;(p = this.ClipDiagonalBound(_ - U, U, _, m)), (d = this.ClipDiagonalBound(_ + U, U, _, m))
        for (let M = p; M <= d; M += 2) {
          M === p || (M < d && g[M - 1] >= g[M + 1]) ? (a = g[M + 1] - 1) : (a = g[M - 1]), (l = a - (M - _) - b)
          let F = a
          for (; a > e && l > n && this.ElementsAreEqual(a, l); ) a--, l--
          if (((g[M] = a), P && Math.abs(M - v) <= U && a <= h[M]))
            return (
              (o[0] = a),
              (s[0] = l),
              F >= h[M] && 1447 > 0 && U <= 1447 + 1
                ? this.WALKTRACE(v, c, u, y, _, p, d, b, h, g, a, r, o, l, i, s, P)
                : null
            )
        }
        if (U <= 1447) {
          let M = new Int32Array(u - c + 2)
          ;(M[0] = v - c + 1),
          ArrayCopy.Copy2(h, c, M, 1, u - c + 1),
            this.m_forwardHistory.push(M),
            (M = new Int32Array(d - p + 2)),
            (M[0] = _ - p + 1),
            ArrayCopy.Copy2(g, p, M, 1, d - p + 1),
            this.m_reverseHistory.push(M)
        }
      }
      return this.WALKTRACE(v, c, u, y, _, p, d, b, h, g, a, r, o, l, i, s, P)
    }
    ConcatenateChanges(e, r) {
      let n = []
      if (e.length === 0 || r.length === 0) return r.length > 0 ? r : e
      if (this.ChangesOverlap(e[e.length - 1], r[0], n)) {
        let i = new Array(e.length + r.length - 1)
        return ArrayCopy.Copy(e, 0, i, 0, e.length - 1), (i[e.length - 1] = n[0]), ArrayCopy.Copy(r, 1, i, e.length, r.length - 1), i
      } else {
        let i = new Array(e.length + r.length)
        return ArrayCopy.Copy(e, 0, i, 0, e.length), ArrayCopy.Copy(r, 0, i, e.length, r.length), i
      }
    }
    ChangesOverlap(e, r, n) {
      if (
        (Assert.Assert(e.originalStart <= r.originalStart, 'Left change is not less than or equal to right change'),
        Assert.Assert(e.modifiedStart <= r.modifiedStart, 'Left change is not less than or equal to right change'),
        e.originalStart + e.originalLength >= r.originalStart || e.modifiedStart + e.modifiedLength >= r.modifiedStart)
      ) {
        let i = e.originalStart,
          o = e.originalLength,
          s = e.modifiedStart,
          a = e.modifiedLength
        return (
          e.originalStart + e.originalLength >= r.originalStart &&
            (o = r.originalStart + r.originalLength - e.originalStart),
          e.modifiedStart + e.modifiedLength >= r.modifiedStart &&
            (a = r.modifiedStart + r.modifiedLength - e.modifiedStart),
          (n[0] = new TextDiff(i, o, s, a)),
          !0
        )
      } else return (n[0] = null), !1
    }
    ClipDiagonalBound(e, r, n, i) {
      if (e >= 0 && e < i) return e
      let o = n,
        s = i - n - 1,
        a = r % 2 === 0
      if (e < 0) {
        let l = o % 2 === 0
        return a === l ? 0 : 1
      } else {
        let l = s % 2 === 0
        return a === l ? i - 1 : i - 2
      }
    }
  }
class TextAlignment {
  constructor() {
    this.spacesDiff = 0;
    this.looksLikeAlignment = false;
  }
}
function calculateAlignment(str1, len1, str2, len2, alignment) {
  alignment.spacesDiff = 0;
  alignment.looksLikeAlignment = false;

  let commonLength;
  for (commonLength = 0; commonLength < len1 && commonLength < len2; commonLength++) {
    let charCode1 = str1.charCodeAt(commonLength),
      charCode2 = str2.charCodeAt(commonLength);
    if (charCode1 !== charCode2) break;
  }

  let spaces1 = 0,
    nonSpaces1 = 0;
  for (let i = commonLength; i < len1; i++) str1.charCodeAt(i) === 32 ? spaces1++ : nonSpaces1++;

  let spaces2 = 0,
    nonSpaces2 = 0;
  for (let i = commonLength; i < len2; i++) str2.charCodeAt(i) === 32 ? spaces2++ : nonSpaces2++;

  if ((spaces1 > 0 && nonSpaces1 > 0) || (spaces2 > 0 && nonSpaces2 > 0)) return;

  let nonSpacesDiff = Math.abs(nonSpaces1 - nonSpaces2),
    spacesDiff = Math.abs(spaces1 - spaces2);

  if (nonSpacesDiff === 0) {
    alignment.spacesDiff = spacesDiff;
    if (
      spacesDiff > 0 &&
      0 <= spaces2 - 1 &&
      spaces2 - 1 < str1.length &&
      spaces2 < str2.length &&
      str2.charCodeAt(spaces2) !== 32 &&
      str1.charCodeAt(spaces2 - 1) === 32 &&
      str1.charCodeAt(str1.length - 1) === 44
    ) {
      alignment.looksLikeAlignment = true;
    }
    return;
  }

  if (spacesDiff % nonSpacesDiff === 0) {
    alignment.spacesDiff = spacesDiff / nonSpacesDiff;
    return;
  }
}
function calculateIndentation(text, defaultTabSize, defaultInsertSpaces) {
  let lineCount = Math.min(text.getLineCount(), 1e4),
    tabLines = 0,
    spaceLines = 0,
    previousLine = '',
    previousLineIndentation = 0,
    tabSizes = [2, 4, 6, 8, 3, 5, 7],
    maxTabSize = 8,
    tabSizeCounts = [0, 0, 0, 0, 0, 0, 0, 0, 0],
    alignment = new TextAlignment();

  for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
    let lineLength = text.getLineLength(lineNumber),
      lineContent = text.getLineContent(lineNumber),
      hasNonWhitespace = false,
      indentationLength = 0,
      spaceCount = 0,
      tabCount = 0;

    for (let charIndex = 0, charCount = lineLength; charIndex < charCount; charIndex++) {
      let charCode = lineContent.charCodeAt(charIndex);
      if (charCode === 9) tabCount++;
      else if (charCode === 32) spaceCount++;
      else {
        hasNonWhitespace = true;
        indentationLength = charIndex;
        break;
      }
    }

    if (!hasNonWhitespace || (tabCount > 0 ? tabLines++ : spaceCount > 1 && spaceLines++, calculateAlignment(previousLine, previousLineIndentation, lineContent, indentationLength, alignment), alignment.looksLikeAlignment && !(defaultInsertSpaces && defaultTabSize === alignment.spacesDiff)))
      continue;

    let spacesDiff = alignment.spacesDiff;
    if (spacesDiff <= maxTabSize) tabSizeCounts[spacesDiff]++;
    previousLine = lineContent;
    previousLineIndentation = indentationLength;
  }

  let insertSpaces = defaultInsertSpaces;
  if (tabLines !== spaceLines) insertSpaces = tabLines < spaceLines;

  let tabSize = defaultTabSize;
  if (insertSpaces) {
    let maxCount = insertSpaces ? 0 : 0.1 * lineCount;
    tabSizes.forEach(size => {
      let count = tabSizeCounts[size];
      if (count > maxCount) {
        maxCount = count;
        tabSize = size;
      }
    });

    if (tabSize === 4 && tabSizeCounts[4] > 0 && tabSizeCounts[2] > 0 && tabSizeCounts[2] >= tabSizeCounts[4] / 2) {
      tabSize = 2;
    }
  }

  return { insertSpaces: insertSpaces, tabSize: tabSize };
}

function calculateIndentationLength(text, tabSize) {
  let indentationLength = 0,
    charIndex = 0,
    textLength = text.length;

  for (; charIndex < textLength; ) {
    let charCode = text.charCodeAt(charIndex);
    if (charCode === 32) indentationLength++;
    else if (charCode === 9) indentationLength = indentationLength - (indentationLength % tabSize) + tabSize;
    else break;
    charIndex++;
  }

  return charIndex === textLength ? -1 : indentationLength;
}

function calculateIndentationLevel(text, tabSize) {
  let indentationLength = calculateIndentationLength(text, tabSize);
  return indentationLength === -1 ? indentationLength : Math.floor(indentationLength / tabSize);
}

function roundUpToNextMultiple(number, multiple) {
  return number + multiple - (number % multiple);
}

function createIndentationString(text, tabSize, useSpaces) {
  let indentationLength = 0;
  for (let charIndex = 0; charIndex < text.length; charIndex++) text.charAt(charIndex) === '\t' ? (indentationLength = roundUpToNextMultiple(indentationLength, tabSize)) : indentationLength++;

  let indentationString = '';
  if (!useSpaces) {
    let tabCount = Math.floor(indentationLength / tabSize);
    indentationLength = indentationLength % tabSize;
    for (let tabIndex = 0; tabIndex < tabCount; tabIndex++) indentationString += '\t';
  }

  for (let spaceIndex = 0; spaceIndex < indentationLength; spaceIndex++) indentationString += ' ';
  return indentationString;
}

function replaceIndentation(text, tabSize, useSpaces) {
  let firstNonWhitespaceCharIndex = findFirstNonWhitespaceChar(text);
  if (firstNonWhitespaceCharIndex === -1) firstNonWhitespaceCharIndex = text.length;
  return createIndentationString(text.substring(0, firstNonWhitespaceCharIndex), tabSize, useSpaces) + text.substring(firstNonWhitespaceCharIndex);
}

var TextEditGroup = class {
  constructor(firstLineIndex, endLineIndex, lines) {
    this.firstLineIndex = firstLineIndex;
    this.endLineIndex = endLineIndex;
    this.lines = lines;
  }
  toTextEdit() {
    let text =
      this.lines.length > 0
        ? this.lines.join('\n') + '\n'
        : '';
    return VscodeTextEdit.replace(new VscodeRange(this.firstLineIndex, 0, this.endLineIndex, 0), text);
  }
},
TextUtils;

((TextUtils) => {
function fromString(text) {
  return text.length === 0 ? [] : text.split(/\r\n|\r|\n/g);
}
TextUtils.fromString = fromString;
})((TextUtils ||= {}));

var DocumentContext = class {
  constructor(text, languageId) {
    this.text = text;
    this.languageId = languageId;
  }
  static fromDocumentContext(context) {
    return new DocumentContext(context.document.getText(), context.language.languageId);
  }
}

function processInputText(input, editor, rawText, marker, importFilter, options) {
  let lines = TextUtils.fromString(rawText)
  if (lines.length === editor.range.lines.length && editor.range.lines.every((line, index) => line === lines[index])) return []
  let startMarker = findStartMarker(editor, lines, importFilter),
    processedLines = [],
    hasFakeMarkers = false
  for (let line of lines) {
    let markerType = identifyMarkerType(editor, line)
    markerType === null ? processedLines.push(line) : (markerType.type === 'fakestart' || markerType.type === 'fakend') && (hasFakeMarkers = true)
  }
  let edit = generateEdit(input, editor, processedLines, importFilter),
    finalEdit
  if (!startMarker) finalEdit = edit
  else if (!edit) finalEdit = startMarker
  else {
    let markerScore = calculateMarkerScore(startMarker)
    calculateMarkerScore(edit) < markerScore ? (finalEdit = edit) : (finalEdit = startMarker)
  }
  finalEdit || (finalEdit = generateEdit(input, editor, marker, importFilter, hasFakeMarkers, processedLines))
  let edits = [finalEdit]
  return options && (edits = filterImports(options, edits)), edits.map(edit => edit.toTextEdit())
}

function generateEdit(input, editor, markerScore, importFilter, hasFakeMarkers, processedLines) {
  let logger = input.get(LoggerManager).getLogger('editGeneration')
  return hasFakeMarkers
    ? (logger.info('(case 6) Appending to selected code'), appendToBottom(editor.range, processedLines, importFilter))
    : markerScore === 3
    ? (logger.info('(case 7) Appending to selected code'), appendToBottom(editor.range, processedLines, importFilter))
    : markerScore === 1
    ? (logger.info('(case 8) Prepending to selected code'),
    createTextEditGroupAtFirstLine(
        editor.range,
        adjustIndentation(
          processedLines,
          editor.range.lines.filter(line => line.trim() !== '').length > 0
            ? { whichLine: 'topMost', lines: editor.range.lines }
            : { whichLine: 'bottomMost', lines: editor.above.lines },
          importFilter
        )
      ))
    : (logger.info('(Default) Replacing selected code'), generateTextEditGroup(editor.range, processedLines, importFilter))
}

function calculateMarkerScore(marker) {
  let lineDifference = marker.endLineIndex - marker.firstLineIndex,
    lineCount = marker.lines.length
  return lineDifference + lineCount
}

function findStartMarker(markerGroup, markers, textEditGroup) {
  let startMarker = null,
    markerList = []
  for (let marker of markers) {
    let identifiedMarker = identifyMarkerType(markerGroup, marker)
    if (identifiedMarker === null) markerList.push(marker)
    else if (startMarker) {
      if (identifiedMarker.type === 'end' && identifiedMarker.endMarker === startMarker) return generateTextEditGroup(startMarker, markerList, textEditGroup)
      if (identifiedMarker.type === 'end' && startMarker === markerGroup.above && identifiedMarker.endMarker === markerGroup.range) {
        let newRange = markerGroup.range.clone()
        return newRange.mergeFromAbove(markerGroup.above.clone()), generateTextEditGroup(newRange, markerList, textEditGroup)
      } else if (identifiedMarker.type === 'end' && startMarker === markerGroup.above && identifiedMarker.endMarker === markerGroup.below) {
        let newRange = markerGroup.range.clone()
        return newRange.mergeFromAbove(markerGroup.above.clone()), newRange.mergeFromBelow(markerGroup.below.clone()), generateTextEditGroup(newRange, markerList, textEditGroup)
      } else markerList.push(marker)
    } else identifiedMarker.type === 'start' && ((startMarker = identifiedMarker.startMarker), (markerList = []))
  }
  if (markerList.length > 0 && startMarker) return generateTextEditGroup(startMarker, markerList, textEditGroup)
}

function filterImports(document, textEditGroups) {
  let filteredGroups = [],
    lines = document.text.split(/\r\n|\r|\n/g),
    lastImportIndex = findLastIndex(lines, line => isImportStatement(line, document.languageId)),
    importLines = []
  for (let group of textEditGroups) {
    if (group.endLineIndex <= lastImportIndex + 1) return textEditGroups
    let isImport = false,
      nonImportLines = [],
      groupLines = group.lines
    for (let line of groupLines) isImportStatement(line, document.languageId) ? (importLines.push(trimLeadingSpaces(line)), (isImport = true)) : (isImport && line.length === 0) || (nonImportLines.push(line), (isImport = false))
    if (!isImport && nonImportLines.length > 0) {
      if (group.firstLineIndex < lastImportIndex + 1) return textEditGroups
      filteredGroups.push(new TextEditGroup(group.firstLineIndex, group.endLineIndex, nonImportLines))
    }
  }
  if (importLines.length === 0) return textEditGroups
  let newGroupIndex = lastImportIndex + 1
  return filteredGroups.unshift(new TextEditGroup(newGroupIndex, newGroupIndex, importLines)), filteredGroups
}

function findLastIndex(array, predicate) {
  for (let index = array.length - 1; index >= 0; index--) if (predicate(array[index])) return index
  return -1
}

function trimLeadingSpaces(text) {
  return text.replace(/^\s+/g, '')
}

function isImportStatement(line, languageId) {
  switch (languageId) {
    case 'java':
      return !!line.match(/^\s*import\s/)
    case 'typescript':
    case 'javascript':
      return !!line.match(/^\s*import[\s{*]|^\s*[var|const|let].*=\s*require\(/)
    case 'php':
      return !!line.match(/^\s*use/)
    case 'rust':
      return !!line.match(/^\s*use\s+[\w:{}, ]+\s*(as\s+\w+)?;/)
    case 'python':
      return !!line.match(/^\s*from\s+[\w.]+\s+import\s+[\w, *]+$/) || !!line.match(/^\s*import\s+[\w, ]+$/)
    default:
      return false
  }
}

var tabRegex = /^(\t+)/,
spaceMap = new Map()

function getSpaceRegex(spaceCount) {
  if (!spaceMap.has(spaceCount)) {
    spaceMap.set(spaceCount, new RegExp(`^(( {${spaceCount}})+)`));
  }
  return spaceMap.get(spaceCount);
}

function getIndentationInfo(line, insertSpaces, tabSize) {
  let regex = insertSpaces ? getSpaceRegex(tabSize) : tabRegex,
    match = line.match(regex)
  return match ? [match[0], match[0].length / (insertSpaces ? tabSize : 1)] : ['', 0]
}

function calculateMinIndentLevel(lines) {
  let lineInfo = {
      getLineCount: function () {
        return lines.length
      },
      getLineLength: function (index) {
        return lines[index - 1].length
      },
      getLineContent: function (index) {
        return lines[index - 1]
      },
    },
    { insertSpaces, tabSize } = calculateIndentation(lineInfo, 4, false),
    minIndentLevel = Number.MAX_VALUE

  for (let line of lines) {
    if (/^\s*$/.test(line)) continue
    let [, indentLevel] = getIndentationInfo(line, insertSpaces, tabSize)
    minIndentLevel = Math.min(minIndentLevel, indentLevel)
  }
  return { insertSpaces, tabSize, minIndentLevel }
}

function generateIndentation(character, count) {
  if (count === 0) return ''
  if (character === ' ')
    switch (count) {
      case 2:
        return '  '
      case 4:
        return '    '
      case 8:
        return '        '
      case 12:
        return '            '
    }
  if (character === '\t')
    switch (count) {
      case 1:
        return '\t'
      case 2:
        return '\t\t'
      case 3:
        return '\t\t\t'
    }
  return new Array(count).fill(character).join('')
}

function getIndentLevelFromLines(linesInfo, indentationInfo) {
  let lines = linesInfo.lines,
    lineToCheck
  if (linesInfo.whichLine === 'topMost') lineToCheck = lines.find(line => line !== '')
  else
    for (let i = lines.length - 1; i >= 0; --i)
      if (lines[i] !== '') {
        lineToCheck = lines[i]
        break
      }
  return lineToCheck === undefined ? 0 : getIndentationInfo(lineToCheck, indentationInfo.insertSpaces, indentationInfo.tabSize)[1]
}

function adjustIndentation(lines, linesInfo, indentationInfo) {
  if (indentationInfo === undefined) return lines
  let currentIndentLevel = getIndentLevelFromLines(linesInfo, indentationInfo),
    minIndentInfo = calculateMinIndentLevel(lines),
    indentation = indentationInfo.insertSpaces ? generateIndentation(' ', indentationInfo.tabSize) : '\t'
  return lines.map(line => {
    if (line === '') return ''
    {
      let [indentationString, indentLevel] = getIndentationInfo(line, minIndentInfo.insertSpaces, minIndentInfo.tabSize),
        content = line.substring(indentationString.length)
      return generateIndentation(indentation, currentIndentLevel + (indentLevel - minIndentInfo.minIndentLevel)) + content
    }
  })
}

function identifyMarkerType(markers, line) {
  switch (line) {
    case markers.above.startMarker:
      return { type: 'start', startMarker: markers.above }
    case markers.above.endMarker:
      return { type: 'end', endMarker: markers.above }
    case markers.range.startMarker:
      return { type: 'start', startMarker: markers.range }
    case markers.range.endMarker:
      return { type: 'end', endMarker: markers.range }
    case markers.below.startMarker:
      return { type: 'start', startMarker: markers.below }
    case markers.below.endMarker:
      return { type: 'end', endMarker: markers.below }
  }
  return line.trimStart().startsWith(BlockComment.begin(markers.language))
    ? { type: 'fakestart' }
    : line.trimStart().startsWith(BlockComment.end(markers.language))
    ? { type: 'fakend' }
    : null
}

function generateEdit(serviceLocator, editContext, modifiedLines, options) {
  let computeDiffMetrics = (diffResult, originalLines, modifiedLines) => {
      let totalCharsRemoved = 0
      for (let diff of diffResult)
        for (let lineIndex = diff.originalStart; lineIndex < diff.originalStart + diff.originalLength; lineIndex++) {
          let line = originalLines.lines[lineIndex]
          totalCharsRemoved += line.length
        }
      let originalCharCount = originalLines.getCharCount(),
        modifiedCharCount = modifiedLines.getCharCount(),
        equalCharCount = originalCharCount - totalCharsRemoved
      return {
        equalCharCount: equalCharCount,
        originalCharCount: originalCharCount,
        modifiedCharCount: modifiedCharCount,
        originalCharRatio: originalCharCount > 0 ? equalCharCount / originalCharCount : 0,
        modifiedCharRatio: modifiedCharCount > 0 ? equalCharCount / modifiedCharCount : 0,
      }
    },
    computeDiffForRange = range => {
      let originalLines = new LineOperator(range.lines),
        modifiedLinesOperator = new LineOperator(modifiedLines),
        diffResult = new DiffAlgorithm(originalLines, modifiedLinesOperator).ComputeDiff()
      return computeDiffMetrics(diffResult, originalLines, modifiedLinesOperator)
    },
    entireRange = editContext.range.clone()
  entireRange.mergeFromAbove(editContext.above.clone()), entireRange.mergeFromBelow(editContext.below.clone())
  let entireDiffMetrics = computeDiffForRange(entireRange),
    selectedDiffMetrics = computeDiffForRange(editContext.range),
    diffMetrics = { diffToEntireScore: entireDiffMetrics, diffToRangeScore: selectedDiffMetrics },
    logger = serviceLocator.get(LoggerManager).getLogger('editGeneration')
  if ((logger.info(`Diff metrics: ${JSON.stringify(diffMetrics, null, '	')}`), entireDiffMetrics.originalCharCount > 30 && entireDiffMetrics.originalCharRatio > 0.7))
    return logger.info('(case 1) Replacing entire code'), generateTextEditGroup(entireRange, modifiedLines, options)
  if (selectedDiffMetrics.originalCharCount > 20 && selectedDiffMetrics.originalCharRatio > 0.7)
    return logger.info('(case 2) Replacing selected code'), generateTextEditGroup(editContext.range, modifiedLines, options)
  let minEntireRatio = Math.min(entireDiffMetrics.originalCharRatio, entireDiffMetrics.modifiedCharRatio),
    minSelectedRatio = Math.min(selectedDiffMetrics.originalCharRatio, selectedDiffMetrics.modifiedCharRatio)
  if (minEntireRatio > 0.2 && minEntireRatio > minSelectedRatio) return logger.info('(case 3) Replacing entire code'), generateTextEditGroup(entireRange, modifiedLines, options)
  if (minSelectedRatio > 0.2) return logger.info('(case 4) Replacing selected code'), generateTextEditGroup(editContext.range, modifiedLines, options)
  if (!editContext.range.hasContent)
    return (
      logger.info('(case 5) Replacing empty selected code'),
      generateTextEditGroup(editContext.range, modifiedLines, options, { whichLine: 'bottomMost', lines: editContext.above.lines })
    )
}
function generateTextEditGroup(range, lines, indentation, options) {
  let adjustedLines = adjustIndentation(lines, options ?? { whichLine: 'topMost', lines: range.lines }, indentation).slice(0),
    originalLines = range.lines.slice(0),
    firstLineIndex = range.firstLineIndex,
    lastLineIndex = range.lastLineIndex
  if (originalLines.length === 1 && originalLines[0] === '') return new TextEditGroup(lastLineIndex, lastLineIndex, adjustedLines)
  let commonPrefixLength = findCommonPrefixLength(originalLines, adjustedLines)
  if (((firstLineIndex += commonPrefixLength), originalLines.splice(0, commonPrefixLength), adjustedLines.splice(0, commonPrefixLength), originalLines.length === 0)) return new TextEditGroup(lastLineIndex + 1, lastLineIndex + 1, adjustedLines)
  let commonSuffixLength = findCommonSuffixLength(originalLines, adjustedLines)
  return (
    (lastLineIndex -= commonSuffixLength),
    originalLines.splice(originalLines.length - commonSuffixLength, commonSuffixLength),
    adjustedLines.splice(adjustedLines.length - commonSuffixLength, commonSuffixLength),
    originalLines.length === 0 ? new TextEditGroup(firstLineIndex, firstLineIndex, adjustedLines) : new TextEditGroup(firstLineIndex, lastLineIndex + 1, adjustedLines)
  )
}

function findCommonPrefixLength(array1, array2) {
  let minLength = Math.min(array1.length, array2.length)
  for (let index = 0; index < minLength; index++) if (array1[index] !== array2[index]) return index
  return minLength
}

function findCommonSuffixLength(array1, array2) {
  let minLength = Math.min(array1.length, array2.length)
  for (let index = 0; index < minLength; index++) if (array1[array1.length - 1 - index] !== array2[array2.length - 1 - index]) return index
  return minLength
}

function createTextEditGroupAtFirstLine(range, lines) {
  return new TextEditGroup(range.firstLineIndex, range.firstLineIndex, lines)
}

function appendToBottom(range, lines, indentation) {
  let adjustedLines = adjustIndentation(lines, { whichLine: 'bottomMost', lines: range.lines }, indentation),
    nextLineIndex = range.lastLineIndex + 1
  return new TextEditGroup(nextLineIndex, nextLineIndex, adjustedLines)
}

function createInlineEdit(edits, newWholeRange, content, followUp) {
  return { type: 'inlineEdit', edits: edits, newWholeRange: newWholeRange, content: content, followUp: followUp }
}

function extractCodeBlock(context, text, filePathComment) {
  let codeBlock = findCodeBlock(context, text)
  if (!codeBlock) return null
  let { code, contentBeforeCode, language } = codeBlock
  if (FilePathComment.testLine(filePathComment, code)) {
    let newLineIndex = code.indexOf(`
`)
    code = code.substring(newLineIndex).trim()
  }
  return { code, contentBeforeCode, language }
}

function findCodeBlock(context, text) {
  text = text.trim()
  let codeStartIndex = text.startsWith('```') ? 0 : text.indexOf('```')
  if (codeStartIndex !== -1) {
    let codeEndIndex = text.indexOf('\n```', codeStartIndex + 1)
    codeEndIndex === -1 && (codeEndIndex = text.indexOf('```', codeStartIndex + 1))
    let codeBlockEndIndex = codeEndIndex !== -1 ? codeEndIndex : text.length,
      codeContentStartIndex = text.indexOf(
        `
`,
        codeStartIndex + 1
      ),
      codeContent = text.substring(codeContentStartIndex, codeBlockEndIndex)
    codeContent = codeContent.trim()
    let contentBeforeCode = text.substring(0, codeStartIndex).trim(),
      language = text.substring(codeStartIndex + 3, codeContentStartIndex).trim()
    return { code: codeContent, contentBeforeCode, language }
  }
  let lines = text.split(/\r\n|\r|\n/g),
    isCodeStarted = false,
    contentLines = [],
    codeLines = []
  for (let line of lines) {
    let markerType = identifyMarkerType(context, line)
    if (isCodeStarted) {
      if (markerType)
        return (
          codeLines.push(line),
          {
            code: codeLines.join(`
`),
            contentBeforeCode: contentLines.join(`
`),
            language: '',
          }
        )
      codeLines.push(line)
    } else markerType ? ((isCodeStarted = true), codeLines.push(line)) : contentLines.push(line)
  }
  return null
}

var BaseVariableResolver = class {}
async function resolveContexts(context, resolvers, param1, param2, param3) {
  let resolvedContexts = await Promise.all(resolvers.map(resolver => resolver.resolveContext(context, param1, param2, param3)))
  return filterTruthyValues(resolvedContexts)
}

function filterKinds(kinds, filterSet) {
  let filteredKinds = [],
    kindMap = new Map()
  for (let kind of kinds)
    if (!filterSet.has(kind.kind) && !kindMap.has(kind.kind)) {
      kindMap.set(kind.kind, filteredKinds.length)
      filteredKinds.push(kind)
    }
  let kindIndex = kindMap.get(activeEditorContextResolver.kind)
  if (kindIndex !== void 0 && kindMap.has(currentSelectionContextResolver.kind))
    filteredKinds.splice(kindIndex, 1)
  return filteredKinds
}

var ChatMessageProcessor = class {
  constructor(accessor, maxResponseTokens, maxTokenTestOverride) {
    this.accessor = accessor;
    this.maxResponseTokens = maxResponseTokens;
    this.maxTokenTestOverride = maxTokenTestOverride;
  }

  async toChatMessages(chatSession, systemContent, tokenLimit, isContextMerged = false) {
    let maxTokens = await this.computeMaxRequestTokens(tokenLimit),
      successfulTurns = chatSession.turns.filter(turn => turn.status === 'success' || turn.status === 'in-progress'),
      messages = [{ role: 'system', content: systemContent }],
      totalTokenCount = calculateTokenLength(this.accessor, messages),
      contextMessages = [];

    for (let i = successfulTurns.length - 1; i >= 0; i--) {
      let isLastTurn = i === successfulTurns.length - 1,
        currentTurn = successfulTurns[i],
        turnMessages = await this.turnToMessages(currentTurn, isLastTurn),
        turnTokenCount = calculateTokenLength(this.accessor, turnMessages);

      while (totalTokenCount + turnTokenCount >= maxTokens && turnMessages.length >= 1) {
        turnMessages.shift();
        turnTokenCount = calculateTokenLength(this.accessor, turnMessages);
      }

      if (!turnMessages.length && currentTurn instanceof ShortMessageSession) {
        let shorterMessage = await currentTurn.getShorterMessage();
        turnMessages.push({ role: 'user', content: shorterMessage, isContext: true });
        turnTokenCount = calculateTokenLength(this.accessor, turnMessages);

        while (totalTokenCount + turnTokenCount >= maxTokens && turnMessages.length >= 1) {
          turnMessages.shift();
          turnTokenCount = calculateTokenLength(this.accessor, turnMessages);
        }

        if (!turnMessages.length) throw new Error(vscodeL10n.t('Sorry, the included context is too long.'));
      }

      if (isLastTurn && !turnMessages.length) throw new Error(vscodeL10n.t('Sorry, this message is too long. Please try a shorter question.'));

      if (totalTokenCount + turnTokenCount < maxTokens) {
        contextMessages = [...turnMessages, ...contextMessages];
        totalTokenCount += turnTokenCount;
      } else break;
    }

    if (isContextMerged) {
      let lastMessage = messages[messages.length - 1];
      for (let i = messages.length - 2; i >= 0; i--) {
        let currentMessage = messages[i];
        if (currentMessage.isContext) {
          lastMessage.content = currentMessage.content + '\n\n' + lastMessage.content;
          messages.splice(i, 1);
        } else break;
      }
    }

    return { messages: messages.map(message => ({ role: message.role, content: message.content })), tokenCount: totalTokenCount };
  }
  async computeMaxRequestTokens(modelParams) {
    let maxTokenWindow = this.maxTokenTestOverride ?? modelParams.modelMaxTokenWindow
    if (this.maxResponseTokens !== void 0) return maxTokenWindow - this.maxResponseTokens
    let tokenRatio = maxTokenWindow < 8192 ? 0.25 : maxTokenWindow < 16384 ? 0.15 : 0.1
    return Math.floor(maxTokenWindow * (1 - tokenRatio))
  }
  async turnToMessages(turn, isLastTurn) {
    let messages = []
    if (isLastTurn) {
      turn.contextParts.forEach(contextPart => {
        contextPart.userMessages.forEach(userMessage => {
          messages.push({
            role: 'user',
            content: userMessage + `\n\n`,
          })
        })
      })
    }
    messages.push({ role: 'user', content: turn.request.message, isContext: turn.request.isContext })
    if (turn.response && turn.response.type !== 'meta') {
      messages.push({ role: 'assistant', content: turn.response.message })
    }
    return messages
  }
}
var ChatBuilder = class {
  constructor(accessor, options, location, context) {
    this.accessor = accessor;
    this.options = options;
    this.location = location;
    this.context = context;
    this._promptVariablesService = accessor.get(BaseVariableResolver);
  }
  get selectionContextMetadata() {
    return this._selectionContextMetadata;
  }
  async buildPrompt(conversation, endpoint, variables, reporter, context, session) {
    let latestTurn = conversation.getLatestTurn(),
      resolvedPrompt = await this._promptVariablesService.resolveVariablesInPrompt(latestTurn.request.message, variables),
      kindsSet = new Set(resolvedPrompt.parts.map(part => part.kind));
    latestTurn.request.message = resolvedPrompt.message;
    let contextResolvers = this.options.contextResolvers;
    Array.isArray(contextResolvers) || (contextResolvers = await contextResolvers.provideResolvers(conversation, context, session));
    contextResolvers = filterKinds(contextResolvers, kindsSet);
    let promptContext = { conversation: conversation, endpoint: endpoint, message: latestTurn.request.message, documentContext: this.context },
      resolvedContexts = await resolveContexts(this.accessor, contextResolvers, promptContext, session, reporter),
      sessions = [],
      references = [];
    for (let { userMessages: messages, usedContext: usedDocs, references: refs, metadata: meta, getShorterMessage: getShortMsg } of [
      resolvedPrompt.parts,
      resolvedContexts,
    ].flat()) {
      for (let message of messages)
        getShortMsg
          ? sessions.push(new ShortMessageSession({ message: message, type: 'user', isContext: true }, getShortMsg))
          : sessions.push(new Session({ message: message, type: 'user', isContext: true }));
      usedDocs && reporter.report({ documents: usedDocs });
      refs && references.push(...refs);
      !this._selectionContextMetadata && contextInfo.is(meta) && (this._selectionContextMetadata = meta);
    }
    let uniqueReferences = processAnchors(references);
    for (let ref of uniqueReferences) reporter.report({ reference: ref.anchor });
    conversation = new Conversation(conversation.turns);
    sessions.length > 0 && conversation.insertBeforeLatestTurn(sessions);
    let systemMessage;
    if (this.location === 1) {
      let rules = this.options.rules ?? (this.context && generateInstructions(this.context));
      systemMessage = this.createInlineChatSystemMessage(rules ?? '');
    } else if (this.location === 2) {
      systemMessage = await this.createPanelChatSystemMessage(endpoint);
    }
    systemMessage ??= await generateAssistantMessage(this.accessor, this.location, endpoint);
    if (this.options.turnFilter && this.location === 2) {
      let filteredTurns = this.options.turnFilter(conversation.turns);
      conversation = new Conversation(filteredTurns);
    }
    let latestTurnAfterFilter = conversation.getLatestTurn();
    if (latestTurnAfterFilter) {
      latestTurnAfterFilter.references = uniqueReferences;
      if (this.options.queryPrefix) {
        latestTurnAfterFilter.request.message = `${this.options.queryPrefix} ${latestTurnAfterFilter.request.message}`.trim();
      }
    }
    return new ChatMessageProcessor(this.accessor, this.accessor.get(conversationOptions).maxResponseTokens).toChatMessages(conversation, systemMessage, endpoint, false);
  }
  async createPanelChatSystemMessage(endpoint) {
    let systemPromptOptions = this.options.systemPromptOptions?.roleplay || this.options.systemPromptOptions,
      assistantMessage = systemPromptOptions
        ? await generateAssistantMessage(this.accessor, this.location, endpoint, this.options.systemPromptOptions)
        : await generateAssistantMessage(this.accessor, this.location, endpoint, { includeCodeGenerationRules: true, includeCapabilities: true }),
      rules = this.options.rules ?? '';
    return `
${assistantMessage}

${rules ? 'Additional Rules' : ''}
${rules ?? ''}

${this.options.systemPromptOptions?.examples ? 'Examples:' : ''}
${this.options.systemPromptOptions?.examples ?? ''}
`.trim();
  }
  createInlineChatSystemMessage(rules) {
    return `
${this.options.systemPromptOptions?.roleplay ?? getAssistantIntroduction()}
${getAssistantIdentity()}
${rules}
${getAssistantExpertise()}
${getLocaleResponse(this.accessor)}
`.trim();
  }
};
var generateInstructions = t =>
    `
The user has a ${t.language.languageId} file opened in a code editor.
The user includes some code snippets from the file.
Each code block starts with \`\`\` and ${FilePathComment.forLanguage(t.language)}.
Answer with a single ${t.language.languageId} code block.
If you modify existing code, you will use the ${BlockComment.begin(t.language)} and ${BlockComment.end(t.language)} markers.
${isNotebookCell(t.document.uri) ? generateNotebookInstructions() : ''}
`.trim()
function generateNotebookInstructions() {
  return `
When dealing with Jupyter Notebook, if a module is already imported in a cell, it can be used in other cells directly without importing it again. For the same reason, if a variable is defined in a cell, it can be used in other cells as well
When dealing with Jupyter Notebook, cells below the current cell can be executed before the current cell, you must use the variables defined in the cells below, unless you want to overwrite them.
When dealing with Jupyter Notebook, do not generate CELL INDEX in the code blocks in your answer, it is only used to help you understand the context.
`.trim()
}
var StreamProcessor = class {
  constructor(document, language, selection, defaultEditStrategy) {
    this.document = document
    this.language = language
    this.selection = selection
    this.defaultEditStrategy = defaultEditStrategy
    this.indentationTracker = null
  }
  async processStream(stream) {
    stream = extractCode(stream);
    stream = filterComments(stream, this.language);
    let lineIndex = this.document.firstSentLineIndex;
    for await (let line of this.findInitialAnchor(stream))
      typeof line != 'string'
        ? (lineIndex = this.handleFirstReplyLine(line.anchor, line.line))
        : (lineIndex = this.handleSubsequentReplyLine(lineIndex, line));
    if (this.document.didReplaceEdits && lineIndex <= this.document.lastRangeLine.lineIndex) {
        this.document.deleteLines(lineIndex, this.document.lastRangeLine.lineIndex);
    }
    return this.document.didEdits;
  }
  handleFirstReplyLine(anchor, line) {
    if (anchor) {
      this.indentationTracker = new IndentationTracker(this.document, anchor.lineIndex, line);
      let reindentedLine = this.indentationTracker.reindent(line, this.document.indentStyle);
      if (this.document.getLine(anchor.lineIndex).sentInCodeBlock === 2) {
        return this.document.replaceLines(this.document.firstRangeLine.lineIndex, anchor.lineIndex, reindentedLine);
      } else {
        return this.document.replaceLine(anchor.lineIndex, reindentedLine);
      }
    }
    let firstLineIndex = this.document.firstRangeLine.lineIndex;
    this.indentationTracker = new IndentationTracker(this.document, firstLineIndex, line);
    let reindentedLine = this.indentationTracker.reindent(line, this.document.indentStyle);
    if (this.selection.isEmpty &&
      this.document.getLine(this.selection.active.line).content === '' &&
      this.selection.active.line === this.document.firstRangeLine.lineIndex) {
      return this.document.insertLineBefore(firstLineIndex, reindentedLine);
    } else if (this.defaultEditStrategy === 1) {
      return this.document.insertLineBefore(firstLineIndex, reindentedLine);
    } else if (this.defaultEditStrategy === 3) {
      return this.document.insertLineAfter(firstLineIndex, reindentedLine);
    } else {
      return this.document.replaceLine(firstLineIndex, reindentedLine);
    }
  }
  handleSubsequentReplyLine(lineIndex, line) {
    let reindentedLine = this.indentationTracker.reindent(line, this.document.indentStyle);
    if (reindentedLine.trimmedContent !== '' || this.document.didReplaceEdits) {
      let matchedLine = this.matchReplyLine(reindentedLine, lineIndex);
      if (matchedLine) return this.document.replaceLines(lineIndex, matchedLine.lineIndex, reindentedLine);
    }
    if (lineIndex >= this.document.getLineCount()) return this.document.appendLineAtEndOfDocument(reindentedLine);
    let currentLine = this.document.getLine(lineIndex);
    if (!currentLine.isSent || currentLine.content === '' || reindentedLine.trimmedContent === '') {
      return this.document.insertLineBefore(lineIndex, reindentedLine);
    } else if (currentLine.indentLevel < reindentedLine.adjustedIndentLevel) {
      return this.document.insertLineBefore(lineIndex, reindentedLine);
    } else if (currentLine.indentLevel === reindentedLine.adjustedIndentLevel && !this.document.didReplaceEdits) {
      return this.document.insertLineBefore(lineIndex, reindentedLine);
    } else {
      return this.document.replaceLine(lineIndex, reindentedLine);
    }
  }
  matchReplyLine(line, lineIndex) {
    let isShortLine = line.trimmedContent.length <= 3;
    for (let i = lineIndex; i < this.document.getLineCount(); i++) {
      let currentLine = this.document.getLine(i);
      if (currentLine.isSent) {
        if (currentLine.normalizedContent === line.adjustedContent) return new LineIndex(i);
        if ((currentLine.trimmedContent.length > 0 && currentLine.indentLevel < line.adjustedIndentLevel) ||
          (isShortLine && currentLine.trimmedContent.length > 0)) {
          return null;
        }
      }
    }
    return null;
  }
  findInitialAnchor(stream) {
    return new AsyncIterable(async emitter => {
      let lines = [],
        totalLength = 0,
        foundAnchor = false;
      for await (let line of stream) {
        if (foundAnchor) emitter.emitOne(line);
        else {
          lines.push(line);
          totalLength += line.trim().length;
          if (totalLength > 10) {
            let equalSentLine = this.searchForEqualSentLines(lines);
            foundAnchor = true;
            emitter.emitOne(new AnchorLine(lines[0], equalSentLine));
            emitter.emitMany(lines.slice(1));
          }
        }
      }
    });
  }
  searchForEqualSentLines(lines) {
    let trimmedLines = lines.map(line => line.trim());
    for (let i = this.document.firstSentLineIndex, end = this.document.getLineCount() - lines.length; i <= end; i++) {
      if (!this.document.getLine(i).isSent) continue;
      let isMatch = true;
      for (let j = 0; j < trimmedLines.length; j++) {
        let currentLine = this.document.getLine(i + j);
        if (!currentLine.isSent || currentLine.trimmedContent !== trimmedLines[j]) {
          isMatch = false;
          break;
        }
      }
      if (isMatch) return new LineIndex(i);
    }
    return null;
  }
};
class IndentationTracker {
  constructor(document, lineIndex, lineContent) {
    let indentLevel = 0
    for (let i = lineIndex; i >= 0; i--) {
      let currentLine = document.getLine(i)
      if (!/^\s*$/.test(currentLine.content)) {
        indentLevel = currentLine.indentLevel
        break
      }
    }
    this._replyIndentStyle = IndentationHelper.guessIndentStyleFromLine(lineContent)
    let calculatedIndentLevel = calculateIndentationLevel(lineContent, this._replyIndentStyle?.tabSize ?? 4)
    calculatedIndentLevel === -1 && (calculatedIndentLevel = 0), (this.indentDelta = calculatedIndentLevel - indentLevel)
  }
  reindent(lineContent, indentStyle) {
    if (lineContent === '') return new LineContent('', 0, '', 0)
    this._replyIndentStyle || (this._replyIndentStyle = IndentationHelper.guessIndentStyleFromLine(lineContent))
    let originalIndentLevel = 0,
      adjustedIndentLevel = 0,
      adjustIndentLevel = indentLevel => ((originalIndentLevel = indentLevel), (adjustedIndentLevel = Math.max(originalIndentLevel - this.indentDelta, 0)), adjustedIndentLevel),
      reindentedLine = IndentationHelper.reindentLine(lineContent, this._replyIndentStyle ?? { insertSpaces: true, tabSize: 4 }, indentStyle, adjustIndentLevel)
    return new LineContent(lineContent, originalIndentLevel, reindentedLine, adjustedIndentLevel)
  }
}
class AnchorLine {
  constructor(line, anchor) {
    this.line = line
    this.anchor = anchor
  }
}
class CodeEditor {
  constructor(progress, document, rangeInfo, indentSize) {
    this.progress = progress;
    this.lines = [];
    this._didEdits = false;
    this._didReplaceEdits = false;
    this.indentStyle = IndentationHelper.getDocumentIndentStyle(rangeInfo, indentSize);
    let textLines = document.getText().split(/\r\n|\r|\n/g);
    for (let index = 0; index < textLines.length; index++) {
      this.lines[index] = new CodeBlock(textLines[index], this.indentStyle);
    }
    let markLines = (range, mark) => {
      for (let index = 0; index < range.lines.length; index++) {
        let lineIndex = range.firstLineIndex + index;
        this.lines[lineIndex].markSent(mark);
      }
    };
    markLines(rangeInfo.above, 1);
    markLines(rangeInfo.range, 2);
    markLines(rangeInfo.below, 3);
    this.firstSentLineIndex = rangeInfo.above.hasContent ? rangeInfo.above.firstLineIndex : rangeInfo.range.firstLineIndex;
    this.firstRangeLine = new LineIndex(rangeInfo.range.firstLineIndex);
    this.lastRangeLine = new LineIndex(rangeInfo.range.firstLineIndex + rangeInfo.range.lines.length - 1);
  }
  get didEdits() {
    return this._didEdits;
  }
  get didReplaceEdits() {
    return this._didReplaceEdits;
  }
  getText() {
    return this.lines.map(line => line.content).join('\n');
  }
  getLineCount() {
    return this.lines.length;
  }
  getLine(index) {
    return this.lines[index];
  }
  replaceLine(index, lineContent) {
    this.lines[index] = new CodeBlock(lineContent.adjustedContent, this.indentStyle);
    this.progress.report({ edits: [new VscodeTextEdit(new VscodeRange(index, 0, index, 1e3), lineContent.adjustedContent)] });
    this._didEdits = true;
    this._didReplaceEdits = true;
    return index + 1;
  }
  replaceLines(startIndex, endIndex, lineContent) {
    if (startIndex === endIndex) {
      return this.replaceLine(startIndex, lineContent);
    } else {
      this.lines.splice(startIndex, endIndex - startIndex + 1, new CodeBlock(lineContent.adjustedContent, this.indentStyle));
      this.progress.report({ edits: [new Zs(new VscodeRange(startIndex, 0, endIndex, 1e3), lineContent.adjustedContent)] });
      this._didEdits = true;
      this._didReplaceEdits = true;
      return startIndex + 1;
    }
  }
  appendLineAtEndOfDocument(lineContent) {
    this.lines.push(new CodeBlock(lineContent.adjustedContent, this.indentStyle));
    this.progress.report({
      edits: [
        new VscodeTextEdit(
          new VscodeRange(this.lines.length - 1, 1e3, this.lines.length - 1, 1e3),
          '\n' + lineContent.adjustedContent
        ),
      ],
    });
    this._didEdits = true;
    return this.lines.length;
  }
  insertLineAfter(index, lineContent) {
    this.lines.splice(index + 1, 0, new CodeBlock(lineContent.adjustedContent, this.indentStyle));
    this.progress.report({
      edits: [
        new VscodeTextEdit(
          new VscodeRange(index, 1e3, index, 1e3),
          '\n' + lineContent.adjustedContent
        ),
      ],
    });
    this._didEdits = true;
    return index + 2;
  }
  insertLineBefore(index, lineContent) {
    this.lines.splice(index, 0, new CodeBlock(lineContent.adjustedContent, this.indentStyle));
    this.progress.report({
      edits: [
        new VscodeTextEdit(
          new VscodeRange(index, 0, index, 0),
          lineContent.adjustedContent + '\n'
        ),
      ],
    });
    this._didEdits = true;
    return index + 1;
  }
  deleteLines(startIndex, endIndex) {
    this.lines.splice(startIndex, endIndex - startIndex + 1);
    this.progress.report({ edits: [new VscodeTextEdit(new VscodeRange(startIndex, 0, endIndex + 1, 0), '')] });
    this._didEdits = true;
    this._didReplaceEdits = true;
    return startIndex + 1;
  }
}
class LineContent {
  constructor(originalContent, originalIndentLevel, adjustedContent, adjustedIndentLevel) {
    this.originalContent = originalContent
    this.originalIndentLevel = originalIndentLevel
    this.adjustedContent = adjustedContent
    this.adjustedIndentLevel = adjustedIndentLevel
    this.trimmedContent = this.originalContent.trim()
  }
}

class LineIndex {
  constructor(index) {
    this.lineIndex = index
  }
}

class CodeBlock {
  constructor(content, indentStyle) {
    this.content = content
    this._indentStyle = indentStyle
    this._sentInCodeBlock = 0
    this._trimmedContent = null
    this._normalizedContent = null
    this._indentLevel = -1
  }
  get isSent() {
    return this._sentInCodeBlock !== 0
  }
  get sentInCodeBlock() {
    return this._sentInCodeBlock
  }
  get trimmedContent() {
    if (this._trimmedContent === null) {
      this._trimmedContent = this.content.trim()
    }
    return this._trimmedContent
  }
  get normalizedContent() {
    if (this._normalizedContent === null) {
      this._normalizedContent = replaceIndentation(this.content, this._indentStyle.tabSize, this._indentStyle.insertSpaces)
    }
    return this._normalizedContent
  }
  get indentLevel() {
    if (this._indentLevel === -1) {
      this._indentLevel = calculateIndentationLevel(this.content, this._indentStyle.tabSize)
      if (this._indentLevel === -1) {
        this._indentLevel = 0
      }
    }
    return this._indentLevel
  }
  markSent(sentInCodeBlock) {
    this._sentInCodeBlock = sentInCodeBlock
  }
}

class IndentationHelper {
  static getDocumentIndentStyle(documentRange, indentStyle) {
    if (indentStyle) return indentStyle
    let document = documentRange.document
    return calculateIndentation(
      {
        getLineCount: function () {
          return document.lineCount
        },
        getLineLength: function (lineNumber) {
          return document.lineAt(lineNumber - 1).text.length
        },
        getLineContent: function (lineNumber) {
          return document.lineAt(lineNumber - 1).text
        },
      },
      4,
      false
    )
  }
  static guessIndentStyleFromLine(line) {
    let leadingWhitespace = IndentationHelper._getLeadingWhitespace(line)
    return leadingWhitespace === '' || leadingWhitespace === ' '
      ? undefined
      : calculateIndentation(
          {
            getLineCount: function () {
              return 1
            },
            getLineLength: function () {
              return line.length
            },
            getLineContent: function () {
              return line
            },
          },
          4,
          false
        )
  }
  static reindentLine(line, oldIndentStyle, newIndentStyle, adjustIndentLevel = level => level) {
    let indentLevel = calculateIndentationLevel(line, oldIndentStyle.tabSize)
    indentLevel === -1 && ((indentLevel = 0), (line = ''))
    let targetIndentLevel = adjustIndentLevel(indentLevel)
    while (indentLevel > 0) {
      line = this._outdent(line, oldIndentStyle)
      indentLevel--
    }
    while (indentLevel < targetIndentLevel) {
      line = '\t' + line
      indentLevel++
    }
    return replaceIndentation(line, newIndentStyle.tabSize, newIndentStyle.insertSpaces)
  }
  static _outdent(line, indentStyle) {
    let index = 0
    while (index < line.length) {
      let charCode = line.charCodeAt(index)
      if (charCode === 9 || (charCode === 32 && index === indentStyle.tabSize)) {
        break
      }
      index++
    }
    return line.substring(index)
  }
  static _getLeadingWhitespace(line) {
    for (let index = 0; index < line.length; index++) {
      let charCode = line.charCodeAt(index)
      if (charCode !== 32 && charCode !== 9) return line.substring(0, index)
    }
    return line
  }
}

function processCodeBlocks(input) {
  return new AsyncIterable(async output => {
    let state
    ;(stateEnum => (
      (stateEnum[(stateEnum.BeforeCodeBlock = 0)] = 'BeforeCodeBlock'),
      (stateEnum[(stateEnum.InCodeBlock = 1)] = 'InCodeBlock'),
      (stateEnum[(stateEnum.AfterCodeBlock = 2)] = 'AfterCodeBlock')
    ))((state ||= {}))
    let currentState = 0
    for await (let line of input) {
      if (currentState === 0) {
        if (/^```/.test(line)) {
          (currentState = 1), output.emitOne({ value: line, kind: 2 })
          continue
        }
      } else currentState === 1 && /^```/.test(line) && (currentState = 2)
      output.emitOne({ value: line, kind: currentState === 1 ? 1 : 2 })
    }
  })
}

function filterComments(input, language) {
  return new AsyncIterable(async output => {
    let commentStart = BlockComment.begin(language),
      commentEnd = BlockComment.end(language),
      isFirstLine = true,
      isNotEmpty = false
    for await (let line of input) {
      if (isFirstLine && FilePathComment.testLine(language, line)) {
        isFirstLine = false
        continue
      }
      ;(!isNotEmpty && /^\s*$/.test(line)) || line.startsWith(commentStart) || line.startsWith(commentEnd) || ((isNotEmpty = true), output.emitOne(line))
    }
  })
}

function extractCode(input) {
  let lines = splitLines(input)
  return processCodeBlocks(lines)
    .filter(line => line.kind === 1)
    .map(line => line.value)
}

function splitLines(input) {
  return new AsyncIterable(async output => {
    let buffer = ''
    for await (let chunk of input) {
      buffer += chunk
      do {
        let newlineIndex = buffer.indexOf(`
`)
        if (newlineIndex === -1) break
        let line = buffer.substring(0, newlineIndex)
        ;(buffer = buffer.substring(newlineIndex + 1)), output.emitOne(line)
      } while (!0)
    }
    buffer.length > 0 && output.emitOne(buffer)
  })
}

class ProgressMessageGenerator {
  constructor() {
    this._data = new Map()
    this._messages = {
      0: ProgressMessageGenerator._shuffleArray(ProgressMessageGenerator._progressMessages[0]),
      1: ProgressMessageGenerator._shuffleArray(ProgressMessageGenerator._progressMessages[1]),
      2: ProgressMessageGenerator._shuffleArray(ProgressMessageGenerator._progressMessages[2]),
      3: ProgressMessageGenerator._shuffleArray(ProgressMessageGenerator._progressMessages[3]),
    }
  }
  static {
    this._progressMessages = {
      0: [
        requestLight.t("Fetching response, it won't be long now."),
        requestLight.t('Working hard to get your response...'),
        requestLight.t('Request is being processed, sit tight!'),
        requestLight.t('Response is being prepared, please be patient.'),
      ],
      1: [
        requestLight.t('Data is on its way, please wait a moment.'),
        requestLight.t('Request is being processed, sit tight!'),
        requestLight.t('Response is being prepared, please be patient.'),
      ],
      2: [
        requestLight.t('Data is on its way, please wait a moment.'),
        requestLight.t('Source code arriving...'),
        requestLight.t("Hold on tight, we're almost there!"),
        requestLight.t('Response is being prepared, please be patient.'),
        requestLight.t('Code chunks incoming...'),
        requestLight.t('Receiving code, please wait...'),
        requestLight.t('Code is being processed, please wait...'),
      ],
      3: [requestLight.t('Almost done, just a few more seconds...'), requestLight.t('Processing response, please wait...')],
    }
  }
  next(progressType) {
    let progressData = this._data.get(progressType)
    if (progressData) {
      if (Date.now() - progressData.time < 3579) return this._messages[progressType][progressData.index]
      progressData.index += 1
      progressData.time = Date.now()
      let messages = this._messages[progressType]
      return messages[Math.min(messages.length - 1, progressData.index)]
    } else {
      this._data.set(progressType, { index: 0, time: Date.now() })
      return this._messages[progressType][0]
    }
  }
  static _shuffleArray(array) {
    return shuffleArray(array), array
  }
}
class ProgressReporter {
  constructor(progress) {
    this.progress = progress
    this._progressMessages = new ProgressMessageGenerator()
    this._lastText = undefined
  }
  _reportProgress(progressType) {
    let message = this._progressMessages.next(progressType)
    this.progress.report({ message: message })
  }
  update(text) {
    this._reportProgress(this._lastText ? (text.includes('```') ? 2 : 1) : 0)
    this._lastText = text
    return { shouldFinish: isCodeBlock(text) }
  }
  async finish() {
    if (!this._lastText) throw new Error('No text')
    this._reportProgress(3)
    return await this.interpretReply(this._lastText)
  }
}
class ReplyInterpreter extends ProgressReporter {
  constructor(interpreter, progress) {
    super(progress)
    this.replyInterpreter = interpreter
  }
  static createFactory(interpreter) {
    return progress => new ReplyInterpreter(interpreter, progress)
  }
  interpretReply(reply) {
    return this.replyInterpreter(reply, this.progress)
  }
}
class CodeReplyInterpreter extends ProgressReporter {
  constructor(accessor, selectionContextMetadata, context, editStrategy, progress) {
    super(progress)
    this.accessor = accessor
    this.selectionContextMetadata = selectionContextMetadata
    this.context = context
    this.editStrategy = editStrategy
  }
  static createFactory(accessor, selectionContext, context, editStrategy = 2) {
    return progress => {
      if (!selectionContext.selectionContextMetadata) throw new Error('code reply NEEDS a selection context')
      return new CodeReplyInterpreter(accessor, selectionContext.selectionContextMetadata, context, editStrategy, progress)
    }
  }
  interpretReply(reply) {
    if (!this.selectionContextMetadata) throw new Error('code reply NEEDS a selection context')
    let { contextInfo, expandedRange } = this.selectionContextMetadata,
      codeBlock = extractCodeBlock(contextInfo, reply, this.context.language)
    if (!codeBlock) return { type: 'conversational', content: reply }
    let { code } = codeBlock,
      processedText = processInputText(
        this.accessor,
        contextInfo,
        code,
        this.editStrategy,
        this.context.fileIndentInfo,
        DocumentContext.fromDocumentContext(this.context)
      )
    return createInlineEdit(processedText, expandedRange)
  }
}
class StreamProcessor {
  constructor(progress) {
    this._progress = progress
    this._responseStream = new DeferredAsyncIterable()
    this._lastLength = 0
    this._lastText = undefined
    this._promise = undefined
    this._progressMessages = new ProgressMessageGenerator()
  }
  static createFactory() {
    return progress => new StreamProcessor(progress)
  }
  _reportProgress(progressType) {
    let message = this._progressMessages.next(progressType)
    this._progress.report({ message: message })
  }
  update(text) {
    if (!this._promise) {
      this._reportProgress(0)
      this._promise = this.processStream(this._responseStream, this._progress)
    }
    this._reportProgress(1)
    let newText = text.slice(this._lastLength)
    this._lastLength = text.length
    this._lastText = text
    this._responseStream.emitOne(newText)
    return { shouldFinish: false }
  }
  async finish() {
    this._responseStream.resolve()
    return { type: 'conversational', content: this._lastText ?? '' }
  }
  async processStream(stream, progress) {
    for await (let content of stream.asyncIterable) progress.report({ content: content })
    return false
  }
}
function applyTextEdits(text, edits) {
  let offsetCalculator = new OffsetCalculator(text),
    sortedEdits = edits.map(edit => {
      let range = edit.range
      return { startOffset: offsetCalculator.getOffset(range.start), endOffset: offsetCalculator.getOffset(range.end), text: edit.newText }
    })
  sortedEdits.sort((edit1, edit2) => edit2.startOffset - edit1.startOffset || edit2.endOffset - edit1.endOffset)
  for (let edit of sortedEdits) text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset)
  return text
}

class OffsetCalculator {
    constructor(text) {
      this.lineStartOffsetByLineIdx = []
      this.lineStartOffsetByLineIdx.push(0)
      for (let i = 0; i < text.length; i++)
        if (text.charAt(i) === '\n') this.lineStartOffsetByLineIdx.push(i + 1)
      this.lineStartOffsetByLineIdx.push(text.length)
    }
    getOffset(position) {
      return this.lineStartOffsetByLineIdx[position.line] + position.character
    }
}
class CodeReplyInterpreter {
  constructor(accessor, selectionContextMetadata, context, editStrategy, progress) {
    this._accessor = accessor
    this._selectionContextMetadata = selectionContextMetadata
    this._context = context
    this._editStrategy = editStrategy
    this._progress = progress
    this._responseStream = new DeferredAsyncIterable()
    this._lastLength = 0
    this._lastText = undefined
    this._streamingPromise = undefined
    this._initialDocText = this._context.document.getText()
    this._progressMessages = new ProgressMessageGenerator()
    this._documentInfo = DocumentContext.fromDocumentContext(this._context)
    if (!this._selectionContextMetadata) throw new Error('code reply NEEDS a selection context')
    this._streamingWorkingCopyDocument = new CodeEditor(
      progress,
      this._context.document,
      this._selectionContextMetadata.contextInfo,
      this._context.fileIndentInfo
    )
    let streamProcessor = new StreamProcessor(
      this._streamingWorkingCopyDocument,
      this._context.language,
      this._context.selection,
      this._editStrategy
    )
    this._streamingPromise = streamProcessor.processStream(this._responseStream.asyncIterable)
  }
  static createFactory(accessor, metadata, context, editStrategy = 2) {
    return (progress, shouldCreateNewInstance) => {
      if (!metadata.selectionContextMetadata) throw new Error('code reply NEEDS a selection context')
      return shouldCreateNewInstance ? new CodeReplyInterpreter(accessor, metadata.selectionContextMetadata, context, editStrategy, progress) : new CodeReplyInterpreter(accessor, metadata.selectionContextMetadata, context, editStrategy, progress)
    }
  }
  update(text) {
    this._reportMessageProgress(this._lastText ? 2 : 0), (this._lastText = text)
    let newText = text.slice(this._lastLength)
    this._lastLength = text.length
    this._responseStream.emitOne(newText)
    return { shouldFinish: isCodeBlock(text) }
  }
  _reportMessageProgress(progressType) {
    let message = this._progressMessages.next(progressType)
    this._progress.report({ message: message })
  }
  async finish() {
    if (!this._lastText) throw new Error('No text')
    this._responseStream.resolve()
    let streamingResult = await this._streamingPromise,
      interpretedReply = await this._interpretReply(this._lastText)
    if (interpretedReply.type === 'inlineEdit') {
      let newText = applyTextEdits(this._initialDocText, interpretedReply.edits)
      return {
        type: 'inlineEdit',
        edits: [{ range: new VscodeRange(new VscodePosition(0, 0), new VscodePosition(Number.MAX_SAFE_INTEGER, 0)), newText: newText }],
        newWholeRange: interpretedReply.newWholeRange,
      }
    }
    if (streamingResult) {
      this._progress.report({
        edits: [{ range: new VscodeRange(new VscodePosition(0, 0), new VscodePosition(Number.MAX_SAFE_INTEGER, 0)), newText: this._initialDocText }],
      })
    }
    return interpretedReply
  }
  _interpretReply(text) {
    let { contextInfo, expandedRange } = this._selectionContextMetadata,
      codeBlock = extractCodeBlock(contextInfo, text, this._context.language)
    if (!codeBlock) return { type: 'conversational', content: text }
    let { code } = codeBlock,
      processedText = processInputText(this._accessor, contextInfo, code, this._editStrategy, this._context.fileIndentInfo, this._documentInfo)
    return createInlineEdit(processedText, expandedRange)
  }
}
class Intent {
  constructor(options) {
    this.opts = options
    this.id = options.id
    this.locations = Array.isArray(options.location) ? options.location : [options.location]
    this.description = options.description
    this.intentDetectionInput = {
      sampleQuestion: options.modelSampleQuestion,
      modelDescription: options.modelDescription ?? options.description,
    }
    this.commandInfo = options.commandInfo
  }
  async invoke(extension, context) {
    let location = context.location
    let documentContext = context.documentContext
    let chatBuilder = new ChatBuilder(extension, this.opts, location, documentContext)
    let endpoint = this.opts.endpoint ?? (await getChatEndpointInfo(extension, location, this.id))
    return {
      intent: this,
      location: location,
      promptCrafter: chatBuilder,
      endpoint: endpoint,
      followUps: this.opts.followUps,
      responseProcessor: this.opts.responseProcessor,
      createReplyInterpreter: documentContext && CodeReplyInterpreter.createFactory(extension, chatBuilder, documentContext),
    }
  }
}

function processAnchors(anchors) {
  let resourceMap = new ResourceMap(),
    mergeRanges = (range1, range2) => {
      if (range1.contains(range2)) return range1
      if (range2.contains(range1)) return range2
      let [smaller, larger] = range1.start.line < range2.start.line ? [range1, range2] : [range2, range1]
      if (smaller.end.line >= larger.start.line - 1) return new VscodeRange(smaller.start, larger.end)
    }
  return (
    anchors.forEach(anchorItem => {
      let anchor = anchorItem.anchor
      if (!isUriRange(anchor)) resourceMap.set(anchor, anchorItem)
      else {
        let existingItem = resourceMap.get(anchor.uri)
        if (!existingItem) resourceMap.set(anchor.uri, [anchorItem])
        else if (!(existingItem instanceof Anchor)) {
          let nonOverlappingAnchors = [],
            mergedRange = anchor.range
          existingItem.forEach(item => {
            if (!isUriRange(item.anchor)) return
            let merged = mergeRanges(mergedRange, item.anchor.range)
            merged ? (mergedRange = merged) : nonOverlappingAnchors.push(item.anchor)
          })
          let newAnchor = { uri: anchor.uri, range: mergedRange }
          resourceMap.set(
            anchor.uri,
            [...nonOverlappingAnchors, newAnchor]
              .sort((a, b) => a.range.start.line - b.range.start.line || a.range.end.line - b.range.end.line)
              .map(a => new Anchor(a))
          )
        }
      }
    }),
    Array.from(resourceMap.keys())
      .sort((uri1, uri2) => uri1.fsPath.localeCompare(uri2.fsPath))
      .map(uri => {
        let item = resourceMap.get(uri)
        return item || []
      })
      .flat()
  )
}

function isUriRange(item) {
  return 'uri' in item && 'range' in item
}

class CommandParser {
  constructor(accessor) {
    this.accessor = accessor
    this.commandPrefix = '/'
    this.readConfig()
  }
  readConfig() {
    this._enabledCommands = this.accessor.get(ConfigManager).getConfigMixedWithDefaults(settings.ConversationSlashCommandEnablements)
  }
  isCommandEnabled(commandId, context) {
    if (this._enabledCommands === void 0) return false
    if (this._enabledCommands[commandId] === void 0) {
      if (this._enabledCommands['*']) return true
      let defaultEnablement = CommandManager.getCommand(commandId, context)?.intent?.commandInfo?.defaultEnablement
      return typeof defaultEnablement == 'boolean' ? defaultEnablement : true
    }
    return !!this._enabledCommands[commandId]
  }
  parse(input, context) {
    if (((input = input.trimStart()), input.startsWith(this.commandPrefix))) {
      let matchGroups = /\/(?<intentId>\w+)(?::(?<intentArgument>\w*))?(?<restOfQuery>\s.*)?/s.exec(input)?.groups,
        intentId = matchGroups?.intentId ?? '',
        intentArgument = matchGroups?.intentArgument ?? '',
        restOfQuery = (matchGroups?.restOfQuery ?? '').trim(),
        command = CommandManager.getCommand(intentId, context)
      if ((this.readConfig(), command && this.isCommandEnabled(intentId, context)))
        return { command: command, intentArgument: intentArgument, restOfQuery: restOfQuery }
    }
    return { restOfQuery: input }
  }
  getCommand(commandId, context) {
    return this.allCommands(context).find(command => command.commandId === commandId)
  }
  allCommands(context) {
    return this.readConfig(), CommandManager.getCommands(context).filter(command => this.isCommandEnabled(command.commandId, context))
  }
}

var InstructionComponent = class extends BaseComponent {
  render() {
    let language = this.props.language
    return vscpp(
      vscppf,
      null,
      'You are an AI programming assistant.',
      vscpp('br', null),
      'When asked for your name, you must respond with "GitHub Copilot".',
      vscpp('br', null),
      "Follow the user's requirements carefully & to the letter.",
      vscpp('br', null),
      'The user has a ',
      language.languageId,
      ' file opened in a code editor.',
      vscpp('br', null),
      'The user includes some code snippets from the file.',
      vscpp('br', null),
      'Each code block starts with ``` and ',
      FilePathComment.forLanguage(language),
      '.',
      vscpp('br', null),
      'Answer with a single ',
      language.languageId,
      ' code block.',
      vscpp('br', null),
      'If you modify existing code, you will use the ',
      BlockComment.begin(language),
      ' and ',
      BlockComment.end(language),
      ' markers.'
    )
  }
}

var InlineChatPrompt = class extends BaseComponent {
  render() {
    if (isNotebookCell(this.props.documentContext.document.uri))
      throw throwIllegalArgumentError('InlineChatBasePrompt should not be used with a notebook!')
    let language = this.props.documentContext.language
    return vscpp(
      vscppf,
      null,
      vscpp(SystemComponent, null, vscpp(InstructionComponent, { language: language }), vscpp(ExpertiseComponent, null)),
      this.props.history && vscpp(UserComponent, null, this.props.history),
      vscpp(InlineChatSelection, { documentContext: this.props.documentContext }),
      vscpp(UserComponent, null, this.props.query)
    )
  }
}

var InlineNotebookPrompt = class extends BaseComponent {
  render() {
    if (!isNotebookCell(this.props.documentContext.document.uri))
      throw throwIllegalArgumentError('InlineChatNotebookBasePrompt should be used only with a notebook!')
    let language = this.props.documentContext.language
    return vscpp(
      vscppf,
      null,
      vscpp(
        SystemComponent,
        null,
        vscpp(InstructionComponent, { language: language }),
        vscpp('br', null),
        'When dealing with Jupyter Notebook, if a module is already imported in a cell, it can be used in other cells directly without importing it again. For the same reason, if a variable is defined in a cell, it can be used in other cells as well',
        vscpp('br', null),
        'When dealing with Jupyter Notebook, cells below the current cell can be executed before the current cell, you must use the variables defined in the cells below, unless you want to overwrite them.',
        vscpp('br', null),
        'When dealing with Jupyter Notebook, do not generate CELL INDEX in the code blocks in your answer, it is only used to help you understand the context.',
        vscpp('br', null),
        vscpp(ExpertiseComponent, null)
      ),
      this.props.history && vscpp(UserComponent, null, this.props.history),
      vscpp(InlineNotebookSelection, { documentContext: this.props.documentContext }),
      vscpp(UserComponent, null, this.props.query)
    )
  }
}

var IntentHandler = class IntentHandler {
  constructor(accessor, documentContext, editStrategy) {
    this.accessor = accessor
    this.documentContext = documentContext
    this.editStrategy = editStrategy
  }
  static async createIntentInvocation(intent, accessor, context, editStrategy) {
    let { location, documentContext } = context
    if (!documentContext) throw new Error('Open a file to add code.')
    let handler = new IntentHandler(accessor, documentContext, editStrategy),
      endpoint = await getChatEndpointInfo(accessor, location, intent.id)
    return {
      intent: intent,
      location: location,
      endpoint: endpoint,
      promptCrafter: handler,
      createReplyInterpreter: (reply, isCode) => handler.createReplyInterpreter(reply, isCode),
    }
  }
  async buildPrompt(chat, maxTokenCount, isCode, isTest, isDebug, isTrace) {
    let query = chat.getLatestTurn().request.message,
      history = chat.turns.length > 1 ? chat.turns[chat.turns.length - 2].request.message : void 0,
      renderer = new Renderer(this.accessor, 8192, maxTokenCount),
      promptType = isNotebookCell(this.documentContext.document.uri) ? InlineNotebookPrompt : InlineChatPrompt,
      messages = await renderer.render(promptType, { documentContext: this.documentContext, query: query, history: history })
    this.selectionContextMetadata = renderer.getMeta(InlineChatSelection.METADATA_ID) || renderer.getMeta(InlineNotebookSelection.METADATA_ID)
    return { messages: messages, tokenCount: 100 }
  }
  createReplyInterpreter(reply, isCode) {
    if (!this.selectionContextMetadata)
      throw new Error('Could not create reply interpreter without selection context metadata')
    return new CodeReplyInterpreter(this.accessor, this.selectionContextMetadata, this.documentContext, this.editStrategy, reply)
  }
}

var UnknownIntent = class UnknownIntent {
  constructor() {
    this.id = UnknownIntent.ID
    this.locations = [1, 2]
    this.description = 'Intent of this command is unclear or is not related to information technologies'
    this.commandInfo = { hiddenFromUser: true }
    this.intentDetectionInput = { sampleQuestion: 'Add a dog to this comment.' }
  }
  static {
    this.ID = 'unknown'
  }
  static {
    this.Instance = new UnknownIntent()
  }
  async invoke(accessor, context) {
    if (context.location === 1) return IntentHandler.createIntentInvocation(this, accessor, context, 2)
    let location = context.location,
      documentContext = context.documentContext,
      endpoint = await getChatEndpointInfo(accessor, location, this.id),
      chatBuilder = new ChatBuilder(accessor, { contextResolvers: [currentSelectionContextResolver] }, location, context.documentContext)
    return {
      intent: this,
      location: location,
      promptCrafter: chatBuilder,
      endpoint: endpoint,
      createReplyInterpreter: documentContext && CodeReplyInterpreter.createFactory(accessor, chatBuilder, documentContext),
    }
  }
}

var commandTypes = [
    'code',
    'doc',
    'edit',
    'search',
    'workspace',
    'tests',
    'fix',
    'explain',
    'terminal',
    'unknown',
    'api',
    'newNotebook',
    'new',
  ],
  IntentManager = new (class {
    constructor() {
      this.intents = new Set()
    }
    registerIntent(intent) {
      intent.locations.every(location => this.getIntent(intent.id, location)) ||
        (this.intents.add(intent),
        (!intent.commandInfo || !intent.commandInfo.hiddenFromUser) &&
          CommandManager.registerCommand({ commandId: intent.id, intent: intent, details: intent.description, locations: intent.locations }))
    }
    getIntents(location) {
      let findIndex = intentId => {
        let index = commandTypes.indexOf(intentId)
        return index === -1 ? Number.MAX_SAFE_INTEGER : index
      }
      return Array.from(this.intents.values())
        .filter(intent => intent.locations.includes(location))
        .sort((intent1, intent2) => findIndex(intent1.id) - findIndex(intent2.id))
    }
    getIntent(intentId, location) {
      return this.getIntents(location).find(intent => intent.id === intentId)
    }
  })()
var IntentDetector = class IntentDetector {
  constructor(accessor, location) {
    this.accessor = accessor
    this.location = location
    this.logger = accessor.get(LoggerManager).getPromptResponseLogger('intent detection')
    this.ghTelemetry = accessor.get(IGHTelemetryService)
    this.options = accessor.get(conversationOptions)
  }
  async detectIntent(document, preferredIntent, chatLocation, telemetryContext, request) {
    let textExcerpt
    try {
      if (document) {
        let selection = document.selection,
          range = new VscodeRange(
            new VscodePosition(Math.max(selection.start.line - 5, 0), 0),
            new VscodePosition(Math.min(selection.end.line + 5, document.document.lineCount), document.document.lineAt(selection.end.line).text.length)
          )
        textExcerpt = document.document.getText(range)
      }
    } catch {}
    let filePath = document?.document.uri.fsPath,
      prompt = this.createIntentDetectionPrompt(request, preferredIntent, filePath, textExcerpt),
      chatMessages = [{ role: 'system', content: prompt }]
    this.logger.logPrompt(chatMessages)
    let defaultChatEndpointInfo = await getDefaultChatEndpointInfo(this.accessor),
      chatResponses = await this.accessor
        .get(DataRetriever)
        .fetchMany(
          chatMessages,
          void 0,
          chatLocation,
          this.location,
          defaultChatEndpointInfo,
          { temperature: this.options.temperature, top_p: this.options.topP, stop: [';'], n: 1 },
          { messageSource: 'chat.intentprompt' }
        ),
      detectedIntent = this.handleResult(chatResponses, telemetryContext, request)
    return this.sendInternalTelemetry(request, preferredIntent, filePath, textExcerpt, detectedIntent?.id, document?.language.languageId), detectedIntent
  }
  handleResult(response, telemetryContext, request) {
    if ((this.logger.logResponse(response), response.type !== 'success')) {
      this.sendPromptIntentErrorTelemetry(telemetryContext, response)
      return
    }
    let responseValues = response.value.map(value =>
        value
          .trimStart()
          .split('\n')[0]
          .replace(/function id:|response:/i, '')
          .trim()
      ),
      intents = responseValues.map(value => IntentManager.getIntent(value, this.location)).filter(intent => intent !== void 0 && intent.id !== UnknownIntent.ID),
      mostFrequentIntent = IntentDetector.pickMostFrequent(intents)
    this.logger.info(`picked intent "${mostFrequentIntent?.id}" from ${JSON.stringify(response.value, null, '\t')}`)
    let extendedTelemetryContext = telemetryContext.extendedBy({ messageText: request, promptContext: responseValues.join(), intent: mostFrequentIntent?.id || 'unknown' })
    return this.ghTelemetry.sendRestrictedTelemetry('conversation.promptIntent', extendedTelemetryContext.raw), mostFrequentIntent
  }
  sendPromptIntentErrorTelemetry(telemetryContext, response) {
    let extendedContext = telemetryContext.extendedBy({ resultType: response.type, reason: response.reason })
    this.ghTelemetry.sendRestrictedTelemetry('conversation.promptIntentError', extendedContext.raw)
  }
  static pickMostFrequent(intents) {
    if (intents.length === 0) return
    let intentFrequencyMap = new Map()
    for (let intent of intents) {
      let frequencyAndIntent = intentFrequencyMap.get(intent.id) ?? [0, intent]
      ;(frequencyAndIntent[0] += 1), intentFrequencyMap.set(intent.id, frequencyAndIntent)
    }
    let [, mostFrequentIntent] = [...intentFrequencyMap.values()].reduce((currentMax, next) => (currentMax[0] > next[0] ? currentMax : next))
    return mostFrequentIntent
  }
  createIntentDetectionPrompt(request, preferredIntentId, filePath, fileExcerpt) {
    let intents = IntentManager.getIntents(this.location),
    fileLocation = filePath ? ` in file ${filePath}` : '',
    fileContent = fileExcerpt
        ? `Current active file contains following excerpt:
\`\`\`
${fileExcerpt}
\`\`\``
        : ''
    return `
${getAssistantIdentity()}

A software developer is using an AI chatbot in a code editor${fileLocation}.
${fileContent}
The developer added the following request to the chat and your goal is to select a function to perform the request.
${preferredIntentId ? `The developer probably wants Function Id '${preferredIntentId}', pick different only if you're certain.` : ''}
Request: ${request}

Available functions:
${intents.map(
  l => `Function Id: ${l.id}
Function Description: ${l.intentDetectionInput.modelDescription || l.description}
`
).join(`
`)}

Here are some examples to make the instructions clearer:
${intents.map(
  l => `Request: ${l.intentDetectionInput.sampleQuestion}
Response: ${l.id}
`
).join(`
`)}
Request: ${request}
Response:
`.trim()
  }
  sendInternalTelemetry(request, preferredIntent, filePath, fileExcerpt, detectedIntent, languageId) {
    fileExcerpt = fileExcerpt && fileExcerpt.length < 5000 ? fileExcerpt : void 0
    this.accessor
      .safeGet(IMSTelemetryService)
      ?.sendInternalTelemetryEvent(
        'intentDetection',
        {
          chatLocation: getConversationType(this.location),
          request: request,
          preferredIntent: preferredIntent ?? '<none>',
          filePath: filePath ?? '<none>',
          fileExcerpt: fileExcerpt ?? '<none>',
          detectedIntent: detectedIntent ?? '<none>',
          languageId: languageId ?? '<none>',
        },
        {}
      )
  }
}

async function processCommand(context, query, documentContext, commandData, filePath, languageId) {
  let commandParser = new CommandParser(context),
    intentArgument,
    intent,
    restOfQuery = '',
    parsedCommand = commandParser.parse(query, 1)
  if (parsedCommand.command) {
    intent = parsedCommand.command.intent
    restOfQuery = parsedCommand.restOfQuery
    intentArgument = parsedCommand.intentArgument
  } else {
    let configManager = context.get(ConfigManager)
    if (configManager.isDefaultSettingOverwritten(settings.ConversationIntentDetection)
      ? configManager.getConfig(settings.ConversationIntentDetection)
      : true) {
      intent = await new IntentDetector(context, 1).detectIntent(documentContext, query, languageId, filePath, commandData?.preferredIntent)
    }
    restOfQuery = query
  }
  let slashCommand
  if (intent && commandData) {
    slashCommand = commandData.slashCommands.find(command => command.command === intent.id)
  }
  intent = intent ?? UnknownIntent.Instance
  let intentInvocation = await intent.invoke(context, { location: 1, documentContext: documentContext, intentArgument: intentArgument }, slashCommand)
  return { queryWithoutCommand: restOfQuery, intentInvocation: intentInvocation, slashCommand: slashCommand }
}

async function generateMessages(commandResult, previousMessages, telemetryContext, telemetryProperties) {
  let conversation = new Conversation()
  if (previousMessages && previousMessages.length > 0) {
    let initialMessage = `The current code is a result of a previous interaction with you. Here are my previous messages:
- ${previousMessages.join(`
- `)}`
    let initialSession = new Session({ message: initialMessage, type: 'user' })
    conversation.addTurn(initialSession)
  }
  let userSession = new Session({ message: commandResult.queryWithoutCommand, type: 'user' })
  userSession.intentInvocation = commandResult.intentInvocation
  conversation.addTurn(userSession)
  let { messages: promptMessages } = await commandResult.intentInvocation.promptCrafter.buildPrompt(
    conversation,
    commandResult.intentInvocation.endpoint,
    {},
    { report() {} },
    telemetryContext,
    telemetryProperties
  )
  return promptMessages
}

var ConcurrencyModule = handleDefaultExports(ConcurrencyModule())
var PromptGenerator = class {
  constructor(accessor, id, description, roleplay, rules, sampleQuestion, options) {
    this.accessor = accessor
    this.id = id
    this.description = description
    this.roleplay = roleplay
    this.rules = rules
    this.sampleQuestion = sampleQuestion
    this.options = options
    this.pLimit = (0, ConcurrencyModule.default)(1)
    this.logger = accessor.get(LoggerManager).getLogger('GenerateFileContentsPrompt')
  }
  turnFilter(turns) {
    return turns.filter(
      turn => turn.intentInvocation?.intent.id === 'new' || (turn.request.type !== 'user' && turn.request.type !== 'follow-up')
    )
  }
  buildPrompt() {
    return [this.roleplay, this.rules, this.sampleQuestion].join(`
`)
  }
  async run(turns, replacements, options) {
    return this.pLimit(() => this.doRun(turns, replacements, options))
  }
  async doRun(turns, replacements, options) {
    let prompt = this.buildPrompt()
    for (let [key, value] of Object.entries(replacements)) prompt = prompt.replace(`{${key}}`, value)
    this.logger.info('prompt: ' + prompt)
    let endpointInfo = await getChatEndpointInfo(this.accessor, 2, this.id),
      fetchResult = await this.accessor
        .get(DataRetriever)
        .fetchOne(
          [{ role: 'system', content: getAssistantExpertise() }, ...turns, { role: 'user', content: prompt }],
          async a => {},
          options,
          2,
          endpointInfo,
          { temperature: this.options.temperature, top_p: this.options.topP, stop: ['stopIt'] },
          { messageSource: 'newIntent' }
        )
    return fetchResult.type !== 'success'
      ? (this.logError('fetch failure type: ' + fetchResult.type + ', reason: ' + fetchResult.reason), '')
      : (this.log('fetch response: ' + fetchResult.value), fetchResult.value)
  }
  logError(message) {
    this.logger.error(`[newIntent] ${this.id} `, message)
  }
  log(...messages) {
    this.logger.info(`[newIntent] ${this.id} `, ...messages)
  }
}

function generateExampleResponse(userInput, assistantResponse, replacements = {}) {
  let response = `Below you will find a set of examples of what you should respond with. Please follow these examples as closely as possible.

    ## Valid question

    User: ${userInput}
    Assistant: ${assistantResponse}`
  for (let [key, value] of Object.entries(replacements)) response = response.replace(`{${key}}`, value)
  return response
}

var ProjectPlanGenerator = class extends PromptGenerator {
  constructor(accessor, options) {
    let projectDescription =
        'I want to set up the following project: {PROJECT_DESCRIPTION}.\n		This is the project tree structure:\n		```markdown\n		{PROJECT_TREE_STRUCTURE}\n		```\n		',
      instructions = `
      Think step by step and respond with a text description that lists and summarizes each file inside this project.
      List the classes, types, interfaces, functions, and constants it exports and imports if it is a code file.
      You should be as specific as possible when listing the public properties and methods for each exported class.
      Do not use code blocks or backticks. Do not include any text before or after the file contents.
      Do not include product names such as Visual Studio in the comments.`.trim(),
      exampleResponse =
        'The project has the following files:\n		`src/app.ts`: This file is the entry point of the application. It creates an instance of the express app and sets up middleware and routes.\n		`src/controllers/index.ts`: This file exports a class `IndexController` which has a method `getIndex` that handles the root route of the application.\n		`src/routes/index.ts`: This file exports a function `setRoutes` which sets up the routes for the application. It uses the `IndexController` to handle the root route.\n		`src/types/index.ts`: This file exports interfaces `Request` and `Response` which extend the interfaces from the `express` library.\n		`tsconfig.json`: This file is the configuration file for TypeScript. It specifies the compiler options and the files to include in the compilation.\n		`package.json`: This file is the configuration file for npm. It lists the dependencies and scripts for the project.\n		`README.md`: This file contains the documentation for the project.',
      example = generateExampleResponse(projectDescription + instructions, exampleResponse, {
        PROJECT_DESCRIPTION: 'Create a TypeScript Express app',
        PROJECT_TREE_STRUCTURE: `
      my-express-app
      \u251C\u2500\u2500 src
      \u2502   \u251C\u2500\u2500 app.ts
      \u2502   \u251C\u2500\u2500 controllers
      \u2502   \u2502   \u2514\u2500\u2500 index.ts
      \u2502   \u251C\u2500\u2500 routes
      \u2502   \u2502   \u2514\u2500\u2500 index.ts
      \u2502   \u2514\u2500\u2500 types
      \u2502       \u2514\u2500\u2500 index.ts
      \u251C\u2500\u2500 package.json
      \u251C\u2500\u2500 tsconfig.json
      \u2514\u2500\u2500 README.md`,
      })
    super(accessor, 'generateProjectPlan', 'Generate a plan for the contents of a project', projectDescription, instructions, example, options)
  }
  async run(turns, replacements, options) {
    return super.run(turns, replacements, options)
  }
}
var FileGenerator = class extends PromptGenerator {
  constructor(accessor, options) {
    super(
      accessor,
      'generateFile',
      'Generate the contents of a file',
      'I want to set up the following project: {PROJECT_DESCRIPTION}.\n			This is the project tree structure:\n			```markdown\n			{PROJECT_TREE_STRUCTURE}\n			```\n			The project should adhere to the following specification:\n			{PROJECT_SPECIFICATION}',
      `
Think step by step and give me just the file {FILEPATH} within this project. The code should not contain bugs.
If the file is supposed to be empty, please respond with a code comment saying that this file is intentionally left blank.
Do not include comments in json files.
Do not use code blocks or backticks.
Do not include product names such as Visual Studio in the comments.`.trim(),
      '',
      options
    )
  }
  async run(turns, replacements, options) {
    let response = await super.run(turns, replacements, options),
      parsedContent = extractCodeFromResponse(replacements.FILEPATH, response)
    return (
      response.length !== 0 &&
        parsedContent.length === 0 &&
        (this.logError('failed to parse content'),
        this.log(`failed to parse ${replacements.FILEPATH} content
${response}`)),
      parsedContent.startsWith('Sorry, I cannot generate file contents')
        ? (this.logError('AI failed to generate file contents'),
          this.log(`failed to generate ${replacements.FILEPATH} content
${response}`),
          '')
        : parsedContent
    )
  }
}

function extractCodeFromResponse(filePath, response) {
  response = response.trimEnd().replace('[RESPONSE END]', '')

  function extractCode(content, regex) {
    try {
      let match = regex.exec(content.trim())
      if (match && match.length > 2) return match[2]
    } catch (error) {
      console.error(error)
    }
    return content
  }

  if (filePath.endsWith('.md')) {
    let extractedCode = extractCode(response, /^```([a-zA-Z]+)?\s*([\s\S]+?)\s*```$/),
      [firstLine, ...restLines] = extractedCode.split('#')
    return firstLine.length ? ['', ...restLines].join('#') : extractedCode
  } else return extractCode(response, /```([^\n]+)?\s*\n([\s\S]+?)\s*```/g)
}

var ProjectManager = class {
  constructor(accessor) {
    this.accessor = accessor
    this.promises = []
    this.responseScopedData = new Map()
    this.generatePlanPrompt = new ProjectPlanGenerator(this.accessor, {
      maxResponseTokens: undefined,
      temperature: 0.1,
      topP: 1,
      additionalPromptContext: 'none',
      rejectionMessage: '',
    })
    this.generateFilePrompt = new FileGenerator(this.accessor, {
      maxResponseTokens: undefined,
      temperature: 0.1,
      topP: 1,
      additionalPromptContext: 'none',
      rejectionMessage: '',
    })
  }
  set(responseId, projectName, userPrompt, projectStructure, treeData, chatMessages) {
    let projectSpecification = this.generatePlanPrompt.run(chatMessages, { PROJECT_DESCRIPTION: userPrompt, PROJECT_TREE_STRUCTURE: projectStructure }, new VscodeCancellationTokenSource().token)
    this.promises.push(projectSpecification),
      this._getResponseScopedData(responseId).set(projectName, {
        userPrompt: userPrompt,
        projectStructure: projectStructure,
        projectSpecification: projectSpecification,
        chatMessages: chatMessages,
        fileTreeData: this._prefetch(userPrompt, projectStructure, projectSpecification, treeData.treeData, chatMessages),
      })
  }
  get(responseId, filePath) {
    let { projectName, path } = this._getProjectMetadata(filePath),
      projectData = this._getResponseScopedData(responseId).get(projectName)
    if (!projectData) return
    let fileData = projectData.fileTreeData
    for (let part of path) fileData = fileData?.children?.find(child => child.label === part)
    if (fileData && !fileData?.content && !fileData?.children) {
      let file = fileData
      file.content = this._getFileContent(
        projectData.userPrompt,
        projectData.projectStructure,
        projectData.projectSpecification,
        filePath,
        projectData.chatMessages
      ).catch(() => (file.content = undefined))
    }
    return fileData
  }
  _prefetch(userPrompt, projectStructure, projectSpecification, treeData, chatMessages) {
    let currentTime = Date.now()
    return treeData.children
      ? { ...treeData, children: treeData.children.map(child => this._prefetch(userPrompt, projectStructure, projectSpecification, child, chatMessages)), ctime: currentTime }
      : { ...treeData, content: undefined, ctime: currentTime }
  }
  async _getFileContent(userPrompt, projectStructure, projectSpecification, filePath, chatMessages, cancellationToken = new VscodeCancellationTokenSource().token) {
    return this.generateFilePrompt
      .run(chatMessages, { PROJECT_DESCRIPTION: userPrompt, PROJECT_TREE_STRUCTURE: projectStructure, PROJECT_SPECIFICATION: await projectSpecification, FILEPATH: filePath }, cancellationToken)
      .then(content => Buffer.from(content))
  }
  _getResponseScopedData(responseId) {
    let data = this.responseScopedData.get(responseId)
    return data || ((data = new Map()), this.responseScopedData.set(responseId, data)), data
  }
  _getProjectMetadata(filePath) {
    let [, projectName, ...path] = filePath.split('/')
    return { projectName: projectName, path: path }
  }
},
var responseExamples = `
Below you will find a set of examples of what you should respond with. Please follow these examples as closely as possible.

## Valid setup question

User: Create a TypeScript express app
Assistant:

Sure, here's a proposed directory structure for a TypeScript Express app:

\`\`\`filetree
my-express-app
\u251C\u2500\u2500 src
\u2502   \u251C\u2500\u2500 app.ts
\u2502   \u251C\u2500\u2500 controllers
\u2502   \u2502   \u2514\u2500\u2500 index.ts
\u2502   \u251C\u2500\u2500 routes
\u2502   \u2502   \u2514\u2500\u2500 index.ts
\u2502   \u2514\u2500\u2500 types
\u2502       \u2514\u2500\u2500 index.ts
\u251C\u2500\u2500 package.json
\u251C\u2500\u2500 tsconfig.json
\u2514\u2500\u2500 README.md
\`\`\`

## Invalid setup question

User: Create a horse project
Assistant: Sorry, I don't know how to set up a horse project.`,
newIntentId = 'new'
function registerNewWorkspaceIntent() {
  let newWorkspaceIntent = new Intent({
    location: 2,
    id: newWorkspaceIntentId,
    description: requestLight.t('Scaffold code for a new workspace'),
    modelDescription: 'Scaffolds a new project from scratch based on requirements from the user.',
    modelSampleQuestion: 'Create a RESTful API server using typescript',
    commandInfo: {
      followupPlaceholder: 'Provide additional instructions to refine the proposed workspace',
      shouldRepopulate: true,
      allowsEmptyArgs: false,
      yieldsTo: [{ command: 'fix' }, { command: 'explain' }, { command: 'workspace' }, { command: 'tests' }],
      defaultEnablement: true,
      sampleRequest: requestLight.t('Create a RESTful API server using typescript'),
    },
    systemPromptOptions: {
      examples: responseExamples,
      roleplay:
        'You are a VS Code assistant. Your job is to suggest a filetree directory structure for a project that a user wants to create. If a step does not relate to filetree directory structures, do not respond. Please do not guess a response and instead just respond with a polite apology if you are unsure. Please end your response with [RESPONSE END] and do not include any other text.',
    },
    rules: `
You should generate a markdown file tree structure for the same project and include it in your response.
You should only list common files for the user's desired project type.
You should always include a README.md file which describes the project.
Do not include folders and files generated after compiling, building or running the project such as node_modules, dist, build, out
Do not include image files such as png, jpg, ico, etc
Do not include any descriptions or explanations in your response.`.trim(),
    turnFilter: turns =>
      turns.filter(
        turn => turn.intentInvocation?.intent.id === newWorkspaceIntentId || (turn.request.type !== 'user' && turn.request.type !== 'follow-up')
      ),
    responseProcessor: processNewWorkspaceResponse,
    followUps: generateWorkspaceCommands,
    contextResolvers: [],
  });

  IntentManager.registerIntent(newWorkspaceIntent);
}
ContributionManager.registerContribution(registerNewWorkspaceIntent)
function processNewWorkspaceResponse(context, response, reporter, messages) {
  let isFileTreeStarted = false,
    appliedText = '',
    fileTreeText = '',
    promiseOutcome,
    fileTreeStartRegex = /```filetree\n/,
    fileTreeEndRegex = /```[^\n]*/,
    userMessages = messages.filter(message => message.role !== 'system'),
    textApplier = new TextApplier(message => {
      let requestId = response.requestId ?? ''
      if (
        (response.response || (response.response = { message: appliedText, type: 'model' }),
        (message = message.replace('[RESPONSE END]', '')),
        (response.response.message += message),
        (appliedText += message),
        !message)
      )
        return
      let requestMessage = response.request.message,
        fileTreeMatch = message.match(/```filetree\n([\s\S]+?)\n```/)
      if (fileTreeMatch) {
        let [beforeFileTree, afterFileTree] = message.split(fileTreeMatch[0])
        fileTreeText = fileTreeMatch[1]
        let parsedFileTree = parseFileTree(fileTreeText),
          fileTreeItem = { treeData: generateFileTreeItem(requestId, parsedFileTree) }
        reporter.report({ content: beforeFileTree }),
          reporter.report({ placeholder: requestLight.t('Generating workspace preview...'), resolvedContent: Promise.resolve(fileTreeItem) }),
          reporter.report({ content: afterFileTree }),
          context.get(ProjectManager).set(requestId, fileTreeItem.treeData.label, requestMessage, fileTreeText, fileTreeItem, userMessages)
      } else if (message.trim().match(fileTreeEndRegex) && isFileTreeStarted && promiseOutcome) {
        fileTreeText = fileTreeText.trim()
        isFileTreeStarted = false
        let parsedFileTree = parseFileTree(fileTreeText),
          fileTreeItem = { treeData: generateFileTreeItem(requestId, parsedFileTree) }
        fileTreeItem.treeData.children?.length === 0
          ? promiseOutcome.complete({ content: requestLight.t('Sorry, something went wrong. Please try asking your question again.') })
          : (promiseOutcome.complete(fileTreeItem), context.get(ProjectManager).set(requestId, fileTreeItem.treeData.label, requestMessage, fileTreeText, fileTreeItem, userMessages))
      } else
        message.match(fileTreeStartRegex) && !isFileTreeStarted && !promiseOutcome
          ? (isFileTreeStarted = true,
            promiseOutcome = new PromiseOutcome(),
            reporter.report({ placeholder: requestLight.t('Generating workspace preview...'), resolvedContent: promiseOutcome.p }))
          : isFileTreeStarted
          ? (fileTreeText += message)
          : reporter.report({ content: message })
    })
  return {
    get appliedText() {
      return Promise.resolve(appliedText)
    },
    apply: message => textApplier.apply(message),
  }
}

async function generateWorkspaceCommands(context, response) {
  let logger = context.get(LoggerManager).getPromptResponseLogger('new')
  if (!response.response?.message) return []

  let fileTreeRegex = /```[^\n]*\n([\s\S]+?)\n```/,
    fileTreeMatch = response.response.message.match(fileTreeRegex),
    fileTreeText = fileTreeMatch && fileTreeMatch[1].trim()

  if (!fileTreeText) {
    logger.info(
      `[workspaceIntent] Response validation failed for response:
` + JSON.stringify(response.response.message)
    )
    return []
  }

  let parsedFileTree = parseFileTree(fileTreeText),
    projectItems = []

  if ((generateFileTree(parsedFileTree, '', projectItems), projectItems.length === 0)) {
    logger.info(
      `[workspaceIntent] Failed to fetch project items for
` + fileTreeText
    )
    return []
  }

  let commands = [],
    createProjectCommand = {
      commandId: 'github.copilot.createProject',
      args: [response.request.message, projectItems, fileTreeText.replace(/\n/g, ''), response.sessionId, response.requestId],
      title: requestLight.t('Create Workspace'),
    }

  commands.push(createProjectCommand)
  return commands
}

function calculateIndentationLevel(text) {
  let index = text.indexOf('\u2500\u2500 '),
    indentationLevel =
      index -
      text.indexOf(
        `
`,
        index
      ) -
      1
  return indentationLevel === -1 ? 0 : indentationLevel
}

var excludedFilesAndFolders = [
  'node_modules',
  'out',
  'bin',
  'debug',
  'obj',
  'lib',
  '.dll',
  '.pdb',
  '.lib',
  '.jpg',
  '.png',
  '.ico',
  '.gif',
  '.svg',
  '.jpeg',
  '.tiff',
  '.bmp',
  '.webp',
  '.jpeg',
  '.gitignore',
  'LICENSE.txt',
  'yarn.lock',
  'package-lock.json',
]

function filterOutExcludedFiles(node) {
  let filteredChildren = []
  for (let child of node.children) excludedFilesAndFolders.some(excluded => child.name.endsWith(excluded)) || filteredChildren.push(child)
  node.children = filteredChildren
  for (let child of node.children) filterOutExcludedFiles(child)
  return node
}

function parseFileTree(text) {
  let lines = text.trim().split(`
`),
    root = { name: '', depth: 0, parent: void 0, children: [] },
    current = root
  for (let line of lines) {
    let depth = calculateIndentationLevel(line),
      index = line.lastIndexOf('\u2500\u2500 '),
      node = { name: index >= 0 ? line.substring(index + 3) : line, depth: depth, parent: void 0, children: [] }
    if (depth === 0) {
      root.name = line
      continue
    } else if (current.depth < depth) (node.parent = current), current.children.push(node)
    else if (current.depth === depth) (node.parent = current.parent), current.parent?.children.push(node)
    else {
      for (; current.depth !== depth && current.parent; ) current = current.parent
      ;(node.parent = current.parent), current.parent?.children.push(node)
    }
    current = node
  }
  return filterOutExcludedFiles(root)
}

function isFile(path) {
  return /\.[^/.]+$/.test(path)
}

function generateFileTree(node, path = '', result) {
  let fullPath = path === '' ? node.name : `${path}/${node.name}`
  result.push({ type: node.children.length || !isFile(fullPath) ? 'folder' : 'file', path: fullPath })
  for (let child of node.children) generateFileTree(child, fullPath, result)
}

function generateFileTreeItem(workspace, node, path = '') {
  let fullPath = path === '' ? node.name : `${path}/${node.name}`,
    children = [],
    sortedChildren = node.children.sort((child1, child2) =>
      child1.children.length && child2.children.length ? child1.name.localeCompare(child2.name) : child1.children.length ? -1 : 1
    )
  for (let child of sortedChildren) children.push(generateFileTreeItem(workspace, child, fullPath))
  return { label: node.name, uri: generateUri(workspace, fullPath), children: children.length || !isFile(fullPath) ? children : void 0 }
}

async function processErrorAndFix(workspace, options, document, error, context) {
  let errorCode = error.code ? (typeof error.code == 'string' || typeof error.code == 'number' ? error.code : error.code.value) : '',
    errorMessage = `${error.message}. ${errorCode}`,
    messageSource = { messageSource: 'slash.new' },
    range = error.range,
    commandContext = { document: document, fileIndentInfo: void 0, language: getCommentSymbol(document), wholeRange: range, selection: new VscodeSelection(range.start, range.end) },
    commandResult = await processCommand(workspace, `/fix ${errorMessage}`, commandContext, void 0, generateTelemetryEvent(), context),
    endpoint = commandResult.intentInvocation.endpoint,
    messages = await generateMessages(commandResult, void 0, generateTelemetryEvent(), context),
    dataRetriever = workspace.get(DataRetriever),
    messageLength = async message => (isCodeBlock(message) ? message.length : void 0),
    fetchedMessage = await dataRetriever.fetchOne(messages, messageLength, context, 2, endpoint, { temperature: options.temperature, top_p: options.topP }, messageSource)
  if (fetchedMessage.type === 'success' && fetchedMessage.value.length > 0) {
    let replyInterpreter = commandResult.intentInvocation.createReplyInterpreter({ report() {} }, !1)
    replyInterpreter.update(fetchedMessage.value)
    let finalResult = await replyInterpreter.finish()
    return finalResult.type === 'inlineEdit' ? finalResult.edits : void 0
  }
}

function generateUri(workspace, path) {
  return VscodeUri.from({ scheme: 'vscode-copilot-workspace', authority: workspace ?? '', path: `/${path}` })
}

var BaseEnvironment = class {}

function registerExperimentFilters(container) {
  let experimentManager = container.get(ExperimentManager),
    configManager = container.get(ConfigManager)
  experimentManager.registerStaticFilters(mergeAllFilters(container)),
    experimentManager.registerDynamicFilter('X-Copilot-OverrideEngine', () => configManager.getConfig(settings.DebugOverrideEngine))
}

function mergeAllFilters(container) {
  let staticFilters = generateStaticFilters(container),
    dynamicFilters = container.get(BaseEnvironment).addEditorSpecificFilters()
  return { ...staticFilters, ...dynamicFilters }
}

function generateStaticFilters(container) {
  let buildInfo = container.get(BuildInfo),
    editorInfo = buildInfo.getEditorInfo()
  return {
    'X-VSCode-AppVersion': extractVersion(editorInfo.version),
    'X-MSEdge-ClientId': buildInfo.machineId,
    'X-VSCode-ExtensionName': buildInfo.getName(),
    'X-VSCode-ExtensionVersion': extractVersion(buildInfo.getVersion()),
    'X-VSCode-TargetPopulation': 'public',
  }
}

function extractVersion(versionString) {
  return versionString.split('-')[0]
}

var fetch = handleDefaultExports(fetch(), 1),
  iht = {
    ALPN_HTTP2: fetch.default.ALPN_HTTP2,
    ALPN_HTTP2C: fetch.default.ALPN_HTTP2C,
    ALPN_HTTP1_1: fetch.default.ALPN_HTTP1_1,
    ALPN_HTTP1_0: fetch.default.ALPN_HTTP1_0,
  },
  {
    fetch: oht,
    context: context,
    reset: sht,
    noCache: aht,
    h1: cht,
    keepAlive: lht,
    h1NoCache: uht,
    keepAliveNoCache: pht,
    cacheStats: dht,
    clearCache: fht,
    offPush: mht,
    onPush: hht,
    createUrl: ght,
    timeoutSignal: vht,
    Body: _ht,
    Headers: yht,
    Request: xht,
    Response: bht,
    AbortController: AbortController,
    AbortError: AbortError,
    AbortSignal: Eht,
    FetchBaseError: Tht,
    FetchError: FetchError,
    ALPN_HTTP2: Sht,
    ALPN_HTTP2C: Cht,
    ALPN_HTTP1_1: Iht,
    ALPN_HTTP1_0: wht,
  } = fetch.default
var tls = handleDefaultExports(require('tls'))
var fs = handleDefaultExports(require('fs'))
var Cache = class {
  constructor() {
    this.cache = new Map()
  }
  get(key) {
    return this.cache.get(key)
  }
  set(key, value) {
    this.cache.set(key, value)
  }
}

var BaseCertificateLoader = class {
  async loadCaCerts() {}
}

var BaseCertificateReader = class {},
var createInstance = (container, platform = process.platform) => new CertificateReader(container.get(EventEmitter), createCertificateLoader(platform, container), new EmptyCertificateReader()),

var CertificateReader = class extends BaseClass {
  constructor(eventEmitter, realReader, noopReader) {
    super()
    this.realReader = realReader
    this.noopReader = noopReader
    this.delegate = realReader
    eventEmitter.on('onCopilotToken', token => {
      this.delegate = token.getTokenValue('ssc') === '1' ? this.realReader : this.noopReader
    })
  }
  getAllRootCAs() {
    return this.delegate.getAllRootCAs()
  }
}
var createCertificateLoader = (platform, container) => {
    let loader = container.get(Cache).get(platform)
    if (loader) return loader
    let platformSpecificLoader = createPlatformSpecificLoader(platform, container),
      certificateManager = new ExtraCertificateReader(platformSpecificLoader),
      certificateValidator = new CachedCertificateReader(certificateManager),
      certificateLoader = new LoggerCertificateReader(container, certificateValidator)
    container.get(Cache).set(platform, certificateLoader)
    return certificateLoader
  }
var createPlatformSpecificLoader = (platform, container) => {
    switch (platform) {
      case 'linux':
        return new LinuxCertificateReader()
      case 'darwin':
        return new MacOSCertificateReader()
      case 'win32':
        return new WindowsCertificateReader(container)
      default:
        return new UnsupportedPlatformReader()
    }
  },
  LoggerCertificateReader = class extends BaseCertificateReader {
    constructor(accessor, delegate) {
      super()
      this.accessor = accessor
      this.delegate = delegate
    }
    async getAllRootCAs() {
      try {
        return await this.delegate.getAllRootCAs()
      } catch (error) {
        return this.accessor.get(LoggerManager).getLogger('certificates').warn(`Failed to read root certificates: ${error}`), []
      }
    }
  },
  CachedCertificateReader = class extends BaseCertificateReader {
    constructor(delegate) {
      super()
      this.delegate = delegate
    }
    async getAllRootCAs() {
      return this.certificates || (this.certificates = await this.delegate.getAllRootCAs()), this.certificates
    }
  },
  ExtraCertificateReader = class extends BaseCertificateReader {
    constructor(delegate) {
      super()
      this.delegate = delegate
    }
    async getAllRootCAs() {
      let rootCAs = await this.delegate.getAllRootCAs(),
        extraCertsPath = process.env.NODE_EXTRA_CA_CERTS
      if (!extraCertsPath) return rootCAs
      let extraCerts = await readCertificatesFromFile(extraCertsPath)
      return rootCAs.concat(extraCerts)
    }
  },
  LinuxCertificateReader = class extends BaseCertificateReader {
    async getAllRootCAs() {
      let rootCAs = []
      for (let path of ['/etc/ssl/certs/ca-certificates.crt', '/etc/ssl/certs/ca-bundle.crt']) {
        let certs = await readCertificatesFromFile(path)
        rootCAs = rootCAs.concat(certs)
      }
      return rootCAs
    }
  },
  MacOSCertificateReader = class extends BaseCertificateReader {
    async getAllRootCAs() {
      let macCerts = macCa()
      return macCerts.all(macCerts.der2.pem).filter(cert => cert !== void 0)
    }
  },
  WindowsCertificateReader = class extends BaseCertificateReader {
    constructor(accessor) {
      super()
      this.accessor = accessor
    }
    async getAllRootCAs() {
      return (await this.accessor.get(BaseCertificateLoader).loadCaCerts()) || []
    }
  },
  UnsupportedPlatformReader = class extends BaseCertificateReader {
    async getAllRootCAs() {
      throw new Error('No certificate reader available for unsupported platform')
    }
  },
  EmptyCertificateReader = class extends BaseCertificateReader {
    async getAllRootCAs() {
      return []
    }
  }
async function readCertificatesFromFile(filePath) {
  try {
    let fileContent = (await fs.promises.readFile(filePath, { encoding: 'utf8' }))
        .split(/(?=-----BEGIN CERTIFICATE-----)/g)
        .filter(cert => cert.length > 0),
      uniqueCerts = new Set(fileContent)
    return Array.from(uniqueCerts)
  } catch (error) {
    if (error?.code !== 'ENOENT') throw error
  }
  return []
}
var CertificateManager = class {
  constructor(dependency) {
    this._certificateReader = dependency.get(CertificateReader)
  }
  async enhanceProxySettings(settings) {
    let certificates = await this.getCertificates()
    return { ...settings, ca: certificates }
  }
  async getCertificates() {
    let certificates = await this._certificateReader.getAllRootCAs()
    if (certificates.length !== 0) return certificates
  }
  async applyToRequestOptions(options) {
    let certificates = await this._certificateReader.getAllRootCAs(),
      additionalCerts = { _vscodeAdditionalCaCerts: certificates }
    options.secureContext = tls.createSecureContext(additionalCerts)
    options.ca = certificates
    options.cert = certificates
    certificates.map(cert => {
      options.secureContext.context.addCACert(cert)
    })
  }
}
var http = handleDefaultExports(require('http'))
var BaseKerberosLoader = class {
  async loadKerberos() {}
}
var ProxyAuthorizationRequired = 407,
BaseSocketFactory = class {},
  ProxyError = class extends Error {
    constructor(message, cause, responseStatus) {
      super(message)
      this.cause = cause
      this.responseStatus = responseStatus
    }
  }
function createSocketFactory(t) {
  return new SocketFactory(t, new ProxySocketFactory(t))
}
var SocketFactory = class extends BaseSocketFactory {
  constructor(accessor, delegate, platform = process.platform) {
    super()
    this.accessor = accessor
    this.delegate = delegate
    this.platform = platform
    this.successfullyAuthorized = new LimitedLinkedMap(20)
    this.logger = accessor.get(LoggerManager).getLogger('proxy-socket-factory')
  }
  async createSocket(request, proxy) {
    if (this.successfullyAuthorized.get(this.getProxyCacheKey(proxy))) {
      this.logger.debug('Proxy authorization already successful once, skipping 407 rountrip')
      await this.reauthorize(request, proxy)
    }
    try {
      return await this.delegate.createSocket(request, proxy)
    } catch (error) {
      if (error instanceof ProxyError && error.responseStatus === ProxyAuthorizationRequired) {
        this.logger.debug('Proxy authorization required, trying to authorize first time')
        let socket = await this.authorizeAndCreateSocket(request, proxy)
        if (socket) {
          this.logger.debug('Proxy authorization successful, caching result')
          this.successfullyAuthorized.set(this.getProxyCacheKey(proxy), true)
          return socket
        }
      }
      throw error
    }
  }
  async reauthorize(request, proxy) {
    let token = await this.authorize(proxy)
    if (token) {
      this.logger.debug('Proxy re-authorization successful, received token')
      request.headers['Proxy-Authorization'] = 'Negotiate ' + token
    }
  }
  async authorizeAndCreateSocket(request, proxy) {
    let token = await this.authorize(proxy)
    if (token) {
      this.logger.debug('Proxy authorization successful, received token')
      this.logger.debug('Trying to create socket with proxy authorization')
      request.headers['Proxy-Authorization'] = 'Negotiate ' + token
      return await this.delegate.createSocket(request, proxy)
    }
  }
  async authorize(proxy) {
    this.logger.debug('Loading kerberos module')
    let kerberos = await loadKerberosModule(this.accessor)
    if (!kerberos) {
      this.logger.debug('Could not load kerberos module')
      return
    }
    let spn = this.computeSpn(proxy)
    this.logger.debug('Initializing kerberos client using spn', spn)
    let client = await kerberos.initializeClient(spn)
    this.logger.debug('Perform client side kerberos step')
    let serverResponse = await client.step('')
    this.logger.debug('Received kerberos server response')
    return serverResponse
  }
  computeSpn(proxy) {
    let configManager = this.accessor.get(ConfigManager)
    let spn = configManager.isDefaultSettingOverwritten(settings.KerberosServicePrincipal)
      ? configManager.getConfig(settings.KerberosServicePrincipal)
      : proxy.kerberosServicePrincipal
    if (spn) {
      this.logger.debug('Using configured kerberos spn', spn)
      return spn
    }
    let defaultSpn = this.platform === 'win32' ? `HTTP/${proxy.host}` : `HTTP@${proxy.host}`
    this.logger.debug('Using default kerberos spn', defaultSpn)
    return defaultSpn
  }
  getProxyCacheKey(proxy) {
    return proxy.host + ':' + proxy.port
  }
}
var ProxySocketFactory = class extends BaseSocketFactory {
    constructor(dependency) {
      super()
      this.logger = dependency.get(LoggerManager).getLogger('proxy-socket-factory')
    }
    async createSocket(request, proxy) {
      let requestOptions = this.createConnectRequestOptions(request, proxy)
      return new Promise((resolve, reject) => {
        this.logger.debug('Attempting to establish connection to proxy')
        let proxyRequest = http.request(requestOptions)
        proxyRequest.useChunkedEncodingByDefault = false
        proxyRequest.once('connect', (response, socket, head) => {
            this.logger.debug('Socket Connect returned status code', response.statusCode)
            proxyRequest.removeAllListeners()
            socket.removeAllListeners()
            if (response.statusCode !== 200) {
              socket.destroy()
              reject(new ProxyError('tunneling socket could not be established', undefined, response.statusCode))
            } else if (head.length > 0) {
              socket.destroy()
              reject(new ProxyError('got illegal response body from proxy'))
            } else {
              this.logger.debug('Successfully established tunneling connection to proxy')
              resolve(socket)
            }
          })
          proxyRequest.once('error', error => {
            this.logger.debug('Proxy socket connection error', error.message)
            proxyRequest.removeAllListeners()
            reject(new ProxyError('tunneling socket could not be established', error))
          })
          proxyRequest.on('timeout', () => {
            this.logger.debug('Proxy socket connection timeout')
            reject(new ProxyError(`tunneling socket could not be established, proxy socket connection timeout while connecting to ${requestOptions.host}:${requestOptions.port}`))
          })
          proxyRequest.end()
      })
    }
    createConnectRequestOptions(request, proxy) {
      let options = {
        ...proxy,
        method: 'CONNECT',
        path: request.host + ':' + request.port,
        agent: false,
        headers: { host: request.host + ':' + request.port, 'Proxy-Connection': 'keep-alive' },
        timeout: request.timeout,
      }
      if (request.localAddress) options.localAddress = request.localAddress
      this.configureProxyAuthorization(options, request)
      return options
    }
    configureProxyAuthorization(options, request) {
      options.headers['Proxy-Authorization'] = []
      if (options.proxyAuth) options.headers['Proxy-Authorization'].push('Basic ' + Buffer.from(options.proxyAuth).toString('base64'))
      if (request.headers && request.headers['Proxy-Authorization']) options.headers['Proxy-Authorization'].push(request.headers['Proxy-Authorization'])
    }
  }

async function loadKerberosModule(accessor) {
  try {
    return accessor.get(BaseKerberosLoader).loadKerberos()
  } catch {
    return
  }
}

var ConnectionManager = class extends ConnectionSettings {
  constructor(settings) {
    super()
    this.accessor = settings
    this.createSocketFactory = (settings, rejectUnauthorized) => async requestOptions => {
      requestOptions.rejectUnauthorized = rejectUnauthorized
      requestOptions.timeout = settings.connectionTimeoutInMs
      await this.certificateConfigurator.applyToRequestOptions(requestOptions)
      let proxySettings = await this.certificateConfigurator.enhanceProxySettings(settings)
      try {
        return await this.proxySocketFactory.createSocket(requestOptions, proxySettings)
      } catch (error) {
        throw error instanceof ProxyError && error.cause ? new Error(`${error.message}, cause=${error.cause.message}`) : new Error(error.message)
      }
    }
    this.fetchApi = this.createFetchApi(settings)
    this.certificateConfigurator = new CertificateManager(settings)
    this.proxySocketFactory = settings.get(BaseSocketFactory)
  }
  set proxySettings(settings) {
    this._proxySettings = settings
    this.fetchApi = this.createFetchApi(this.accessor)
  }
  get proxySettings() {
    return this._proxySettings
  }
  set rejectUnauthorized(settings) {
    super.rejectUnauthorized = settings
    this.fetchApi = this.createFetchApi(this.accessor)
  }
  get rejectUnauthorized() {
    return super.rejectUnauthorized
  }
  createFetchApi(settings) {
    let buildInfo = settings.get(BuildInfo)
    return context({
      userAgent: `GitHubCopilotChat/${buildInfo.getVersion()}`,
      socketFactory: this._proxySettings
        ? this.createSocketFactory(this._proxySettings, super.rejectUnauthorized)
        : void 0,
      rejectUnauthorized: super.rejectUnauthorized,
    })
  }
  async fetch(url, options) {
    let requestOptions = { ...options, body: options.body ? options.body : options.json, signal: options.signal }
    await this.certificateConfigurator.applyToRequestOptions(requestOptions)
    let certificates = await this.certificateConfigurator.getCertificates()
    this.fetchApi.setCA(certificates)
    let response = await this.fetchApi.fetch(url, requestOptions)
    return new HttpResponse(
      response.status,
      response.statusText,
      response.headers,
      () => response.text(),
      () => response.json(),
      async () => response.body
    )
  }
  disconnectAll() {
    return this.fetchApi.reset()
  }
  makeAbortController() {
    return new AbortController()
  }
  isAbortError(error) {
    return error instanceof AbortError
  }
  isDNSLookupFailedError(error) {
    return error instanceof FetchError && error.code === 'ENOTFOUND'
  }
  isFetcherError(error) {
    return error instanceof FetchError
  }
}
var http = handleDefaultExports(require('http')),
https = handleDefaultExports(require('https'))
var NetworkManager = class extends ConnectionSettings {
  constructor(runtimeInfoService) {
    super()
    this._runtimeInfoService = runtimeInfoService
  }
  fetch(url, options) {
    let headers = options.headers || {}
    headers['User-Agent'] = `GitHubCopilotChat/${this._runtimeInfoService.getVersion()}`
    let body = options.body
    if (options.json) {
      if (options.body) throw new Error("Illegal arguments! Cannot pass in both 'body' and 'json'!")
      headers['Content-Type'] = 'application/json'
      body = JSON.stringify(options.json)
    }
    let method = options.method || 'GET'
    if (method !== 'GET' && method !== 'POST') throw new Error("Illegal arguments! 'method' must be either 'GET' or 'POST'!")
    let signal = options.signal ?? new AbortController().signal
    if (signal && !(signal instanceof AbortSignal))
      throw new Error("Illegal arguments! 'signal' must be an instance of AbortSignal!")
    return this._fetch(url, method, headers, body, signal)
  }
  _fetch(url, method, headers, body, signal) {
    return new Promise((resolve, reject) => {
      let request = (url.startsWith('https:') ? https : http).request(url, { method: method, headers: headers }, response => {
        if (signal.aborted) {
          response.destroy()
          request.destroy()
          reject(getAbortReason(signal))
          return
        }
        let responseManager = new ResponseManager(request, response, signal)
        resolve(
          new HttpResponse(
            response.statusCode || 0,
            response.statusMessage || '',
            responseManager.headers,
            async () => responseManager.text(),
            async () => responseManager.json(),
            async () => responseManager.body()
          )
        )
      })
      request.setTimeout(60 * 1e3)
      request.on('error', reject)
      body && request.write(body)
      request.end()
    })
  }
  async disconnectAll() {}
  makeAbortController() {
    return new AbortController()
  }
  isAbortError(error) {
    return isAbortError(error)
  }
  isDNSLookupFailedError(error) {
    return error && error.code === 'ENOTFOUND'
  }
  isFetcherError(error) {
    return error && ['EADDRINUSE', 'ECONNREFUSED', 'ECONNRESET', 'ENOTFOUND', 'EPIPE', 'ETIMEDOUT'].includes(error.code)
  }
  set proxySettings(settings) {}
  get proxySettings() {}
}

function getAbortReason(signal) {
  return signal.reason
}

function isAbortError(error) {
  return error && error.name === 'AbortError'
}

var ResponseManager = class {
  constructor(request, response, signal) {
    this.req = request
    this.res = response
    this.signal = signal
    this.headers = new (class {
      get(headerName) {
        let headerValue = response.headers[headerName]
        return Array.isArray(headerValue) ? headerValue[0] : headerValue ?? null
      }
      [Symbol.iterator]() {
        let headerKeys = Object.keys(response.headers),
          index = 0
        return {
          next: () => {
            if (index >= headerKeys.length) return { done: true, value: undefined }
            let key = headerKeys[index++]
            return { done: false, value: [key, this.get(key)] }
          },
        }
      }
    })()
  }
  text() {
    return new Promise((resolve, reject) => {
      let chunks = []
      this.res.on('data', chunk => chunks.push(chunk)),
        this.res.on('end', () => resolve(Buffer.concat(chunks).toString())),
        this.res.on('error', reject),
        this.signal.addEventListener('abort', () => {
          this.res.destroy(), this.req.destroy(), reject(getAbortReason(this.signal))
        })
    })
  }
  async json() {
    let text = await this.text()
    return JSON.parse(text)
  }
  async body() {
    this.signal.addEventListener('abort', () => {
      this.res.emit('error', getAbortReason(this.signal)), this.res.destroy(), this.req.destroy()
    })
    return this.res
  }
}

var fs = handleDefaultExports(require('fs'))
var tokenFilePath = `${process.env.HOME || process.env.USERPROFILE}/.copilot-testing-gh-token`,
  tokenHandler
function getTokenHandler() {
  return tokenHandler || (tokenHandler = createTokenHandler()), tokenHandler
}
var createTokenHandler = () => {
  if (process.env.GITHUB_PAT) return new DefaultTokenHandler(process.env.GITHUB_PAT)
  let token = readTokenFromFile()
  if (token) return new GitHubTokenHandler({ token: token.trim() })
  throw new Error(
    `Tests: either GITHUB_PAT must be set, or there must be a GitHub token from an app with access to Copilot in ${tokenFilePath}. Run "npm run get_token" to get one.`
  )
}
function readTokenFromFile() {
  if (fs.existsSync(tokenFilePath)) return fs.readFileSync(tokenFilePath).toString()
}
var UrlOpener = class {
  constructor() {
    this.openedUrls = []
  }
  open(url) {
    this.openedUrls.push(url)
  }
}
var vscode = handleDefaultExports(require('vscode'))

function stringify(t) {
  return typeof t == 'string' ? t : JSON.stringify(t)
}

var WorkspaceConfigManager = class extends ConfigManager {
  constructor() {
    super()
    this.config = vscode.workspace.getConfiguration(extensionId)
    vscode.workspace.onDidChangeConfiguration(event => {
        if (event.affectsConfiguration(extensionId)) {
          this.config = vscode.workspace.getConfiguration(extensionId)
        }
      })
  }
  getConfig(setting) {
    return this.config[setting.firstPart] && this.config[setting.firstPart][setting.secondPart] !== void 0
      ? this.config[setting.firstPart][setting.secondPart]
      : setting.defaultValue
  }
  isDefaultSettingOverwritten(setting) {
    return this.config[setting.firstPart] && this.config[setting.firstPart][setting.secondPart] !== void 0
  }
  dumpConfig() {
    let configDump = {}
    try {
      let properties = packageInfo.contributes.configuration?.properties ?? {}
      for (let key in properties) {
        let value = key
          .replace(`${extensionId}.`, '')
          .split('.')
          .reduce((obj, prop) => obj[prop], this.config)
        if (typeof value == 'object' && value !== null) {
          Object.keys(value)
            .filter(prop => prop !== 'secret_key')
            .forEach(prop => (configDump[`${key}.${prop}`] = stringify(value[prop])))
        } else {
          configDump[key] = stringify(value)
        }
      }
    } catch (error) {
      console.error(`Failed to retrieve configuration properties ${error}`)
    }
    return configDump
  }
}

var vscode = require('vscode'),
  consoleOutput = []
function getConsoleOutput() {
  return consoleOutput.join(`
`)
}
function addOutput(output, maxOutputLength = 40) {
  consoleOutput.push(removeEscapeSequences(output))
  if (consoleOutput.length > maxOutputLength) {
    consoleOutput.shift()
  }
}
var DebugSessionHandler = class {
  constructor(session) {
    this.session = session
  }
  onWillStartSession() {}
  onWillReceiveMessage(message) {}
  onDidSendMessage(message) {
    if (vscode.debug.activeDebugSession !== this.session) return
    let output = this.extractOutput(message)
    output && addOutput(output)
  }
  extractOutput(message) {
    if (message.event === 'output' && (message.body.category === 'stdout' || message.body.category === 'stderr')) return message.body.output
  }
  onWillStopSession() {}
  onError(error) {}
  onExit(exitCode, signal) {}
}
function removeEscapeSequences(text) {
  let escapeSequenceRegex = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g
  return text && text.replace(escapeSequenceRegex, '')
}
function registerDebugAdapterTrackerFactory() {
  return [vscode.debug.registerDebugAdapterTrackerFactory('*', new DebugAdapterTrackerFactory())]
}
var DebugAdapterTrackerFactory = class {
  createDebugAdapterTracker(session) {
    return new DebugSessionHandler(session)
  }
}
var DebugConsole = class extends DisposableClass {
  constructor() {
    super()
    for (let trackerFactory of registerDebugAdapterTrackerFactory()) {
      this._register(trackerFactory)
    }
  }
  get consoleOutput() {
    return getConsoleOutput()
  }
}

var crypto = require('crypto')
var EmbeddingComputer = class {
  constructor(accessor) {
    this.accessor = accessor
  }
  async computeEmbeddings(inputs, telemetryContext) {
    this._embeddingEndpoint || (this._embeddingEndpoint = await this.accessor.get(EndpointManager).getEmbeddingsEndpointInfo())
    let maxBatchSize = this._embeddingEndpoint.maxBatchSize,
      modelMaxTokenWindow = this._embeddingEndpoint.modelMaxTokenWindow
    return this.fetchResponseWithBatches(inputs, telemetryContext, modelMaxTokenWindow, maxBatchSize)
  }
  async fetchResponseWithBatches(inputs, telemetryContext, maxTokenCount, maxBatchSize) {
    let embeddings = [],
      tokenizer = this.accessor.get(Tokenizer),
      batch = [],
      tokenCount = 0
    for (let input of inputs) {
      let inputTokenCount = tokenizer.tokenLength(input)
      if (tokenCount + inputTokenCount >= maxTokenCount || batch.length >= maxBatchSize) {
        let response = await this.rawEmbeddingsFetchWithTelemetry(this.accessor, (0, crypto.randomUUID)(), batch, telemetryContext)
        if (response.type === 'failed') return
        embeddings.push(...response.embeddings), (batch = []), (tokenCount = 0)
      }
      batch.push(input), (tokenCount += inputTokenCount)
    }
    if (batch.length > 0) {
      let response = await this.rawEmbeddingsFetchWithTelemetry(this.accessor, (0, crypto.randomUUID)(), batch, telemetryContext)
      if (response.type === 'failed') return
      embeddings.push(...response.embeddings)
    }
    return embeddings.length === 0 ? void 0 : embeddings
  }
  async rawEmbeddingsFetchWithTelemetry(accessor, requestId, inputs, telemetryContext) {
    let startTime = Date.now(),
      telemetryService = this.accessor.get(IMSTelemetryService),
      response = await this.rawEmbeddingsFetch(accessor, requestId, inputs, telemetryContext)
    return response.type === 'failed'
      ? (telemetryService.sendTelemetryEvent('embedding.error', { type: response.type, reason: response.reason }), response)
      : (telemetryService.sendTelemetryEvent(
          'embedding.success',
          {},
          {
            batchSize: inputs.length,
            inputTokenCount: inputs.reduce((count, input) => count + this.accessor.get(Tokenizer).tokenLength(input), 0),
            timeToComplete: Date.now() - startTime,
          }
        ),
        response)
  }
  async rawEmbeddingsFetch(accessor, requestId, inputs, telemetryContext) {
    this._embeddingEndpoint || (this._embeddingEndpoint = await this.accessor.get(EndpointManager).getEmbeddingsEndpointInfo())
    try {
      let tokenHandler = accessor.get(BaseTokenHandler),
        token = tokenHandler instanceof DefaultTokenHandler ? await tokenHandler.getEmbeddingsToken(accessor) : await tokenHandler.getCopilotToken(accessor),
        requestBody = { input: inputs, model: 'copilot-text-embedding-ada-002' }
      this._embeddingEndpoint.interceptBody?.(requestBody)
      let response = await sendRequest(accessor, this._embeddingEndpoint, token.token, 'copilot-panel', telemetryContext, requestBody, telemetryContext),
        responseBody = await response.json()
      return response.status === 200 && responseBody.data
        ? { type: 'success', embeddings: responseBody.data.map(item => item.embedding) }
        : { type: 'failed', reason: responseBody.error }
    } catch (error) {
      let errorMessage = error?.message ?? 'Unknown error'
      return errorMessage.match(/Unexpected.*JSON/i) && (errorMessage = 'timeout'), { type: 'failed', reason: errorMessage }
    }
  }
}

var vscode = handleDefaultExports(require('vscode'))
var VSCodeInfoProvider = class extends BaseVSCodeInfoProvider {
  get language() {
    return vscode.env.language
  }
  getAllExtensions() {
    return vscode.extensions.all
  }
  async getAllCommands() {
    return vscode.commands.executeCommand('_getAllCommands')
  }
  async getAllSettings() {
    return vscode.commands.executeCommand('_getAllSettings')
  }
}
var vscode = handleDefaultExports(require('vscode'))
var FileSystemOperations = class extends BaseFileSystemOperations {
  async stat(e) {
    return vscode.workspace.fs.stat(e)
  }
  async readDirectory(e) {
    return vscode.workspace.fs.readDirectory(e)
  }
  async createDirectory(e) {
    return vscode.workspace.fs.createDirectory(e)
  }
  async readFile(e) {
    return vscode.workspace.fs.readFile(e)
  }
  async writeFile(e, r) {
    return vscode.workspace.fs.writeFile(e, r)
  }
  async delete(e, r) {
    return vscode.workspace.fs.delete(e, r)
  }
  async rename(e, r, n) {
    return vscode.workspace.fs.rename(e, r, n)
  }
  async copy(e, r, n) {
    return vscode.workspace.fs.copy(e, r, n)
  }
  isWritableFileSystem(e) {
    return !!vscode.workspace.fs.isWritableFileSystem(e)
  }
  createFileSystemWatcher(e) {
    return vscode.workspace.createFileSystemWatcher(e)
  }
}
var BaseGitExtensionService = class {}
var vscode = handleDefaultExports(require('vscode'))
class GitExtensionService extends BaseGitExtensionService {
  constructor(accessor) {
    super();
    this.accessor = accessor;
    this._onDidChange = new vscode.EventEmitter();
    this.onDidChange = this._onDidChange.event;
    this._disposables = [];
    this._logger = accessor.get(LoggerManager).getLogger('gitExtensionService');
    this._logger.info('Initializing Git extension service.');
    this._disposables.push(...this._initializeExtensionApi());
  }

  getExtensionApi() {
    return this._api;
  }

  _initializeExtensionApi() {
    let disposables = [];
    let gitExtension = vscode.extensions.getExtension('vscode.git');

    let activateGitExtension = async () => {
      let activatedExtension = await gitExtension.activate();
      this._logger.info('Successfully activated the vscode.git extension.');

      let handleEnablementChange = isEnabled => {
        this._logger.info(`Enablement state of the vscode.git extension: ${isEnabled}.`);
        if (isEnabled) {
          this._api = activatedExtension.getAPI(1);
          this._onDidChange.fire();
          this._logger.info('Successfully registered Git commit message provider.');
        }
      };

      disposables.push(activatedExtension.onDidChangeEnablement(handleEnablementChange));
      handleEnablementChange(activatedExtension.enabled);
    };

    if (gitExtension) {
      activateGitExtension();
    } else {
      this._logger.info('vscode.git extension is not yet activated.');
      let onDidChange = vscode.extensions.onDidChange(() => {
        if (!gitExtension && vscode.extensions.getExtension('vscode.git')) {
          gitExtension = vscode.extensions.getExtension('vscode.git');
          activateGitExtension();
          onDidChange.dispose();
        }
      });
    }

    return disposables;
  }
}
var vscode = handleDefaultExports(require('vscode'))
class GitRepositoryManager extends BaseGitRepositoryManager {
  constructor(tabsAndEditors) {
    super();
    this.tabsAndEditors = tabsAndEditors;
  }

  get repositories() {
    let gitExtension = vscode.extensions.getExtension('vscode.git');
    if (!gitExtension) return;
    let workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return;
    let gitApi = gitExtension.exports.getAPI(1);
    return workspaceFolders.map(folder => {
      let repository = gitApi.getRepository(folder.uri);
      if (repository)
        return {
          headBranchName: repository.state.HEAD?.name,
          upstreamBranchName: repository.state.HEAD?.upstream?.name,
          isRebasing: repository.state.rebaseCommit !== null,
          remotes: repository.state.remotes.map(remote => remote.name),
          remoteFetchUrls: repository.state.remotes.map(remote => remote.fetchUrl),
        };
    });
  }

  get currentRepository() {
    let gitExtension = vscode.extensions.getExtension('vscode.git');
    if (gitExtension) {
      let gitApi = gitExtension.exports.getAPI(1);
      let selectedRepository = this.selectRepository(gitApi);
      return selectedRepository
        ? {
            headBranchName: selectedRepository.state.HEAD?.name,
            upstreamBranchName: selectedRepository.state.HEAD?.upstream?.name,
            isRebasing: selectedRepository.state.rebaseCommit !== null,
            remotes: selectedRepository.state.remotes.map(remote => remote.name),
            remoteFetchUrls: selectedRepository.state.remotes.map(remote => remote.fetchUrl),
          }
        : undefined;
    }
  }

  selectRepository(gitApi) {
    if (gitApi.repositories.length === 0) return;
    if (gitApi.repositories.length === 1) return gitApi.repositories[0];
    let activeEditor = this.tabsAndEditors.activeTextEditor;
    return gitApi.repositories.filter(repo => activeEditor?.document.uri.fsPath.startsWith(repo.rootUri.fsPath))[0];
  }
}
var vscode = require('vscode')
function processPattern(pattern) {
  if (typeof pattern != 'string') throw new TypeError('Argument must be a string.')
  if (!pattern) return pattern

  let isNegated = pattern.startsWith('!'),
    trimmedPattern = isNegated ? pattern.slice(1) : pattern,
    modifiedPattern = trimmedPattern,
    isAbsolute = false

  switch ((trimmedPattern[0] === '/' && ((isAbsolute = true), (modifiedPattern = trimmedPattern.slice(1))), modifiedPattern[0])) {
    case '*':
      trimmedPattern[1] !== '*' && (modifiedPattern = '**/' + modifiedPattern)
      break
    default:
      if ((((!isAbsolute && !modifiedPattern.includes('/')) || modifiedPattern.endsWith('/')) && (modifiedPattern = '**/' + modifiedPattern), modifiedPattern.endsWith('*') || modifiedPattern.endsWith('?'))) break
      ;/\.[a-z\d_-]+$/.test(modifiedPattern) || (modifiedPattern.endsWith('/') || (modifiedPattern += '/'), (modifiedPattern += '**'))
  }

  return isNegated ? '!' + modifiedPattern : modifiedPattern
}
var Gee = handleDefaultExports(Hee())
var path = require('path')
class IgnoreFileManager {
  constructor() {
    this._ignoreMap = new Map()
    this._ignoreCache = new Map()
    this._searchRankCache = null
  }

  setIgnoreFile(file, patterns) {
    this._ignoreMap.set(file.fsPath, {
      ignore: (0, Gee.default)().add(patterns),
      patterns: patterns.split(/\r?\n/).filter(Boolean).map(processPattern),
    })
    this._searchRankCache = null
    this._ignoreCache.clear()
  }

  removeIgnoreFile(file) {
    this._ignoreMap.delete(file.fsPath)
    this._searchRankCache = null
    this._ignoreCache.clear()
  }

  removeWorkspace(workspace) {
    let count = 0
    for (let key of this._ignoreMap.keys()) {
      if (isPathEqualOrChild(workspace.fsPath, key)) {
        this._ignoreMap.delete(key)
        count += 1
      }
    }
    if (count > 0) {
      this._searchRankCache = null
      this._ignoreCache.clear()
    }
  }

  asMinimatchPatterns() {
    return [...this._ignoreMap.values()].flatMap(value => value.patterns)
  }

  isIgnored(file) {
    if (this._ignoreMap.size === 0) return false
    let filePath = file.fsPath
    if (this._ignoreCache.has(filePath)) return this._ignoreCache.get(filePath)
    let rank = 0
    let result = { ignored: false, unignored: false }
    try {
      let searchRank = this._searchRank
      for (let rankItem of searchRank) {
        rank += 1
        let dir = (0, path.dirname)(rankItem)
        let relativePath = (0, path.relative)(dir, filePath)
        if (!relativePath.startsWith('..') && dir !== filePath && isPathEqualOrChild(dir, filePath)) {
          let ignoreInfo = this._ignoreMap.get(rankItem)
          if (!ignoreInfo) throw new Error(`No ignore patterns found for ${rankItem}`)
          result = ignoreInfo.ignore.test(relativePath)
          if (result.ignored || result.unignored) break
        }
      }
      this._ignoreCache.set(filePath, result.ignored)
      return result.ignored
    } catch {
      return false
    }
  }

  get _searchRank() {
    if (this._searchRankCache !== null) return this._searchRankCache
    let pathLengths = {}
    let getPathLength = path => path.split(path.sep).length
    return (this._searchRankCache = [...this._ignoreMap.keys()].sort((path1, path2) => (pathLengths[path2] ||= getPathLength(path2)) - (pathLengths[path1] ||= getPathLength(path1))))
  }
}

function isPathEqualOrChild(parentPath, childPath) {
  return parentPath === childPath
    ? true
    : (parentPath.charAt(parentPath.length - 1) !== path.sep && (parentPath += path.sep), (0, path.normalize)(childPath).startsWith((0, path.normalize)(parentPath)))
}
const copilotIgnoreFileName = '.copilotignore'
const gitIgnoreFileName = '.gitignore'

class IgnoreFileHandler {
  constructor(accessor) {
    this.accessor = accessor
    this._gitIgnoreFiles = new IgnoreFileManager()
    this._copilotIgnoreFiles = new IgnoreFileManager()
    this._disposables = []
    this.fs = accessor.get(BaseFileSystemOperations)
  }

  dispose() {
    this._disposables.forEach(disposable => disposable.dispose())
    this._disposables = []
  }

  isIgnored(file, options) {
    let isGitIgnored = this._gitIgnoreFiles.isIgnored(file)
    let isCopilotIgnored = this._copilotIgnoreFiles.isIgnored(file)
    return !options || (options.includeGitIgnore && options.includeCopilotIgnore)
      ? isGitIgnored || isCopilotIgnored
      : options.includeGitIgnore && !options.includeCopilotIgnore
      ? isGitIgnored
      : !options.includeGitIgnore && options.includeCopilotIgnore
      ? isCopilotIgnored
      : false
  }

  asMinimatchPattern(options) {
    let patterns = []
    options.includeCopilotIgnore && patterns.push(this._copilotIgnoreFiles.asMinimatchPatterns())
    options.includeGitIgnore && patterns.push(this._gitIgnoreFiles.asMinimatchPatterns())
    let flatPatterns = patterns.flat()
    if (flatPatterns.length !== 0) return flatPatterns.length === 1 ? flatPatterns[0] : `{${flatPatterns.join(',')}}`
  }

  init() {
    return (
      (this._init ??= (async () => {
        for (let workspace of this.accessor.get(WorkspaceClass).getWorkspaceFolders()) await this.addWorkspace(workspace)
      })()),
      this._init
    )
  }

  trackIgnoreFile(file, patterns) {
    file.path.endsWith(gitIgnoreFileName)
      ? this._gitIgnoreFiles.setIgnoreFile(file, patterns)
      : file.path.endsWith(copilotIgnoreFileName) && this._copilotIgnoreFiles.setIgnoreFile(file, patterns)
  }

  removeIgnoreFile(file) {
    file.path.endsWith(gitIgnoreFileName)
      ? this._gitIgnoreFiles.removeIgnoreFile(file)
      : file.path.endsWith(copilotIgnoreFileName) && this._copilotIgnoreFiles.removeIgnoreFile(file)
  }

  removeWorkspace(workspace) {
    this._gitIgnoreFiles.removeWorkspace(workspace)
    this._copilotIgnoreFiles.removeWorkspace(workspace)
  }

  isIgnoreFile(file) {
    return file.path.endsWith(gitIgnoreFileName) ? true : !!file.path.endsWith(copilotIgnoreFileName)
  }

  async addWorkspace(workspace) {
    let files = []
    if (workspace.scheme !== 'file') return
    let fileFinder = this.accessor.get(FileFinder)
    files = files.concat(await fileFinder.findFiles(new BaseUriPattern(workspace, `**/${copilotIgnoreFileName}`)))
    files = files.concat(await fileFinder.findFiles(new BaseUriPattern(workspace, `**/${gitIgnoreFileName}`)))
    for (let file of files) {
      let content = (await this.fs.readFile(file)).toString()
      this.trackIgnoreFile(file, content)
    }
  }
}
var WorkspaceIgnoreFileHandler = class extends IgnoreFileHandler {
  constructor(accessor) {
    super(accessor)
    this.installListeners()
  }

  installListeners() {
    this._disposables.push(
      vscode.workspace.onDidChangeWorkspaceFolders(event => {
        for (let folder of event.removed) this.removeWorkspace(folder.uri)
        for (let folder of event.added) this.addWorkspace(folder.uri)
      })
    )

    this._disposables.push(
      vscode.workspace.onDidSaveTextDocument(async document => {
        if (this.isIgnoreFile(document.uri)) {
          let content = (await vscode.workspace.fs.readFile(document.uri)).toString()
          this.trackIgnoreFile(document.uri, content)
        }
      }),

      vscode.workspace.onDidDeleteFiles(event => {
        for (let file of event.files) this.removeIgnoreFile(file)
      }),

      vscode.workspace.onDidRenameFiles(async event => {
        for (let file of event.files)
          if (this.isIgnoreFile(file.newUri)) {
            let content = (await vscode.workspace.fs.readFile(file.newUri)).toString()
            this.removeIgnoreFile(file.oldUri)
            this.trackIgnoreFile(file.newUri, content)
          }
      })
    )
  }
}
var vscode = handleDefaultExports(require('vscode'))
var DiagnosticListener = class extends DiagnosticWaiter {
  constructor() {
    super(...arguments)
    this.onDidChangeDiagnostics = vscode.languages.onDidChangeDiagnostics
  }
  getDiagnostics(r) {
    return vscode.languages.getDiagnostics(r)
  }
}
var vscode = handleDefaultExports(require('vscode'))
var SymbolProvider = class extends BaseSymbolProvider {
  async getDefinitions(uri, position) {
    return await vscode.commands.executeCommand('vscode.executeDefinitionProvider', uri, position)
  }
  async getImplementations(uri, position) {
    return await vscode.commands.executeCommand('vscode.executeImplementationProvider', uri, position)
  }
  async getReferences(uri, position) {
    return await vscode.commands.executeCommand('vscode.executeReferenceProvider', uri, position)
  }
  async getWorkspaceSymbols(query) {
    return await vscode.commands.executeCommand('vscode.executeWorkspaceSymbolProvider', query)
  }
}
var fs = handleDefaultExports(require('fs')),
vscode = handleDefaultExports(require('vscode'))
var VariableManager = class {
  constructor(configProvider) {
    this._variableEnablements = configProvider.get(ConfigManager).getConfigMixedWithDefaults(settings.ConversationVariablesEnablements)
  }
  isVariableEnabled(variable) {
    return typeof this._variableEnablements[variable.name] == 'boolean'
      ? this._variableEnablements[variable.name]
      : typeof variable.defaultEnablement == 'boolean'
      ? variable.defaultEnablement
      : !!this._variableEnablements['*']
  }
  getVariables() {
    let variables = []
    for (let resolver of ContextResolverRegistry.contextResolvers)
      resolver.variableInfo &&
        this.isVariableEnabled(resolver.variableInfo) &&
        variables.push({
          name: resolver.variableInfo.name,
          kind: resolver.kind,
          description: resolver.variableInfo.description,
          resolve: resolver.resolveContext.bind(resolver),
        })
    return variables
  }
  getVariable(variableName) {
    return this.getVariables().find(variable => variable.name === variableName)
  }
}

var VariableResolver = class extends BaseEmptyClass {
  constructor(accessor) {
    super()
    this.accessor = accessor
    this._chatVariableService = accessor.get(VariableManager)
  }
  async resolveVariablesInPrompt(prompt, variables) {
    let regex = /(^|\s)\[([^\]]+)\]\(values:([^\)]+)\)/gi,
      parts = []
    for (;;) {
      let match = regex.exec(prompt)
      if (!match) return { parts, message: prompt }
      let [fullMatch, whitespace, variableName, variableKey] = match,
        variableValues = variables[variableKey]
      if (!variableValues || variableValues.length === 0) continue
      let cleanedKey = variableKey.replace(/^#/, ''),
        shortenFunction,
        selectedValue = variableValues.find(value => value.level === 3) ?? variableValues[0]
      if (selectedValue.value instanceof VscodeUri) {
        let uri = selectedValue.value
        selectedValue.value = wrapCodeWithBackticks('', (await fs.promises.readFile(selectedValue.value.fsPath)).toString()),
        shortenFunction = async () => formatContext(cleanedKey) + wrapCodeWithBackticks('', await this.shortenUriVariableValue(uri))
      }
      if (selectedValue.kind === 'github.docset') prompt = prompt.slice(0, match.index) + whitespace + selectedValue.value + prompt.slice(match.index + fullMatch.length)
      else {
        let variable = this._chatVariableService.getVariable(variableKey)
        parts.push({ kind: variable?.kind ?? 'variable', userMessages: [formatContext(cleanedKey) + selectedValue.value], getShorterMessage: shortenFunction }),
        prompt = prompt.slice(0, match.index) + whitespace + `[${variableName}](#${cleanedKey}-context)` + prompt.slice(match.index + fullMatch.length)
      }
    }
  }
  async shortenUriVariableValue(uri) {
    let document = await vscode.workspace.openTextDocument(uri),
      text = document.getText(),
      functionBodies = await getSortedFunctionBodies(this.accessor, document, 1e3),
      delimiter = document.languageId === 'typescript' ? ';' : ''
    return insertIntoStringAtIndicesjke(text, functionBodies, delimiter)
  }
}

function formatContext(context) {
  return `# ${context.toUpperCase()} CONTEXT
`
}

function insertIntoStringAtIndices(source, indices, insertValue) {
  let currentIndex = 0,
    result = ''
  for (let index of indices)
    if (currentIndex < index.startIndex) {
      result += source.substring(currentIndex, index.startIndex)
      result += insertValue
      currentIndex = index.endIndex
    }
  return result
}
var vscode = handleDefaultExports(require('vscode'))
var FileSearcher = class extends FileFinder {
  findTextInFiles(query, options, progress, token) {
    return Promise.resolve(vscode.workspace.findTextInFiles(query, options, match => progress.report(match), token))
  }
  findFiles(include, exclude, maxResults, token) {
    return vscode.workspace.findFiles(include, exclude, maxResults, token)
  }
}
var vscode = handleDefaultExports(require('vscode'))
var TabManager = class extends BaseTabManager {
  constructor() {
    super()
    this._disposableStore = new DisposableStore()
    this._tabGroupsUsageInfo = new Map()
    this._tabUsageCounter = 0
    this.onDidChangeActiveTextEditor = vscode.window.onDidChangeActiveTextEditor
    this.onDidChangeTabs = vscode.window.tabGroups.onDidChangeTabs
    this._disposableStore.add(
      vscode.window.tabGroups.onDidChangeTabGroups(tabGroupChangeEvent => {
        tabGroupChangeEvent.closed.forEach(closedGroup => this._tabGroupsUsageInfo.delete(closedGroup)),
          this._tabGroupsUsageInfo.set(vscode.window.tabGroups.activeTabGroup, this._tabUsageCounter++)
      })
    )
  }
  dispose() {
    this._disposableStore.dispose()
  }
  get activeTextEditor() {
    let activeEditor = vscode.window.activeTextEditor
    if (activeEditor && activeEditor.document.uri.scheme !== 'output') return activeEditor
    let visibleEditorsMap = new ResourceMap()
    vscode.window.visibleTextEditors.forEach(editor => visibleEditorsMap.set(editor.document.uri, editor))
    let usageInfoArray = [...this._tabGroupsUsageInfo]
    usageInfoArray.sort((a, b) => b[1] - a[1])
    for (let [group] of usageInfoArray)
      if (group.activeTab) {
        let tabInfo = this._convertToTabInfo(group.activeTab)
        if (tabInfo.uri && visibleEditorsMap.has(tabInfo.uri)) return visibleEditorsMap.get(tabInfo.uri)
      }
  }
  get tabs() {
    return vscode.window.tabGroups.all.flatMap(group => group.tabs).map(this._convertToTabInfo, this)
  }
  _convertToTabInfo(tab) {
    let uri
    return (
      tab.input instanceof vscode.TabInputText || tab.input instanceof vscode.TabInputNotebook
        ? (uri = tab.input.uri)
        : (tab.input instanceof vscode.TabInputTextDiff || tab.input instanceof vscode.TabInputNotebookDiff) &&
          (uri = tab.input.modified),
      { tab: tab, uri: uri }
    )
  }
}

var TelemetryManager = class {
  sendInternalTelemetryEvent(eventName, properties, measurements) {}
  postEvent(eventName, properties) {}
  setSharedProperty(name, value) {}
  sendTelemetryErrorEvent(eventName, properties, measurements) {}
  sendTelemetryEvent(eventName, properties, measurements) {}
}

var telemetryModule = handleDefaultExports(Hme()),
os = handleDefaultExports(require('os'))
var TelemetryClient = class {
  constructor(context, namespace, config) {
    this.namespace = namespace
    ;(this.client = createTelemetryClient(context, config)), setupTelemetryClient(context, this.client)
  }
  separateData(data) {
    let properties = {},
      measurements = {}
    for (let [key, value] of Object.entries(data)) typeof value == 'number' ? (measurements[key] = value) : (properties[key] = value)
    return { properties: properties, measurements: measurements }
  }
  sendEventData(eventName, data) {
    let { properties, measurements } = this.separateData(data || {})
    this.client.trackEvent({ name: this.qualifyEventName(eventName), properties: properties, measurements: measurements })
  }
  sendErrorData(error, data) {
    let { properties, measurements } = this.separateData(data || {})
    this.client.trackException({ exception: error, properties: properties, measurements: measurements })
  }
  flush() {
    return new Promise(resolve => {
      this.client.flush({
        callback: () => {
          resolve(void 0)
        },
      })
    })
  }
  qualifyEventName(eventName) {
    return eventName.startsWith(this.namespace) ? eventName : `${this.namespace}/${eventName}`
  }
}
function createTelemetryClient(context, config) {
  let client = new telemetryModule.TelemetryClient(config)
  return (
    (client.config.enableAutoCollectRequests = !1),
    (client.config.enableAutoCollectPerformance = !1),
    (client.config.enableAutoCollectExceptions = !1),
    (client.config.enableAutoCollectConsole = !1),
    (client.config.enableAutoCollectDependencies = !1),
    (client.config.noDiagnosticChannel = !0),
    setupTelemetryClient(context, client),
    client
  )
}
function setupTelemetryClient(context, client) {
  client.commonProperties = setupCommonProperties(client.commonProperties, context)
  let buildInfo = context.get(BuildInfo)
  ;(client.context.tags[client.context.keys.sessionId] = buildInfo.sessionId),
    (client.context.tags[client.context.keys.userId] = buildInfo.machineId),
    (client.context.tags[client.context.keys.cloudRoleInstance] = 'REDACTED'),
    (client.config.endpointUrl = context.get(UrlProvider).getUrl())
}
function setupCommonProperties(properties, context) {
  ;(properties = properties || {}), (properties.common_os = os.platform()), (properties.common_platformversion = os.release())
  let buildInfo = context.get(BuildInfo)
  return (
    (properties.common_vscodemachineid = buildInfo.machineId),
    (properties.common_vscodesessionid = buildInfo.sessionId),
    (properties.common_uikind = 'desktop'),
    (properties.common_remotename = 'none'),
    (properties.common_isnewappinstall = ''),
    properties
  )
}
var telemetryId1 = '7d7048df-6dd0-4048-bb23-b716c1461f8f',
telemetryId2 = '3fdd7f28-937a-48c8-9a21-ba337db23bd1'
async function setupTelemetry(context, namespace, shouldActivate) {
  let telemetryService = context.get(IGHTelemetryService);
  if ((await telemetryService.deactivate(), !shouldActivate)) return;
  let telemetryClient1 = new TelemetryClient(context, namespace, telemetryId1),
    telemetryClient2 = new TelemetryClient(context, namespace, telemetryId2);
  return (
    telemetryService.setReporter(telemetryClient1),
    telemetryService.setSecureReporter(telemetryClient2),
    {
      dispose() {
        telemetryService.setReporter(void 0), telemetryService.setSecureReporter(void 0), telemetryClient1.flush(), telemetryClient2.flush();
      },
    }
  );
}
var path = require('path'),
process = require('process'),
vscode = require('vscode'),
terminalDataMap = new Map(),
terminalCommandMap = new Map()
function getTerminalData() {
  let terminal = vscode.window.activeTerminal;
  return terminal === void 0
    ? ''
    : terminalDataMap.get(terminal)?.join(`
`) || '';
}

function getLastTerminalCommand() {
  let terminal = vscode.window.activeTerminal;
  if (terminal !== void 0) return terminalCommandMap.get(terminal)?.at(-1);
}

function getTerminalSelection() {
  try {
    return vscode.window.activeTerminal?.selection ?? '';
  } catch {
    return '';
  }
}
var lastShellType

function getShellType() {
  let terminal = vscode.window.activeTerminal;
  if (terminal && 'shellPath' in terminal.creationOptions) {
    let shellPath = terminal.creationOptions.shellPath;
    if (shellPath) {
      let shellType,
        baseName = (0, path.basename)(shellPath);
      if (baseName === 'bash.exe') shellType = 'Git Bash';
      else {
        let nameWithoutExtension = baseName.replace(/\..+/, '');
        switch (nameWithoutExtension) {
          case 'pwsh':
          case 'powershell':
            shellType = 'powershell';
          case '':
            break;
          default:
            shellType = nameWithoutExtension;
        }
      }
      if (shellType) return (lastShellType = shellType), shellType;
    }
  }
  return lastShellType || (process.platform === 'win32' ? 'powershell' : 'bash');
}

function limitArraySize(array, item) {
  array.push(item), array.length > 40 && array.shift();
}

function removeEscapeSequences(text) {
  let escapeSequenceRegex = /(:?\x1b\[|\x9B)[=?>!]?[\d;:]*["$#'* ]?[a-zA-Z@^`{}|~]/g;
  return text && (text = text.replace(escapeSequenceRegex, '')), text;
}

function setupTerminalListeners() {
  return [
    vscode.window.onDidWriteTerminalData(event => {
      let terminalData = terminalDataMap.get(event.terminal);
      terminalData || ((terminalData = []), terminalDataMap.set(event.terminal, terminalData)), limitArraySize(terminalData, removeEscapeSequences(event.data));
    }),
    vscode.window.onDidExecuteTerminalCommand(event => {
      let terminalCommands = terminalCommandMap.get(event.terminal);
      terminalCommands || ((terminalCommands = []), terminalCommandMap.set(event.terminal, terminalCommands)), limitArraySize(terminalCommands, event);
    }),
    vscode.window.onDidCloseTerminal(terminal => {
      terminalDataMap.delete(terminal);
    }),
  ];
}

var TerminalInfoProvider = class extends BaseTerminalInfoProvider {
  constructor() {
    super();
    for (let listener of setupTerminalListeners()) {
      this._register(listener);
    }
  }
  get terminalBuffer() {
    return getTerminalData();
  }
  get terminalLastCommand() {
    return getLastTerminalCommand();
  }
  get terminalSelection() {
    return getTerminalSelection();
  }
  get terminalShellType() {
    return getShellType();
  }
}

var vscode = require('vscode')
var WorkspaceManager = class extends WorkspaceClass {
  constructor(r) {
    super()
    this.onDidOpenTextDocument = vscode.workspace.onDidOpenTextDocument
    this.onDidChangeTextDocument = vscode.workspace.onDidChangeTextDocument
    this.onDidCloseTextDocument = vscode.workspace.onDidCloseTextDocument
  }
  get textDocuments() {
    return vscode.workspace.textDocuments
  }
  async openTextDocument(r) {
    return await vscode.workspace.openTextDocument(r)
  }
  get notebookDocuments() {
    return vscode.workspace.notebookDocuments
  }
  getWorkspaceFolders() {
    return vscode.workspace.workspaceFolders?.map(r => r.uri) ?? []
  }
}
var vscode = handleDefaultExports(require('vscode'))
var ChatLogger = class Logger {
  constructor(accessor, outputChannelProvider) {
    this.accessor = accessor
    this.outputChannelProvider = outputChannelProvider
    this.requestCount = -1
    this.logger = accessor.get(LoggerManager).getPromptResponseLogger('chat')
  }
  logRequest(request) {
    this.requestCount++, this.logInfo('REQUEST', `User:${this.headerSeparator()}${this.printMessageContent(request.message)}`)
  }
  logMessages(messages) {
    this.logInfo(
      'PROMPT MESSAGES',
      messages.map(message => `${this.getDisplayRole(message.role)}:${this.headerSeparator()}${this.printMessageContent(message.content)}`)
        .join(`
`)
    )
  }
  logProgress(progress, isResponse) {
    let content = 'markdownContent' in progress ? progress.markdownContent.value : 'content' in progress ? progress.content : void 0
    content && (isResponse ? this.logInfo('RESPONSE', `Assistant:	${content}`) : this.logInfo('', `${this.bodySeparator()}${content}`, false))
  }
  logResponse(response) {
    this.logInfo('', ''), response.errorDetails && this.logInfo('ERROR DETAILS', JSON.stringify(response.errorDetails, void 0, 4))
  }
  logFollowups(followups) {
    this.logInfo(
      'FOLLOWUPS',
      'Followups:	' +
        followups.map(
          (followup, index) => `${followup.title}
${this.bodySeparator()}`
        ).join(`
${this.bodySeparator()}`)
    )
  }
  logThrownError(error) {
    this.logInfo('THROWN ERROR', error.stack ? error.stack : error.message)
  }
  logIntent(intent, isUser) {
    this.logInfo(
      'INTENT',
      intent !== void 0
        ? `User intent determined to be '${intent}' via the ${isUser ? 'user' : 'model'}`
        : 'Intent could not be determined'
    )
  }
  logInfo(title, content, isNewLine = true) {
    if (!this.accessor.get(ConfigManager).getConfig(settings.ConversationLoggingEnabled)) return
    let timestamp = new Date().toISOString()
    title &&
      ((content = `[${title} ${this.requestCount}]
${content}`),
      (content = `${timestamp} [info] ${content}`)),
      Logger.outputChannel === void 0 && (Logger.outputChannel = this.outputChannelProvider()),
      isNewLine
        ? (this.logger.info(
            content +
              `
`
          ),
          Logger.outputChannel.appendLine(
            content +
              `
`
          ))
        : (this.logger.info(content), Logger.outputChannel.append(content))
  }
  printMessageContent(message) {
    return message.split(`
`).join(`
${this.bodySeparator()}`)
  }
  headerSeparator() {
    return '		'
  }
  bodySeparator() {
    return '			'
  }
  getDisplayRole(role) {
    switch (role) {
      case 'system':
        return 'System'
      case 'user':
        return 'User'
      case 'assistant':
        return 'Assistant'
    }
  }
}
var requestLight = handleDefaultExports(requestLight())
var uGe = `
[EXAMPLES START]
Below you will find a set of examples of what you should respond with. Please follow these examples as closely as possible.

## Settings response
Question: How do I disable telemetry?

Response:
\`\`\`json
{
    "telemetry.telemetryLevel": "off"
}
\`\`\`
is a setting which can be used to disable telemetry.

## Command response
Question: How do I close all editors?

Response:
You can use the **Close All Editors** command to close all editors.

[COMMANDS START]
\`\`\`json
[
    { "command": "workbench.action.closeAllEditors" }
]
\`\`\`
[COMMANDS END]

## No such command
Question: How do I move the terminal to a new window?

Response:
There is no such command.

## Invalid Question
Question: How do I bake a potato?

Response:
Sorry this question isn't related to VS Code.

## Marketplace search
Question: How do I add PHP support?

Response:
You can use the **Search marketplace** command to search for extensions that add PHP support.

[COMMANDS START]
\`\`\`json
[
    { "command": "workbench.extensions.search", "args": "php" }
]
\`\`\`
[COMMANDS END]
`,
  rq = 'vscode'
  IntentManager.registerIntent(
  new Intent({
    location: 2,
    id: rq,
    description: 'Ask questions about VS Code',
    modelDescription:
      'Looks up information about VS Code via commands, settings, and documentation to accomplish the given editor-specific task.',
    modelSampleQuestion: 'What is the command to open the integrated terminal?',
    systemPromptOptions: {
      examples: uGe,
      roleplay:
        'You are a VS Code assistant. Your job is to assist users in using VS Code by providing knowledge to accomplish their task. This knowledge should focus on settings and commands, but also includes documentation. Please do not guess a response and instead just respond with a polite apology if you are unsure.',
    },
    commandInfo: { allowsEmptyArgs: !1, sampleRequest: requestLight.t('What is the command to open the integrated terminal?') },
    rules: `
You must respond with either a setting to set or a command to execute when applicable.
When referring to a command, you must use the command name in markdown bold syntax.
When referring to any commands, you must include a section wrapped with [COMMANDS START] and [COMMANDS END] at the end of your response which lists all commands you referenced in your response in the order they were referenced in a JSON code block containing a JSON array.
If a command or setting references another command or setting, you must respond with the original setting or command and the referenced setting or command.
All referenced settings must be properly formatted in a JSON markdown code block to allow copying them into the user's settings.json file.
You must not respond with a setting that is not in a properly formatted JSON markdown code block.
If a setting and command will accomplish the same thing, you must suggest the command instead.
You must not suggest opening the settings editor.
You must not suggest pressing any keybindings or keyboard shortcuts to execute commands.
You must not suggest opening the command palette to execute commands.
You must not suggest commands or settings identifiers that do not exist.
If you believe the context given to you is incorrect or not relevant you may ignore it.
If an extension might help the user, you may suggest a search query for the extension marketplace. You must also include the command **Search marketplace** (\`workbench.extensions.search\`) with args set to the suggested query in the commands section at the end of your response. The query can also contain the tags "@popular", "@recommended", or "@featured" to filter the results.`.trim(),
    contextResolvers: [vSCodeContextResolver],
    followUps: loadAndProcessIndexes,
  })
)
var requestLight = handleDefaultExports(requestLight())
var path = require('path')
var openRelativePathCommand = '_github.copilot.openRelativePath',
  openSymbolInFileCommand = '_github.copilot.openSymbolInFile'

function createRelativePathLink(text, path) {
  return `[\`${text}\`](${createCommandLink(openRelativePathCommand, [path.replace(/\\/g, '/')])} "${escapeQuotes(path)}")`
}

function createSymbolInFileLink(symbol, path) {
  return `[\`${symbol}\`](${createCommandLink(openSymbolInFileCommand, [path.replace(/\\/g, '/'), symbol])} "${escapeQuotes(path)}")`
}

function createCommandLink(command, args) {
  return `command:${command}?${encodeURIComponent(JSON.stringify(args))}`
}

function escapeQuotes(text) {
  return text.replace(/"/g, '\\"')
}

var linkifiersSet = new Set()

function addLinkifier(linkifier) {
  linkifiersSet.add(linkifier)
  return { dispose: () => linkifiersSet.delete(linkifier) }
}
var TextLinkifier = class {
  constructor(references, workspaceFolders, fileSystem) {
    this.references = references
    this.workspaceFolders = workspaceFolders
    this.fileSystem = fileSystem
    this.additionalLinkifiers = Array.from(linkifiersSet, linkifier => linkifier(references, workspaceFolders, fileSystem))
  }
  async linkify(text, cancellationToken) {
    if (
      ((text = await replaceAllWithPromise(text, /\[`([^`\[\]]+?)`]\((\S+?\.\w+)\)/g, async (match, symbol, path) => {
        let uri = Uri.joinPath(this.workspaceFolders[0], path)
        return (await fileExists(this.fileSystem, uri)) ? createSymbolInFileLink(symbol, path) : '`' + symbol + '`'
      })),
      cancellationToken?.isCancellationRequested)
    )
      return ''
    let linkifyPath = async (match, linkText, path) => {
      if (/^\w+:/.test(path) || !this.workspaceFolders.length) return match
      let uri = Uri.joinPath(this.workspaceFolders[0], path)
      if (await fileExists(this.fileSystem, uri)) return createRelativePathLink(path, path)
      let basename = getBasename(uri),
        referenceUri = this.references.map(ref => (Uri.isUri(ref.anchor) ? ref.anchor : ref.anchor.uri)).find(uri => getBasename(uri) === basename)
      if (referenceUri) {
        let relativePath = (0, path.relative)(this.workspaceFolders[0].fsPath, referenceUri.fsPath)
        return createRelativePathLink(path, relativePath)
      }
      return linkText
    }
    if (((text = await replaceAllWithPromise(text, /\[([^`\s]+)\]\((\1)\)/g, linkifyPath)), cancellationToken?.isCancellationRequested)) return ''
    text = await replaceAllWithPromise(text, /(?<!\[)(`([^`\s]+)`)(?!\])/g, linkifyPath)
    for (let linkifier of this.additionalLinkifiers) if (((text = await linkifier.linkify(text, cancellationToken)), cancellationToken?.isCancellationRequested)) return ''
    return (text = text.replace(/\[([^\[\]]+)]\((\S+?\.\w+)\)/g, (match, linkText, path) => (/^\w+:/.test(path) ? match : linkText))), text
  }
}
async function fileExists(fileSystem, file) {
  try {
    await fileSystem.stat(file)
    return true
  } catch {
    return false
  }
}
var stepByStepGuide = `
Think step by step:

1. Read the provided relevant workspace information (code excerpts, file names, and symbols) to understand the user's workspace.

2. Consider how to answer the user's prompt based on the provided information and your specialized coding knowledge. Always assume that the user is asking about the code in their workspace instead of asking a general programming question. Prefer using variables, functions, types, and classes from the workspace over those from the standard library.

3. Generate a response that clearly and accurately answers the user's question. In your response, add fully qualified links for referenced symbols (example: [\`namespace.VariableName\`](path/to/file.ts)) and links for files (example: [path/to/file](path/to/file.ts)) so that the user can open them. If you do not have enough information to answer the question, respond with "I'm sorry, I can't answer that question with what I currently know about your workspace".

Remember that you MUST add links for all referenced symbols from the workspace and fully qualify the symbol name in the link, for example: [\`namespace.functionName\`](path/to/util.ts).
Remember that you MUST add links for all workspace files, for example: [path/to/file.js](path/to/file.js)
`.trim(),
var exampleDialogue = `
Question:
What file implements base64 encoding?

Response:
Base64 encoding is implemented in [src/base64.ts](src/base64.ts) as [\`encode\`](src/base64.ts) function.


Question:
How can I join strings with newlines?

Response:
You can use the [\`joinLines\`](src/utils/string.ts) function from [src/utils/string.ts](src/utils/string.ts) to join multiple strings with newlines.


Question:
How do I build this project?

Response:
To build this TypeScript project, run the \`build\` script in the [package.json](package.json) file:

\`\`\`sh
npm run build
\`\`\`


Question:
How do I read a file?

Response:
To read a file, you can use a [\`FileReader\`](src/fs/fileReader.ts) class from [src/fs/fileReader.ts](src/fs/fileReader.ts).
`.trim(),
var exampleDialogue = 'workspace',
var workspaceIntent = new Intent({
    location: 2,
    id: exampleDialogue,
    description: requestLight.t('Ask a question about the files in your current workspace'),
    modelSampleQuestion: 'How do I build this project?',
    commandInfo: { allowsEmptyArgs: !1, defaultEnablement: !0, sampleRequest: requestLight.t('How do I build this project?') },
    systemPromptOptions: {
      roleplay:
        'You are a software engineer with expert knowledge of the codebase the user has open in their workspace.',
      examples: exampleDialogue,
    },
    rules: stepByStepGuide,
    contextResolvers: [contextResolverRegistry, currentSelectionContextResolver, workspaceResolver],
    responseProcessor: (t, e, r, n, i) => new TextProcessor2(t, e, r, i),
  })
IntentManager.registerIntent(workspaceIntent)
var TextProcessor2 = class {
  constructor(context, references, reporter, cancellationToken, textApplier) {
    this._appliedText = ''
    this._isInCodeBlock = false
    this._promise = Promise.resolve('')
    let fileSystemOperations = context.get(BaseFileSystemOperations),
      workspace = context.get(WorkspaceClass)
    ;(this._appliesTextPromise = new PromiseOutcome()), cancellationToken.onCancellationRequested(() => this._appliesTextPromise.cancel())
    let textLinkifier = new TextLinkifier(references, workspace.getWorkspaceFolders(), fileSystemOperations)
    this._deltaCallback = new TextApplier(text => {
      this._promise = this._promise.then(async () => {
        text.startsWith('```') && (this._isInCodeBlock = !this._isInCodeBlock),
          this._isInCodeBlock || (text = await textLinkifier.linkify(text, cancellationToken))
        let markdownString = new VscodeMarkdownString(text)
        return (
          (markdownString.isTrusted = { enabledCommands: [
            openRelativePathCommand, openSymbolInFileCommand] }),
          (this._appliedText += text),
          reporter.report({ markdownContent: markdownString }),
          this._appliedText
        )
      })
    })
  }
  get appliedText() {
    return this._appliesTextPromise.p
  }
  apply(text) {
    this._deltaCallback.apply(text)
  }
  finish() {
    this._promise.then(
      text => this._appliesTextPromise.complete(text),
      error => this._appliesTextPromise.error(error)
    )
  }
}
var requestLight = handleDefaultExports(requestLight()),
crypto = require('crypto')
class FollowUpGenerator {
  constructor(accessor, messageConverter, options) {
    this.accessor = accessor;
    this.messageConverter = messageConverter;
    this.options = options;
    this.logger = accessor.get(LoggerManager).getLogger('ConversationFollowUp');
  }

  async followUp(chatSession, user, options) {
    let copiedChatSession = chatSession.copy();
    copiedChatSession.addTurn(
      new Session({
        type: 'meta',
        message:
          `Write a short one-sentence question that the user can ask that naturally follows from the previous few questions and answers. It should not ask a question which is already answered in the conversation. It should be a question that you are capable of answering. Reply with only the text of the question and nothing else.
                    ${getLocaleResponse(this.accessor)}`.trim(),
      })
    );

    let fetchOptions = options ? { ...options } : {};
    fetchOptions.messageSource = 'chat.followup';

    let tokenLimit = await getDefaultChatEndpointInfo(this.accessor),
      assistantMessage = await generateAssistantMessage(this.accessor, 2, tokenLimit),
      { messages: chatMessages } = await this.messageConverter.toChatMessages(copiedChatSession, assistantMessage, tokenLimit),
      fetchResult = await this.accessor
        .get(DataRetriever)
        .fetchOne(chatMessages, undefined, user, 2, tokenLimit, { temperature: this.options.temperature, top_p: this.options.topP }, fetchOptions);

    if (fetchResult.type === 'success') {
      let followUpQuestions = [];
      if (fetchResult.value) followUpQuestions.push(fetchResult.value.trim());
      return followUpQuestions;
    } else {
      this.logger.error(`Failed to fetch followups because of response type (${fetchResult.type}) and reason (${fetchResult.reason})`, fetchResult);
      return [];
    }
  }
}
var editorInfo;

((namespace) => {
  function extractEditorInfo(editor, config, range) {
    let { options, document, selection, visibleRanges } = config,
      fileIndentInfo = { insertSpaces: options.insertSpaces, tabSize: options.tabSize },
      language = getCommentSymbol(document);

    range = range || (visibleRanges.length === 1 ? visibleRanges[0] : visibleRanges.length > 1 ? visibleRanges[0].union(visibleRanges[visibleRanges.length - 1]) : selection);

    return { document, fileIndentInfo, language, selection, wholeRange: range };
  }

  namespace.fromEditor = extractEditorInfo;
})((editorInfo ||= {}));

var TextProcessor1 = class {
  constructor(stopStartMappings, progress, processNonReportedDelta) {
    this.stopStartMappings = stopStartMappings;
    this.progress = progress;
    this.processNonReportedDelta = processNonReportedDelta;
    this.stagedDeltasToApply = [];
    this.currentStartStop = undefined;
    this._appliedText = '';
    this.nonReportedDeltas = [];
  }

  get appliedText() {
    return Promise.resolve(this._appliedText);
  }

  apply(input, delta) {
    return this.applyDelta(delta);
  }

  applyDeltaToProgress(delta) {
    let annotations = delta.annotations?.map(annotation => ({ title: annotation.details.type, description: annotation.details.description }));
    (delta.text || annotations?.length) && this.progress.report({ content: delta.text, vulnerabilities: annotations?.length ? annotations : undefined });
  }

  updateStagedDeltasUpToIndex(index, length) {
    let updatedDeltas = [];
    for (let i = 0; i < index + length; ) {
      let delta = this.stagedDeltasToApply.shift();
      if (delta) {
        if (i + delta.text.length <= index) updatedDeltas.push(delta);
        else if (i < index || i < index + length) {
          if (i < index) {
            let newDelta = { ...delta };
            newDelta.text = delta.text.substring(0, index - i);
            updatedDeltas.push(newDelta);
          }
          let remainingDelta = { ...delta };
          remainingDelta.text = delta.text.substring(index - i + length);
          remainingDelta.text && this.stagedDeltasToApply.unshift(remainingDelta);
        }
        i += delta.text.length;
      } else break;
    }
    return updatedDeltas;
  }

  checkForKeyWords(keywords, delta, callback = this.applyDeltaToProgress.bind(this)) {
    let text = this.stagedDeltasToApply.map(delta => delta.text).join('') + delta.text;
    for (let keyword of keywords) {
      let index = text.indexOf(keyword);
      if (index === -1) continue;
      this.stagedDeltasToApply.push(delta);
      this.updateStagedDeltasUpToIndex(index, keyword.length).forEach(delta => callback(delta));
      return keyword;
    }
    for (let keyword of keywords)
      for (let i = keyword.length - 1; i > 0; i--) {
        let substring = keyword.substring(0, i);
        if (text.endsWith(substring)) {
          this.stagedDeltasToApply = [...this.stagedDeltasToApply, delta];
          return;
        }
      }
    [...this.stagedDeltasToApply, delta].forEach(delta => {
      callback(delta);
    });
    this.stagedDeltasToApply = [];
  }

  postReportRecordProgress(delta) {
    this.nonReportedDeltas.push(delta);
  }

  applyDelta(delta) {
    this._appliedText += delta.text;
    if (this.currentStartStop === undefined) {
      let stopKeyword = this.checkForKeyWords(
        this.stopStartMappings.map(mapping => mapping.stop),
        delta
      );
      if (stopKeyword) this.currentStartStop = this.stopStartMappings.find(mapping => mapping.stop === stopKeyword);
      return;
    } else {
      if (!this.currentStartStop.start) return;
      if (this.checkForKeyWords([this.currentStartStop.start], delta, this.postReportRecordProgress.bind(this))) {
        if (this.processNonReportedDelta) {
          this.processNonReportedDelta(this.nonReportedDeltas).forEach(text => this.applyDeltaToProgress({ text }));
        }
        this.currentStartStop = undefined;
        if (this.stagedDeltasToApply.length > 0) this.applyDelta({ text: '' });
      }
    }
  }
}
var CopilotConversationManager = class {
  constructor(etelemetryService, options, username, conversationLogger, isInternal, sessionId) {
    this.options = options
    this.username = username
    this.conversationLogger = conversationLogger
    this.isInternal = isInternal
    this.sessionId = sessionId
    this.inputPlaceholder = requestLight.t('Ask Copilot or type / for commands')
    ;(this._microsoftTelemetryService = telemetryService.get(IMSTelemetryService)),
      (this.accessor = telemetryService),
      (this.conversation = new Conversation()),
      (this.intentDetector = new IntentDetector(telemetryService, 2)),
      (this.conversation = this.intializeConversation()),
      (this.messageConverter = new ChatMessageProcessor(this.accessor, this.options.maxResponseTokens)),
      (this.conversationFollowUp = new FollowUpGenerator(this.accessor, this.messageConverter, this.options))
  }
  get responder() {
    return { name: 'GitHub Copilot' }
  }
  get requester() {
    return {
      name: this.username ?? requestLight.t('You'),
      icon: this.username ? Uri.parse(`https://avatars.githubusercontent.com/${this.username}`) : undefined,
    }
  }
  addHistory(historyItems) {
    historyItems.forEach((item, index) => {
      let nextItem = historyItems[index + 1];
      let response = nextItem && nextItem.role === 2 ? { message: nextItem.content, type: 'model' } : undefined;
      let session = new Session({ message: item.content, type: item.role === 1 ? 'user' : 'model' });
      if (response) {
        session.response = response;
        index++; // Skip the next item as it's already processed
      }
      this.conversation.addTurn(session);
    });
  }
  intializeConversation() {
    return new Conversation()
  }
  async provideResponseWithProgress(prompt, progress, cancellationToken, options) {
    this.refreshFollowupsCancellationToken();
    try {
      let isFirstReport = true,
        progressReporter = {
          report: report => {
            if (!('responseId' in report)) {
              this.conversationLogger?.logProgress(report, isFirstReport);
              isFirstReport = false;
            }
            progress.report(report);
          },
        },
        newTurn = this.createTurn(prompt),
        telemetryEvent = generateTelemetryEvent();
      telemetryEvent.markAsDisplayed();
      let response = await this._provideResponseWithProgress(newTurn, prompt, progressReporter, cancellationToken, telemetryEvent, options);
      this.conversationLogger?.logResponse(response);
      this._microsoftTelemetryService.sendInternalTelemetryEvent(
        'interactiveSessionResponse',
        {
          chatLocation: 'panel',
          intent: newTurn.intentInvocation?.intent.id ?? '',
          request: prompt.prompt,
          response: newTurn.response?.message ?? '',
          sessionId: this.sessionId,
        },
        { turnNumber: this.conversation.turns.length }
      );
      return { ...response, responseId: newTurn.requestId, session: this };
    } catch (error) {
      this.conversationLogger?.logThrownError(error);
      throw error;
    }
  }

  createTurn(prompt) {
    let message = { message: prompt.prompt, type: 'user' },
      newSession = new Session(message, this.sessionId);
    this.conversation.addTurn(newSession);
    return newSession;
  }
  async _provideResponseWithProgress(e, r, n, i, o, s) {
    if (i.isCancellationRequested) return (e.status = 'cancelled'), { errorDetails: { message: requestLight.t('Cancelled') } }
    try {
      let a = this.accessor.get(BaseTabManager).activeTextEditor,
        l = e.request.message
      this.conversationLogger?.logRequest(e.request)
      let c = { command: s.intentId ? CommandManager.getCommand(s.intentId, 2) : void 0, restOfQuery: l }
      if (c.command?.intent && !(c.command.intent.commandInfo?.allowsEmptyArgs ?? !0) && !c.restOfQuery) {
        let y = getCommandCategory(c.command.intent.id),
          b = ''
        return (
          y && ((b = `@${y.agent} `), y.command && (b += ` /${y.command}`), (b += ` ${c.command.details}`)),
          (e.response = {
            message: requestLight.t(
              `Please specify a question when using this command.

Usage: {0}`,
              b
            ),
            type: 'meta',
          }),
          (e.status = 'error'),
          { errorDetails: { message: e.response.message, responseIsFiltered: !1, responseIsIncomplete: !1 } }
        )
      }
      let u = c?.command?.intent,
        p
      u &&
        ((e.request = { message: c.restOfQuery || u.intentDetectionInput.sampleQuestion, type: 'user' }),
        this.conversationLogger?.logIntent(u.id, !0)),
        !u && this.accessor.get(ConfigManager).getConfig(settings.ConversationIntentDetection)
          ? ((u = p = await this.intentDetector.detectIntent(void 0, l, i, o, void 0)),
            this.conversationLogger?.logIntent(u?.id, !1))
          : this.isInternal &&
            (p =
              u || this.conversation.turns.length !== 1
                ? void 0
                : await this.intentDetector.detectIntent(void 0, l, i, o, void 0)),
        (u ??= UnknownIntent.Instance)
      let d = a ? editorInfo.fromEditor(this.accessor, a) : void 0,
        f = await u.invoke(this.accessor, { location: 2, documentContext: d }, void 0)
      e.intentInvocation = f
      let m = f.endpoint,
        { messages: h, tokenCount: g } = await f.promptCrafter.buildPrompt(this.conversation, m, r.variables, n, o, i),
        v = this.conversation.getLatestTurn()?.contextParts.map(y => y.kind) ?? []
      if (
        (this._microsoftTelemetryService.sendInternalTelemetryEvent(
          'interactiveSessionMessage',
          { intent: u?.id ?? 'none', detectedIntent: p?.id ?? 'none', contextTypes: v.join(','), query: c.restOfQuery },
          {}
        ),
        (e.chatMessages = h),
        this.conversationLogger?.logMessages(h),
        (o = extendTelemetryEventWithUserInput(this.conversation, this.sessionId, 'conversationPanel', l, g, u?.id, o)),
        i.isCancellationRequested)
      )
        return (e.status = 'cancelled'), { errorDetails: { message: requestLight.t('Cancelled') } }
      let _ = f?.responseProcessor
        ? f.responseProcessor(this.accessor, e, n, h, i)
        : new TextProcessor1([{ stop: '[COMMANDS START]' }], n)
      return await this.fetchConversationResponse(e, m, l, h, i, n, _, o, {
        messageId: o.properties.messageId,
        messageSource: 'chat.user',
      })
    } catch (a) {
      this.accessor.get(LoggerManager).defaultLogger.exception(a),
        this.accessor.get(IGHTelemetryService).sendExceptionTelemetry(a, 'Error'),
        this.conversationLogger?.logThrownError(a)
      let l = a.message
      return (
        (e.status = 'error'),
        (e.response = { message: l, type: 'meta' }),
        { errorDetails: { message: l, responseIsIncomplete: !0 } }
      )
    }
  }
  async fetchConversationResponse(e, r, n, i, o, s, a, l, c) {
    let u = generateTelemetryEvent()
    e.requestId = u.properties.messageId
    let p = Date.now(),
      d = 0,
      f = new Set(),
      m = await this.accessor.get(DataRetriever).fetchOne(
        i,
        async (x, P, U) => {
          d === 0 && (d = Date.now()),
            U.annotations &&
              (!((x.match(/(^|\n)```/g)?.length ?? 0) % 2 === 1) || x.match(/(^|\n)```\w*\s*$/)) &&
              (U.annotations = void 0),
            U.annotations &&
              ((U.annotations = U.annotations.filter(H => !f.has(H.details.type))),
              U.annotations.forEach(H => f.add(H.details.type))),
            a.apply(x, U)
        },
        o,
        2,
        r,
        { temperature: this.options.temperature, top_p: this.options.topP },
        c,
        { intent: !0 }
      )
    a.finish?.()
    let h = await a.appliedText,
      g = h ? extractCodeBlocks(h) : [],
      v = l.raw.displayedTime ?? p,
      _ = ['programming-related tasks', 'programming related questions', 'related to programming'],
      y = 0
    m.type === 'success' &&
      !h.trim().includes(`
`) &&
      _.some(x => h.toLowerCase().includes(x)) &&
      (y = 1)
    let b = this.accessor.get(Tokenizer)
    switch (
      (this._microsoftTelemetryService.sendTelemetryEvent(
        'panel.request',
        {
          command: e.intentInvocation?.intent.id ?? 'none',
          contextTypes: e.contextParts.map(x => x.kind).join(',') ?? 'none',
          promptTypes: i.map(x => `${x.role}${x.name ? `-${x.name}` : ''}:${x.content.length}`).join(','),
          conversationId: this.sessionId,
          requestId: e.requestId,
          responseId: m.requestId,
          responseType: m.type,
          codeBlocks: g.join(','),
          model: r.model,
        },
        {
          turn: this.conversation.turns.length,
          textBlocks: g.length ? -1 : h.split(/\n{2,}/).length ?? 0,
          maybeOffTopic: y,
          messageTokenCount: b.tokenLength(e.request.message),
          promptTokenCount: calculateTokenLength(this.accessor, i),
          userPromptCount: i.filter(x => x.role === 'user').length,
          responseTokenCount: b.tokenLength(h) ?? 0,
          timeToRequest: p - v,
          timeToFirstToken: d ? d - v : -1,
          timeToComplete: Date.now() - v,
        }
      ),
      extendTelemetryEventWithOffTopicFlag(
        this.accessor,
        'conversationPanel',
        n,
        m.type === 'offTopic',
        this.accessor.get(BaseTabManager).activeTextEditor?.document,
        l
      ),
      m.type)
    ) {
      case 'success':
        return await this.processSuccessfulFetchResult(r, e, a, m.requestId, u)
      case 'offTopic':
        return this.processOffTopicFetchResult(s, e, n, l)
      case 'canceled':
        return (
          (e.status = 'cancelled'), (e.response = { message: 'Cancelled', type: 'user' }), { errorDetails: e.response }
        )
      case 'rateLimited':
        return (
          (e.status = 'error'),
          {
            errorDetails: {
              message: requestLight.t('Sorry, your request was rate-limited. Please wait and try sending again later.'),
              responseIsFiltered: !0,
            },
          }
        )
      case 'badRequest':
      case 'failed':
        return (e.status = 'error'), (e.response = { message: m.reason, type: 'server' }), { errorDetails: e.response }
      case 'filtered':
        return (
          (e.status = 'filtered'),
          {
            errorDetails: {
              message: requestLight.t({
                message:
                  'Sorry, the response matched public code so it was blocked. Please rephrase your prompt. [Learn more](https://aka.ms/copilot-chat-filtered-docs).',
                comment: ["{Locked='](https://aka.ms/copilot-chat-filtered-docs)'}"],
              }),
              responseIsFiltered: !0,
            },
          }
        )
      case 'length':
        return (
          (e.status = 'error'),
          { errorDetails: { message: requestLight.t('Sorry, the response hit the length limit. Please rephrase your prompt.') } }
        )
      case 'unknown':
        return (
          (e.status = 'error'),
          { errorDetails: { message: requestLight.t('Sorry, no response was returned.'), responseIsFiltered: !1 } }
        )
    }
  }
  async processSuccessfulFetchResult(e, r, n, i, o) {
    let s = await n.appliedText
    return s.length > 0
      ? ((r.status = 'success'),
        (r.response = { message: s, type: 'model' }),
        o.markAsDisplayed(),
        extendTelemetryEventWithModelOutput(
          this.accessor,
          this.conversation,
          this.sessionId,
          'conversationPanel',
          s,
          i,
          this.accessor.get(BaseTabManager).activeTextEditor?.document,
          o
        ),
        { followupsPromise: this.computeFollowups(!0, { messageId: o.properties.messageId }) })
      : ((r.status = 'error'),
        (r.response = {
          message: requestLight.t(
            'The model unexpectedly did not return a response, which may indicate a service issue. Please report a bug.'
          ),
          type: 'meta',
        }),
        { errorDetails: r.response })
  }
  processOffTopicFetchResult(e, r, n, i) {
    let o = generateTelemetryEvent()
    return (
      e.report({ content: this.options.rejectionMessage }),
      (r.response = { message: this.options.rejectionMessage, type: 'offtopic-detection' }),
      (r.status = 'off-topic'),
      o.markAsDisplayed(),
      extendTelemetryEventWithOffTopicMessage(
        this.accessor,
        this.conversation,
        this.sessionId,
        'conversationPanel',
        n,
        i.properties.messageId,
        this.accessor.get(BaseTabManager).activeTextEditor?.document,
        o
      ),
      { followupsPromise: this.computeFollowups(!1) }
    )
  }
  getLatestTurn() {
    return this.conversation.getLatestTurn()
  }
  removeRequest(e) {
    let r = this.conversation.removeTurn(e)
    this._microsoftTelemetryService.sendTelemetryEvent('panel.action.remove', {
      command: r?.intentInvocation?.intent.id,
      contextTypes: r?.contextParts.map(n => n.kind).join(',') ?? 'none',
      responseType: r?.response?.type,
      conversationId: this.sessionId,
      requestId: e,
    })
  }
  refreshFollowupsCancellationToken() {
    this.lastResponseFollowupsCancellation?.cancel(),
      this.lastResponseFollowupsCancellation?.dispose(),
      (this.lastResponseFollowupsCancellation = new VscodeCancellationTokenSource())
  }
  async computeFollowups(e = !0, r) {
    let n = this.lastResponseFollowupsCancellation.token,
      o = (e ? await this.conversationFollowUp.followUp(this.conversation, n, r) : []).map(c =>
        generateSuggestion(c, this.accessor, r)
      )
    n.isCancellationRequested || this.conversationLogger?.logFollowups(o)
    let s = this.conversation.getLatestTurn(),
      a = [],
      l = s?.intentInvocation
    return l?.followUps && (a = await l.followUps(this.accessor, s)), o.concat(a)
  }
}
function generateSuggestion(message, context, metadata = {}) {
  metadata.suggestionId = (0, crypto.randomUUID)();
  metadata.suggestionType = 'Follow-up from model';
  displaySuggestion(context, metadata.suggestionType, metadata.messageId, metadata.suggestionId, context.get(BaseTabManager).activeTextEditor?.document);
  return { message, title: message, metadata };
}
var vscode = handleDefaultExports(require('vscode'))
function generateSuggestion(message, context, metadata = {}) {
  metadata.suggestionId = (0, crypto.randomUUID)();
  metadata.suggestionType = 'Follow-up from model';
  displaySuggestion(context, metadata.suggestionType, metadata.messageId, metadata.suggestionId, context.get(BaseTabManager).activeTextEditor?.document);
  return { message, title: message, metadata };
}

var vscode = handleDefaultExports(require('vscode'));

function handleAction(service, actionResult) {
  let activeDocument = vscode.window.activeTextEditor?.document,
    activeSelection = vscode.window.activeTextEditor?.selection,
    result = actionResult.result,
    telemetryService = service.get(IMSTelemetryService);

  switch (actionResult.action.kind) {
    case 'copy':
      telemetryService.sendTelemetryEvent(
        'panel.action.copy',
        { languageId: activeDocument?.languageId, requestId: result.responseId },
        {
          codeBlockIndex: actionResult.action.codeBlockIndex,
          copyType: actionResult.action.copyKind,
          characterCount: actionResult.action.copiedCharacters,
          lineCount: actionResult.action.copiedText.split('\n').length,
        }
      );
      break;
    case 'insert':
      telemetryService.sendTelemetryEvent(
        'panel.action.insert',
        { languageId: activeDocument?.languageId, requestId: result.responseId },
        { codeBlockIndex: actionResult.action.codeBlockIndex, characterCount: actionResult.action.totalCharacters }
      );
      break;
    case 'runInTerminal':
      telemetryService.sendTelemetryEvent(
        'panel.action.runinterminal',
        { languageId: activeDocument?.languageId, requestId: result.responseId, blockLanguage: actionResult.action.languageId },
        { codeBlockIndex: actionResult.action.codeBlockIndex }
      );
      break;
    case 'followUp':
      break;
    case 'bug':
      service.get(Reporter)?.reportChat(result.session);
      break;
  }

  if (actionResult.action.kind === 'copy' || actionResult.action.kind === 'insert') {
    let telemetryData = { totalCharacters: actionResult.action.totalCharacters };
    if (actionResult.action.kind === 'copy') {
      telemetryData = { ...telemetryData, copiedCharacters: actionResult.action.copiedCharacters };
    }
    if (activeDocument && activeSelection) {
      telemetryData = { ...telemetryData, cursorLocation: activeDocument.offsetAt(activeSelection.active) };
    }
    sendSuggestionTelemetry(
      service,
      vscode.window.activeTextEditor?.document,
      { codeBlockIndex: actionResult.action.codeBlockIndex.toString(), messageId: result.responseId },
      telemetryData,
      actionResult.action.kind === 'copy' ? 'conversation.acceptedCopy' : 'conversation.acceptedInsert'
    );
  }
}
function handleVote(service, feedback) {
  let activeDocument = vscode.window.activeTextEditor?.document,
    result = feedback.result;
  service
    .get(IMSTelemetryService)
    .sendTelemetryEvent(
      'panel.action.vote',
      { languageId: activeDocument?.languageId, requestId: result.responseId },
      { direction: feedback.kind === vscode.ChatAgentResultFeedbackKind.Helpful ? 1 : 2 }
    );
  sendSuggestionTelemetry(
    service,
    activeDocument,
    { rating: feedback.kind === vscode.ChatAgentResultFeedbackKind.Helpful ? 'positive' : 'negative', messageId: result.responseId },
    {},
    'conversation.messageRating'
  );
}
var ExtensionProvider = class {
  constructor(accessor) {
    this.accessor = accessor
  }
  async register(options) {
    return new ChatAgentRegistrar(this.accessor, options).register()
  }
},
ChatAgentRegistrar = class {
    constructor(e, r) {
      this.accessor = e
      this.options = r
      this._logger = new ChatLogger(this.accessor, () =>
      vscode.window.createOutputChannel('GitHub Copilot Chat Conversation', 'log')
      )
    }
    async register() {
      ;(this._isInternal = (await this.accessor.get(BaseTokenHandler).getCopilotToken(this.accessor))?.isInternal),
        this.accessor
          .get(extensionContext)
          .subscriptions.push(
            this.registerWorkspaceAgent(),
            this.registerVSCodeAgent(),
            this.registerTerminalAgent(),
            this.registerDefaultAgent()
          )
    }
    createAgent(e, r) {
      let n = vscode.chat.createChatAgent(e, this.getChatAgentHandler(r))
      return (
        n.onDidPerformAction(i => handleAction(this.accessor, i)),
        n.onDidReceiveFeedback(i => handleVote(this.accessor, i)),
        (n.supportIssueReporting = this.accessor.get(ConfigManager).getConfig(settings.DebugReportFeedback)),
        n
      )
    }
    registerWorkspaceAgent() {
      let e = this.createAgent(workspace, exampleDialogue)
      return (
        (e.fullName = 'Workspace'),
        (e.description = 'Ask about your workspace'),
        (e.followupProvider = { provideFollowups: (r, n) => ('followupsPromise' in r ? r.followupsPromise : []) }),
        (e.iconPath = new vscode.ThemeIcon('code')),
        (e.slashCommandProvider = { provideSlashCommands: r => this.getSlashCommands(commandCategories.workspace) }),
        (e.isSecondary = !0),
        (e.sampleRequest = CommandManager.getCommand('workspace', 2)?.intent?.commandInfo?.sampleRequest),
        e
      )
    }
    registerVSCodeAgent() {
      let e = this.createAgent(vscode, rq)
      ;(e.fullName = 'VS Code'),
        (e.description = 'Ask about VS Code'),
        (e.followupProvider = { provideFollowups: (n, i) => ('followupsPromise' in n ? n.followupsPromise : []) }),
        (e.slashCommandProvider = { provideSlashCommands: n => this.getSlashCommands(commandCategories.vscode) })
      let r = vscode.env.appName.includes('Insiders') || vscode.env.appName.includes('OSS')
      return (
        (e.iconPath = Uri.joinPath(
          this.accessor.get(extensionContext).extensionUri,
          'assets',
          r ? 'vscode-chat-avatar-insiders.svg' : 'vscode-chat-avatar-stable.svg'
        )),
        (e.sampleRequest = CommandManager.getCommand('vscode', 2)?.intent?.commandInfo?.sampleRequest),
        e
      )
    }
    registerTerminalAgent() {
      let e = this.createAgent(terminal, 'terminal')
      return (
        (e.fullName = 'Terminal'),
        (e.description = 'Ask how to do something in the terminal'),
        (e.followupProvider = { provideFollowups: (r, n) => ('followupsPromise' in r ? r.followupsPromise : []) }),
        (e.iconPath = new vscode.ThemeIcon('terminal')),
        (e.slashCommandProvider = { provideSlashCommands: r => this.getSlashCommands(commandCategories.terminal) }),
        (e.sampleRequest = CommandManager.getCommand('terminal', 2)?.intent?.commandInfo?.sampleRequest),
        e
      )
    }
    registerDefaultAgent() {
      let e = this.createAgent('', '')
      ;(e.isDefault = !0),
        (e.helpTextPrefix = vscode.l10n.t(
          'You can ask me general programming questions, or chat with the following agents which have specialized expertise and can perform actions:'
        ))
      let r = vscode.l10n.t({
          message: `To have a great conversation, ask me questions as if I was a real programmer:

* **Show me the code** you want to talk about by having the files open and selecting the most important lines.
* **Make refinements** by asking me follow-up questions, adding clarifications, providing errors, etc.
* **Review my suggested code** and tell me about issues or improvements, so I can iterate on it.

You can also ask me questions about your editor selection by [starting an inline chat session](command:inlineChat.start).

Learn more about [GitHub Copilot](https://docs.github.com/copilot/getting-started-with-github-copilot?tool=vscode) in [Visual Studio Code](https://code.visualstudio.com/docs/editor/artificial-intelligence).`,
          comment: "{Locked='](command:inlineChat.start)'}",
        }),
        n = new vscode.MarkdownString(r)
      return (
        (n.isTrusted = { enabledCommands: ['inlineChat.start'] }),
        (e.helpTextPostfix = n),
        (e.fullName = 'GitHub Copilot'),
        (e.description = ''),
        (e.followupProvider = { provideFollowups: (i, o) => ('followupsPromise' in i ? i.followupsPromise : []) }),
        (e.slashCommandProvider = { provideSlashCommands: i => [] }),
        e
      )
    }
    getSlashCommands(e) {
      let r = []
      return (
        e.forEach(n => {
          let i = CommandManager.getCommand(n, 2)?.intent
          i &&
            r.push({
              name: i.id,
              description: i.description,
              followupPlaceholder: i.commandInfo?.followupPlaceholder,
              shouldRepopulate: i.commandInfo?.shouldRepopulate,
              sampleRequest: i.commandInfo?.sampleRequest,
            })
        }),
        r
      )
    }
    getChatAgentHandler(e) {
      return async (r, n, i, o) => {
        let s = new CopilotConversationManager(this.accessor, this.options, '', this._logger, this._isInternal, '')
        s.addHistory(n.history)
        let a = r.slashCommand?.name ?? e
        return await s.provideResponseWithProgress(r, i, o, { intentId: a })
      }
    }
  }
var vscode = handleDefaultExports(require('vscode'))
var MainComponent = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        vscpp(SystemComponent, null, vscpp(AIAssistantComponent, null), vscpp(ExpertiseComponent, null)),
        vscpp(UserComponent, null, vscpp(GitDiffComponent, { diff: this.props.diff }), vscpp(CommitMessageComponent, null))
      )
    }
  },
  AIAssistantComponent = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        'You are an AI programming assistant.',
        vscpp('br', null),
        'You are helping a software developer to commit some changes to a Git repository.'
      )
    }
  },
  CommitMessageComponent = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        'The commit message should be short and concise that describes the changes in the code.',
        vscpp('br', null),
        'The commit message should start with *** and end with ***.'
      )
    }
  },
  GitDiffComponent = class extends BaseComponent {
    render() {
      return vscpp(
        vscppf,
        null,
        'Below is a git diff that contains the changes that the developer has made:',
        vscpp('br', null),
        this.props.diff.join(`

`),
        vscpp('br', null),
        'Based on the git diff, please suggest a commit message for the developer to use.'
      )
    }
  }
  var GitCommitMessageGenerator = class {
    constructor(accessor) {
      this.accessor = accessor;
      this.microsoftTelemetryService = accessor.get(IMSTelemetryService);
      this.logger = accessor.get(LoggerManager).getPromptResponseLogger('git commit message generator');
      this.options = accessor.get(conversationOptions);
    }
    async generateGitCommitMessage(diff, attemptCount, cancellationToken) {
      let startTime = Date.now(),
        chatEndpointInfo = await getChatEndpointInfo(this.accessor, 3),
        maxTokenWindow = Math.floor((chatEndpointInfo.modelMaxTokenWindow * 4) / 3),
        processedDiff = this.processDiff(diff, maxTokenWindow),
        renderedComponent = await new Renderer(this.accessor, chatEndpointInfo.modelMaxTokenWindow, chatEndpointInfo).render(MainComponent, { diff: diff }),
        temperature = Math.min(this.options.temperature * (1 + attemptCount), 2),
        requestTime = Date.now(),
        response = await this.accessor
          .get(DataRetriever)
          .fetchOne(
            renderedComponent,
            undefined,
            cancellationToken,
            3,
            chatEndpointInfo,
            { temperature: temperature, top_p: this.options.topP },
            { messageSource: 'command.generateGitCommitMessagePrompt' }
          );
      if (
        (this.logger.logResponse(response),
        this.microsoftTelemetryService.sendTelemetryEvent(
          'git.generateCommitMessage',
          { model: chatEndpointInfo.model, requestId: response.requestId, responseType: response.type },
          {
            attemptCount: attemptCount,
            originalDiffFileCount: diff.length,
            originalDiffLength: diff.join('').length,
            processedDiffFileCount: processedDiff.length,
            processedDiffLength: processedDiff.join('').length,
            timeToRequest: requestTime - startTime,
            timeToComplete: Date.now() - startTime,
          }
        ),
        response.type === 'success')
      )
        return this.processGeneratedCommitMessage(response.value);
    }
    processDiff(diff, maxTokenWindow) {
      let threshold = maxTokenWindow - Math.floor(maxTokenWindow * 0.1),
        diffLength = diff.join(`

  `).length;
      if (diffLength > threshold)
        for (diff.sort((a, b) => a.length - b.length); diffLength > threshold && diff.length > 0; ) {
          let removedDiff = diff.pop();
          diffLength -= removedDiff.length;
        }
      return diff;
    }
    processGeneratedCommitMessage(commitMessage) {
      return commitMessage.replace(/\*\*\*/gm, '').trim();
    }
  }
var requestLight = handleDefaultExports(requestLight()),
crypto = require('crypto')
var requestLight = handleDefaultExports(requestLight())
var CodeEditor = class Editor {
  constructor() {
    this.id = Editor.ID
    this.description = requestLight.t('Make changes to existing code')
    this.intentDetectionInput = {
      sampleQuestion: 'Change this method to use async/await',
      modelDescription: 'Make changes to existing code',
    }
    this.locations = [1]
    this.commandInfo = { hiddenFromUser: true }
  }
  static {
    this.ID = 'edit'
  }
  async invoke(intent, context) {
    return IntentHandler.createIntentInvocation(this, intent, context, 2)
  }
}
var requestLight = handleDefaultExports(requestLight())
var CodeGenerator = class {
  constructor() {
    this.id = CodeGenerator.ID
    this.description = requestLight.t('Generate new code')
    this.intentDetectionInput = {
      sampleQuestion: 'Add a function that returns the sum of two numbers',
      modelDescription: 'Generate new code',
    }
    this.locations = [1]
    this.commandInfo = { hiddenFromUser: !0 }
  }
  static {
    this.ID = 'generate'
  }
  async invoke(e, r) {
    return IntentHandler.createIntentInvocation(this, e, r, 3)
  }
}
var SamplingParameters = { top_p: 1, temperature: 0.1 }
var Conversation = class {
  constructor(placeholder, slashCommands, wholeRange, document, formattingOptions, message, input, preferredIntent) {
    this.placeholder = placeholder
    this.slashCommands = slashCommands
    this.wholeRange = wholeRange
    this.document = document
    this.formattingOptions = formattingOptions
    this.message = message
    this.input = input
    this.preferredIntent = preferredIntent
    this._requests = []
    this.sessionId = crypto.randomUUID()
    this.conversation = undefined
  }
  addRequest(request) {
    this._requests.push(request)
  }
  getRequests() {
    return this._requests
  }
},
CopilotInteractiveEditorSessionProvider = class CopilotInteractiveEditorSessionProvider {
    constructor(accessor, rejectionMessage) {
      this.accessor = accessor
      this.rejectionMessage = rejectionMessage
      ;(this.logger = accessor.get(LoggerManager).getPromptResponseLogger('interactiveEditor')),
        (this.tabAndEditorsService = accessor.get(BaseTabManager)),
        (this.languageDiagnosticService = accessor.get(DiagnosticWaiter)),
        (this._microsoftTelemetryService = accessor.get(IMSTelemetryService)),
        this.logger.info(
          `CopilotInteractiveEditorSessionProvider created, with rejection message: ${this.rejectionMessage}`
        )
    }
    async prepareInteractiveEditorSession(e) {
      let r
      if (this.tabAndEditorsService.activeTextEditor?.document.uri.toString() === e.document.uri.toString()) {
        let d = this.tabAndEditorsService.activeTextEditor.options
        r = { insertSpaces: d.insertSpaces, tabSize: d.tabSize }
      }
      let n,
        i = this.languageDiagnosticService.getDiagnostics(e.document.uri).find(d => d.range.contains(e.selection))
      i && (i.severity === VscodeDiagnosticSeverity.Warning || i.severity === VscodeDiagnosticSeverity.Error) && (n = `/fix ${i.message}`)
      let o = {
          document: e.document,
          fileIndentInfo: r,
          language: getCommentSymbol(e.document),
          selection: e.selection,
          wholeRange: e.selection,
        },
        s = []
      for (let d of CommandManager.getCommands(1))
        d.intent?.asSlashCommand
          ? s.push(await d.intent.asSlashCommand(this.accessor, o))
          : s.push({ command: d.commandId, detail: d.details, executeImmediately: d.executeImmediately })
      let a = [
        requestLight.t({
            message: '{0} Copilot generated code may be incorrect',
            args: ['$(copilot-logo)'],
            comment: ["{Locked='Copilot'}", "Do not translate 'Copilot'"],
          }),
        ],
        l = requestLight.t({
          message: '{0} You can also type / for commands',
          args: ['$(copilot-logo)'],
          comment: ["{Locked='Copilot'}", "Do not translate 'Copilot'"],
        }),
        c,
        u
      e.selection.isEmpty && e.document.lineAt(e.selection.start.line).text.trim() === ''
        ? (a.push(
            l,
            requestLight.t({
              message: '{0} You can also select code to make an edit',
              args: ['$(copilot-logo)'],
              comment: ["{Locked='Copilot'}", "Do not translate 'Copilot'"],
            })
          ),
          (u = requestLight.t('Ask Copilot to generate code...')),
          (c = CodeGenerator.ID))
        : !e.selection.isEmpty && e.selection.start.line !== e.selection.end.line
        ? (a.push(l), (u = requestLight.t('Ask Copilot to edit code...')), (c = CodeEditor.ID))
        : (u = requestLight.t('Ask Copilot or type / for commands'))
      let p = a[Math.floor(Math.random() * a.length)]
      return new Conversation(u, s, e.selection, e.document, r, p, n, c)
    }
    async provideInteractiveEditorResponse(e, r, n, i) {
      this.logger.info(`CopilotInteractiveEditorSessionProvider query: ${r.prompt}`),
        n.report({ message: requestLight.t('Fetching response...'), edits: [] }),
        r.attempt === 0 && e.addRequest(r.prompt)
      let o = this.accessor.get(ConfigManager).getConfig(settings.InlineChatStreaming),
        s = r.live
      if (o === 'off') s = !1
      else if (o === 'instant') {
        let l = n
        n = {
          report: c => {
            l.report({ ...c, editsShouldBeInstant: !0 })
          },
        }
      }
      let a = await this.fetchResponse(e, r, n, s, i)
      if (a) return handleReply(a, s)
    }
    async provideFollowups(e, r, n) {
      return r.reply.followUp?.(n)
    }
    handleInteractiveEditorResponseFeedback(e, r, n) {
      if (
        (this.logger.debug('CopilotInteractiveEditorSessionProvider feedback received'), n === VscodeInteractiveEditorResponseFeedbackKind.Bug && e.conversation)
      ) {
        this.accessor.get(Reporter)?.reportInline(e.conversation, r.promptQuery, r.reply)
        return
      }
      let i = { messageId: r.messageId },
        o,
        { selection: s, wholeRange: a, intent: l, query: c } = r.promptQuery,
        u = e.conversation?.getLatestTurn()?.requestId ?? '',
        p = e.sessionId,
        d = l?.id,
        f = e.document.languageId,
        m = r.reply.type,
        h = m === 'inlineEdit' ? r.reply.edits : null,
        g = generateDiagnosticsTelemetry(s, this.languageDiagnosticService.getDiagnostics(e.document.uri)),
        v = isNotebookCell(e.document.uri) ? 1 : 0,
        _ = { languageId: f, replyType: m, conversationId: p, requestId: u, command: d },
        y = {
          selectionLineCount: s ? Math.abs(s.end.line - s.start.line) : -1,
          wholeRangeLineCount: a ? Math.abs(a.end.line - a.start.line) : -1,
          editCount: h?.length ?? -1,
          editLineCount:
            h?.reduce(
              (x, P) =>
                x +
                P.newText.split(`
`).length,
              0
            ) ?? -1,
          isNotebook: v,
          problemsCount: g.fileDiagnosticsTelemetry.problemsCount,
          selectionProblemsCount: g.selectionDiagnosticsTelemetry.problemsCount,
          diagnosticsCount: g.fileDiagnosticsTelemetry.diagnosticsCount,
          selectionDiagnosticsCount: g.selectionDiagnosticsTelemetry.diagnosticsCount,
        },
        b = (x, P) => {
          this._microsoftTelemetryService.sendInternalTelemetryEvent(
            x,
            {
              language: f,
              intent: d,
              query: c,
              conversationId: p,
              requestId: u,
              replyType: m,
              problems: g.fileDiagnosticsTelemetry.problems,
              selectionProblems: g.selectionDiagnosticsTelemetry.problems,
              diagnosticCodes: g.fileDiagnosticsTelemetry.diagnosticCodes,
              selectionDiagnosticCodes: g.selectionDiagnosticsTelemetry.diagnosticCodes,
            },
            { isNotebook: v, ...P }
          )
        }
      if (n === VscodeInteractiveEditorResponseFeedbackKind.Helpful || n === VscodeInteractiveEditorResponseFeedbackKind.Unhelpful) {
        let x = n === VscodeInteractiveEditorResponseFeedbackKind.Helpful ? 1 : 0
        this._microsoftTelemetryService.sendTelemetryEvent('inline.action.vote', _, { ...y, vote: x }),
          b('interactiveSessionVote', { vote: x })
      } else if (n === VscodeInteractiveEditorResponseFeedbackKind.Undone || n === VscodeInteractiveEditorResponseFeedbackKind.Accepted) {
        let x = n === VscodeInteractiveEditorResponseFeedbackKind.Accepted ? 1 : 0
        this._microsoftTelemetryService.sendTelemetryEvent('inline.done', _, { ...y, accepted: x }),
          b('interactiveSessionDone', { accepted: x })
      }
      switch (n) {
        case VscodeInteractiveEditorResponseFeedbackKind.Helpful:
          ;(i.rating = 'positive'), (o = 'inlineConversation.messageRating')
          break
        case VscodeInteractiveEditorResponseFeedbackKind.Unhelpful:
          ;(i.rating = 'negative'), (o = 'inlineConversation.messageRating')
          break
        case VscodeInteractiveEditorResponseFeedbackKind.Undone:
          ;(i.action = 'undo'), (o = 'inlineConversation.undo')
          break
        case VscodeInteractiveEditorResponseFeedbackKind.Accepted:
          ;(i.action = 'accept'), (o = 'inlineConversation.accept')
          break
        case VscodeInteractiveEditorResponseFeedbackKind.Bug:
          o = ''
          break
      }
      o && sendSuggestionTelemetry(this.accessor, e.document, i, {}, o)
    }
    async fetchResponse(e, r, n, i, o) {
      let s = generateTelemetryEvent(),
        a = Date.now(),
        l = {
          document: e.document,
          fileIndentInfo: e.formattingOptions,
          language: getCommentSymbol(e.document),
          selection: r.selection,
          wholeRange: r.wholeRange,
        }
      ;(e.getRequests().length > 1 || r.attempt > 0) && (e.preferredIntent = void 0)
      let c = await processCommand(this.accessor, r.prompt, l, e, s, o),
        u = c.intentInvocation
      n.report({ slashCommand: c.slashCommand })
      let p = await generateMessages(c, e.getRequests().slice(0, -1), s, o)
      if (o.isCancellationRequested) return
      let d = e.conversation,
        f = d === void 0
      d || (d = e.conversation = new Conversation())
      let m = p.map(T => T.content).join(`
`),
        h = new Session({ message: m, type: 'user' })
      ;(h.chatMessages = p),
        d.addTurn(h),
        (s = extendTelemetryEventWithUserInput(d, e.sessionId, 'conversationInline', r.prompt, calculateTokenLength(this.accessor, p), u.intent.id, s))
      let g = s.properties.messageId
      ;(h.requestId = g), this.logger.logPrompt(p)
      let v,
        _,
        y = 0,
        b = u.createReplyInterpreter(n, i),
        x = async T => (y === 0 && (y = Date.now()), b.update(T).shouldFinish ? T.length : void 0),
        P = Date.now(),
        U = u.endpoint
      try {
        v = await this.accessor
          .get(DataRetriever)
          .fetchOne(
            p,
            x,
            o,
            1,
            U,
            { temperature: CopilotInteractiveEditorSessionProvider.pickTemperature(r), top_p: SamplingParameters.top_p },
            { messageId: g, messageSource: 'inline.user' },
            { intent: !0 }
          )
      } catch (T) {
        throw (
          (this.logger.exception(T, 'Fetching failed: '),
          this.accessor.get(IGHTelemetryService).sendExceptionTelemetry(T, 'Fetching failed: '),
          (h.status = 'error'),
          (h.response = { message: T.message, type: 'server' }),
          new Error('Failed to make request'))
        )
      }
      this.logger.logResponse(v),
      extendTelemetryEventWithOffTopicFlag(
          this.accessor,
          'conversationInline',
          r.prompt,
          v.type === 'offTopic',
          this.tabAndEditorsService.activeTextEditor?.document,
          s
        )
      let H = isNotebookCell(e.document.uri) ? 1 : 0,
        j = generateDiagnosticsTelemetry(r.selection, this.languageDiagnosticService.getDiagnostics(e.document.uri)),
        M = this.accessor.get(Tokenizer),
        F = T => {
          this._microsoftTelemetryService.sendTelemetryEvent(
            'inline.request',
            {
              command: u.intent.id ?? '',
              contextTypes: 'none',
              promptTypes: p.map(A => `${A.role}${A.name ? `-${A.name}` : ''}:${A.content.length}`).join(','),
              conversationId: e.sessionId,
              requestId: g,
              languageId: this.tabAndEditorsService.activeTextEditor?.document?.languageId,
              responseType: v.type,
              replyType: T?.type,
              model: U.model,
              diagnosticsProvider: j.diagnosticsProvider,
            },
            {
              firstTurn: f ? 1 : 0,
              isNotebook: H,
              messageTokenCount: M.tokenLength(c.queryWithoutCommand),
              promptTokenCount: calculateTokenLength(this.accessor, p),
              responseTokenCount: v.type === 'success' ? M.tokenLength(v.value) : -1,
              implicitCommand: r.prompt.trim().startsWith(`/${u.intent.id}`) ? 0 : 1,
              attemptCount: r.attempt || 0,
              selectionLineCount: r.selection ? Math.abs(r.selection.end.line - r.selection.start.line) + 1 : -1,
              wholeRangeLineCount: r.wholeRange ? Math.abs(r.wholeRange.end.line - r.wholeRange.start.line) + 1 : -1,
              editCount: T?.type === 'inlineEdit' ? T.edits.length : -1,
              editLineCount:
                T?.type === 'inlineEdit'
                  ? T.edits.reduce(
                      (A, X) =>
                        A +
                        X.newText.split(`
`).length,
                      0
                    )
                  : -1,
              problemsCount: j.fileDiagnosticsTelemetry.problemsCount,
              selectionProblemsCount: j.selectionDiagnosticsTelemetry.problemsCount,
              diagnosticsCount: j.fileDiagnosticsTelemetry.diagnosticsCount,
              selectionDiagnosticsCount: j.selectionDiagnosticsTelemetry.diagnosticsCount,
              timeToRequest: P - a,
              timeToFirstToken: y ? y - a : -1,
              timeToComplete: Date.now() - a,
            }
          )
        },
        z = (T, A) => {
          this._microsoftTelemetryService.sendInternalTelemetryEvent(
            'interactiveSessionResponse',
            {
              chatLocation: 'inline',
              intent: u.intent.id ?? '',
              problems: j.fileDiagnosticsTelemetry.problems,
              selectionProblems: j.selectionDiagnosticsTelemetry.problems,
              diagnosticCodes: j.fileDiagnosticsTelemetry.diagnosticCodes,
              selectionDiagnosticCodes: j.selectionDiagnosticsTelemetry.diagnosticCodes,
              diagnosticsProvider: j.diagnosticsProvider,
              language: this.tabAndEditorsService.activeTextEditor?.document?.languageId,
              request: r.prompt,
              responseType: T,
              response: A,
            },
            { isNotebook: H }
          )
        }
      switch (v.type) {
        case 'rateLimited': {
          let T = `Response failed ${v.type}: ${v.reason}`
          throw (
            ((h.status = 'error'),
            (h.response = { message: T, type: 'server' }),
            F(),
            z(v.type, T),
            new Error('Oops, your request failed due to a rate limit. Please try again later.'))
          )
        }
        case 'badRequest': {
          let T = `Response failed ${v.type}: ${v.reason}`
          throw (
            ((h.status = 'error'),
            (h.response = { message: T, type: 'server' }),
            F(),
            z(v.type, T),
            new Error('Failed to make request'))
          )
        }
        case 'failed': {
          this.logger.error(`Response failed: ${v.reason}`), (h.status = 'error')
          let T = v.reason
          throw ((h.response = { message: T, type: 'server' }), F(), z(v.type, T), new Error('Failed to make request'))
        }
        case 'canceled': {
          this.logger.debug(`Response canceled: ${v.reason}`), (h.status = 'error')
          let T = 'Cancelled'
          ;(h.response = { message: T, type: 'user' }), F(), z(v.type, T)
          return
        }
        case 'unknown': {
          let T = `Response is empty: ${v.reason}`
          this.logger.info(T), (h.status = 'error'), (h.response = { message: T, type: 'server' }), F(), z(v.type, T)
          return
        }
        case 'filtered': {
          let T = `Response got filtered: ${v.reason}`
          throw (
            (this.logger.info(T),
            (h.status = 'filtered'),
            (h.response = { message: T, type: 'server' }),
            F(),
            z(v.type, T),
            new Error('Oops, response got filtered. Please rephrase your prompt.'))
          )
        }
        case 'offTopic': {
          this.logger.info(`Response marked as offtopic: ${v.reason}`), (h.status = 'off-topic')
          let T = this.rejectionMessage
          ;(h.response = { message: T, type: 'offtopic-detection' }),
            F(),
            z(v.type, T),
            extendTelemetryEventWithOffTopicMessage(this.accessor, d, e.sessionId, 'conversationInline', r.prompt, g, e.document, s)
          return
        }
        case 'length': {
          let T = `Response was too long: ${v.reason}`
          this.logger.info(T), (h.status = 'error'), (h.response = { message: T, type: 'server' }), F(), z(v.type, T)
          return
        }
        case 'success':
          break
        default: {
          this.logger.error('Unexpected response type'), this.logger.info(JSON.stringify(v)), (h.status = 'error')
          let T = `Unexpected response type: ${JSON.stringify(v)}`
          ;(h.response = { message: T, type: 'server' }), F(), z('unknown', T)
          return
        }
      }
      if (((_ = v.value), _.length === 0)) {
        this.logger.info('Response is empty.'), F(), z('unknown', 'Empty response')
        return
      }
      b.update(_)
      let q = await b.finish()
      h.status = 'success'
      let L = _
      return (
        (h.response = { message: L, type: 'model' }),
        F(q),
        z('success', L),
        (s = s.extendedBy({ replyType: q.type })),
        extendTelemetryEventWithModelOutput(this.accessor, d, e.sessionId, 'conversationInline', _, g, e.document, s),
        this.logger.info(`Parsed response: ${JSON.stringify(q, null, '	')}`),
        {
          promptQuery: { query: c.queryWithoutCommand, ...l, intent: u.intent },
          parsedReply: q,
          messageId: s.properties.messageId,
        }
      )
    }
    static pickTemperature(e) {
      return 'attempt' in e && typeof e.attempt == 'number'
        ? Math.min(SamplingParameters.temperature * (e.attempt + 1), 2)
        : SamplingParameters.temperature
    }
  }

function handleReply(reply, context) {
  let { promptQuery, parsedReply, messageId } = reply
  if (parsedReply.type === 'conversational') return { contents: new VscodeMarkdownString(parsedReply.content), promptQuery, reply: parsedReply, messageId }
  let contents = parsedReply.content !== void 0 ? new VscodeMarkdownString(parsedReply.content) : void 0
  return parsedReply.type === 'workspaceEdit'
    ? { edits: parsedReply.workspaceEdit, promptQuery, reply: parsedReply, messageId, contents }
    : {
        edits: parsedReply.edits,
        wholeRange: parsedReply.newWholeRange,
        reply: parsedReply,
        promptQuery,
        messageId,
        contents: parsedReply.content !== void 0 ? new VscodeMarkdownString(parsedReply.content) : void 0,
      }
}

function calculateTokenLength(tokenizer, tokens) {
  let totalLength = 0
  for (let token of tokens) totalLength += tokenizer.tokenLength(token.content)
  return totalLength
}

function generateDiagnosticsTelemetry(range, diagnostics) {
  let filteredDiagnostics = diagnostics.filter(diagnostic => range.intersection(diagnostic.range)),
    fileDiagnosticsTelemetry = {
      problems: diagnostics.map(diagnostic => diagnostic.message).join(', '),
      problemsCount: diagnostics.length,
      diagnosticCodes: '',
      diagnosticsCount: 0,
    },
    selectionDiagnosticsTelemetry = {
      problems: filteredDiagnostics.map(diagnostic => diagnostic.message).join(', '),
      problemsCount: filteredDiagnostics.length,
      diagnosticCodes: '',
      diagnosticsCount: 0,
    },
    fileDiagnosticCodes = new Map(),
    selectionDiagnosticCodes = new Map()
  diagnostics.forEach(diagnostic => {
    let code = diagnostic.code,
      codeString = typeof code == 'string' || typeof code == 'number' ? code.toString() : code ? code.value.toString() : ''
    fileDiagnosticCodes.set(codeString, (fileDiagnosticCodes.get(codeString) || 0) + 1), range.intersection(diagnostic.range) && selectionDiagnosticCodes.set(codeString, (selectionDiagnosticCodes.get(codeString) || 0) + 1)
  })
  let generateDiagnosticCodesString = map => {
    let result = ''
    map.forEach((count, code) => {
      result += `${code}:${count},`
    })
    return result
  }
  fileDiagnosticsTelemetry.diagnosticCodes = generateDiagnosticCodesString(fileDiagnosticCodes)
  fileDiagnosticsTelemetry.diagnosticsCount = fileDiagnosticCodes.size
  selectionDiagnosticsTelemetry.diagnosticCodes = generateDiagnosticCodesString(selectionDiagnosticCodes)
  selectionDiagnosticsTelemetry.diagnosticsCount = selectionDiagnosticCodes.size
  let diagnosticsProvider = diagnostics.length > 0 ? diagnostics[0].source ?? '' : ''
  return { fileDiagnosticsTelemetry, selectionDiagnosticsTelemetry, diagnosticsProvider }
}
var requestLight = handleDefaultExports(requestLight())
var TextProcessor = class {
  constructor(turn, progress, textApplier) {
    this.turn = turn
    this.progress = progress
    this.stagedTextToApply = ''
    this.reporting = true
    this._appliedText = ''
    this._resolvedContentDeferredPromise = new PromiseOutcome()
    this._incodeblock = false
    this.conversationCallback = new TextApplier(delta => this.applyDelta(delta))
  }
  get appliedText() {
    return Promise.resolve(this._appliedText)
  }
  apply(text) {
    this.conversationCallback.apply(text)
  }
  applyDeltaToTurn(delta) {
    this.turn.response || (this.turn.response = { message: delta, type: 'model' }),
      (this._appliedText += delta),
      (this.turn.response.message += delta)
  }
  applyDeltaToProgress(delta) {
    this.progress.report({ content: delta })
  }
  applyDelta(delta) {
    if (!this.reporting) {
      this.applyDeltaToTurn(delta)
      return
    }
    delta = this.stagedTextToApply + delta
    if (this._incodeblock) {
      let codeBlockEndIndex = delta.indexOf('```')
      if (codeBlockEndIndex === -1) {
        this.stagedTextToApply = delta
        this.applyDeltaToProgress('')
        this.applyDeltaToTurn('')
        return
      } else {
        this._incodeblock = false
        delta = delta.substring(0, codeBlockEndIndex) + '```'
        try {
          this.applyDeltaToTurn(delta)
        } catch {
        } finally {
          this.reporting = false
          this.stagedTextToApply = ''
          this._resolvedContentDeferredPromise.complete({ content: '' })
        }
        return
      }
    }
    let codeBlockStartIndex = delta.indexOf('```')
    if (codeBlockStartIndex !== -1) {
      this._incodeblock = true
      let codeBlockEndIndex = delta.indexOf('```', codeBlockStartIndex + 3)
      if (codeBlockEndIndex !== -1) {
        this._incodeblock = false
        this.applyDeltaToProgress(delta.substring(0, codeBlockStartIndex))
        this.applyDeltaToProgress(delta.substring(codeBlockEndIndex + 3))
        this.applyDeltaToTurn(delta)
        this.reporting = false
        this.stagedTextToApply = ''
        return
      } else {
        let textBeforeCodeBlock = delta.substring(0, codeBlockStartIndex)
        this.applyDeltaToProgress(textBeforeCodeBlock)
        this.applyDeltaToTurn(delta)
        this.stagedTextToApply = ''
        this.progress.report({
          placeholder: 'Thinking ...',
          resolvedContent: this._resolvedContentDeferredPromise.p,
        })
        return
      }
    }
    this.applyDeltaToProgress(delta)
    this.applyDeltaToTurn(delta)
    this.stagedTextToApply = ''
  }
},
outlineInstructions = `
DO NOT include Introduction or Conclusion section in the outline!
Focus only on sections that will need code!

Generate the outline as two parts:
- First part is markdown bullet list of section titles
- Second part is the JSON data that will validate against this JSON schema, wrap the response in code block. We assume that a code block begins with \`\`\`[optionally the language] and ends with \`\`\`

The JSON schema is:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
	"description": {
	  "type": "string"
	},
	"sections": {
	  "type": "array",
	  "items": {
		"type": "object",
		"properties": {
		  "title": {
			"type": "string"
		  },
		  "content": {
			"type": "string"
		  }
		},
		"required": ["title", "content"]
	  }
	}
  },
  "required": ["sections"]
}`,
exampleResponse = `
Below you will find a set of examples of what you should respond with. Please follow these examples as closely as possible.

## Valid notebook creation question

user: Creating Random Arrays with Numpy

assistant: Here's an outline for a Jupyter notebook that creates Random Arrays with Numpy:

* **Import Required Libraries**
* **Create Random Arrays**
* **Seed the Random Number Generator**
* **Generate Random Integers**

\`\`\`json
{
  "description": "A Jupyter notebook that creates Random Arrays with Numpy.",
  "sections": [
    {
      "title": "Import Required Libraries",
      "content": "Import the necessary libraries, including NumPy."
    },
    {
      "title": "Create Random Arrays",
      "content": "Use NumPy to create random arrays of various shapes and sizes, including 1D, 2D, and 3D arrays."
    },
    {
      "title": "Seed the Random Number Generator",
      "content": "Use the seed() function to seed the random number generator for reproducibility."
    },
	{
	  "title": "Generate Random Integers",
	  "content": "Use the randint() function to generate random integers within a specified range."
	}
  ]
}
\`\`\`
`
function createNewNotebookIntent() {
  let newNotebookIntent = new Intent({
    location: 2,
    id: 'newNotebook',
    description: requestLight.t('Create a new Jupyter Notebook'),
    modelDescription:
      'Creates a new Jupyter Notebook for tasks such as data analysis, scientific computing, and machine learning.',
    modelSampleQuestion: 'How do I create a notebook to load data from a csv file?',
    commandInfo: {
      allowsEmptyArgs: false,
      yieldsTo: [{ command: 'fix' }, { command: 'explain' }, { command: 'workspace' }, { command: 'tests' }],
      defaultEnablement: true,
      sampleRequest: requestLight.t('How do I create a notebook to load data from a csv file?'),
    },
    systemPromptOptions: {
      examples: exampleResponse,
      roleplay: 'You are an AI that creates a detailed content outline for a Jupyter notebook on a given topic.',
    },
    rules: outlineInstructions,
    turnFilter: intents =>
    intents.filter(
      intent =>
        intent.intentInvocation?.intent.id === 'newNotebook' ||
          (intent.request.type !== 'user' && intent.request.type !== 'follow-up')
      ),
    responseProcessor: (response, intent, context) => new TextProcessor(response, intent, context),
    followUps: async (response, intent) => {
      let message = (intent.response?.message ?? '').replace(/\n/g, ''),
        jsonMatch = /```(?:json)?(.+)/g.exec(message)
      if (jsonMatch)
        try {
          let json = jsonMatch[1],
            endOfJson = json.indexOf('```'),
            jsonContent = endOfJson === -1 ? json : json.substring(0, endOfJson)
          return [{ commandId: 'github.copilot.newNotebook', args: [JSON.parse(jsonContent)], title: 'Create Notebook' }]
        } catch {}
      return []
    },
    contextResolvers: [contextResolverRegistry, currentSelectionContextResolver],
  })
  IntentManager.registerIntent(newNotebookIntent)
}
ContributionManager.registerContribution(createNewNotebookIntent)
async function generatePythonCodeForSection(serviceProvider, context, options, notebookTopic, sectionInfo, existingCode, sessionId) {
  let messageSource = { messageSource: 'slash.newNotebook' },
    prompt = `
    You are an AI that writes Python code for a single section of a Jupyter notebook.
    Overall topic of the notebook: ${notebookTopic}
    Title of the notebook section: ${sectionInfo.title}
    Description of the notebok section: ${sectionInfo.content}
    Given this information, write all the code for this section and this section only.
    Your output should be valid Python code with inline comments.
    You should return the code directly without any explantion.
    You should not print message to explain the code or purpose of the code.

    Code in the notebook so far:

    ${existingCode}

    Please make sure the new code you generate works fine with the code above.
    You should return the code directly, without wrapping it inside \`\`\`.

    Please make sure that the new code is syntactically valid Python code. It can be validated by running it in a Python interpreter.
    For example, it should pass the validation through builtin module codeop \`codeop.compile_command(statement)\`.
    `,
    response = await serviceProvider
      .get(DataRetriever)
      .fetchOne([{ content: prompt, role: 'user' }], undefined, sessionId, 2, context, { temperature: options.temperature, top_p: options.topP }, messageSource)
  if (response.type === 'success') return response.value
}
async function improvePythonCode(serviceProvider, context, options, notebookTopic, sectionInfo, existingCode, codeToImprove, sessionId) {
  let messageSource = { messageSource: 'slash.newNotebook' },
    prompt = `
You are an AI that improves Python code with respect to readability and performance for a single section of a Jupyter notebook.
You MUST return Python code as your answer.
DO NOT explain in inline comments for your the improvements
Overall topic of the notebook: ${notebookTopic}
Title of the notebook section: ${sectionInfo.title}
Description of the notebok section: ${sectionInfo.content}

Code in the notebook so far:

${existingCode}

Given this information, improve the following code.

Make sure the new code you generate works fine with the code above.
Make sure if a module is already imported in the code above, it can be used in the new code directly without importing it again. For the same reason, if a variable is defined above, it can be used in new code as well.
Make sure to return the code only - don't give an explanation of the improvements.

${codeToImprove}
    `,
    response = await serviceProvider
      .get(DataRetriever)
      .fetchOne([{ content: prompt, role: 'user' }], undefined, sessionId, 2, context, { temperature: options.temperature, top_p: options.topP }, messageSource)
  if (response.type === 'success') return response.value
}
var vscode = handleDefaultExports(require('vscode'))
var ChatResponseProvider = class {
  constructor(context) {
    this.context = context
  }
  async provideChatResponse(messages, options, progress, cancellationToken) {
    let formattedMessages = messages.map(message => {
        let formattedMessage = { content: message.content, name: message.name, role: 'user' }
        switch (message.role) {
          case vscode.ChatMessageRole.System:
            formattedMessage.role = 'system'
            break
          case vscode.ChatMessageRole.Assistant:
            formattedMessage.role = 'assistant'
            break
          case vscode.ChatMessageRole.User:
            formattedMessage.role = 'user'
            break
        }
        return formattedMessage
      }),
      chatEndpointInfo = await getChatEndpointInfo(this.context, 3),
      dataRetriever = this.context.get(DataRetriever),
      offset = 0
    await dataRetriever.fetchMany(
      formattedMessages,
      async (content, index) => {
        let part = content.substring(offset)
        offset += part.length
        progress.report({ part: part, index: index })
      },
      cancellationToken,
      3,
      chatEndpointInfo,
      { n: options.n, stream: true }
    )
  }
}
var vscode = handleDefaultExports(require('vscode'))
var GitCommitGenerator = class {
  constructor(accessor) {
    this.accessor = accessor
    this._changesMap = new Map()
  }
  async run(repository, cancellationToken) {
    if (cancellationToken.isCancellationRequested || !repository) return
    let extensionApi = this.accessor.get(BaseGitExtensionService).getExtensionApi()
    if (!extensionApi) return
    let repo = extensionApi.getRepository(repository)
    repo &&
      (await vscode.window.withProgress({ location: vscode.ProgressLocation.SourceControl }, async () => {
        let diff = await repo.getDiff(),
          attemptCount = this._getAttemptCount(repo, diff),
          commitMessage = await new GitCommitMessageGenerator(this.accessor).generateGitCommitMessage(diff, attemptCount, cancellationToken)
        commitMessage && ((repo.inputBox.value = commitMessage), this._changesMap.set(repo.rootUri.fsPath, [diff, attemptCount]))
      }))
  }
  _getAttemptCount(repo, diff) {
    let [previousDiff, previousAttemptCount] = this._changesMap.get(repo.rootUri.fsPath) ?? [[], 1]
    if (previousDiff.length !== diff.length) return 1
    for (let index = 0; index < diff.length; index++) if (previousDiff[index] !== diff[index]) return 1
    return previousAttemptCount + 1
  }
}
var vscode = handleDefaultExports(require('vscode'))
var PullRequestProvider = class {
  constructor(accessor) {
    this.accessor = accessor
    this.disposables = new DisposableStore()
    this.lastContext = { commitMessages: [], patches: [] }
    this.internalLogger = accessor.get(LoggerManager).getPromptResponseLogger('GitHub pull request title and description generator')
    this.logger = accessor.get(LoggerManager).getLogger('githubTitleAndDescriptionProvider')
    this.logger.info('Initializing GitHub PR title and description provider provider.')
    this.options = accessor.get(conversationOptions)
  }
  dispose() {
    this.disposables.dispose()
  }
  isRegenerate(commitMessages, patches) {
    if (commitMessages.length !== this.lastContext.commitMessages.length || patches.length !== this.lastContext.patches.length) return false
    for (let index = 0; index < commitMessages.length; index++) if (commitMessages[index] !== this.lastContext.commitMessages[index]) return false
    for (let index = 0; index < patches.length; index++) if (patches[index] !== this.lastContext.patches[index]) return false
    return true
  }
  async provideTitleAndDescription(commitMessages, patches, issues, cancellationToken) {
    let chatEndpointInfo = await getChatEndpointInfo(this.accessor, 3)
    let maxTokenWindow = Math.floor((chatEndpointInfo.modelMaxTokenWindow * 4) / 3)
    let prTitleAndDescriptionPrompt = this.createPRTitleAndDescriptionPrompt(commitMessages, patches, issues, maxTokenWindow)
    let prompt = [{ role: 'system', content: prTitleAndDescriptionPrompt }]
    this.internalLogger.logPrompt(prompt)
    let fetchResult = await this.accessor
      .get(DataRetriever)
      .fetchOne(
        prompt,
        undefined,
        cancellationToken,
        3,
        chatEndpointInfo,
        {
          temperature: this.isRegenerate(commitMessages, patches) ? this.options.temperature + 0.1 : this.options.temperature,
          top_p: this.options.topP,
        },
        { messageSource: 'extension.providePullRequestTitleAndDescription' }
      )
    this.internalLogger.logResponse(fetchResult)
    this.lastContext = { commitMessages: commitMessages, patches: patches }
    if (fetchResult.type === 'success') return PullRequestProvider.parseFetchResult(fetchResult.value)
  }

  static parseFetchResult(fetchResult, isRecursive = true) {
    fetchResult = fetchResult.trim()
    let result = fetchResult,
      firstDelimiterIndex = result.indexOf('+++')
    if (firstDelimiterIndex === -1) return
    let lastDelimiterIndex = result.lastIndexOf('+++')
    result = result
      .substring(firstDelimiterIndex + 3, lastDelimiterIndex > firstDelimiterIndex + 3 ? lastDelimiterIndex : void 0)
      .trim()
      .replace(/\+\+\+?(\n)\+\+\+/, '+++')
    let splitResult = result.split('+++').filter(part => part.trim().length > 0),
      titleAndDescription
    if (splitResult.length === 1)
      titleAndDescription = splitResult[0].split(`
`)
    else if (splitResult.length > 1) {
      let descriptionParts = splitResult
        .slice(1)
        .map(part =>
          part.split(`
`)
        )
        .flat()
        .filter(part => part.trim().length > 0)
      titleAndDescription = [splitResult[0], ...descriptionParts]
    } else return
    let title, description
    if (titleAndDescription.length === 1) {
      if (
        ((title = titleAndDescription[0].trim()),
        isRecursive &&
          fetchResult.includes(`
`) &&
          fetchResult.split('+++').length === 3)
      )
        return this.parseFetchResult(fetchResult + '+++', false)
    } else if (titleAndDescription.length > 1) {
      title = titleAndDescription[0].trim()
      description = ''
      let descriptionParts = titleAndDescription.slice(1)
      for (let part of descriptionParts)
        part.includes('commit message') ||
          (description += `${part.trim()}

`)
    }
    if (title)
      return (
        (title = title.replace(/Title\:\s/, '').trim()),
        description && (description = description.replace(/Description\:\s/, '').trim()),
        { title: title, description: description }
      )
  }
  createPRTitleAndDescriptionPrompt(commitMessages, patches, issues, maxTokenWindow) {
    let commitList = commitMessages.map(message => `* ${message}`).join(`
`),
      availableSpace = maxTokenWindow - Math.floor(maxTokenWindow * 0.1) - commitList.length,
      patchesLength = patches.join(`

`).length
    if (patchesLength > availableSpace)
      for (patches.sort((a, b) => a.length - b.length); patchesLength > availableSpace && patches.length > 0; ) {
        let patch = patches.pop()
        patchesLength -= patch.length
      }
    let promptIntro
    issues && issues.length > 0
      ? (promptIntro = `You are an AI assistant for a software developer who is about to make a pull request to a GitHub repository to fix the following issues:
${issues
  .map(
    issue => `
-------
Issue ${issue.reference}:
${issue.content}`
  )
  .join()}
-------
`)
      : (promptIntro = `You are an AI assistant for a software developer who is about to make a pull request to a GitHub repository.
`)
    let examples
    issues && issues.length > 0
        ? (examples = `Example One:
    +++Batch mark/unmark files as viewed
    +++Previously, when marking/unmarking a folder as viewed, a request was sent for every single file. This PR ensures that only one request is sent when marking/unmarking a folder as viewed.
    Fixes #4520+++
Example two:
    +++Fallback to hybrid after 20 process ports
    +++Additionally the \`remote.autoForwardPortsSource\` setting has been updated to remove the \`markdownDescription\` reference to a reload being required for changes to take effect.
    Fixes microsoft/vscode-internalbacklog#4533+++`)
        : (examples = `Example One:
    +++Batch mark/unmark files as viewed
    +++Previously, when marking/unmarking a folder as viewed, a request was sent for every single file. This PR ensures that only one request is sent when marking/unmarking a folder as viewed.+++
Example two:
    +++Fallback to hybrid after 20 process ports
    +++Additionally the \`remote.autoForwardPortsSource\` setting has been updated to remove the \`markdownDescription\` reference to a reload being required for changes to take effect.+++`),
      return `
${getAssistantIdentity()}
${getAssistantExpertise()}

${promptIntro}
Pull requests have a short and concise title that describes the changes in the code and a slightly longer description.
The description can be more detailed but should still be concise. Do not list commits, files or patches. Do not make up an issue reference if the pull request isn't fixing an issue.
The title and description of a pull request should be markdown and start with +++ and end with +++. Here are two good examples.
--------
${examples}
--------
These are the commits that will be included in the pull request you are about to make:
${commitList}
Below is a list of git patches that contain the file changes for all the files that will be included in the pull request:
${patches.join(`

`)}

Based on the git patches and on the git commit messages above, the title and description of the pull request should be:
`
  }
}
var GitHubPRProvider = class extends PullRequestProvider {
  constructor(accessor) {
    super(accessor)
    this.initializeGitHubPRExtensionApi()
  }
  getExtension() {
    return vscode.extensions.getExtension('github.vscode-pull-request-github')
  }
  initializeGitHubPRExtensionApi() {
    let extension = this.getExtension(),
      activateExtension = async () => {
        if (extension) {
          let activatedExtension = await extension.activate()
          this.logger.info('Successfully activated the GitHub.vscode-pull-request-github extension.'),
            (this.gitHubExtensionApi = activatedExtension),
            this.registerTitleAndDescriptionProvider()
        }
      }
    if (extension) activateExtension()
    else {
      this.logger.info('GitHub.vscode-pull-request-github extension is not yet activated.')
      let onDidChangeHandler = vscode.extensions.onDidChange(() => {
        ;(extension = this.getExtension()), extension && (activateExtension(), onDidChangeHandler.dispose())
      })
      this.disposables.add(onDidChangeHandler)
    }
  }
  async registerTitleAndDescriptionProvider() {
    if (this.gitHubExtensionApi)
      try {
        this.disposables.add(
          this.gitHubExtensionApi.registerTitleAndDescriptionProvider(vscode.l10n.t('Generate with Copilot'), this)
        ),
          this.logger.info('Successfully registered GitHub PR title and description provider.')
      } catch {}
  }
}
var vscode = handleDefaultExports(require('vscode'))
var EditProvider = class {
  provideMappedEdits(document, edits, editDocument, options) {
    if (editDocument.documents.length === 0) return null
    let firstDocument = editDocument.documents[0],
      documentUri = document.uri.toString(),
      matchedDocument = firstDocument.find(_ => _.uri.toString() === documentUri)
    if (!matchedDocument) return null
    let ranges = matchedDocument.ranges
    if (ranges.length !== 1 || edits.length !== 1) return null
    let firstRange = ranges[0],
      firstEdit = edits[0]
    if (
      !document
        .getText(new vscode.Range(new vscode.Position(firstRange.start.line, 0), new vscode.Position(firstRange.start.line, firstRange.start.character)))
        .match(/^\s*$/)
    )
      return null
    let activeEditor = vscode.window.activeTextEditor,
      indentationOptions
    if (activeEditor && activeEditor.options && document.languageId === activeEditor.document.languageId) {
      let options = activeEditor.options,
        tabSize = typeof options.tabSize == 'number' ? options.tabSize : 4,
        insertSpaces = typeof options.insertSpaces == 'boolean' ? options.insertSpaces : true
      indentationOptions = { tabSize: tabSize, insertSpaces: insertSpaces }
    }
    let rangeToReplace = new vscode.Range(new vscode.Position(firstRange.start.line, 0), firstRange.end),
      textInRange = document.getText(rangeToReplace),
      adjustedIndentation = adjustIndentation(
        firstEdit.split(`
`),
        {
          whichLine: 'topMost',
          lines: textInRange.split(`
`),
        },
        indentationOptions
      ).join(`
`),
      workspaceEdit = new vscode.WorkspaceEdit()
    return workspaceEdit.replace(document.uri, rangeToReplace, adjustedIndentation), workspaceEdit
  }
}
var vscode = handleDefaultExports(require('vscode'))
var requestLight = handleDefaultExports(requestLight())
var maxTextLength = 6e4,
  maxLineCount = 1500,
  DocumentationCommand = class Command {
    constructor() {
      this.id = Command.ID
      this.description = requestLight.t('Add documentation comment for this symbol')
      this.intentDetectionInput = { sampleQuestion: 'Add jsdoc to this method' }
      this.locations = [1]
      this.commandInfo = { executeImmediately: true }
    }
    static {
      this.ID = 'doc'
    }
    async asSlashCommand(accessor, context) {
      if (context.document.lineCount > maxLineCount || context.document.getText().length > maxTextLength)
        return new SlashCommand('Add documentation comment for this symbol')
      let nodeToDocument = await DocumentSelectionResolver.determineNodeToDocument(accessor, context),
        detail = nodeToDocument.identifier
          ? requestLight.t("Add documentation comment for '{0}'", nodeToDocument.identifier)
          : requestLight.t('Add documentation comment for this symbol')
      return new SlashCommand(detail, nodeToDocument)
    }
    async invoke(accessor, context, slashCommand) {
      let documentContext = context.documentContext
      if (!documentContext) throw new Error('Open a file to add documentation.')
      let nodeToDocument
      slashCommand instanceof SlashCommand
        ? (nodeToDocument = slashCommand.nodeToDocument)
        : accessor
            .get(LoggerManager)
            .getLogger('InlineDocIntent#invoke')
            .warn('Unexpected: SlashCommand given to intent invocation is not a DocSlashCommand')
      let endpointInfo = await getChatEndpointInfo(accessor, context.location, this.id)
      return new DocumentationAssistant(accessor, endpointInfo, documentContext, this, nodeToDocument)
    }
  },
  SlashCommand = class {
    constructor(detail, nodeToDocument = void 0) {
      this.detail = detail
      this.nodeToDocument = nodeToDocument
      this.command = DocumentationCommand.ID
      this.executeImmediately = true
    }
  },
var DocumentationAssistant = class Assistant {
  constructor(accessor, endpoint, context, intent, nodeToDocument = void 0) {
    this.accessor = accessor
    this.endpoint = endpoint
    this.context = context
    this.intent = intent
    this.nodeToDocument = nodeToDocument
    this.location = 1
    this.createReplyInterpreter = ReplyInterpreter.createFactory(async message => {
      if (!this.contextInfo || !this.expandedRange) throw new Error('doc intent NEEDS a selection context')
      let codeBlock = extractCodeBlock(this.contextInfo, message, this.context.language)
      if (!codeBlock) return { type: 'conversational', content: message }
      let code = codeBlock.code,
        startTime = Date.now(),
        extractedDoc = await extractDoc(this.context.document.languageId, code),
        timeSpent = Date.now() - startTime
      Assistant._sendExtractDocTelemetry(this.accessor.get(IMSTelemetryService), this.context.document.languageId, code.length, extractedDoc, timeSpent),
        extractedDoc && (code = extractedDoc)
      let processedInput = processInputText(this.accessor, this.contextInfo, code, 1, this.context.fileIndentInfo)
      return createInlineEdit(processedInput, this.expandedRange)
    })
    let self = this,
      rules = this.computeRules(context)
    this.promptCrafter = new (class extends ChatBuilder {
      constructor() {
        super(accessor, { rules: rules, contextResolvers: [] }, 1, context)
      }
      async buildPrompt(conversation, endpoint, user, prompt, delay, feedback) {
        self.nodeToDocument || (self.nodeToDocument = await DocumentSelectionResolver.determineNodeToDocument(self.accessor, self.context))
        let contextResolution = await new DocumentSelectionResolver(self.nodeToDocument).resolveContext(
          self.accessor,
          { endpoint: endpoint, conversation: conversation, documentContext: self.context, message: void 0 },
          void 0
        )
        if (contextResolution) {
          self.contextInfo = contextResolution?.metadata.contextInfo
          self.expandedRange = contextResolution?.metadata.expandedRange
          let queryPrefix = await self.computeQueryPrefix(accessor, context),
            sessions = []
          for (let message of contextResolution.userMessages) sessions.push(new Session({ message: message, type: 'user' }))
          let lastTurn = conversation.getLatestTurn()
          if (!lastTurn) throw new Error('No last message')
          lastTurn.request.message = `${queryPrefix} ${lastTurn.request.message}`.trim()
          conversation = new Conversation([sessions, conversation.turns].flat())
        }
        return super.buildPrompt(conversation, endpoint, user, prompt, delay, feedback)
      }
    })()
  }
  computeRules(context) {
    return `
- Each code block starts with \`\`\` and ${FilePathComment.forLanguage(context.language)}.
- You always answer with ${context.language.languageId} code.
- When the user asks you to document something, you must answer in the form of a ${
      context.language.languageId
    } code block.`.trim()
  }
  async computeQueryPrefix(accessor, context) {
    let isNode, identifier
    this.nodeToDocument === void 0 || !this.nodeToDocument.identifier
      ? ((isNode = false), (identifier = 'the selection'))
      : ((isNode = true), (identifier = this.nodeToDocument.identifier))
    let docType
    switch (context.document.languageId) {
      case 'typescript':
      case 'typescriptreact':
        docType = isNode ? 'a TSDoc comment' : 'TSDoc comment'
        break
      case 'javascript':
      case 'javascriptreact':
        docType = isNode ? 'a JSDoc comment' : 'JSDoc comment'
        break
      case 'python':
        docType = 'docstring'
        break
      default:
        docType = 'documentation comment'
    }
    return `Please add ${docType} for ${identifier}.`
  }
  static _sendExtractDocTelemetry(telemetryService, languageId, codeBlockLen, couldExtractDoc, timeSpentMs) {
    telemetryService.sendTelemetryEvent(
      'extractDoc',
      { languageId: languageId, couldExtractDoc: couldExtractDoc === void 0 ? 'false' : 'true' },
      { codeBlockLen: codeBlockLen, timeSpentMs: timeSpentMs }
    )
  }
}
var requestLight = handleDefaultExports(requestLight())
var EXPLANATION_PROMPT = 'Write an explanation for the active selection as paragraphs of text.',
explanationOptions = {
  systemPromptOptions: {
    includeCodeGenerationRules: false,
    roleplay:
      'You are a world-class coding tutor. Your code explanations perfectly balance high-level concepts and granular details. Your approach ensures that students not only understand how to write code, but also grasp the underlying principles that guide effective programming.',
  },
  rules: `
Think step by step:
1. Examine the provided code selection and any other context like user question, related errors, project details, class definitions, etc.
2. If you are unsure about the code, concepts, or the user's question, ask clarifying questions.
3. If the user provided a specific question or error, answer it based on the selected code and additional provided context. Otherwise focus on explaining the selected code.
4. Provide suggestions if you see opportunities to improve code readability, performance, etc.

Focus on being clear, helpful, and thorough without assuming extensive prior knowledge.
Use developer-friendly terms and analogies in your explanations.
Identify 'gotchas' or less obvious parts of the code that might trip up someone new.
Provide clear and relevant examples aligned with any provided context.
`.trim(),
  contextResolvers: [currentSelectionContextResolver, bY, contextResolverRegistry],
  turnFilter: turn => turn.map(message => (message.request.message.startsWith(EXPLANATION_PROMPT) && (message.request.message = EXPLANATION_PROMPT), message)),
},
DefaultPanelPromptCrafter = class {
  constructor(context) {
    this.defaultPanelPromptCrafter = new ChatBuilder(context, explanationOptions, 2, undefined)
  }
  async buildPrompt(conversation, endpoint, context, reporter, prompt, message) {
    return this.defaultPanelPromptCrafter.buildPrompt(conversation, endpoint, context, reporter, prompt, message)
  }
},
ExplainIntent = class {
  constructor() {
    this.id = 'explain'
    this.locations = [2, 1]
    this.description = requestLight.t('Explain how the selected code works')
    this.intentDetectionInput = { sampleQuestion: 'Write an explanation for the code above as paragraphs of text.' }
  }
  static {
    this.ID = 'explain'
  }
  async invoke(context, request, workspace) {
    let location = request.location,
      endpointInfo = await getChatEndpointInfo(context, location, this.id)
    if (location === 1) {
      let documentContext = request.documentContext,
        customChatBuilder = new (class extends ChatBuilder {
          async buildPrompt(conversation, endpoint, context, reporter, prompt, message) {
            let latestTurn = conversation.getLatestTurn()
            if (latestTurn?.request.message === '') {
              latestTurn.request = { message: EXPLANATION_PROMPT, type: 'user' }
            }
            return super.buildPrompt(conversation, endpoint, context, reporter, prompt, message)
          }
        })(context, explanationOptions, 1, documentContext),
        replyInterpreterFactory = documentContext && StreamProcessor.createFactory()
      return { intent: this, location: location, endpoint: endpointInfo, promptCrafter: customChatBuilder, createReplyInterpreter: replyInterpreterFactory }
    }
    return { intent: this, location: location, endpoint: endpointInfo, promptCrafter: new DefaultPanelPromptCrafter(context) }
  }
  async asSlashCommand(context, request) {
    return { command: this.id, detail: this.description, refer: context.get(ConfigManager).getConfig(settings.ExplainIntentRefer) }
  }
}
var vscode = require('vscode')

function registerCommandWithTelemetry(context, commandId, commandHandler) {
  let command = vscode.commands.registerCommand(commandId, async (...args) => {
    try {
      return await commandHandler(...args)
    } catch (error) {
      context.get(IGHTelemetryService).sendExceptionTelemetry(error, commandId)
    }
  })
  context.get(extensionContext).subscriptions.push(command)
}
var vscode = handleDefaultExports(require('vscode'))

var AIAction = class extends vscode.CodeAction {
    constructor() {
      super(...arguments)
      this.isAI = true
    }
  },
  CodeActionProvider = class {
    constructor(accessor) {
      this.accessor = accessor
    }
    static {
      this.providedCodeActionKinds = [vscode.CodeActionKind.QuickFix]
    }
    static getSevereDiagnostics(diagnostics) {
      let severeDiagnostics = diagnostics.filter(diagnostic => diagnostic.severity <= vscode.DiagnosticSeverity.Warning)
      return severeDiagnostics.length === 0 ? [] : severeDiagnostics
    }
    static getDiagnosticsAsText(diagnostics) {
      return diagnostics.map(diagnostic => diagnostic.message).join(', ')
    }
    async provideCodeActions(document, range, context) {
      if (!vscode.workspace.getConfiguration('github.copilot.editor').get('enableCodeActions')) return
      let actions = []
      if (!vscode.window.activeTextEditor) return actions
      let severeDiagnostics = CodeActionProvider.getSevereDiagnostics(context.diagnostics)
      if (severeDiagnostics.length === 0) return actions
      let unionRange = severeDiagnostics.map(diagnostic => diagnostic.range).reduce((range, current) => range.union(current)),
        selection = new vscode.Selection(unionRange.start, unionRange.end),
        diagnosticsText = CodeActionProvider.getDiagnosticsAsText(severeDiagnostics),
        fixAction = new AIAction(vscode.l10n.t('Fix using Copilot'), vscode.CodeActionKind.QuickFix)
      fixAction.diagnostics = severeDiagnostics
      fixAction.command = {
          title: fixAction.title,
          command: 'vscode.editorChat.start',
          arguments: [{ autoSend: true, message: `/fix ${diagnosticsText}`, position: unionRange.start, initialSelection: selection, initialRange: unionRange }],
        }
      let explainAction = new AIAction(vscode.l10n.t('Explain using Copilot'), vscode.CodeActionKind.QuickFix)
      explainAction.diagnostics = severeDiagnostics
      let explainCommand = `/explain ${diagnosticsText}`
      if (this.accessor.get(ConfigManager).getConfig(settings.ExplainIntentRefer)) {
        explainCommand = `@${exampleDialogue} ${explainCommand}`
      }
      explainAction.command = { title: explainAction.title, command: 'github.copilot.interactiveEditor.explain', arguments: [explainCommand] }
      actions.push(fixAction, explainAction)
      return actions
    }
  }

var RefactorProvider = class {
  static {
    this.providedCodeActionKinds = [vscode.CodeActionKind.RefactorRewrite]
  }
  constructor(serviceProvider) {
    this.logger = serviceProvider.get(LoggerManager).getLogger('RefactorsProvider')
    this.ghTelemetryService = serviceProvider.get(IGHTelemetryService)
  }
  async provideCodeActions(document, range, context) {
    if (!vscode.workspace.getConfiguration('github.copilot.editor').get('enableCodeActions')) return
    let generateActions = this.provideGenerateUsingCopilotCodeAction(document, range)
    return [...(await this.provideDocumentUsingCopilotCodeAction(document, range)), ...generateActions]
  }
  provideGenerateUsingCopilotCodeAction(document, range) {
    let action
    if (range.isEmpty) {
      let lineText = document.lineAt(range.start.line).text
      if (/^\s*$/g.test(lineText)) {
        action = new AIAction(vscode.l10n.t('Generate using Copilot'), vscode.CodeActionKind.RefactorRewrite)
      }
    } else {
      let rangeText = document.getText(range)
      if (!/^\s*$/g.test(rangeText)) {
        action = new AIAction(vscode.l10n.t('Modify using Copilot'), vscode.CodeActionKind.RefactorRewrite)
      }
    }
    return action === undefined
      ? []
      : [this.createActionCommand(action, range)]
  }
  createActionCommand(action, range) {
    action.command = {
      title: action.title,
      command: 'vscode.editorChat.start',
      arguments: [{ position: range.start, initialSelection: range, initialRange: range }],
    }
    return action
  }
  async provideDocumentUsingCopilotCodeAction(document, range) {
    let startIndex = document.offsetAt(range.start),
      endIndex = document.offsetAt(range.end),
      indexRange = { startIndex: startIndex, endIndex: endIndex },
      documentableNode
    try {
      documentableNode = await getDocumentableNodeIfOnIdentifier(document.languageId, document.getText(), indexRange)
    } catch (error) {
      this.logger.exception(error, 'RefactorsProvider: getDocumentableNodeIfOnIdentifier failed')
      this.ghTelemetryService.sendExceptionTelemetry(
        error,
        'RefactorsProvider: getDocumentableNodeIfOnIdentifier failed'
      )
    }
    if (documentableNode === undefined) return []
    let actionTitle = vscode.l10n.t('Document using Copilot: {0}', documentableNode.identifier),
      action = new AIAction(actionTitle, vscode.CodeActionKind.RefactorRewrite),
      nodeRange =
        documentableNode.nodeRange === undefined
          ? undefined
          : new VscodeRange(document.positionAt(documentableNode.nodeRange.startIndex), document.positionAt(documentableNode.nodeRange.endIndex))
    action.command = {
      title: actionTitle,
      command: 'vscode.editorChat.start',
      arguments: [{ autoSend: true, message: '/doc', initialRange: nodeRange }],
    }
    return [action]
  }
}
var util = require('util'),
vscode = handleDefaultExports(require('vscode'))
var ERROR_MIME_TYPE = 'application/vnd.code.notebook.error'
var CellStatusBarProvider = class {
  constructor(serviceAccessor) {
    this.serviceAccessor = serviceAccessor
  }
  async provideCellStatusBarItems(cell, token) {
    let errorOutput = cell.outputs.flatMap(output => output.items).find(item => item.mime === ERROR_MIME_TYPE)
    if (!errorOutput) return []
    let error
    try {
      let decoder = new util.TextDecoder()
      error = JSON.parse(decoder.decode(errorOutput.data))
      if (!error.name && !error.message) return []
      let actionTitle = 'Fix using Copilot',
        errorMessage = [error.name, error.message]
          .filter(Boolean)
          .join(': ')
          .replace(/\s*\(\S+,\s*line\s*\d+\)/, '')
      return [
        {
          text: '$(sparkle)',
          alignment: vscode.NotebookCellStatusBarAlignment.Left,
          priority: Number.MAX_SAFE_INTEGER - 1,
          tooltip: actionTitle,
          command: {
            title: actionTitle,
            command: 'vscode.editorChat.start',
            arguments: [{ autoSend: true, message: `/fix ${errorMessage}` }],
          },
        },
      ]
    } catch (parseError) {
      this.serviceAccessor.get(LoggerManager).defaultLogger.error(`Failed to parse error output ${parseError}`)
    }
    return []
  }
}
function registerCommands(context) {
  let explainCommand = input => {
      let message = `@${exampleDialogue} /explain `
      if (typeof input == 'string' && input) message = input
      else {
        let currentSelection = CurrentSelectionContextResolver.getCurrentSelection(context.get(BaseTabManager))
        if (currentSelection) {
          let diagnostics = vscode.languages.getDiagnostics(currentSelection.activeDocument.uri),
            intersectingDiagnostics = diagnostics.filter(diagnostic => !!diagnostic.range.intersection(currentSelection.range))
            CodeActionProvider.getSevereDiagnostics(intersectingDiagnostics).length
            ? (message += CodeActionProvider.getDiagnosticsAsText(diagnostics))
            : ((message += EXPLANATION_PROMPT), (message += CurrentSelectionContextResolver.formatSelection({ languageId: currentSelection.languageId, selectedText: currentSelection.selectedText })))
        }
      }
      vscode.interactive.sendInteractiveRequestToProvider('copilot', { message: message })
    },
    generateCommand = () => vscode.commands.executeCommand('vscode.editorChat.start', { message: '/generate ' }),
    generateDocsCommand = () =>
    vscode.commands.executeCommand('vscode.editorChat.start', {
        message: `/${DocumentationCommand.ID} `,
        autoSend: true,
        initialRange: vscode.window.activeTextEditor?.selection,
      }),
    generateTestsCommand = () =>
    vscode.commands.executeCommand('vscode.editorChat.start', {
        message: '/tests ',
        autoSend: true,
        initialRange: vscode.window.activeTextEditor?.selection,
      }),
    fixCommand = () => {
      let activeEditor = vscode.window.activeTextEditor
      if (!activeEditor) return
      let selection = activeEditor.selection,
        diagnostics = vscode.languages
          .getDiagnostics(activeEditor.document.uri)
          .filter(diagnostic => !!selection.intersection(diagnostic.range))
          .map(diagnostic => diagnostic.message)
          .join(', ')
      return vscode.commands.executeCommand('vscode.editorChat.start', {
        message: `/fix ${diagnostics}`,
        autoSend: true,
        initialRange: vscode.window.activeTextEditor?.selection,
      })
    }
  try {
    registerCommandWithTelemetry(context, 'github.copilot.interactiveEditor.explain', explainCommand),
    registerCommandWithTelemetry(context, 'github.copilot.interactiveEditor.generate', generateCommand),
      registerCommandWithTelemetry(context, 'github.copilot.interactiveEditor.generateDocs', generateDocsCommand),
      registerCommandWithTelemetry(context, 'github.copilot.interactiveEditor.generateTests', generateTestsCommand),
      registerCommandWithTelemetry(context, 'github.copilot.interactiveEditor.fix', fixCommand)
  } catch (error) {
    context.get(LoggerManager).defaultLogger.exception(error, 'Could not register explain command'),
      context.get(IGHTelemetryService).sendExceptionTelemetry(error, 'Could not register explain command')
  }
  context.get(extensionContext).subscriptions.push(
    vscode.languages.registerCodeActionsProvider('*', new CodeActionProvider(context), { providedCodeActionKinds: CodeActionProvider.providedCodeActionKinds }),
    vscode.languages.registerCodeActionsProvider('*', new RefactorProvider(context), { providedCodeActionKinds: RefactorProvider.providedCodeActionKinds }),
    vscode.notebooks.registerNotebookCellStatusBarItemProvider('jupyter-notebook', new CellStatusBarProvider(context))
  )
}
var crypto = require('crypto'),
vscode = handleDefaultExports(require('vscode'))
var vscode = require('vscode')
var userReadScope = ['read:user'],
userEmailScope = ['user:email'],
fullScopes = ['read:user', 'user:email', 'repo', 'workflow'],
notSignedInMessage = 'You are not signed in to GitHub. Please sign in to use Copilot.'

function getAuthProvider(configManager) {
  return configManager.getConfig(settings.AuthProvider) === 'github-enterprise' ? 'github-enterprise' : 'github'
}

async function handleProvider(provider, serviceManager) {
  let authProvider = getAuthProvider(serviceManager.get(ConfigManager))
  if (provider.id === authProvider) {
    let { defaultLogger: logger } = serviceManager.get(LoggerManager)
    if (await vscode.authentication.getSession(authProvider, userEmailScope, { silent: true }))
      return await serviceManager.get(BaseTokenHandler).getCopilotToken(serviceManager, true)
    serviceManager.get(BaseTokenHandler).resetCopilotToken(serviceManager), logger.warn(notSignedInMessage)
  }
}

async function getSessionWithMinimalScope(configManager) {
  let authProvider = getAuthProvider(configManager)
  return (
    (await vscode.authentication.getSession(authProvider, userEmailScope, { silent: true })) ??
    (await vscode.authentication.getSession(authProvider, userReadScope, { silent: true }))
  )
}

async function getSessionWithFullScope(configManager, options) {
  let authProvider = getAuthProvider(configManager)
  return await vscode.authentication.getSession(authProvider, fullScopes, options)
}

var crypto = require('crypto'),
util = handleDefaultExports(require('util')),
vscode = require('vscode')
var agentMap = new Map()

async function initializeExtension(contextManager) {
  contextManager.get(extensionContext).subscriptions.push(new vscode.Disposable(() => agentMap.forEach(agent => agent.dispose()))), loadAgents(contextManager)
}

var supportedAgents = ['docs', 'datastax'],
  MP
async function loadAgents(contextManager) {
  return agentPromise || (agentPromise = fetchAgents(contextManager)), agentPromise.finally(() => (agentPromise = undefined))
}
async function fetchAgents(contextManager) {
  let logger = contextManager.get(LoggerManager).getLogger('RemoteAgents')
  if (!contextManager.get(ConfigManager).getConfig(settings.EnableRemoteAgents)) return
  let agentsEndpointUrl = contextManager.get(ConfigManager).getConfig(settings.AgentsEndpointUrl),
    existingAgents = new Set(agentMap.keys())
  try {
    let token = await contextManager.get(BaseTokenHandler).getBasicGitHubToken(),
      response = await (
        await contextManager
          .get(ConnectionSettings)
          .fetch(`${agentsEndpointUrl}/agents`, {
            method: 'GET',
            headers: { Authorization: util.format('Bearer %s', token), ...contextManager.get(BuildInfo).getEditorVersionHeaders() },
          })
      ).text(),
      agents
    try {
      agents = JSON.parse(response).agents
    } catch (error) {
      logger.warn(`Invalid remote agent response: ${response} (${error})`)
      return
    }
    for (let agent of agents) supportedAgents.includes(agent.slug) && (existingAgents.delete(agent.slug) || agentMap.set(agent.slug, createChatAgent(contextManager, logger, agent, agentsEndpointUrl)))
  } catch (error) {
    logger.warn(`Failed to load remote slash commands: ${error}`)
  }
  for (let agent of existingAgents) agentMap.get(agent).dispose(), agentMap.delete(agent)
}

function createChatAgent(contextManager, logger, agentInfo, agentsEndpointUrl) {
  let chatAgent = vscode.chat.createChatAgent(agentInfo.slug, async (chat, user, reporter, cancellation) => {
    try {
      let engineService = new EngineService(agentsEndpointUrl, `agents/${agentInfo.slug}?chat`, 'copilot-chat', 4096),
        resolvedPrompt = await contextManager.get(BaseVariableResolver).resolveVariablesInPrompt(chat.prompt, chat.variables),
        response = await contextManager.get(DataRetriever).fetchMany(
          [{ role: 'user', content: resolvedPrompt.message, intent: 'conversation' }],
          async (role, message, result) => {
            reporter.report({ content: result.text })
          },
          cancellation,
          2,
          engineService,
          { secretKey: await contextManager.get(BaseTokenHandler).getBasicGitHubToken() }
        )
      return response.type !== 'success'
        ? (logger.warn(`Bad response from /agents/${agentInfo.slug}: ${response.type} ${response.reason}`),
          response.reason.includes('400 no docs found')
            ? { errorDetails: { message: 'No docs found' } }
            : { errorDetails: { message: response.reason } })
        : {}
    } catch (error) {
      return logger.warn(`/agents/${agentInfo.slug} failed: ${error}`), {}
    }
  })
  return (
    (chatAgent.description = agentInfo.description),
    (chatAgent.fullName = agentInfo.name),
    (chatAgent.agentVariableProvider = {
      triggerCharacters: ['#'],
      provider: {
        async provideCompletionItems(chat, position) {
          return (await fetchCompletionItems(contextManager, agentInfo.slug, chat, logger, position)).map(item => {
            let completionItem = new vscode.ChatAgentCompletionItem('#' + item, [
              { value: '#' + item, level: vscode.ChatVariableLevel.Full, description: '', kind: 'github.docset' },
            ])
            return (completionItem.insertText = '#' + item.replace(/ /g, '')), completionItem
          })
        },
      },
    }),
    chatAgent
  )
}

async function fetchAutocompleteItems(contextManager, agentSlug, query, logger, position) {
  let requestParams = {
    url: `${contextManager.get(ConfigManager).getConfig(settings.AgentsEndpointUrl)}/agents/autocomplete`,
    modelMaxTokenWindow: 0
  }
  query.startsWith('#') && (query = query.substring(1))
  let token = await contextManager.get(BaseTokenHandler).getBasicGitHubToken(),
    responseText = await (await sendRequest(contextManager, requestParams, token ?? '', void 0, (0, crypto.randomUUID)(), { agents: [agentSlug], query: query }, position)).text()
  try {
    let parsedResponse = JSON.parse(responseText)
    if (parsedResponse === null) return []
    if (!Array.isArray(parsedResponse)) throw new Error('Expected array')
    return parsedResponse.map(item => item.metadata.display_name)
  } catch (error) {
    return logger.warn(`Invalid autocomplete response (${error.toString()}): ${responseText}`), []
  }
}

var ChatSessionManager = class {
  constructor(serviceAccessor, options) {
    this.serviceAccessor = serviceAccessor
    this.options = options
    this.hasShownWelcomeMessage = false
    this.isInternal = false
  }
  getLastSession() {
    return this.lastSession
  }
  async prepareSession(session) {
    if (!this.username) {
      let session = await getSessionWithMinimalScope(this.serviceAccessor.get(ConfigManager))
      this.isInternal = (await this.serviceAccessor.get(BaseTokenHandler).getCopilotToken(this.serviceAccessor))?.isInternal
      this.username = session?.account?.label
    }
    loadAgents(this.serviceAccessor)
    let sessionId = (0, crypto.randomUUID)(),
      chatLogger = new ChatLogger(this.serviceAccessor, () => vscode.window.createOutputChannel('GitHub Copilot Chat Conversation', { log: true })),
      conversationManager = new CopilotConversationManager(this.serviceAccessor, this.options, this.username, chatLogger, this.isInternal, sessionId)
    return (this.lastSession = conversationManager), conversationManager
  }
  async provideSampleQuestions(session) {
    let questions =
      vscode.window.activeNotebookEditor || vscode.window.activeTextEditor
        ? generateWorkspaceQuestions()
        : generateHelpQuestion([['', '/help', vscode.l10n.t('What can you do?')]])
    return displaySuggestions([...questions], this.serviceAccessor, 'welcome'), questions
  }
  async provideWelcomeMessage(session) {
    let feedbackUrl = generateFeedbackUrl(),
      welcomeMessageSetting = this.serviceAccessor.get(ConfigManager).getConfig(settings.WelcomeMessage),
      aiDisclaimer = vscode.l10n.t({
        message:
          "I'm powered by AI, so surprises and mistakes are possible. Make sure to verify any generated code or suggestions, and [share feedback]({0}) so that we can learn and improve. Check out the [{1} documentation]({2}) to learn more.",
        args: [feedbackUrl, 'Copilot', 'https://code.visualstudio.com/docs/editor/github-copilot#_chat-view'],
        comment: [
          "{Locked=']({'}",
          'the [text](url) is a markdown link syntax. Do not add any additional spaces between ] and (',
        ],
      }),
      usernamePrefix = this.username ? ' **@' + this.username + '**' : ''
    if (welcomeMessageSetting === 'never' || (this.hasShownWelcomeMessage && welcomeMessageSetting === 'first'))
      return [vscode.l10n.t('Hi{0}, how can I help you?', usernamePrefix)]
    this.hasShownWelcomeMessage = true
    let inlineChatCommand = 'workbench.action.quickchat.launchInlineChat',
      inlineChatPrompt =
        vscode.window.activeNotebookEditor || vscode.window.activeTextEditor
          ? vscode.l10n.t('You can also [start an inline chat session]({0}).', `command:${inlineChatCommand}`)
          : '',
      welcomeMessage = new vscode.MarkdownString(
        vscode.l10n.t("Welcome,{0}, I'm your {1} and I'm here to help you get things done faster. {2}", usernamePrefix, 'Copilot', inlineChatPrompt)
      )
    return (welcomeMessage.isTrusted = { enabledCommands: [inlineChatCommand] }), [welcomeMessage, aiDisclaimer]
  }
}

function displaySuggestions(suggestions, accessor, type) {
  suggestions.map(suggestion => {
    displaySuggestion(accessor, suggestion.message, type, suggestion.metadata.suggestionId, vscode.window.activeTextEditor?.document)
  })
}

function generateFeedbackUrl() {
  return 'https://aka.ms/microsoft/vscode-copilot-release'
}

function generateWorkspaceQuestions() {
  let workspacePrefix = '@workspace '
  return generateHelpQuestion([
    [workspacePrefix, '/fix', vscode.l10n.t('the problems in my code')],
    [workspacePrefix, '/tests', vscode.l10n.t('add unit tests for my code')],
    [workspacePrefix, '/explain', vscode.l10n.t('how the selected code works')],
  ])
}

function generateHelpQuestion(questions) {
  return questions.map(([prefix, command, description]) => ({
    message: prefix + command + ' ',
    title: command + ' ' + description,
    metadata: { messageId: 'welcome', suggestionId: (0, crypto.randomUUID)(), suggestionType: 'Follow-up from model' },
  }))
}

var path = require('path'),
util = require('util'),
vscode = require('vscode')
var vscode = require('vscode'),
var ReadOnlyFileSystem = class {
  constructor(contentManager) {
    this.contentManager = contentManager
    this._onDidChangeFile = new vscode.EventEmitter()
    this.onDidChangeFile = this._onDidChangeFile.event
  }
  async stat(uri) {
    let file = this.contentManager.get(uri.authority, uri.path)
    if (!file) throw vscode.FileSystemError.FileNotFound(uri)
    let size = (await file.content?.then(content => content?.length)) ?? 0
    return {
      ctime: file.ctime ?? 0,
      mtime: file.ctime ?? 0,
      size: size,
      type: file.children ? vscode.FileType.Directory : vscode.FileType.File,
      permissions: vscode.FilePermission.Readonly,
    }
  }
  readDirectory(uri) {
    let directory = this.contentManager.get(uri.authority, uri.path)
    if (!directory) throw vscode.FileSystemError.FileNotFound(uri)
    return directory.children?.map(child => [child.label, child.children ? vscode.FileType.Directory : vscode.FileType.File]) ?? []
  }
  async readFile(uri) {
    let file = this.contentManager.get(uri.authority, uri.path)
    if (!file) throw vscode.FileSystemError.FileNotFound(uri)
    let content
    try {
      content = await file.content
    } catch {}
    return content ?? new Uint8Array()
  }
  watch(uri, options) {
    return { dispose() {} }
  }
  createDirectory(uri) {
    throw vscode.FileSystemError.NoPermissions(uri)
  }
  writeFile(uri, content, options) {
    throw vscode.FileSystemError.NoPermissions(uri)
  }
  delete(uri, options) {
    throw vscode.FileSystemError.NoPermissions(uri)
  }
  rename(source, target, options) {
    throw vscode.FileSystemError.NoPermissions(target)
  }
  copy(source, target, options) {
    throw vscode.FileSystemError.NoPermissions(target)
  }
}
function registerCopilotCommands(contextManager, extensionContext) {
  return (
    processWorkspaceErrors(contextManager, extensionContext),
    vscode.Disposable.from(
      vscode.workspace.registerFileSystemProvider('vscode-copilot-workspace', new ReadOnlyFileSystem(contextManager.get(ProjectManager)), {
        isReadonly: new Jvscodee.MarkdownString(
          vscode.l10n.t(`This file preview was generated by Copilot and may contain surprises or mistakes.

Ask followup questions to refine it, then press Create Workspace.`)
        ),
      }),
      vscode.commands.registerCommand('github.copilot.createProject', async (fileSystemItems, paths, i, o, workspaceUri) => {
        let lastInteractiveSession = contextManager.get(ChatEngine).getLastInteractiveSession(),
          parentFolder = (
            await vscode.window.showOpenDialog({
              canSelectFolders: true,
              canSelectFiles: false,
              canSelectMany: false,
              openLabel: 'Select as Parent Folder',
            })
          )?.[0]
        if (!parentFolder) return
        let originalPath = paths[0].path,
          newPath = await generateUniqueName(parentFolder, originalPath),
          pathRegex = new RegExp(originalPath, 'g'),
          tabsToClose = []
          vscode.window.tabGroups.all.forEach(tabGroup => {
          tabGroup.tabs.forEach(tab => {
            tab.input instanceof vscode.TabInputText && tab.input.uri.scheme === 'vscode-copilot-workspace' && tabsToClose.push(tab)
          })
        }),
        vscode.window.tabGroups.close(tabsToClose, true),
          await vscode.window.withProgress(
            { location: vscode.ProgressLocation.Notification, cancellable: true },
            async (progress, cancellationToken) => {
              for (let item of paths) {
                let itemPath = item.path.replace(pathRegex, newPath),
                  itemUri = vscode.Uri.joinPath(parentFolder, itemPath)
                switch (item.type) {
                  case 'folder': {
                    progress.report({ message: vscode.l10n.t('Creating folder {0}...', itemPath) }),
                      await vscode.workspace.fs.createDirectory(itemUri)
                    break
                  }
                  case 'file': {
                    progress.report({ message: vscode.l10n.t('Creating file {0}...', itemPath) })
                    let sourceUri = generateUri(workspaceUri, item.path),
                      fileContent = await vscode.workspace.fs.readFile(sourceUri),
                      targetUri = vscode.Uri.joinPath(parentFolder, itemPath)
                    await vscode.workspace.fs.writeFile(targetUri, Buffer.from(fileContent))
                    break
                  }
                  default:
                    break
                }
              }
              let workspacePath = vscode.Uri.joinPath(parentFolder, newPath)
              lastInteractiveSession !== void 0 && vscode.interactive.transferChatSession(lastInteractiveSession, workspacePath),
                contextManager
                  .get(LoggerManager)
                  .getLogger('newIntent')
                  .info('Opening folder: ' + workspacePath.fsPath)
              let globalState = extensionContext.globalState,
                generatedWorkspaceUris = globalState.get('CopilotGeneratedWorkspaceUris', [])
              await globalState.update('CopilotGeneratedWorkspaceUris', [...generatedWorkspaceUris, workspacePath.toString()])
              try {
                await updateWorkspaceList(workspacePath)
              } catch {}
              await vscode.commands.executeCommand('vscode.openFolder', workspacePath)
            }
          )
      })
    )
  )
}

async function processWorkspaceErrors(contextManager, extensionContext) {
  let context = contextManager.get(extensionContext),
    workspaceUris = context.globalState.get('CopilotGeneratedWorkspaceUris', []),
    workspaceUri = vscode.workspace.workspaceFolders?.[0]?.uri.toString()
  if (!workspaceUri) return
  let [remainingUris, workspaceExists] = workspaceUris.reduce(([uris, exists], uri) => (uri === workspaceUri ? [uris, true] : [[...uris, uri], exists]), [[], false])
  if (workspaceExists) {
    let fileLimit = contextManager.get(ConfigManager).getConfig(settings.WorkspaceExperimentalFileLimit)
    if (fileLimit <= 0) return
    let documents = await getDocuments(vscode.Uri.parse(workspaceUri), fileLimit),
      workspaceEdit = new vscode.WorkspaceEdit(),
      cancellationToken = new vscode.CancellationTokenSource().token
    for (let document of documents) {
      let diagnostics = await getDiagnostics(document.uri, cancellationToken)
      if (!diagnostics.length) continue
      let edits = await processErrorAndFix(contextManager, extensionContext, document, diagnostics[0], cancellationToken)
      edits && workspaceEdit.set(document.uri, edits)
    }
    let applyFixes = vscode.l10n.t('Apply Fixes')
    if (workspaceEdit.size > 0) {
      if (
        (await vscode.window.showInformationMessage(
          vscode.l10n.t('We detected errors in your project. Would you like to apply the suggested fixes?'),
          applyFixes
        )) !== applyFixes
      )
        return
      await vscode.workspace.applyEdit(workspaceEdit)
    }
    await context.globalState.update('CopilotGeneratedWorkspaceUris', remainingUris)
  }
}

async function getDiagnostics(uri, cancellationToken, timeout = 5000) {
  let cancellationListener, timer
  return new Promise(resolve => {
    cancellationListener = cancellationToken.onCancellationRequested(resolve)
    let diagnosticsListener
    timer = setTimeout(() => {
      diagnosticsListener?.dispose(), resolve([])
    }, timeout),
      new Promise(resolveDiagnostics => {
        diagnosticsListener = vscode.languages.onDidChangeDiagnostics(async event => {
          if (event.uris.map(String).includes(uri.toString())) {
            let diagnostics = vscode.languages.getDiagnostics(uri)
            if (diagnostics.length > 0) {
              let relevantDiagnostics = diagnostics.filter(diagnostic => isErrorWithSuggestion(diagnostic))
              resolveDiagnostics(relevantDiagnostics)
            }
          } else resolveDiagnostics([])
        })
      }).then(diagnostics => {
        diagnosticsListener?.dispose(), resolve(diagnostics)
      })
  }).finally(() => {
    cancellationListener.dispose(), clearTimeout(timer)
  })
}

var ignoredExtensions = ['.txt', '.md', '.json', '.ini', '.lock', '.gitignore', '.gitattributes', '.env']

async function getDocuments(directoryUri, limit, documents = []) {
  let directoryEntries = await vscode.workspace.fs.readDirectory(directoryUri)
  for (let [entryName, entryType] of directoryEntries) {
    if (documents.length > limit) break
    if (entryType === vscode.FileType.File && !ignoredExtensions.includes(path.extname(entryName))) {
      let fileUri = vscode.Uri.joinPath(directoryUri, entryName),
        textDocument = await vscode.window.showTextDocument(fileUri)
      documents.push(textDocument.document)
    } else if (entryType === vscode.FileType.Directory) {
      await getDocuments(vscode.Uri.joinPath(directoryUri, entryName), limit, documents)
    }
  }
  return documents
}

function isErrorWithSuggestion(diagnostic) {
  return diagnostic.severity === vscode.DiagnosticSeverity.Error && diagnostic.message.includes('Did you mean')
}

async function generateUniqueName(directory, baseName) {
  let counter = 0,
    isUnique = true,
    name = baseName
  while (isUnique) {
    try {
      await vscode.workspace.fs.stat(vscode.Uri.joinPath(directory, name)), (name = baseName + '-' + ++counter)
    } catch {
      isUnique = false
    }
  }
  return name
}

async function fileExists(fileUri) {
  try {
    await vscode.workspace.fs.stat(fileUri)
    return true
  } catch {
    return false
  }
}

async function updateWorkspaceList(workspaceUri) {
  let storageFileUri = getStorageFileUri()
  if (storageFileUri)
    if (await fileExists(storageFileUri)) {
      let fileContent = await vscode.workspace.fs.readFile(storageFileUri).then(buffer => new util.TextDecoder().decode(buffer)),
        workspaceList = JSON.parse(fileContent)
      workspaceList.push(workspaceUri.toString()), await vscode.workspace.fs.writeFile(storageFileUri, Buffer.from(JSON.stringify(workspaceList, null, 2)))
    } else await vscode.workspace.fs.writeFile(storageFileUri, Buffer.from(JSON.stringify([workspaceUri.toString()], null, 2)))
}

function getStorageFileUri() {
  let appName =
      vscode.env.appName.indexOf('Insider') > 0 || vscode.env.appName.indexOf('Code - OSS Dev') >= 0
        ? 'Code - Insiders'
        : 'Code',
    homeDirectory = vscode.Uri.file(process.env.HOME || (process.env.USERPROFILE ? process.env.USERPROFILE : ''))
  switch (process.platform) {
    case 'darwin':
      return vscode.Uri.joinPath(
        homeDirectory,
        'Library',
        'Application Support',
        appName,
        'User',
        'workspaceStorage',
        'aiGeneratedWorkspaces.json'
      )
    case 'linux':
      return vscode.Uri.joinPath(homeDirectory, '.config', appName, 'User', 'workspaceStorage', 'aiGeneratedWorkspaces.json')
    case 'win32':
      return process.env.APPDATA
        ? vscode.Uri.joinPath(vscode.Uri.file(process.env.APPDATA), appName, 'User', 'workspaceStorage', 'aiGeneratedWorkspaces.json')
        : void 0
    default:
      return
  }
}

async function gatherWorkspaceInfo(container, symbolNames) {
  let tabManager = container.get(BaseTabManager),
    diagnosticWaiter = container.get(DiagnosticWaiter),
    symbolProvider = container.get(BaseSymbolProvider),
    workspace = container.get(WorkspaceClass),
    terminalInfoProvider = container.get(BaseTerminalInfoProvider),
    disposable = container.get(DisposableClass),
    gitRepoManager = container.get(BaseGitRepositoryManager),
    workspaceFoldersPaths = workspace.getWorkspaceFolders().map(folder => folder.fsPath + '/'),
    notebookDocumentsPaths = workspace.notebookDocuments.map(doc => doc.uri.fsPath),
    symbols = (await Promise.all(symbolNames.map(name => symbolProvider.getWorkspaceSymbols(name))))
      .flat()
      .map(symbol => ({
        name: symbol.name,
        kind: symbol.kind,
        containerName: symbol.containerName,
        filePath: symbol.location.uri.fsPath,
        start: symbol.location.range.start,
        end: symbol.location.range.end,
      })),
    activeFileDiagnostics = tabManager.activeTextEditor
      ? diagnosticWaiter
          .getDiagnostics(tabManager.activeTextEditor.document.uri)
          .map(diagnostic => ({
            start: diagnostic.range.start,
            end: diagnostic.range.end,
            message: diagnostic.message,
            severity: diagnostic.severity,
            relatedInformation: diagnostic.relatedInformation?.map(createDiagnosticInfo),
          }))
      : [],
    activeTextEditor = tabManager.activeTextEditor
      ? {
          selections:
            tabManager.activeTextEditor?.selections.map(selection => ({
              anchor: selection.anchor,
              active: selection.active,
              isReversed: selection.isReversed,
            })) ?? [],
          documentFilePath: tabManager.activeTextEditor?.document.uri.fsPath ?? '',
          visibleRanges: tabManager.activeTextEditor?.visibleRanges.map(range => ({ start: range.start, end: range.end })) ?? [],
          languageId: tabManager.activeTextEditor?.document.languageId ?? 'javascript',
        }
      : undefined,
    terminalLastCommand = terminalInfoProvider.terminalLastCommand
      ? {
          commandLine: terminalInfoProvider.terminalLastCommand.commandLine,
          cwd:
            typeof terminalInfoProvider.terminalLastCommand.cwd == 'object'
              ? terminalInfoProvider.terminalLastCommand.cwd.toString()
              : terminalInfoProvider.terminalLastCommand.cwd,
          exitCode: terminalInfoProvider.terminalLastCommand.exitCode,
          output: terminalInfoProvider.terminalLastCommand.output,
        }
      : undefined
  return {
    workspaceFoldersFilePaths,
    symbols,
    activeFileDiagnostics,
    activeTextEditor,
    debugConsoleOutput: disposable.consoleOutput,
    terminalBuffer: terminalInfoProvider.terminalBuffer,
    terminalLastCommand,
    terminalSelection: terminalInfoProvider.terminalSelection,
    terminalShellType: terminalInfoProvider.terminalShellType,
    repoContexts: gitRepoManager.repositories,
    notebookDocumentFilePaths: notebookDocumentsPaths,
  }
}
function createDiagnosticInfo(diagnostic) {
  return {
    filePath: diagnostic.location.uri.fsPath,
    start: diagnostic.location.range.start,
    end: diagnostic.location.range.end,
    message: diagnostic.message,
  }
}
var ChatEngine = class {
  constructor(serviceAccessor) {
    this.serviceAccessor = serviceAccessor
    this.logger = serviceAccessor.get(LoggerManager).getLogger('chat')
    this._enabled = false
    this._activated = false
    if (vscode.interactive?._version !== 1) {
      this.logger.warn('Not activating ConversationFeature- api version mismatch')
      return
    }
    this.registerCopilotTokenListener(serviceAccessor)
  }
  get enabled() {
    return this._enabled
  }
  set enabled(value) {
    if (value && !this.activated) {
      this.activated = true
    }
    vscode.commands.executeCommand('setContext', 'github.copilot.interactiveSession.disabled', !value)
    this._enabled = value
  }
  get activated() {
    return this._activated
  }
  set activated(value) {
    if (!this._activated && value) {
      let options = this.serviceAccessor.get(conversationOptions)
      this.registerProviders(options)
      this.registerCommands(options)
      this.registerRelatedInformationProviders()
      this.registerChatVariables()
    }
    this._activated = value
  }
  getLastInteractiveSession() {
    return this.interactiveSessionProvider?.getLastSession()
  }
  registerProviders(options) {
    try {
      let chatResponseProvider = vscode.chat.registerChatResponseProvider('copilot', new ChatResponseProvider(this.serviceAccessor), { name: 'gpt-3.5-turbo' })
      this.interactiveSessionProvider = new ChatSessionManager(this.serviceAccessor, options)
      let interactiveSessionProvider = vscode.interactive.registerInteractiveSessionProvider('copilot', this.interactiveSessionProvider)
      this.interactiveEditorSessionProvider = new CopilotInteractiveEditorSessionProvider(this.serviceAccessor, options.rejectionMessage)
      let interactiveEditorSessionProvider = vscode.interactive.registerInteractiveEditorSessionProvider(this.interactiveEditorSessionProvider, {
        supportReportIssue: this.serviceAccessor.get(ConfigManager).getConfig(settings.DebugReportFeedback),
      })
      registerCommands(this.serviceAccessor)
      this.serviceAccessor.get(extensionContext).subscriptions.push(chatResponseProvider, interactiveSessionProvider, interactiveEditorSessionProvider)
      if ('registerMappedEditsProvider' in vscode.chat) {
        vscode.chat.registerMappedEditsProvider('*', new EditProvider())
      }
      this.serviceAccessor
        .get(ChatAgentServiceIdentifier)
        .register(options)
        .catch(error => {
          this.logger.error('Registration of chat agents failed:', error.toString())
        })
    } catch (error) {
      this.logger.error('Registration of interactive providers failed:', error.toString())
    }
  }
  registerCommands(extensionAccessor) {
    let isBodyPresent = item => 'body' in item && (item.body instanceof vscode.MarkdownString || typeof item.body == 'string'),
    isRangePresent = item => 'range' in item && item.range instanceof vscode.Range
    this.accessor.get(extensionContext).subscriptions.push(
      vscode.commands.registerCommand('github.copilot.interactiveSession.feedback', async () =>
        vscode.env.openExternal(vscode.Uri.parse(generateFeedbackUrl()))
      ),
      vscode.commands.registerCommand('github.copilot.ghpr.applySuggestion', async (i, o) => {
        if (!isBodyPresent(i) || !isRangePresent(o)) return
        let s = i.body instanceof vscode.MarkdownString ? i.body.value : i.body
        await vscode.commands.executeCommand('vscode.editorChat.start', { initialRange: o.range, message: s, autoSend: !0 })
      }),
      vscode.commands.registerCommand('github.copilot.debug.workbenchState', async () => {
        let i = await vscode.window.showInputBox({
            prompt: 'Enter a comma-separated list of symbol queries. Can be left blank if not using WorkspaceSymbols',
          }),
          o = await vscode.window.showInputBox({
            prompt: 'Enter a file name - .state.json will be appended as the extension',
            value: 'workspaceState',
          })
        if (!o) return
        let s = await gatherWorkspaceInfo(this.accessor, i?.split(',') ?? [])
        if (!s) return
        let a = vscode.workspace.workspaceFolders?.[0].uri
        if (!a) return
        let l = vscode.Uri.joinPath(a, `${o}.state.json`),
          c = JSON.stringify(s, null, 2)
        ;(c = c.replace(new RegExp(`${a.fsPath}/`, 'g'), './')), vscode.workspace.fs.writeFile(l, Buffer.from(c))
      }),
      vscode.commands.registerCommand(
        'github.copilot.terminal.explainTerminalSelection',
        async () =>
          await vscode.commands.executeCommand('workbench.action.quickchat.toggle', { query: `@${terminal} #terminalSelection` })
      ),
      vscode.commands.registerCommand('github.copilot.terminal.explainTerminalSelectionContextMenu', () =>
        vscode.commands.executeCommand('github.copilot.terminal.explainTerminalSelection')
      ),
      vscode.commands.registerCommand(
        'github.copilot.terminal.explainTerminalLastCommand',
        async () =>
          await vscode.commands.executeCommand('workbench.action.quickchat.toggle', {
            query: `@${terminal} #terminalLastCommand`,
          })
      ),
      vscode.commands.registerCommand('github.copilot.terminal.suggestCommand', async () => {
        await vscode.commands.executeCommand('workbench.action.quickchat.toggle', { query: `@${terminal} `, isPartialQuery: !0 })
      }),
      vscode.commands.registerCommand('github.copilot.terminal.generateCommitMessage', async () => {
        let i = this.accessor.get(GitContextModelIdentifier),
          o = vscode.workspace.workspaceFolders
        if (!o?.length) return
        let s = o.length === 1 ? o[0].uri : await vscode.window.showWorkspaceFolderPick().then(f => f?.uri)
        if (!s) return
        let a = await i.getRepositoryDiff(s)
        if (!a?.length) {
          vscode.window.showInformationMessage('No changes to commit.')
          return
        }
        let l = new CancellationSource(),
          u = await new GitCommitMessageGenerator(this.accessor).generateGitCommitMessage(a, 3, l.token)
        if (!u || l.token.isCancellationRequested) return
        let d = `git commit -m "${u.replace(/"/g, '\\"').replace(/\\/g, '\\\\').replace(/\$/g, '\\$')}"`
        vscode.window.activeTerminal?.sendText(d, !1)
      }),
      vscode.commands.registerCommand('github.copilot.git.generateCommitMessage', async (i, o, s) => {
        await new GitCommitGenerator(this.accessor).run(i, s)
      }),
      vscode.commands.registerCommand(openRelativePathCommand, async i => {
        let o = vscode.workspace.workspaceFolders?.[0].uri
        if (!o) return
        let s = vscode.Uri.joinPath(o, i)
        if ((this.accessor.get(IMSTelemetryService).sendTelemetryEvent('panel.action.filelink'), await a(s)))
          await vscode.commands.executeCommand('revealInExplorer', s)
        else return vscode.commands.executeCommand('vscode.open', s)
        async function a(l) {
          if (s.path.endsWith('/')) return !0
          try {
            return (await vscode.workspace.fs.stat(l)).type === vscode.FileType.Directory
          } catch {
            return !1
          }
        }
      }),
      vscode.commands.registerCommand(openSymbolInFileCommand, async (i, o, s) => {
        if (((s ??= vscode.workspace.workspaceFolders?.[0].uri), !s)) return
        let a = vscode.Uri.joinPath(s, i),
          l = await vscode.commands.executeCommand('vscode.executeDocumentSymbolProvider', a)
        if (l) {
          let c = findSymbol(l, o)
          if ((this.accessor.get(IMSTelemetryService).sendTelemetryEvent('panel.action.symbollink', {}, { hadMatch: c ? 1 : 0 }), c)) {
            let u = c instanceof vscode.SymbolInformation ? c.location.range : c.selectionRange
            return vscode.commands.executeCommand('vscode.open', a, { selection: new vscode.Range(u.start, u.start) })
          }
        }
        return vscode.commands.executeCommand('vscode.open', a)
      }),
      addLinkifier((i, o, s) => {
        let a = /(?<!\[)`([^`\s]+)`(?!\])/g
        return new (class {
          constructor() {
            this.fileSymbols = new Lazy(async () => {
              let c = new ResourceSet()
              for (let p of i) c.add(Uri.isUri(p.anchor) ? p.anchor : p.anchor.uri)
              let u = new ResourceMap()
              return (
                await Promise.all(
                  Array.from(c, async p => {
                    let d = await timeoutPromise(
                      Promise.resolve(vscode.commands.executeCommand('vscode.executeDocumentSymbolProvider', p)),
                      5e3
                    )
                    d && u.set(p, d)
                  })
                ),
                u
              )
            })
            this.resolvedSymbols = new Map()
          }
          async linkify(c, u) {
            if (!o.length) return c
            let p = new Set()
            for (let [d, f] of c.matchAll(a)) this.resolvedSymbols.has(f) || p.add(f)
            if (p.size) {
              let d = await this.fileSymbols.value
              if (u?.isCancellationRequested) return c
              for (let f of p) {
                let m
                for (let [h, g] of d) {
                  let v = g && findSymbol(g, f)
                  if (v) {
                    m = v instanceof vscode.SymbolInformation ? v.location : new vscode.Location(h, v.range)
                    break
                  }
                }
                this.resolvedSymbols.set(f, m)
              }
            }
            return c.replace(a, (d, f) => {
              let m = this.resolvedSymbols.get(f)
              if (m) {
                let h = getRelativePath(o[0], m.uri)
                if (h) return createSymbolInFileLink(f, h)
              }
              return d
            })
          }
        })()
      }),
      registerNewNotebookCommand(this.accessor, extensionAccessor),
      registerCopilotCommands(this.accessor, extensionAccessor),
      createGitHubPRProvider(this.accessor),
      registerExecuteSearchCommand()
    )
  }
  registerRelatedInformationProviders() {
    this.accessor
      .get(extensionContext)
      .subscriptions.push(
        vscode.ai.registerRelatedInformationProvider(vscode.RelatedInformationType.CommandInformation, this.accessor.get(CommandRelatedInfoProvider)),
        vscode.ai.registerRelatedInformationProvider(vscode.RelatedInformationType.SettingInformation, this.accessor.get(SettingsRelatedInfoProvider))
      )
  }
  registerChatVariables() {
    this.accessor
      .get(VariableManager)
      .getVariables()
      .forEach(e => {
        this.accessor.get(extensionContext).subscriptions.push(
          vscode.chat.registerVariable(e.name, e.description ?? '', {
            resolve: async (r, n, i) => {
              let o = { endpoint: await getChatEndpointInfo(this.accessor, 3), message: n.message },
                s = await e.resolve(this.accessor, o, i)
              return s
                ? [
                    {
                      level: vscode.ChatVariableLevel ? vscode.ChatVariableLevel.Full : 'full',
                      value: s.userMessages.join(`

`),
                      description: '',
                    },
                  ]
                : []
            },
          })
        )
      })
  }
  registerCopilotTokenListener(e) {
    e.get(EventEmitter).on('onCopilotToken', (r, n) => {
      this.logger.info(`copilot token chat_enabled: ${n.chat_enabled}`), (this.enabled = n.chat_enabled ?? !1)
    })
  }
}
function registerNewNotebookCommand(serviceAccessor, chatEndpointProvider) {
  let configManager = serviceAccessor.get(ConfigManager)
  return vscode.commands.registerCommand('github.copilot.newNotebook', async notebookInfo => {
    let isImproving = configManager.getConfig(settings.NotebookIterativeImproving)
    await vscode.window.withProgress({ location: vscode.ProgressLocation.Notification }, async progress => {
      let notebookData = new vscode.NotebookData([])
      notebookData.metadata = { custom: { cells: [], metadata: { orig_nbformat: 4 }, nbformat: 4, nbformat_minor: 2 } }
      let notebookDocument = await vscode.workspace.openNotebookDocument('jupyter-notebook', notebookData),
        notebookEditor = await vscode.window.showNotebookDocument(notebookDocument)
      progress.report({ message: vscode.l10n.t('Generating notebook...') })
      let description = notebookInfo.description,
        sections = notebookInfo.sections,
        chatEndpointInfo = await getChatEndpointInfo(serviceAccessor, 2)
      for (let section of sections) {
        let existingCode = notebookEditor.notebook
            .getCells()
            .filter(cell => cell.kind === vscode.NotebookCellKind.Code)
            .map(cell => cell.document.getText()).join(`
`),
          cancellationTokenSource = new vscode.CancellationTokenSource()
        progress.report({ message: vscode.l10n.t('Generating section "{0}"...', section.title) })
        let generatedCode = await generatePythonCodeForSection(serviceAccessor, chatEndpointInfo, chatEndpointProvider, description, section, existingCode, cancellationTokenSource.token)
        if (!generatedCode) return
        if (isImproving) {
          progress.report({ message: vscode.l10n.t('Improving code for section "{0}"...', section.title) })
          let improvedCode = await improvePythonCode(serviceAccessor, chatEndpointInfo, chatEndpointProvider, description, section, existingCode, generatedCode, cancellationTokenSource.token)
          if (!improvedCode) return
          generatedCode = improvedCode
        }
        let markdownCell = new vscode.NotebookCellData(
            vscode.NotebookCellKind.Markup,
            `# ${section.title}
${section.content}`,
            'markdown'
          ),
          codeCell = new vscode.NotebookCellData(vscode.NotebookCellKind.Code, generatedCode, 'python'),
          insertCellsEdit = vscode.NotebookEdit.insertCells(notebookDocument.cellCount, [markdownCell, codeCell]),
          workspaceEdit = new vscode.WorkspaceEdit()
        workspaceEdit.set(notebookDocument.uri, [insertCellsEdit]),
          await vscode.workspace.applyEdit(workspaceEdit),
          notebookEditor.revealRange(new vscode.NotebookRange(notebookDocument.cellCount - 1, notebookDocument.cellCount), vscode.NotebookEditorRevealType.Default),
          (notebookEditor.selection = new vscode.NotebookRange(notebookDocument.cellCount - 1, notebookDocument.cellCount))
      }
      progress.report({ increment: 100 })
    })
  })
}

function registerExecuteSearchCommand() {
  return vscode.commands.registerCommand('github.copilot.executeSearch', async searchParams => {
    let isFileFilterPresent = searchParams.filesToExclude.length > 0 || searchParams.filesToInclude.length > 0
    vscode.commands
      .executeCommand('workbench.view.search.focus')
      .then(() => vscode.commands.executeCommand('workbench.action.search.toggleQueryDetails', { show: isFileFilterPresent })),
      vscode.commands.executeCommand('workbench.action.findInFiles', searchParams)
  })
}

function createGitHubPRProvider(serviceAccessor) {
  return new GitHubPRProvider(serviceAccessor)
}

function findBestSymbolMatch(symbols, names) {
  if (!names.length) return
  let bestMatch
  for (let symbol of symbols)
    if (symbol.children) {
      let match = symbol.name === names[0] ? { symbol: symbol, matchCount: 1 } : undefined
      if (match) {
        let childMatch = findBestSymbolMatch(symbol.children, names.slice(1))
        childMatch && (match = { symbol: childMatch.symbol, matchCount: match.matchCount + childMatch.matchCount })
      }
      let childMatch = findBestSymbolMatch(symbol.children, names),
        finalMatch
      match && childMatch ? (finalMatch = match.matchCount >= childMatch.matchCount ? match : childMatch) : (finalMatch = match ?? childMatch),
        finalMatch && (!bestMatch || finalMatch.matchCount > bestMatch?.matchCount) && (bestMatch = finalMatch)
    } else symbol.name === names[0] && (bestMatch ??= { symbol: symbol, matchCount: 1 })
  return bestMatch
}

function findSymbol(symbols, name) {
  function extractNames(str) {
    return Array.from(str.matchAll(/[\w$][\w\d$]*/g), match => match[0])
  }
  return (findBestSymbolMatch(symbols, [name]) ?? findBestSymbolMatch(symbols, extractNames(name)))?.symbol
}

var vscode = handleDefaultExports(require('vscode'))
var separator = '---------------------------------',
class FeedbackReporter extends Reporter {
  constructor(accessor) {
    super();
    this.accessor = accessor;
  }

  async canReport() {
    const configManager = this.accessor.get(ConfigManager);
    const baseTokenHandler = this.accessor.get(BaseTokenHandler);
    const copilotToken = await baseTokenHandler.getCopilotToken(this.accessor);
    return configManager.getConfig(settings.DebugReportFeedback) && copilotToken?.isInternal;
  }

  async reportInline(chat, intent, parsedResponse) {
    if (!(await this.canReport())) return;
    const latestTurn = chat.getLatestTurn();
    if (!latestTurn) return;
    const intentBlock = intent ? this.embedCodeblock('INTENT', JSON.stringify(intent, null, '\t')) : '';
    const contextBlock = this.embedCodeblock(
      'CONTEXT',
      JSON.stringify(
        {
          document: intent.document.uri.toString(),
          fileIndentInfo: intent.fileIndentInfo,
          language: intent.language,
          wholeRange: intent.wholeRange,
          selection: intent.selection,
        },
        null,
        '\t'
      )
    );
    let promptMessagesBlock = '';
    const chatMessages = latestTurn.chatMessages;
    if (chatMessages && chatMessages.length > 0) {
      const messages = chatMessages.map(msg => this.embedCodeblock(msg.role.toUpperCase(), msg.content)).join('\n');
      promptMessagesBlock = `\t${separator}\n${this.headerSeparator()}PROMPT MESSAGES:\n${messages}`;
    } else {
      promptMessagesBlock = this.embedCodeblock(latestTurn.request.type.toUpperCase(), latestTurn.request.message);
    }
    const assistantBlock = this.embedCodeblock('ASSISTANT', latestTurn.response?.message || '');
    const parsedResponseBlock = this.embedCodeblock('Parsed response', JSON.stringify(parsedResponse, null, '\t'));
    const details = `${intentBlock}\n${contextBlock}\n${promptMessagesBlock}\n${assistantBlock}\n${parsedResponseBlock}\n`;
    const issueBody = `
* VS Code version: ${vscode.version}
* Language: ${vscode.env.language}

<details><summary>Details</summary>
<p>

${details}

</p>
</details>`;
    await this.reportIssue('Feedback for inline chat', issueBody);
  }

  embedCodeblock(header, content) {
    const formattedContent = this.bodySeparator() + content.split('\n').join(`\n${this.bodySeparator()}`);
    return `\t${separator}\n${this.headerSeparator()}${header}:\n${formattedContent}`;
  }

  headerSeparator() {
    return '\t';
  }

  bodySeparator() {
    return '\t\t';
  }

  async reportIssue(title, body) {
    const encodedTitle = encodeURIComponent(title);
    await vscode.env.clipboard.writeText(body);
    const encodedPrompt = encodeURIComponent('We have written the needed data into your clipboard because it was too large to send. Please paste.');
    const issueUrl = `https://github.com/microsoft/vscode-copilot/issues/new?title=${encodedTitle}&body=${encodedPrompt}`;
    vscode.env.clipboard.writeText(body);
    vscode.env.openExternal(vscode.Uri.parse(issueUrl));
  }
}
var vscode = handleDefaultExports(require('vscode')),
var GitExtensionHandler = class {
  constructor() {
    this._disposables = []
    this._disposables.push(...this.initializeGitExtensionApi())
  }
  initializeGitExtensionApi() {
    let disposables = [],
      gitExtension = vscode.extensions.getExtension('vscode.git'),
      activateExtension = async () => {
        let activatedExtension = await gitExtension.activate(),
          setGitApi = isEnabled => {
            this._gitExtensionApi = isEnabled ? activatedExtension.getAPI(1) : undefined
          }
        disposables.push(activatedExtension.onDidChangeEnablement(setGitApi)), setGitApi(activatedExtension.enabled)
      }
    if (gitExtension) activateExtension()
    else {
      let onExtensionChange = vscode.extensions.onDidChange(() => {
        if (!gitExtension && vscode.extensions.getExtension('vscode.git')) {
          gitExtension = vscode.extensions.getExtension('vscode.git');
          activateExtension();
          onExtensionChange.dispose();
        }
      })
    }
    return disposables
  }
  async getRepositoryDiff(repositoryPath) {
    let repository = await this._getRepository(repositoryPath)
    if (!repository) return
    let diffs = []
    if (repository.state.indexChanges.length !== 0)
      for (let filePath of repository.state.indexChanges.map(change => change.uri.fsPath)) diffs.push(await repository.diffIndexWithHEAD(filePath))
    else for (let filePath of repository.state.workingTreeChanges.map(change => change.uri.fsPath)) diffs.push(await repository.diffWithHEAD(filePath))
    return diffs
  }
  async _getRepository(repositoryPath) {
    return (await this._gitExtensionApi?.openRepository(repositoryPath)) ?? undefined
  }
  dispose() {
    this._disposables.forEach(disposable => disposable.dispose())
  }
}
var vscode = handleDefaultExports(require('vscode'))
var Environment = class extends BaseVscodeEnvironment {
  addEditorSpecificFilters() {
    return { 'X-VSCode-Build': vscode.env.appName, 'X-VSCode-Language': vscode.env.language }
  }
}
var requestLight = handleDefaultExports(requestLight())
var VsCodeExtensionDevelopmentIntent = class extends Intent {
  constructor() {
    super({
      location: 2,
      id: 'api',
      description: requestLight.t('Ask about VS Code extension development'),
      systemPromptOptions: {
        roleplay:
          'You are an expert in VS Code extension development. You know how to use the VS Code API to extend the editor. Your task is to help the Developer with their VS Code extension development.',
      },
      modelSampleQuestion: 'How do I add text to the status bar?',
      commandInfo: { sampleRequest: requestLight.t('How do I add text to the status bar?') },
      rules: `
Assume the question is about VS Code extension development.
Politely decline to answer if the question is not about VS Code extension development.
Please do not guess a response and instead just respond with a polite apology if you are unsure.
If you believe the API related context given to you is incorrect or not relevant you may ignore it.
The user cannot see the API context you are given, so you must not mention it. If you want to refer to it, you must include it in your reply.
Do not talk about initial setup of creating an extension unless the user asks about it.
Only provide information to related VS Code extension development.`.trim(),
      contextResolvers: [extensionAPIContextResolver, contextResolverRegistry],
    })
  }
}
var requestLight = handleDefaultExports(requestLight())
function calculateUpdatedRange(originalRange, edits) {
  let updatedRange = originalRange
  for (let edit of edits) {
    let start = edit.range.start,
      end = edit.range.end,
      originalStart = updatedRange.start,
      originalEnd = updatedRange.end,
      newLinesCount = edit.newText.split(`
`).length,
      lineChange = newLinesCount - (end.line - start.line) - 1,
      newStartLine = originalStart.line,
      newEndLine = originalStart.line
    end.isBefore(originalStart)
      ? ((newStartLine = originalStart.line + lineChange), (newEndLine = originalEnd.line + lineChange))
      : start.isBefore(originalStart) && end.isAfterOrEqual(originalStart) && end.isBeforeOrEqual(originalEnd)
      ? ((newStartLine = start.line), (newEndLine = originalEnd.line + lineChange))
      : start.isAfterOrEqual(originalStart) && start.isBeforeOrEqual(originalEnd) && end.isAfter(originalEnd)
      ? ((newStartLine = originalStart.line), (newEndLine = end.line + lineChange))
      : start.isAfter(originalEnd)
      ? ((newStartLine = originalStart.line), (newEndLine = originalEnd.line))
      : updatedRange.contains(edit.range)
      ? ((newStartLine = originalStart.line), (newEndLine = originalEnd.line + lineChange))
      : edit.range.contains(updatedRange) && ((newStartLine = start.line), (newEndLine = start.line + newLinesCount - 1)),
      (updatedRange = new VscodeRange(newStartLine, 0, newEndLine, 0))
  }
  return updatedRange
}
var modelVersions = { 3: 'gpt-3.5-turbo', 4: 'gpt-4', cl: 'code-llama' },
  CodeFixIntent = class {
    constructor() {
      this.id = 'fix'
      this.locations = [1, 2]
      this.description = requestLight.t('Propose a fix for the problems in the selected code')
      this.intentDetectionInput = {
        sampleQuestion: 'There is a problem in this code. Rewrite the code to show it with the bug fixed.',
      }
      this.commandInfo = {
        sampleRequest: requestLight.t('There is a problem in this code. Rewrite the code to show it with the bug fixed.'),
      }
    }
    static {
      this.ID = 'fix'
    }
    async invoke(context, request) {
      let documentContext = request.documentContext
      if (!documentContext) throw new Error('Open a file to fix an issue')
      let location = request.location,
        intentArgument = request.intentArgument,
        chatEndpointInfo = await getChatEndpointInfo(context, location, this.id, intentArgument ? modelVersions[intentArgument] : void 0)
      return isNotebookCell(documentContext.document.uri) && documentContext.document.languageId === 'python'
        ? new CodeFixWithRulesHandler(this, chatEndpointInfo, location, context, documentContext)
        : new CodeFixHandler(this, chatEndpointInfo, location, context, documentContext)
    }
  },
var CodeFixHandler = class {
  constructor(intent, endpoint, location, accessor, documentContext) {
    this.intent = intent
    this.endpoint = endpoint
    this.location = location
    this.accessor = accessor
    this.documentContext = documentContext
    let chatBuilderOptions = {
      queryPrefix: this.getQueryPrefix(),
      rules: this.getRules(),
      contextResolvers: this.getContextResolvers(),
    }
    this.promptCrafter = new ChatBuilder(accessor, chatBuilderOptions, location, documentContext),
    this.createReplyInterpreter = reply =>
        new (class extends ReplyInterpreter {
          constructor(interpreter) {
            super(interpreter, {
              report: report => {
                reply.report({ ...report, editsShouldBeInstant: true })
              },
            })
          }
          _reportProgress() {}
        })(this.interpretCodeReply.bind(this))
  }
  getContextResolvers() {
    return this.location === 1 ? [fixSelectionResolver, diagnosticResolver] : [currentSelectionContextResolver, diagnosticResolver, contextResolverRegistry]
  }
  getQueryPrefix() {
    return this.location === 1
      ? `Describe in a single sentence how you would solve the problem. After that sentence, add an empty line. Then add a code block with the fix.
`
      : 'Please fix my code.'
  }
  getRules() {
    return this.location === 1
      ? `First think step-by-step how you would fix the issue.
You are expected to either edit the selected code or propose a bash command to install missing packages.
If you propose a code change, use a single code block that starts with \`\`\` and ${FilePathComment.forLanguage(
          this.documentContext.language
        )}.
If you propose to run a bash command, use a code block that starts with \`\`\`bash.
When adding missing imports, always insert them inside of the selected code at the top, do not replace the rest of the selected code.
Describe in a single sentence how you would solve the problem. After that sentence, add an empty line. Then add a code block with the fix.`
      : `You specialize in being a highly skilled code generator. Your task is to help the Developer fix an issue.
If context is provided, try to match the style of the provided code as best as possible.
Generated code is readable and properly indented.
Markdown blocks are used to denote code.
Preserve user's code comment blocks, do not exclude them when refactoring code.
Pay especially close attention to the selection or exception context.
Given a description of what to do you can refactor, fix or enhance the existing code.`
  }
  async interpretCodeReply(reply) {
    let selectionContextMetadata = this.promptCrafter.selectionContextMetadata
    if (!selectionContextMetadata) throw new Error('code reply NEEDS a selection context')
    let codeBlock = extractCodeBlock(this.promptCrafter.selectionContextMetadata.contextInfo, reply, this.documentContext.language)
    if (!codeBlock || codeBlock.language === 'bash' || codeBlock.language === 'ps1') return { type: 'conversational', content: reply }
    let contentBeforeCode = codeBlock.contentBeforeCode.match(/^.+/)?.[0],
      edits = this.generateEdits(selectionContextMetadata, codeBlock.code),
      documentVersion = this.documentContext.document.version,
      generateFollowUps = cancellation => this.generateFollowUps(edits, selectionContextMetadata.expandedRange, documentVersion, cancellation)
    return createInlineEdit(edits, selectionContextMetadata.expandedRange, contentBeforeCode, generateFollowUps)
  }
  generateEdits(selectionContextMetadata, code) {
    return processInputText(
      this.accessor,
      selectionContextMetadata.contextInfo,
      code,
      2,
      this.documentContext.fileIndentInfo,
      DocumentContext.fromDocumentContext(this.documentContext)
    )
  }
  async generateFollowUps(edits, expandedRange, documentVersion, cancellation) {
    let diagnostics = await this.accessor.get(DiagnosticWaiter).waitForNewDiagnostics(this.documentContext.document.uri, cancellation)
    if (!cancellation.isCancellationRequested && diagnostics.length && this.documentContext.document.version !== documentVersion) {
      let updatedRange = calculateUpdatedRange(expandedRange, edits),
        errorDiagnostics = diagnostics.filter(diagnostic => isErrorDiagnostic(diagnostic) && diagnostic.range.intersection(updatedRange))
      if (errorDiagnostics.length)
        return errorDiagnostics.length === 1
          ? [
              {
                title: requestLight.t('An error remains after applying the change, click here to iterate.'),
                message: `/fix ${errorDiagnostics[0].message}`,
              },
            ]
          : [
              {
                title: requestLight.t('{0} errors remain after applying the change, click here to iterate.', errorDiagnostics.length),
                message: '/fix Fix the remaining errors',
              },
            ]
    }
  }
},
var CodeFixWithRulesHandler = class extends CodeFixHandler {
  getRules() {
    return this.location === 1
      ? generateInstructions(this.documentContext) +
          '\nIf you suggest to run a terminal command, use a code block that starts with ```bash.\nWhen fixing "ModuleNotFoundError" or "Import could not be resolved" errors, always use magic command "%pip install" to add the missing packages. The imports MUST be inserted at the top of the code block and it should not replace existing code.\nYou should not import the same module twice.'
      : super.getRules()
  }
  generateEdits(contextMetadata, code) {
    let codeLines = code.split(`
`),
      pipCommands = [],
      otherLines = []
    for (let line of codeLines) line.match(/^[%\!]pip/) ? pipCommands.push(line) : otherLines.push(line)
    if (!pipCommands.length) return super.generateEdits(contextMetadata, code)
    let edits = [],
      pipCommandsBlock =
      adjustIndentation(pipCommands, { whichLine: 'topMost', lines: contextMetadata.contextInfo.range.lines }, this.documentContext.fileIndentInfo).join(`
`) +
        `
`
    edits.push(new VscodeTextEdit(new VscodeRange(contextMetadata.expandedRange.start, contextMetadata.expandedRange.start), pipCommandsBlock)),
    otherLines.length &&
        edits.push(
          ...super.generateEdits(
            contextMetadata,
            otherLines.join(`
`)
          )
        )
    return edits
  }
}
var requestLight = handleDefaultExports(requestLight())
var questionExample = `
### Question:
Search for 'foo' in all files under my 'src' directory.

### Answer:
Populate the query field with 'foo' and specify the files to include as 'src/'.

[ARGS START]
\`\`\`json
{
    "query": "foo",
    "filesToInclude": "src" ,
}
\`\`\`
[ARGS END]

### Question:
Find all CamelCase words in all files under the 'src/extensions' directory.

### Answer:
Perform a regex search for camelCase variables by checking for any word that has a lowercase letter followed by an uppercase letter, followed by any number of lowercase letters. You can use \`\\b[a-z]+[A-Z][a-z]+\\b\` to acheive this.
This must be case-sensitive since the capitalization of the letters in our regex matters.

[ARGS START]
\`\`\`json
{
    "query": "\\\\b[a-z]+[A-Z][a-z]+\\\\b",
    "filesToInclude": "src/extensions" ,
    "isRegex": true,
    "isCaseSensitive": true,
}
\`\`\`
[ARGS END]

### Question:
Find all hex color codes in css files

### Answer:
Perform a search for 6-digit or 3-digit hex color codes using the regex \`#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\\b\`.

[ARGS START]
\`\`\`json
{
    "query": "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\\\\b",
    "filesToInclude": "*.css" ,
    "isRegex": true,
}
\`\`\`
[ARGS END]

### Question:
Find all HTTPS links in markdown.

### Answer:
Search all URLs that have the HTTPS protocol in a markdown file. Make sure to include all valid URL characters in their respective places. This regex should achieve this: \`https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#()?&//=]*)\`.

[ARGS START]
\`\`\`json
{
    "query": "https?:\\\\/\\\\/(www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{2,256}\\\\.[a-z]{2,6}\\\\b([-a-zA-Z0-9@:%_\\\\+.~#()?&//=]*)",
    "filesToInclude": "*.md" ,
    "isRegex": true,
}
\`\`\`
[ARGS END]

### Question:
Replace all YYYY-MM-DD dates with MM/DD/YYYY dates. Don't do this in typescript files.

### Answer:
You will need to use the regex \`\\b(\\d{4})-(\\d{2})-(\\d{2})\\b\` to match the YYYY-MM-DD date format. Then, you will need to use the replace string \`$2/$3/$1\` to replace the date with the MM/DD/YYYY format.

[ARGS START]
\`\`\`json
{
    "query": "\\\\b(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\b",
    "replace: "$2/$3/$1",
    "filesToExclude": "*.ts",
    "isRegex": true,
}
\`\`\`
[ARGS END]

### Question:
Replace all camel case variable names with snake case variable names.

### Answer:
To replace all camel case variables with snake case, we will need to:
1. Find all sequences of lowercase letters succeeded by uppercase letters. Use \`([a-z]+)([A-Z])\` to capture these sequences.
2. Separate them with an underscore character. \`$1_$2\` does this.
3. Convert both characters to lowercase. Adjust the previous replace text to be \`\\l$1_\\l$2\`.

[ARGS START]
\`\`\`json
{
    "query": "([a-z]+)([A-Z])",
    "replace: "\\\\l$1_\\\\l$2",
    "isRegex": true,
    "isCaseSensitive": true,
}
\`\`\`
[ARGS END]

### Question:
alphanumeric

### Answer:
To find all alphanumeric characters, you can use the regex \`[a-zA-Z0-9]\`.

[ARGS START]
\`\`\`json
{
    "query": "[a-zA-Z0-9]",
    "isRegex": true,
    "isCaseSensitive": true,
}
\`\`\`
[ARGS END]

### Question:
link

### Answer:
To find all web links, use the regex \`https?:\\/\\/\\S+\`.

[ARGS START]
\`\`\`json
{
    "query": "https?:\\\\/\\\\/\\\\S+",
    "isRegex": true,
}
\`\`\`
[ARGS END]

### Question:
Search for actionbar files outside of my "extensions" directoy

### Answer:
To do this, use the query \`actionbar\` in all files except the ones in \`extensions\`.

[ARGS START]
\`\`\`json
{
    "query": "actionbar",
    "filesToExclude": "extensions",
}
\`\`\`
[ARGS END]

### Question:
typescript for loop

### Answer:
To look for "for" loops in most languages, use the query \`for\\s*\\(\`.

[ARGS START]
\`\`\`json
{
    "query": "for\\s*\\(",
	"isRegex: true,
	"filesToInclude: "*.ts"
}
\`\`\`
[ARGS END]

`
function generateSearchCommand(searchParams) {
  if (!searchParams) return []
  let commands = [],
    commandParams = {
      query: searchParams.query ?? '',
      replace: searchParams.replace ?? '',
      filesToInclude: searchParams.filesToInclude ?? '',
      filesToExclude: searchParams.filesToExclude ?? '',
      isRegex: searchParams.isRegex ?? false,
      isCaseSensitive: searchParams.isRegex ?? false,
    }
  commands.push({ commandId: 'github.copilot.executeSearch', args: [commandParams], title: 'Search' })
  return commands
}

function parseJsonFromMarkdown(markdownText) {
  let jsonRegex = /```(?:json)\s*([\s\S]+?\s*)```/g,
    jsonMatches = Array.from(markdownText.matchAll(jsonRegex), match => match[1]),
    firstMatch = jsonMatches && jsonMatches.length > 0 ? jsonMatches[0] : undefined,
    parsedJson
  if (firstMatch) {
    let json
    try {
      json = JSON.parse(firstMatch)
    } catch {}
    json && (parsedJson = json)
  }
  return parsedJson
}

function generateMarkdownTable(data) {
  if (!data) return []
  let table = [
    `| Parameter  | Value |
`,
    `| ------ | ----- |
`,
  ]
  for (let [key, value] of Object.entries(data)) {
    if (value === '') continue
    let formattedValue = value
    if (typeof value == 'string' || value instanceof String) {
      formattedValue = value.replace(/\|/g, '\\|')
    }
    table.push(`| ${key} | \`${formattedValue}\` |
`)
  }
  table.push(`
`)
  return table
}

function registerSearchIntent(isEnabledByDefault) {
  let searchIntent = new Intent({
    location: 2,
    id: 'search',
    description: requestLight.t('Generate query parameters for workspace search'),
    modelSampleQuestion: "Search for 'foo' in all files under my 'src' directory",
    systemPromptOptions: {
      examples: questionExample,
      roleplay:
        'You are a VS Code search expert who helps to write search queries for text in a workspace. Users want to search across a whole workspace. Your response will contain parameters to use in the search that targets what the user wants.',
    },
    commandInfo: {
      allowsEmptyArgs: false,
      defaultEnablement: isEnabledByDefault,
      sampleRequest: requestLight.t("Search for 'foo' in all files under my 'src' directory"),
    },
    rules: `
The user's question is ALWAYS related to search or replace. When the user's question does not seem to be related to searching or replacing, you MUST assume that they're searching for or replacing what they are describing.
For example, if the user says "emojis", try appending "I'm looking for _____" to the beginning (e.g. I'm looking for emojis) to make more sense of it.

For all valid questions, you MUST respond with a JSON object with search parameters to use.
- Your answer MUST wrap the JSON object in "[ARGS START]" and "[ARGS END]". "[ARGS START]" must be on a new line.
- Your answer MUST have an explanation in full, human-readable sentences. This goes before the "[ARGS START]" line.

If you put a regex in the "query" parameter, make sure to set "isRegex" to true.
If you put a regex in the "query" parameter, do not start and/or end with forward slashes to denote a regex literal.
You MUST NOT give an answer with an empty-string query parameter.

The "replace" string will be used to replace the query-matched search results.

If you want to target certain files, set "filesToInclude" to a glob pattern. DO NOT assume the "filesToInclude" and "filesToExclude" without being very sure that the user wants to target these files!

If the query is case sensitive, set "isCaseSensitive" to true.

By default, all string fields are the empty string, and all boolean fields are false. Only list the fields you want to change.

I want the JSON object of search parameters to be in this format:
[ARGS START]
\`\`\`json
{
    "query": ...,
    "replace": ...,
    "filesToInclude": ...,
    "filesToExclude": ...,
    "isRegex": ...,
    "isCaseSensitive": ...,
}
\`\`\`
[ARGS END]
`.trim(),
    responseProcessor: (r, n, i) =>
      new TextProcessor([{ start: '[ARGS END]', stop: '[ARGS START]' }], i, o => generateMarkdownTable(parseJsonFromMarkdown(o.join('')))),
    followUps: async (r, n) => {
      let parsedJson = parseJsonFromMarkdown(n.response?.message ?? '')
      return generateSearchCommand(parsedJson)
    },
    contextResolvers: [contextResolverRegistry, currentSelectionContextResolver],
  })
  IntentManager.registerIntent(searchIntent)
}

ContributionManager.registerContribution(registerSearchIntent)
var requestLight = handleDefaultExports(requestLight()),
process = require('process')
var commandExamples = `
User: How do I revert a specific commit?
Assistant:
\`\`\`sh
git revert {commit_id}
\`\`\`

User: How do I print all files recursively within a directory?
Assistant:
\`\`\`sh
ls -lR
\`\`\`

User: How do I delete a directory?
Assistant:
\`\`\`pwsh
rmdir {dir_name}
\`\`\`

User: Print all files starting with "pre"
\`\`\`bash
find . -type f -name 'pre*'
\`\`\`
`.trim(),
stepByStepInstructions = `
Think step by step:

1. Read the provided relevant workspace information (file names, project files in the project root) to understand the user's workspace.

2. Generate a response that clearly and accurately answers the user's question. In your response, follow the following:
    - Prefer single line commands.
    - Omit an explanation unless the suggestion is complex, if an explanation is included then be concise.
    - Provide the command suggestions using the active terminal's shell type for the ${getPlatform()} operating system.
    - Only use a tool like python or perl when it is not possible with the shell.
    - When there is text that needs to be replaced in the suggestion, prefix the text with '{', suffix the text with '}' and use underscores instead of whitespace.
    - Say "I'm not quite sure how to do that." when you aren't confident in your explanation

3. At the end of the response, list all text that needs to be replaced with associated descriptions in the form of a markdown list
`.trim(),
terminalHandlers = {
    terminalSelection: {
      location: 2,
      id: 'explainTerminal',
      description:
        'Explain the terminal selection if it exists, otherwise explain what is happening in the terminal buffer',
      modelSampleQuestion: 'Can you explain what is happening in the terminal selection',
      systemPromptOptions: {
        includeCodeGenerationRules: !1,
        roleplay:
          'You are a programmer who specializes in using the command line. You are an expert at explaining code to anyone. Your task is to help the Developer understand what is happening in the terminal.',
      },
      rules: `
Provide well thought out examples
Utilize provided context in examples
Match the style of provided context when using examples
Say "I'm not quite sure how to explain that." when you aren't confident in your explanation`.trim(),
      contextResolvers: [terminalSelectionResolver, terminalBufferResolver],
      commandInfo: { executeImmediately: !0 },
    },
    terminalLastCommand: {
      location: 2,
      id: 'explainTerminalLastCommand',
      description: 'Explain the command that was last run in the terminal',
      modelSampleQuestion: 'Can you explain what is happening in the last terminal command',
      systemPromptOptions: {
        includeCodeGenerationRules: !1,
        roleplay:
          'You are a programmer who specializes in using the command line. You are an expert at explaining code to anyone. Your task is to help the Developer understand what is happening in the terminal.',
        examples:
          '\nBelow you will find a set of examples of how to suggest to fix the command. Please follow these examples as closely as possible.\n```sh\necho "hello world"\n```',
      },
      rules: `
Provide well thought out examples
Utilize provided context in examples
Match the style of provided context when using examples
Say "I'm not quite sure how to explain that." when you aren't confident in your explanation
If the command can be fixed, make a suggestion wrapped in a markdown codefenced block`.trim(),
      contextResolvers: [terminalLastCommandResolver],
    },
  },
var commandPromptConfiguration = {
    systemPromptOptions: {
      includeCodeGenerationRules: false,
      roleplay:
        'You are a programmer who specializes in using the command line. Your task is to help the Developer craft a command to run on the command line.',
      examples: commandExamples,
    },
    rules: stepByStepInstructions,
    contextResolvers: [contextResolverRegistry, terminalShellTypeResolver, terminalWorkspaceResolver],
  },
  PromptBuilder = class {
    constructor(accessor) {
      this.accessor = accessor
      this.defaultPromptCreator = new ChatBuilder(accessor, commandPromptConfiguration, 2, undefined)
    }
    async buildPrompt(promptParams) {
      let handler
      for (let key of Object.keys(promptParams)) if ((handler = terminalHandlers[key])) break
      return handler
        ? new ChatBuilder(this.accessor, handler, 2, undefined).buildPrompt(promptParams)
        : this.defaultPromptCreator.buildPrompt(promptParams)
    }
  }
  async function explainCommand(terminal, response) {
    let explanationPrompt = `@${terminal} Explain the suggested command`,
      multipleCommands = false,
      responseMessage = response.response?.message
    if (responseMessage) {
      let codeBlocks = extractCodeBlocks(responseMessage)
      if (codeBlocks.length === 0) return []
      codeBlocks.length === 1
        ? (explanationPrompt = `@${terminal} Explain this command:

  ${codeBlocks[0].raw}`)
        : ((multipleCommands = true),
          (explanationPrompt = `@${terminal} Explain these commands:${codeBlocks
            .map(
              block => `

  ${block.raw}`
            )
            .join('')}`))
    }
    return [{ message: explanationPrompt, title: multipleCommands ? 'Explain the suggested commands' : 'Explain the suggested command' }]
  }
function getPlatform() {
  switch (process.platform) {
    case 'win32':
      return 'Windows'
    case 'darwin':
      return 'macOS'
    default:
      return 'Linux'
  }
}
var TerminalIntent = class {
  constructor() {
    this.locations = [2]
    this.id = 'terminal'
    this.description = requestLight.t('Ask how to do something in the terminal')
    this.intentDetectionInput = {
      sampleQuestion: 'How do I view all files within a directory including sub-directories',
    }
    this.commandInfo = { sampleRequest: requestLight.t('How do I view all files within a directory including sub-directories') }
  }
  async invoke(context, request, session) {
    let location = request.location,
      endpointInfo = await getChatEndpointInfo(context, location, this.id)
    return { intent: this, location: 2, endpoint: endpointInfo, promptCrafter: new PromptBuilder(context), followUps: explainCommand }
  }
}

var requestLight = handleDefaultExports(requestLight())
var TestGeneratorIntent = class {
  constructor() {
    this.id = 'tests'
    this.locations = [2, 1]
    this.description = requestLight.t('Generate unit tests for the selected code')
    this.intentDetectionInput = { sampleQuestion: 'Write a set of detailed unit test functions for the code above.' }
    this.commandInfo = undefined
  }
  static {
    this.ID = 'tests'
  }
  async invoke(context, request) {
    let documentContext = request.documentContext
    if (!documentContext) throw new Error('Open a file to generate tests.')
    let location = request.location,
      endpointInfo = await getChatEndpointInfo(context, location, this.id)
    return isTestFile(documentContext.document) ? new TestFileHandler(this, endpointInfo, location, context, documentContext) : new NonTestFileHandler(this, endpointInfo, location, context, documentContext)
  }
},
var TestFileHandler = class {
  constructor(intent, endpoint, location, accessor, context) {
    this.intent = intent
    this.endpoint = endpoint
    this.location = location
    this.accessor = accessor
    this.context = context
    this.promptCrafter = new ChatBuilder(
      this.accessor,
      { queryPrefix: 'Please generate tests for my code.', contextResolvers: [contextResolverRegistration, _Y] },
      this.location,
      this.context
    )
    this.createReplyInterpreter = CodeReplyInterpreter.createFactory(this.accessor, this.promptCrafter, this.context)
    this.responseProcessor = (input, output, reporter) => {
      let textApplier = new AsyncIterableTextApplier()
      return (
        (async () => {
          let commentPrefixes = [
            BlockComment.begin(this.context.language),
            BlockComment.end(this.context.language),
            FilePathComment.forLanguage(this.context.language),
          ]
          for await (let comment of filterComments(textApplier.asyncIterable))
            (comment.kind === 1 && commentPrefixes.some(prefix => comment.value.startsWith(prefix))) || reporter.report({ content: comment.value })
        })().catch(error => console.error(error)),
        textApplier
      )
    }
  }
}
var NonTestFileHandler = class {
  constructor(intent, endpoint, location, accessor, documentContext) {
    this.intent = intent
    this.endpoint = endpoint
    this.location = location
    this.accessor = accessor
    this.documentContext = documentContext
    this.createReplyInterpreter = ReplyInterpreter.createFactory(async (message, reporter) => {
      let codeBlock = extractCodeBlock(this.promptCrafter.selectionContextMetadata.contextInfo, message, this.documentContext.language)
      if (!codeBlock) return { type: 'conversational', content: message }
      reporter.report({ content: codeBlock.contentBeforeCode })
      let code = codeBlock.code,
        document = this.documentContext.document
      if (this.existingTestFile) {
        let testDocument = await this.accessor.get(WorkspaceClass).openTextDocument(this.existingTestFile),
          workspaceEdit = new VscodeWorkspaceEdit()
        return (
          workspaceEdit.set(this.existingTestFile, [VscodeTextEdit.insert(new VscodePosition(testDocument.lineCount, 0), code)]),
          { type: 'workspaceEdit', workspaceEdit: workspaceEdit }
        )
      }
      let testFileName = generateTestFileName(document),
        testFileUri = VscodeUri.joinPath(document.uri, `../${testFileName}`).with({ scheme: resourceTypes.untitled }),
        workspaceEdit = new VscodeWorkspaceEdit()
      return (
        workspaceEdit.createFile(testFileUri, { ignoreIfExists: true }),
        workspaceEdit.replace(testFileUri, new VscodeRange(0, 0, 0, 0), code),
        { type: 'workspaceEdit', workspaceEdit: workspaceEdit }
      )
    })
    let self = this
    this.promptCrafter = new (class extends ChatBuilder {
      constructor() {
        super(accessor, { queryPrefix: 'Please generate tests for my code.', contextResolvers: [documentSelectionResolverInstance] }, location, documentContext)
      }
      async buildPrompt(conversation, endpoint, context, reporter, prompt, message) {
        let testFileResolver = new TestFileContextResolver(),
          candidateHandler = testFileResolver.onDidFindCandidate(candidate => {
            self.existingTestFile = candidate
          }),
          resolvedContext = await testFileResolver.resolveContext(accessor, { endpoint: endpoint, conversation: conversation, documentContext: documentContext, message: undefined }, message)
        if ((candidateHandler.dispose(), resolvedContext)) {
          resolvedContext.references?.forEach(reference => reporter.report({ reference: reference.anchor }))
          let userMessages = []
          for (let userMessage of resolvedContext.userMessages) userMessages.push(new Session({ message: userMessage, type: 'user' }))
          conversation = new Conversation([conversation.turns.slice(0, -1), userMessages, conversation.turns.slice(-1)].flat())
        }
        return super.buildPrompt(conversation, endpoint, context, reporter, prompt, message)
      }
    })()
  }
}
IntentManager.registerIntent(new CodeGenerator())
IntentManager.registerIntent(new DocumentationCommand())
IntentManager.registerIntent(new CodeEditor())
IntentManager.registerIntent(new TestGeneratorIntent())
IntentManager.registerIntent(new CodeFixIntent())
IntentManager.registerIntent(new ExplainIntent())
IntentManager.registerIntent(new TerminalIntent())
IntentManager.registerIntent(UnknownIntent.Instance)
IntentManager.registerIntent(new VsCodeExtensionDevelopmentIntent())
var vscode = handleDefaultExports(require('vscode'))
var KerberosLoader = class extends BaseKerberosLoader {
  async loadKerberosModule() {
    try {
      return require(`${vscode.env.appRoot}/node_modules.asar/kerberos`)
    } catch {}
    try {
      return require(`${vscode.env.appRoot}/node_modules/kerberos`)
    } catch {}
  }
}
var os = handleDefaultExports(require('os')),
vscode = handleDefaultExports(require('vscode'))
var CertificateLoader = class extends BaseCertificateLoader {
  async loadCaCerts() {
    let winCAModule = await this.loadBuiltInWinCAModule(),
      certSet = new Set(),
      crypt32Instance = new winCAModule.Crypt32()
    try {
      let cert
      for (; (cert = crypt32Instance.next()); ) certSet.add(formatCertificate(cert))
    } finally {
      crypt32Instance.done()
    }
    return Array.from(certSet)
  }
  async loadBuiltInWinCAModule() {
    try {
      return require(`${vscode.env.appRoot}/node_modules.asar/@vscode/windows-ca-certs`)
    } catch {}
    try {
      return require(`${vscode.env.appRoot}/node_modules/@vscode/windows-ca-certs`)
    } catch {}
  }
}

function formatCertificate(cert) {
  let formattedCert = ['-----BEGIN CERTIFICATE-----'],
    base64Cert = cert.toString('base64')
  for (let index = 0; index < base64Cert.length; index += 64) formattedCert.push(base64Cert.substr(index, 64))
  return formattedCert.push('-----END CERTIFICATE-----', ''), formattedCert.join(os.EOL)
}

var ExperimentationService = handleDefaultExports(nve())

function getTargetPopulation(isInsider) {
  return isInsider ? ExperimentationService.TargetPopulation.Insiders : ExperimentationService.TargetPopulation.Public
}

async function getExperimentationService(extension, telemetry, isInsider) {
  let extensionId = extension.extension.id,
    version = extension.extension.packageJSON.version,
    targetPopulation = getTargetPopulation(isInsider)
  return (0, ExperimentationService.getExperimentationService)(extensionId, version, targetPopulation, telemetry, extension.globalState)
}

var TelemetryReporter = handleDefaultExports(Vxe())

var TelemetryManager = class {
  constructor(context, internalTelemetryKey, externalTelemetryKey, tokenService, subscriptions) {
    this._sharedProperties = {}
    this._isInternal = false
    tokenService.on('onCopilotToken', async (token, tokenData) => {
      if (
        ((this._username = (await getSessionWithMinimalScope(context))?.account?.label),
        (this._sku = token.getTokenValue('sku')),
        (this._isInternal = token.isInternal),
        this.sendTelemetryEvent('token', {}, { chatEnabled: tokenData.chat_enabled ? 1 : 0 }),
        !token.organization_list || !tokenData.chat_enabled)
      ) {
        this._internalTelemetryReporter = undefined
        return
      }
      token.isInternal &&
        ((this._internalTelemetryReporter = new TelemetryReporter.default(internalTelemetryKey)), subscriptions.subscriptions.push(this._internalTelemetryReporter))
    }),
      (this._externalTelemetryReporter = new TelemetryReporter.default(externalTelemetryKey)),
      subscriptions.subscriptions.push(this._externalTelemetryReporter)
  }
  setSharedProperty(key, value) {
    this._sharedProperties[key] = value
  }
  postEvent(eventName, properties) {
    let formattedProperties = {}
    for (let [key, value] of properties) formattedProperties[key] = value
    this._isInternal && this.sendInternalTelemetryEvent(eventName, formattedProperties), this.sendTelemetryEvent(eventName, formattedProperties)
  }
  sendInternalTelemetryEvent(eventName, properties, metrics) {
    this._internalTelemetryReporter &&
      ((properties = { ...properties, 'common.userName': this._username ?? 'undefined', ...this._sharedProperties }),
      this._internalTelemetryReporter.sendRawTelemetryEvent(eventName, properties, metrics))
  }
  sendTelemetryEvent(eventName, properties, metrics) {
    properties = { ...properties, 'common.sku': this._sku ?? 'undefined', ...this._sharedProperties }
    this._isInternal && (metrics = { ...metrics, 'common.internal': 1 })
    this._externalTelemetryReporter.sendTelemetryEvent(eventName, properties, metrics)
  }
  sendTelemetryErrorEvent(eventName, properties, metrics) {
    properties = { ...properties, 'common.sku': this._sku ?? 'undefined' }
    this._isInternal && (metrics = { ...metrics, 'common.internal': 1 })
    this._externalTelemetryReporter.sendTelemetryErrorEvent(eventName, properties, metrics)
  }
}

var vscode = require('vscode')
var hasShownInvalidTokenWarning = false;
async function fetchAndValidateCopilotToken(context) {
  let authLogger = context.get(LoggerManager).getLogger('auth'),
    session = await getSessionWithMinimalScope(context.get(ConfigManager))
  if (!session) {
    authLogger.info('GitHub login failed');
    context.get(IGHTelemetryService).sendErrorTelemetry('auth.github_login_failed');
    return { kind: 'failure', reason: 'GitHubLoginFailed' };
  }
  authLogger.info(`Logged in as ${session.account.label}`);
  let copilotToken = await fetchCopilotToken(context, { token: session.accessToken });
  if (copilotToken.kind === 'success') authLogger.info(`Got Copilot token for ${session.account.label}`);
  return copilotToken;
}
var WarningNotificationHandler = class {
  async showWarningMessage(message, ...actions) {
    return { title: await vscode.window.showWarningMessage(message, ...actions.map(action => action.title)) };
  }
},
NoAccessError = class extends Error {},
SubscriptionEndedError = class extends Error {},
EnterpriseAdminContactError = class extends Error {}

async function validateCopilotToken(context) {
  let copilotToken = await fetchAndValidateCopilotToken(context);
  if (copilotToken.kind === 'failure' && copilotToken.reason === 'NotAuthorized') {
    let errorMessage = copilotToken.message;
    if (errorMessage?.includes('No access to GitHub Copilot found')) throw new NoAccessError(errorMessage ?? 'User not authorized');
    if (errorMessage?.includes('Your subscription has ended')) throw new SubscriptionEndedError(errorMessage);
  }
  if (copilotToken.kind === 'failure') {
    let errorMessage = copilotToken.message;
    if (errorMessage?.includes('Please contact your enterprise admin to enable your managed account for Copilot for Business'))
      throw new EnterpriseAdminContactError(errorMessage);
  }
  if (copilotToken.kind === 'failure' && copilotToken.reason === 'HTTP401') {
    let errorMessage = 'Your GitHub token is invalid. Please sign out from your GitHub account using the VS Code accounts menu and try again.';
    if (!hasShownInvalidTokenWarning) {
      hasShownInvalidTokenWarning = true;
      vscode.window.showWarningMessage(errorMessage);
    }
    throw Error(errorMessage);
  }
  if (copilotToken.kind === 'failure' && copilotToken.reason === 'GitHubLoginFailed') throw Error('GitHubLoginFailed');
  if (copilotToken.kind === 'failure') throw Error('Failed to get copilot token');
  return copilotToken;
}

var TokenHandler = class extends BaseTokenHandler {
  constructor(configService) {
    super();
    this.configurationService = configService;
    this.copilotToken = undefined;
    this._disposable = vscode.Disposable.from(vscode.authentication.onDidChangeSessions(session => handleGithubTokenChange(session, this)));
  }
  dispose() {
    this._disposable.dispose();
  }
  async getBasicGitHubToken() {
    return (await getSessionWithMinimalScope(this.configurationService))?.accessToken;
  }
  async getPermissiveGitHubToken(scope) {
    return (await getSessionWithFullScope(this.configurationService, scope))?.accessToken;
  }
  async getCopilotToken(context, forceRefresh) {
    if (!this.copilotToken || this.copilotToken.expires_at < getCurrentTimestamp() || forceRefresh) {
      this.copilotToken = await validateCopilotToken(context);
      scheduleTokenRefresh(context, this, this.copilotToken.refresh_in);
    }
    return new TokenParser(this.copilotToken.token, this.copilotToken.organization_list);
  }
  resetCopilotToken(context, httpErrorCode) {
    if (httpErrorCode !== undefined) {
      context.get(IGHTelemetryService).sendTelemetry('auth.reset_token_' + httpErrorCode);
    }
    context
      .get(LoggerManager)
      .getLogger('auth')
      .debug(`Resetting copilot token on HTTP error ${httpErrorCode || 'unknown'}`);
    this.copilotToken = undefined;
  }
}
var vscode = require('vscode')
var enterpriseConfigKey = 'github-enterprise',
defaultGithubUrl = 'https://github.com'

function getGithubUrl(configService) {
  return configService.getConfig(settings.AuthProvider) === 'github-enterprise'
    ? vscode.workspace.getConfiguration(enterpriseConfigKey).get('uri') ?? defaultGithubUrl
    : defaultGithubUrl;
}

var GithubApiService = class extends GitHubAPI {
  constructor(configService) {
    super(getGithubUrl(configService));
    this.configurationService = configService;
  }
  updateBaseUrl(baseUrl, configService) {
    super.updateBaseUrl(baseUrl, getGithubUrl(this.configurationService));
  }
}

function updateBaseUrlOnConfigChange(configChange, serviceLocator) {
  if (configChange.affectsConfiguration(`${extensionId}.advanced`) || configChange.affectsConfiguration(`${enterpriseConfigKey}.uri`)) {
    serviceLocator.get(BaseGithubApiService).updateBaseUrl(serviceLocator);
  }
}

var net = require('net')
var url = require('url')
var vscode = require('vscode')

function getProxyFromEnv(env) {
  return env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy || null;
}

function handleProxyConfigurationChange(proxySettings, env) {
  vscode.workspace.onDidChangeConfiguration(configChange => {
    let isProxyConfigChanged = configChange.affectsConfiguration('http.proxy');
    if (configChange.affectsConfiguration('http.proxyStrictSSL') ||
      configChange.affectsConfiguration('http.proxyAuthorization') ||
      configChange.affectsConfiguration('http.proxyKerberosServicePrincipal') ||
      isProxyConfigChanged) {
      updateProxySettings(proxySettings, env, isProxyConfigChanged);
    }
  });
  updateProxySettings(proxySettings, env);
}

var updateProxySettings = (proxySettings, env, isProxyConfigChanged) => {
  let proxy = vscode.workspace.getConfiguration('http').get('proxy') || getProxyFromEnv(env);
  if (proxy) {
    let headers = {},
      proxyAuthorization = vscode.workspace.getConfiguration('http').get('proxyAuthorization'),
      isStrictSSL = vscode.workspace.getConfiguration('http').get('proxyStrictSSL', true);
    proxyAuthorization && (headers['Proxy-Authorization'] = proxyAuthorization);
    let host = proxy,
      proxyParts = proxy.split(':');
    if (proxyParts.length > 2) {
      if (proxy.includes('[')) {
        let startIndex = proxy.indexOf('['),
          endIndex = proxy.indexOf(']');
        host = proxy.substring(startIndex + 1, endIndex);
      }
    } else host = proxyParts[0];
    let ipVersion = (0, net.isIP)(host);
    ipVersion === 4
      ? (proxy = `https://${proxy}`)
      : ipVersion === 6 && (proxy.includes('[') ? proxy.startsWith('https://') || (proxy = `https://${proxy}`) : (proxy = `https://[${proxy}]`));
    let { hostname, port, username, password } = parseProxyUrl(proxy),
      proxyAuth = username && password && `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
    proxySettings.proxySettings = { host: hostname, port: parseInt(port), proxyAuth, headers };
    let kerberosServicePrincipal = vscode.workspace.getConfiguration('http').get('proxyKerberosServicePrincipal');
    kerberosServicePrincipal && (proxySettings.proxySettings.kerberosServicePrincipal = kerberosServicePrincipal);
    proxySettings.rejectUnauthorized = isStrictSSL;
  } else if (isProxyConfigChanged && !proxy) {
    proxySettings.proxySettings = undefined;
  }
}

function parseProxyUrl(proxyUrl) {
  try {
    return new url.URL(proxyUrl);
  } catch {
    throw new Error(`Invalid proxy URL: '${proxyUrl}'`);
  }
}

var fs = handleDefaultExports(require('fs'))
var FileSystemOperations = class extends BaseFileSystemOperations {
  async getFileStats(fileUri) {
    let stats = await fs.promises.stat(fileUri.fsPath);
    return { type: stats.isFile() ? 1 : 2, ctime: stats.ctimeMs, mtime: stats.mtimeMs, size: stats.size };
  }

  async readDirectory(directoryUri) {
    validateUriScheme(directoryUri);
    let directoryEntries = await fs.promises.readdir(directoryUri.fsPath, { withFileTypes: true }),
      entries = [];
    for (let entry of directoryEntries) entries.push([entry.name, entry.isFile() ? 1 : 2]);
    return entries;
  }

  async createDirectory(directoryUri) {
    validateUriScheme(directoryUri);
    return fs.promises.mkdir(directoryUri.fsPath);
  }

  async readFile(fileUri) {
    validateUriScheme(fileUri);
    return fs.promises.readFile(fileUri.fsPath);
  }

  async writeFile(fileUri, data) {
    validateUriScheme(fileUri);
    return fs.promises.writeFile(fileUri.fsPath, data);
  }

  async delete(fileUri, options) {
    validateUriScheme(fileUri);
    return fs.promises.rm(fileUri.fsPath, { recursive: options?.recursive ?? false });
  }

  async rename(sourceUri, targetUri, options) {
    validateUriScheme(sourceUri);
    validateUriScheme(targetUri);
    if (!(options?.overwrite && fs.existsSync(targetUri.fsPath))) {
      return fs.promises.rename(sourceUri.fsPath, targetUri.fsPath);
    }
  }

  async copy(sourceUri, targetUri, options) {
    validateUriScheme(sourceUri);
    validateUriScheme(targetUri);
    let copyFlags = options?.overwrite ? fs.constants.COPYFILE_FICLONE : fs.constants.COPYFILE_EXCL;
    return fs.promises.copyFile(sourceUri.fsPath, targetUri.fsPath, copyFlags);
  }

  isWritableFileSystem(fileSystemId) {
    return true;
  }

  createFileSystemWatcher(fileSystemId) {
    return new (class {
      constructor() {
        this.ignoreCreateEvents = false;
        this.ignoreChangeEvents = false;
        this.ignoreDeleteEvents = false;
        this.onDidCreate = EventUtils.None;
        this.onDidChange = EventUtils.None;
        this.onDidDelete = EventUtils.None;
      }
      dispose() {}
    })();
  }
}

function validateUriScheme(uri) {
  if (uri.scheme !== 'file') throw new Error(`URI must be of file scheme, received ${uri.scheme}`);
}

var vscode = handleDefaultExports(require('vscode'))
var EnvironmentInfo = class extends BuildInfo {
  get sessionId() {
    return vscode.env.sessionId;
  }
  get machineId() {
    return vscode.env.machineId;
  }
  getEditorInfo() {
    return new VersionInfo('vscode', vscode.version);
  }
  getEditorPluginInfo() {
    return new VersionInfo('copilot-chat', packageInfo.version);
  }
}
var B$t = rbe()
var NoTelemetry = class {
  sendEventData(event, data) {
    throw new Error('Telemetry disabled')
  }
  sendErrorData(error, data) {
    throw new Error('Telemetry disabled')
  }
  flush() {
    return Promise.resolve()
  }
}
function redactFilePaths(text) {
  return text
    .replace(/([\s|(]|file:\/\/)(\/[^\s]+)/g, '$1[redacted]')
    .replace(/([\s|(]|file:\/\/)([a-zA-Z]:[(\\|/){1,2}][^\s]+)/gi, '$1[redacted]')
    .replace(/([\s|(]|file:\/\/)(\\[^\s]+)/gi, '$1[redacted]')
}
var TelemetryManager = class {
  getReporter(environment, secure) {
    if (!secure) return this.reporter
    if (isSecureEnvironment(environment)) return this.reporterSecure
    if (isTestMode(environment)) return new NoTelemetry()
  }
  setReporter(reporter) {
    this.reporter = reporter
  }
  setSecureReporter(reporter) {
    this.reporterSecure = reporter
  }
  async deactivate() {
    let reporterFlushPromise = Promise.resolve()
    if (this.reporter) {
      reporterFlushPromise = this.reporter.flush ? this.reporter.flush() : void 0
      this.reporter = void 0
    }

    let secureReporterFlushPromise = Promise.resolve()
    if (this.reporterSecure) {
      secureReporterFlushPromise = this.reporterSecure.flush ? this.reporterSecure.flush() : void 0
      this.reporterSecure = void 0
    }

    await Promise.all([reporterFlushPromise, secureReporterFlushPromise])
  }
}
var TelemetryController = class {
  constructor(accessor) {
    this.accessor = accessor;
    this.reporters = new TelemetryManager();
    this.openPromises = undefined;
  }
  withPromise(promise) {
    return this.openPromises
      ? (this.openPromises.add(promise),
        promise.then(() => {
          this.openPromises?.delete(promise)
        }))
      : promise
  }
  async enablePromiseTracking(enable) {
    enable ? this.openPromises || (this.openPromises = new Set()) : await this.awaitOpenPromises(undefined)
  }
  setSecureReporter(reporter) {
    this.reporters.setSecureReporter(reporter)
  }
  setReporter(reporter) {
    this.reporters.setReporter(reporter)
  }
  async sendTelemetry(eventName, event) {
    await this.withPromise(this._sendTelemetry(eventName, event, false))
  }
  async sendRestrictedTelemetry(eventName, event) {
    await this.withPromise(this._sendTelemetry(eventName, event, true))
  }
  async sendErrorTelemetry(eventName, event) {
    await this.withPromise(this._sendErrorTelemetry(eventName, event, false))
  }
  async sendRestrictedErrorTelemetry(eventName, event) {
    await this.withPromise(this._sendErrorTelemetry(eventName, event, true))
  }
  async sendExpProblemTelemetry(event) {
    await this.withPromise(this._sendExpProblemTelemetry(event))
  }
  async sendExceptionTelemetry(exception, origin) {
    await this.withPromise(this._sendExceptionTelemetry(exception, origin))
  }
  async deactivate() {
    await this.awaitOpenPromises(new Set()), await this.reporters.deactivate()
  }
  async awaitOpenPromises(newOpenPromises) {
    if (this.openPromises) {
      let promises = [...this.openPromises.values()]
      this.openPromises = newOpenPromises, await Promise.all(promises)
    }
  }
  async _sendTelemetry(eventName, event, isRestricted) {
    if (isRestricted && !isUserOptedIn(this.accessor)) return
    let telemetryEvent = event || TelemetryEvent.createAndMarkAsIssued({}, {})
    await telemetryEvent.makeReadyForSending(this.accessor, isRestricted ?? false, 'IncludeExp'), this.sendTelemetryEvent(isRestricted ?? false, eventName, telemetryEvent)
  }
  async _sendExpProblemTelemetry(event) {
    let eventName = 'expProblem',
      telemetryEvent = TelemetryEvent.createAndMarkAsIssued(event, {})
    await telemetryEvent.makeReadyForSending(this.accessor, false, 'SkipExp'), this.sendTelemetryEvent(false, eventName, telemetryEvent)
  }
  async _sendExceptionTelemetry(exception, origin) {
    let error = exception instanceof Error ? exception : new Error('Non-error thrown: ' + exception),
      isRestricted = isUserOptedIn(this.accessor),
      telemetryEvent = TelemetryEvent.createAndMarkAsIssued({
        origin: redactFilePaths(origin),
        reason: isRestricted ? 'Exception logged to restricted telemetry' : 'Exception, not logged due to opt-out',
      })
    if (
      (await telemetryEvent.makeReadyForSending(this.accessor, false, 'IncludeExp'), this.sendTelemetryEvent(false, 'exception', telemetryEvent), !isRestricted)
    )
      return
    let restrictedTelemetryEvent = TelemetryEvent.createAndMarkAsIssued({ origin: origin })
    await restrictedTelemetryEvent.makeReadyForSending(this.accessor, true, 'IncludeExp'), this.sendTelemetryException(true, error, restrictedTelemetryEvent)
  }
  async _sendErrorTelemetry(eventName, event, isRestricted) {
    if (isRestricted && !isUserOptedIn(this.accessor)) return
    let telemetryEvent = event || TelemetryEvent.createAndMarkAsIssued({}, {})
    await telemetryEvent.makeReadyForSending(this.accessor, isRestricted ?? false, 'IncludeExp'), this.sendTelemetryErrorEvent(isRestricted ?? false, eventName, telemetryEvent)
  }
  sendTelemetryEvent(isRestricted, eventName, telemetryEvent) {
    let reporter = this.reporters.getReporter(this.accessor, isRestricted);
    if (reporter) {
      let properties = TelemetryEvent.maybeRemoveRepoInfoFromPropertiesHack(isRestricted, telemetryEvent.properties);
      reporter.sendEventData(eventName, { ...properties, ...telemetryEvent.measurements });
    }
  }
  sendTelemetryException(isRestricted, error, telemetryEvent) {
    let reporter = this.reporters.getReporter(this.accessor, isRestricted);
    if (reporter) {
      let properties = TelemetryEvent.maybeRemoveRepoInfoFromPropertiesHack(isRestricted, telemetryEvent.properties);
      reporter.sendErrorData(error, { ...properties, ...this.telemetryEvent.measurements });
    }
  }
  sendTelemetryErrorEvent(isRestricted, eventName, telemetryEvent) {
    let reporter = this.reporters.getReporter(this.accessor, isRestricted);
    if (reporter) {
      let properties = TelemetryEvent.maybeRemoveRepoInfoFromPropertiesHack(isRestricted, telemetryEvent.properties);
      reporter.sendEventData(eventName, { ...properties, ...telemetryEvent.measurements });
    }
  }
}
function isUserOptedIn(context) {
  return context.get(TokenHandler).optedIn;
}
function initializeServices(context) {
  context.define(EndpointManager, new EndpointManager(context));
  context.define(BuildInfo, new EnvironmentInfo());
  context.define(IGHTelemetryService, new TelemetryController(context));
  context.define(EnvironmentFlags, EnvironmentFlags.fromEnvironment(false));
  context.define(EventEmitter, new EventEmitter());
  context.define(Cache, new Cache());
  context.define(BaseCertificateReader, createInstance(context));
  context.define(BaseSocketFactory, createSocketFactory(context));

  let config = context.get(ConfigManager).getConfig(settings.DebugUseNodeFetcher);
  context.define(ConnectionSettings, config ? new NetworkManager(context.get(BuildInfo)) : new ConnectionManager(context));
  context.define(TokenHandler, new TokenHandler(context));
  context.define(UrlProvider, new UrlProvider());
  context.define(HeaderContributorList, new HeaderContributorList());
  context.define(CertificateErrorHandler, new CertificateErrorHandler());
  context.define(BaseUrlOpener, new URLHandler());
  context.define(BaseExperimentFetcher, new EmptyExperimentFetcher());
  context.define(BaseFileSystemOperations, new FileSystemOperations());
  context.define(EmbeddingsComputer, new EmbeddingComputer(context));
  context.define(FileResourceTracker, new FileResourceTracker(context));
  context.define(CommandParser, new CommandParser(context));
  context.define(VariableManager, new VariableManager(context));
  context.define(CodeSearchClient, new CodeSearchClient(context));
  context.define(DocsSearchClient, new DocsSearchClient(context));
}
var copilotChatChannel = vscode.window.createOutputChannel('GitHub Copilot Chat', { log: true })
async function activateExtension(extensionContext, e) {
  if (extensionContext.extensionMode === vscode.ExtensionMode.Test && !e) return extensionContext
  vscode.l10n.bundle && Bx.config({ contents: vscode.l10n.bundle })
  let r = await createContext(extensionContext)
  extensionContext.subscriptions.push(deactivateExtension(r)),
  extensionContext.subscriptions.push(
      vscode.window.registerTerminalQuickFixProvider('copilot-chat.fixWithCopilot', {
        provideTerminalQuickFixes(o, s) {
          return [
            { command: 'github.copilot.terminal.explainTerminalLastCommand', title: Bx.t('Explain using Copilot') },
          ]
        },
      })
    ),
    extensionContext.subscriptions.push(
      vscode.window.registerTerminalQuickFixProvider('copilot-chat.generateCommitMessage', {
        async provideTerminalQuickFixes(o, s) {
          return [{ command: 'github.copilot.terminal.generateCommitMessage', title: Bx.t('Generate Commit Message') }]
        },
      })
    )
  let n = r.get(IGHTelemetryService)
  if (
    (await (async () => {
      let o = a => {
        let l = a.message || a
        n.sendErrorTelemetry('activationFailed', TelemetryEvent.createAndMarkAsIssued({ reason: l })), n.deactivate()
        let c =
          l === 'GitHubLoginFailed'
            ? notSignedInMessage
            : `GitHub Copilot could not connect to server. Extension activation failed: "${l}"`
        r.get(LoggerManager).defaultLogger.error(c), vscode.commands.executeCommand('setContext', 'github.copilot.activated', !1)
        let u = vscode.authentication.onDidChangeSessions(async p => {
          try {
            ;(await handleProvider(p, r)) !== void 0 &&
              (vscode.commands.executeCommand('setContext', 'github.copilot.activated', !0), updateCopilotStatus(r), u.dispose())
          } catch (d) {
            updateCopilotStatus(r, d), o(d)
          }
        })
      }
      try {
        await r.get(BaseTokenHandler).getCopilotToken(r), vscode.commands.executeCommand('setContext', 'github.copilot.activated', !0)
      } catch (a) {
        r.get(ConnectionSettings).isDNSLookupFailedError(a) && extensionContext.subscriptions.push(registerOfflineCommand(r, o)), updateCopilotStatus(r, a), o(a)
      }
      extensionContext.subscriptions.push(vscode.workspace.onDidChangeConfiguration(a => updateBaseUrlOnConfigChange(a, r)))
      let s = extensionContext.extensionMode !== vscode.ExtensionMode.Development
      initializeWorker(s, r.get(LoggerManager).getLogger('parser proxy')),
      initializeExtension(r),
        ContributionManager.start(r.get(BuildInfo).isPreRelease()),
        n.sendTelemetry('extension.activate')
    })(),
    vscode.ExtensionMode.Test === extensionContext.extensionMode)
  )
    return r
}
async function createContext(extensionContext) {
  let instanceAccessor = new InstanceAccessor()
  instanceAccessor.define(ConfigManager, new WorkspaceConfigManager()),
  instanceAccessor.define(LoggerManager, new LoggerManager([new ConsoleLogger(), new OutputLogger(copilotChatChannel)], instanceAccessor.get(ConfigManager))),
  initializeServices(instanceAccessor),
  instanceAccessor.define(BaseFileSystemOperations, new FileSystemOperations()),
  instanceAccessor.define(extensionContext, extensionContext),
  instanceAccessor.define(EmbeddingsIndex, new EmbeddingsIndex(instanceAccessor)),
  instanceAccessor.define(FileFinder, new FileSearcher(instanceAccessor))
  let tabManager = new TabManager()
  instanceAccessor.define(BaseTabManager, tabManager),
  instanceAccessor.define(BaseGitExtensionService, new GitExtensionService(instanceAccessor)),
  instanceAccessor.define(BaseGitRepositoryManager, new GitRepositoryManager(tabManager)),
  instanceAccessor.define(DiagnosticWaiter, new DiagnosticListener()),
  instanceAccessor.define(BaseVSCodeInfoProvider, new VSCodeInfoProvider()),
  instanceAccessor.define(BaseSymbolProvider, new SymbolProvider()),
  instanceAccessor.define(BaseKerberosLoader, new KerberosLoader()),
  instanceAccessor.define(BaseCertificateLoader, new CertificateLoader()),
  instanceAccessor.define(BaseTerminalInfoProvider, new TerminalInfoProvider()),
  instanceAccessor.define(DisposableClass, new DebugConsole()),
  instanceAccessor.define(ExperimentManager, new ExperimentManager(instanceAccessor)),
  instanceAccessor.define(ChatAgentServiceIdentifier, new ExtensionProvider(instanceAccessor))
  let internalAIKey = extensionContext.extension.packageJSON.internalAIKey ?? '',
    ariaKey = extensionContext.extension.packageJSON.ariaKey ?? ''
  if (extensionContext.extensionMode === vscode.ExtensionMode.Test)
    instanceAccessor.define(EnvironmentFlags, EnvironmentFlags.fromEnvironment(true)),
      instanceAccessor.define(BaseTokenHandler, getTokenHandler()),
      instanceAccessor.define(BaseUrlOpener, new UrlOpener()),
      await setupTelemetryAndExperimentationService(instanceAccessor, extensionContext, internalAIKey, ariaKey, 'copilot-test', true)
  else {
    let tokenHandler = new TokenHandler(instanceAccessor.get(ConfigManager))
    extensionContext.subscriptions.push(tokenHandler),
      instanceAccessor.define(BaseTokenHandler, tokenHandler),
      instanceAccessor.define(BaseExperimentFetcher, new DefaultExperimentFetcher()),
      await setupTelemetryAndExperimentationService(instanceAccessor, extensionContext, internalAIKey, ariaKey, extensionContext.extension.packageJSON.name, vscode.env.isTelemetryEnabled)
    let useNodeFetcher = await instanceAccessor.get(IExperimentationService).getTreatmentVariableAsync('vscode', 'copilotchat.useNodeFetcher', true),
      debugUseNodeFetcher = instanceAccessor.get(ConfigManager).getConfig(settings.DebugUseNodeFetcher) || useNodeFetcher
    instanceAccessor.define(ConnectionSettings, debugUseNodeFetcher ? new NetworkManager(instanceAccessor.get(BuildInfo)) : new ConnectionManager(instanceAccessor))
  }
  instanceAccessor.define(DataRetriever, new ChatMLFetcher(instanceAccessor)),
  instanceAccessor.define(Tokenizer, new Tokenizer()),
  instanceAccessor.define(EmbeddingsComputer, new EmbeddingComputer(instanceAccessor)),
  instanceAccessor.define(Reporter, new FeedbackReporter(instanceAccessor)),
  instanceAccessor.define(NotificationHandler, new WarningNotificationHandler()),
  instanceAccessor.define(BaseVscodeEnvironment, new Environment()),
  instanceAccessor.define(BaseGithubApiService, new GithubApiService(instanceAccessor.get(ConfigManager))),
  instanceAccessor.define(conversationOptions, {
    maxResponseTokens: undefined,
    temperature: 0.1,
    topP: 1,
    additionalPromptContext: instanceAccessor.get(ConfigManager).getConfig(settings.ConversationAdditionalPromptContext),
    rejectionMessage: Bx.t('Sorry, but I can only assist with programming related questions.'),
  }),
  handleProxyConfigurationChange(instanceAccessor.get(ConnectionSettings), process.env),
  registerExperimentFilters(instanceAccessor)
let workspaceManager = new WorkspaceManager(instanceAccessor)
instanceAccessor.define(WorkspaceClass, workspaceManager),
  instanceAccessor.define(CommandRelatedInfoProvider, new CommandRelatedInfoProvider(instanceAccessor, instanceAccessor.get(EmbeddingsComputer))),
  instanceAccessor.define(SettingsRelatedInfoProvider, new SettingsRelatedInfoProvider(instanceAccessor, instanceAccessor.get(EmbeddingsComputer))),
  instanceAccessor.define(IndexLoader, new IndexLoader(instanceAccessor)),
  instanceAccessor.define(WorkspaceChunkSearch, new WorkspaceChunkSearch(instanceAccessor)),
  instanceAccessor.define(ProjectManager, new ProjectManager(instanceAccessor)),
  instanceAccessor.define(ChatEngine, new ChatEngine(instanceAccessor)),
  instanceAccessor.define(GitContextModelIdentifier, new GitExtensionHandler()),
  instanceAccessor.define(BaseVariableResolver, new VariableResolver(instanceAccessor))
  let workspaceIgnoreFileHandler = new WorkspaceIgnoreFileHandler(instanceAccessor)
  return instanceAccessor.define(IgnoreServiceIdentifier, workspaceIgnoreFileHandler), extensionContext.subscriptions.push(workspaceIgnoreFileHandler), workspaceIgnoreFileHandler.init(), instanceAccessor.seal(), instanceAccessor
}
async function setupExperimentationService(instanceAccessor, extensionContext) {
  if (vscode.ExtensionMode.Production === extensionContext.extensionMode) {
    let telemetryService = instanceAccessor.get(IMSTelemetryService),
      experimentationService = await getExperimentationService(extensionContext, telemetryService, instanceAccessor.get(BuildInfo).isPreRelease())
    instanceAccessor.define(IExperimentationService, experimentationService)
  } else instanceAccessor.define(IExperimentationService, new ExperimentationService())
}
async function setupTelemetryAndExperimentationService(instanceAccessor, extensionContext, internalAIKey, ariaKey, extensionName, isTelemetryEnabled) {
  let telemetrySetup = await setupTelemetry(instanceAccessor, extensionName, isTelemetryEnabled),
    onTelemetryEnabledChange = vscode.env.onDidChangeTelemetryEnabled(async telemetryEnabled => {
      telemetrySetup?.dispose(), (telemetrySetup = await setupTelemetry(instanceAccessor, extensionContext.extension.packageJSON.name, telemetryEnabled && vscode.env.isTelemetryEnabled))
    })
  extensionContext.subscriptions.push(onTelemetryEnabledChange),
    extensionContext.subscriptions.push(new vscode.Disposable(() => telemetrySetup?.dispose())),
    vscode.ExtensionMode.Production === extensionContext.extensionMode
      ? instanceAccessor.define(IMSTelemetryService, new TelemetryManager(instanceAccessor.get(ConfigManager), internalAIKey, ariaKey, instanceAccessor.get(EventEmitter), extensionContext))
      : instanceAccessor.define(IMSTelemetryService, new TelemetryManager()),
      setupExperimentationService(instanceAccessor, extensionContext)
}
function deactivateExtension(context) {
  return {
    dispose: async () => {
      let telemetry = context.get(IGHTelemetryService)
      await telemetry.sendTelemetry('extension.deactivate'), telemetry.deactivate(), terminateWorker()
    },
  }
}
var CopilotStatus = {
  Offline: 'github.copilot.offline',
  IndividualDisabled: 'github.copilot.interactiveSession.individual.disabled',
  IndividualExpired: 'github.copilot.interactiveSession.individual.expired',
  EnterpriseDisabled: 'github.copilot.interactiveSession.enterprise.disabled',
}

function updateCopilotStatus(context, error) {
  let statusValues = Object.values(CopilotStatus),
    status;
  context.get(ConnectionSettings).isDNSLookupFailedError(error)
    ? (status = CopilotStatus.Offline)
    : error instanceof NoAccessError
    ? (status = CopilotStatus.IndividualDisabled)
    : error instanceof SubscriptionEndedError
    ? (status = CopilotStatus.IndividualExpired)
    : error instanceof EnterpriseAdminContactError && (status = CopilotStatus.EnterpriseDisabled);
  status && vscode.commands.executeCommand('setContext', status, true);
  for (let value of statusValues) value !== status && vscode.commands.executeCommand('setContext', value, false);
}

function registerOfflineCommand(context, errorHandler) {
  return vscode.commands.registerCommand('github.copilot.offline', async () => {
    try {
      await context.get(BaseTokenHandler).getCopilotToken(context),
        vscode.commands.executeCommand('setContext', 'github.copilot.activated', true),
        updateCopilotStatus(context);
    } catch (error) {
      if (context.get(ConnectionSettings).isDNSLookupFailedError(error)) return;
      updateCopilotStatus(context, error), errorHandler(error);
    }
  });
}
0 && (module.exports = { activate, createExtensionContext, onDeactivate })
//!!! DO NOT modify, this file was COPIED from 'microsoft/vscode'
/*! Bundled license information:

@microsoft/applicationinsights-web-snippet/dist/esm/applicationinsights-web-snippet.js:
  (*!
   * Application Insights JavaScript SDK - Web Snippet, 1.0.1
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
